/*
 * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>
 * Copyright (C) 2005-2009 MaNGOS <http://getmangos.com/>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include "AccountMgr.h"
#include "AchievementMgr.h"
#include "Anticheat.h"
#include "AreaTriggerData.h"
#include "ArtifactPackets.h"
#include "AuctionHouseMgr.h"
#include "AuthenticationPackets.h"
#include "Battlefield.h"
#include "BattlefieldMgr.h"
#include "BattlegroundAlteracValley.h"
#include "BattlegroundMgr.h"
#include "BattlegroundPackets.h"
#include "BattlePayMgr.h"
#include "BattlePayPackets.h"
#include "BattlePetData.h"
#include "Bracket.h"
#include "BracketMgr.h"
#include "CalendarPackets.h"
#include "CellImpl.h"
#include "ChallengeMgr.h"
#include "Channel.h"
#include "ChannelMgr.h"
#include "CharacterData.h"
#include "CharacterDatabaseCleaner.h"
#include "CharacterPackets.h"
#include "CharmInfo.h"
#include "Chat.h"
#include "ChatPackets.h"
#include "CombatLogPackets.h"
#include "CombatPackets.h"
#include "Common.h"
#include "ConditionMgr.h"
#include "Config.h"
#include "CreatureAI.h"
#include "DatabaseEnv.h"
#include "DB2Stores.h"
#include "DisableMgr.h"
#include "DuelPackets.h"
#include "EquipmentSetPackets.h"
#include "Formulas.h"
#include "GameEventMgr.h"
#include "Garrison.h"
#include "GlobalFunctional.h"
#include "GossipData.h"
#include "GossipDef.h"
#include "GridNotifiers.h"
#include "GridNotifiersImpl.h"
#include "Group.h"
#include "GroupMgr.h"
#include "Guild.h"
#include "GuildMgr.h"
#include "InstancePackets.h"
#include "InstanceSaveMgr.h"
#include "InstanceScript.h"
#include "KillRewarder.h"
#include "Language.h"
#include "LFGListMgr.h"
#include "LFGMgr.h"
#include "Log.h"
#include "LootPackets.h"
#include "MailPackets.h"
#include "MapManager.h"
#include "MiscPackets.h"
#include "MovementPackets.h"
#include "NPCPackets.h"
#include "ObjectAccessor.h"
#include "ObjectMgr.h"
#include "ObjectVisitors.hpp"
#include "Opcodes.h"
#include "OutdoorPvP.h"
#include "OutdoorPvPMgr.h"
#include "Pet.h"
#include "PetBattle.h"
#include "PetBattleSystem.h"
#include "PetPackets.h"
#include "Player.h"
#include "PlayerDefines.h"
#include "QuestData.h"
#include "QuestDef.h"
#include "QuestPackets.h"
#include "ScenarioMgr.h"
#include "ScenePackets.h"
#include "ScriptsData.h"
#include "SkillDiscovery.h"
#include "SocialMgr.h"
#include "SpectatorAddon.h"
#include "Spell.h"
#include "SpellAuraEffects.h"
#include "SpellAuras.h"
#include "SpellMgr.h"
#include "SpellPackets.h"
#include "TalentPackets.h"
#include "ToyPackets.h"
#include "TradeData.h"
#include "Transport.h"
#include "UpdateData.h"
#include "UpdateFieldFlags.h"
#include "UpdatePackets.h"
#include "Util.h"
#include "Vehicle.h"
#include "VehiclePackets.h"
#include "Warden.h"
#include "Weather.h"
#include "WeatherMgr.h"
#include "World.h"
#include "WorldPacket.h"
#include "WorldSession.h"
#include "WorldStateMgr.h"
#include "WorldStatePackets.h"
#include "WowTime.hpp"

#define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)

// corpse reclaim times
#define DEATH_EXPIRE_STEP (5*MINUTE)
#define MAX_DEATH_COUNT 3

static uint32 copseReclaimDelay[MAX_DEATH_COUNT] = { 30, 60, 120 };

BGData::BGData(): BgAfkReportedTimer(0), BgInstanceID(0), BgTeam(0), MountSpellID(0), BgTypeID(MS::Battlegrounds::BattlegroundTypeId::None), LastActiveSpecID(0), BgAfkReportedCount(0)
{
    ClearTaxiPath();
}

VoidStorageItem::VoidStorageItem()
{
}

VoidStorageItem::VoidStorageItem(uint64 id, Item* _item, bool _change) : item(_item), ItemId(id), change(_change)
{
}

VoidStorageItem::VoidStorageItem(uint64 id, uint32 entry, ObjectGuid const& creator, ItemRandomEnchantmentId randomPropertyId, uint32 suffixFactor, bool _change) : CreatorGuid(creator), ItemRandomPropertyId(randomPropertyId), ItemId(id), ItemEntry(entry), ItemSuffixFactor(suffixFactor), change(_change)
{
}

VoidStorageItem::VoidStorageItem(VoidStorageItem&& vsi, bool _change) : CreatorGuid(vsi.CreatorGuid), item(vsi.item), ItemRandomPropertyId(vsi.ItemRandomPropertyId), ItemId(vsi.ItemId),
ItemEntry(vsi.ItemEntry), ItemSuffixFactor(vsi.ItemSuffixFactor), ItemUpgradeId(vsi.ItemUpgradeId), change(_change)
{
}

// we can disable this warning for this since it only
// causes undefined behavior when passed to the base class constructor
#ifdef _MSC_VER
#pragma warning(disable:4355)
#endif
Player::Player(WorldSession* session) : Unit(true), _vignetteMgr(this), m_reputationMgr(this), phaseMgr(this),
m_achievementMgr(sf::safe_ptr<AchievementMgr<Player>>(this))
{
#ifdef _MSC_VER
#pragma warning(default:4355)
#endif

    _collectionMgr = new CollectionMgr(this);
    _garrison = new Garrison(this);

    LastAreaTrigger = NULL;
    m_vis = NULL;
    m_speakTime = 0;
    m_speakCount = 0;
    CustomMultiDonate = 0;

    m_currentPetNumber = 0;
    m_currentSummonedSlot = PET_SLOT_HUNTER_FIRST;

    m_objectType |= TYPEMASK_PLAYER;
    m_objectTypeId = TYPEID_PLAYER;

    m_valuesCount = PLAYER_FIELD_END;
    _dynamicValuesCount = PLAYER_DYNAMIC_END;

    m_session = session;

    m_divider.Clear();

    m_ExtraFlags = 0;

    m_spellModTakingSpell = NULL;

    // players always accept
    if (AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
        SetAcceptWhispers(true);

    m_curSelection.Clear();

    m_regenTimer = 0;

    m_weaponChangeTimer = 0;
    m_statsUpdateTimer = 0;
    m_playerCommandCooldown = sWorld->getIntConfig(CONFIG_WORLD_PLAYER_COMMAND_TIMER);
    m_updateStatsMask = 0;
    m_operationsAfterDelayMask = 0;
    m_updateCRsMask = 0;
    m_duelLock = false;

    m_zoneId = 0;
    m_zoneUpdateTimer = 0;
    m_zoneUpdateAllow = false;
    NeedPhaseRecalculate = false;
    NeedPhaseUpdate = false;
    NeedUpdateVisibility = false;

    m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);

    _resurrectionData = NULL;

    memset(m_items, 0, sizeof(m_items));

    m_social = NULL;

    // group is initialized in the reference constructor
    SetGroupInvite(nullptr);
    m_groupUpdateMask = 0;
    m_bPassOnGroupLoot = false;

    duel = nullptr;

    m_GuildIdInvited = 0;
    m_GuildInviterGuid.Clear();

    m_atLoginFlags = AT_LOGIN_NONE;

    mSemaphoreTeleport_Near = false;
    mSemaphoreTeleport_Far = false;
    m_teleport_target_map = NULL;

    m_DelayedOperations = 0;
    m_bCanDelayTeleport = false;
    m_bHasDelayedTeleport = false;
    m_bHasglobalTeleport = false;
    m_teleport_options = 0;

    m_trade = NULL;

    m_cinematic = 0;

    PlayerTalkClass = new PlayerMenu(GetSession());
    m_currentBuybackSlot = BUYBACK_SLOT_START;

    m_DailyQuestChanged = false;
    m_lastDailyQuestTime = 0;

    for (uint8 i=0; i < MAX_TIMERS; i++)
        m_MirrorTimer[i] = DISABLED_MIRROR_TIMER;

    m_MirrorTimerFlags = UNDERWATER_NONE;
    m_MirrorTimerFlagsLast = UNDERWATER_NONE;
    m_isInWater = false;
    m_drunkTimer = 0;
    m_restTime = 0;
    m_deathTimer = 0;
    m_deathExpireTime = 0;
    m_lastWSUpdateTime = 0;

    m_swingErrorMsg = 0;

    for (uint8 j = 0; j < PLAYER_MAX_BATTLEGROUND_QUEUES; ++j)
    {
        m_bgBattlegroundQueueID[j].bgQueueTypeId = MS::Battlegrounds::BattlegroundQueueTypeId::None;
        m_bgBattlegroundQueueID[j].invitedToInstance = 0;
        m_bgBattlegroundQueueID[j].joinTime = 0;
    }

    m_createdtime = time(NULL);
    m_logintime = time(NULL);
    m_Last_tick = 0;
    m_WeaponProficiency = 0;
    m_ArmorProficiency = 0;
    m_canParry = false;
    m_canBlock = false;
    m_canDualWield = false;
    m_canTitanGrip = false;

    m_temporaryUnsummonedPetNumber = 0;
    //cache for UNIT_FIELD_CREATED_BY_SPELL to allow
    //returning reagents for temporarily removed pets
    //when dying/logging out
    m_oldpetspell = 0;
    m_lastpetnumber = 0;
    m_LastPetEntry = 0;

    ////////////////////Rest System/////////////////////
    time_inn_enter=0;
    inn_pos_mapid=0;
    inn_pos_x=0;
    inn_pos_y=0;
    inn_pos_z=0;
    m_rest_bonus=0;
    rest_type=REST_TYPE_NO;
    ////////////////////Rest System/////////////////////

    //kill honor sistem
    m_flushKills = false;
    m_saveKills = false;

    m_mailsLoaded = false;
    m_mailsUpdated = false;
    unReadMails = 0;
    m_nextMailDelivereTime = 0;

    m_itemUpdateQueueBlocked = false;

    for (uint8 i = 0; i < MAX_MOVE_TYPE; ++i)
        m_forced_speed_changes[i] = 0;

    /////////////////// Instance System /////////////////////

    m_HomebindTimer = 0;
    m_InstanceValid = true;
    m_dungeonDifficulty = DIFFICULTY_NORMAL;
    m_legacyRaidDifficulty = DIFFICULTY_10_N;
    m_raidDifficulty = DIFFICULTY_NORMAL_RAID;
    m_prevMapDifficulty = DIFFICULTY_NORMAL_RAID;

    m_lastPotionId = 0;

    ping = 0;

    for (uint8 i = 0; i < BASEMOD_END; ++i)
    {
        m_auraBaseMod[i][FLAT_MOD] = 0.0f;
        m_auraBaseMod[i][PCT_MOD] = 1.0f;
    }

    m_baseSpellPower = 0;
    m_baseManaRegen = 0;
    m_baseHealthRegen = 0;
    m_spellPenetrationItemMod = 0;

    // Honor System
    m_lastHonorUpdateTime = time(NULL);

    for (uint8 i = 0; i < WIN_TODAY_MAX; ++i)
        _hasWinToday[i] = false;

    // Player summoning
    m_summon_expire = 0;
    m_summon_mapid = 0;
    m_summon_x = 0.0f;
    m_summon_y = 0.0f;
    m_summon_z = 0.0f;

    m_killPoints = 0.0f;

    m_mover = this;
    m_movedPlayer = this;
    m_seer = this;

    m_contestedPvPTimer = 0;
    m_pvpAuraCheckTimer = 3000;

    m_declinedname = NULL;

    m_isActive = true;

    m_lastFallTime = 0;
    m_lastFallZ = 0;

    m_grantableLevels = 0;

    m_ControlledByPlayer = true;

    sWorld->IncreasePlayerCount();

    m_ChampioningFaction = 0;
    m_ChampioningFactionDungeonLevel = 0;

    ItemSetEff = new std::vector<ItemSetEffect*>;

    isDebugAreaTriggers = false;

    m_WeeklyQuestChanged = false;
    m_SeasonalQuestChanged = false;
    m_AdventureQuestChanged = false;

    SetPendingBind(0, 0);

    _activeCheats = CHEAT_NONE;

    _lastTargetedGO = 0;

    m_PersonnalXpRate = 0;

    m_knockBackTimer = 0;

    m_groupUpdateDelay = 5000;

    m_clientCheckDelay = 15000;
    m_clientKickDelay = 0;

    memset(_voidStorageItems, NULL, sizeof(_voidStorageItems));

    m_PetSlots.resize(PET_SLOT_LAST, 0);
    realmTransferid = 0;
    m_scenarioId = 0;

    m_adventure_questID = 0;

    m_crowdControlSpellId = 0;

    m_watching_movie = false;

    _advancedCombatLoggingEnabled = false;
    m_QuestStatusVector = new std::vector<QuestStatusData*>;
    m_QuestStatusVector->assign(sQuestDataStore->GetMaxQuestID(), NULL); // Add to player size at ~250kb

    mSkillStatusVector = new std::vector<SkillStatusData*>;
    mSkillStatusVector->assign(sSkillLineStore.GetNumRows() + 1, NULL);
    mSkillSpellCount.assign(sSkillLineStore.GetNumRows() + 1, 0);

    _wargameRequest = nullptr;
    m_change_map = false;
    m_removeFromMap = false;
    _lastSummonedBattlePet = 0;

    for (size_t i = 0; i < MAX_PETBATTLE_SLOTS; ++i)
        _battlePetCombatTeam[i] = std::shared_ptr<BattlePet>();

    _spectatorFlag = false;
    _spectateCanceled = false;
    _spectateRemoving = false;
    _spectateFrom = nullptr;
    objectCountInWorld[uint8(HighGuid::Player)]++;
    _pvpStatsScalingEnabled = false;
    _pvpRulesTimer = false;

    m_account_time[PLAYED_TIME_TOTAL] = 0;
    m_account_time[PLAYED_TIME_LEVEL] = 0;

    _inventoryEndSlot = INVENTORY_SLOT_ITEM_START + INVENTORY_DEFAULT_SIZE;

    // Anti undermap
    _undermapPosValid = false;
    _lastSafeX = _lastSafeY = _lastSafeZ = 0.f;
    _cheatData = sAnticheatMgr->CreateAnticheatFor(this);

    launched = false;
    xy_speed = 0.0f;
}

Player::~Player()
{
    // it must be unloaded already in PlayerLogout and accessed only for loggined player
    //m_social = NULL;

    delete _cheatData;

    // Note: buy back item already deleted from DB when player was saved
    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; ++i)
        delete m_items[i];

    //all mailed items should be deleted, also all mail should be deallocated
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
        delete *itr;

    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
        delete iter->second;                                //if item is duplicated... then server may crash ... but that item should be deallocated

    delete PlayerTalkClass;

    for (size_t x = 0; x < ItemSetEff->size(); x++)
        delete (*ItemSetEff)[x];

    delete m_declinedname;

    for (uint16 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        if (_voidStorageItems[i])
        {
            delete _voidStorageItems[i]->item;
            delete _voidStorageItems[i];
        }

    for (uint8 i = 0; i < MAX_CUF_PROFILES; ++i)
        _CUFProfiles[i] = nullptr;

    ClearResurrectRequestData();

    delete m_vis;

    delete _wargameRequest;

    sWorld->DecreasePlayerCount();

   //Clear container
    while (!m_updatePacket.empty())
        m_updatePacket.pop();
    while (!m_updatePacketInRange.empty())
        m_updatePacketInRange.pop();
    while (!m_timeSyncQueue.empty())
        m_timeSyncQueue.pop();

    _researchSites.clear();
    _completedProjects.clear();
    m_clientGUIDs.clear();
    m_extraLookList.clear();
    m_DFQuests.clear();
    for (uint8 i = 0; i < MAX_BOUND; ++i)
        m_boundInstances[i].clear();
    WhisperList.clear();
    m_sceneInstanceID.clear();
    m_timedquests.clear();
    m_weeklyquests.clear();
    m_dailyquests.clear();
    m_seasonalquests.clear();
    m_worldquests.clear();
    _currencyStorage.clear();
    m_itemUpdateQueue.clear();
    m_itemUpdate.clear();
    for (std::set<Item*>::iterator i = m_itemDelete.begin(); i != m_itemDelete.end(); ++i)
    {
        Item* item = *i;
        if (!item || item->IsInWorld())
            continue;

        delete item;
    }
    m_itemDelete.clear();
    m_QuestStatus.clear();
    m_QuestStatusSave.clear();
    m_RewardedQuests.clear();
    m_RewardedQuestsSave.clear();
    mSkillStatus.clear();
    m_overrideSpells.clear();
    m_spellOverrides.clear();
    m_itemSpellList.clear();
    m_excludeCasterSpellList.clear();
    m_casterAuraStateSSpellList.clear();
    m_actionButtons.clear();
    for (uint32 j = 0; j < MAX_SPELLMOD; ++j)
        m_spellMods[j].clear();
    m_enchantDuration.clear();
    m_itemDuration.clear();
    m_itemSoulboundTradeable.clear();
    m_channels.clear();
    m_PetSlots.clear();
    _battlePets.clear();
    AllArtifacts.clear();
    _oldPetBattleSpellToMerge.clear();
    _equipmentSets.clear();
    m_refundableItems.clear();
    m_spellCooldowns.clear();
    m_spellChargeData.clear();
    m_BracketsList.clear();
    for(int i = 0; i < MAX_LOOT_COOLDOWN_TYPE; i++)
        m_playerLootCooldown[i].clear();
    m_sceneStatus.clear();
    GlobalArtifactData.clear();
    m_QuestStatusVector->clear();
    mSkillStatusVector->clear();
    ItemSetEff->clear();
    mSkillSpellCount.clear();
    m_spellInQueue.Clear();

    delete m_QuestStatusVector;
    delete mSkillStatusVector;
    delete ItemSetEff;

    delete _collectionMgr;
    _collectionMgr = nullptr;

    delete _garrison;
    _garrison = nullptr;

    objectCountInWorld[uint8(HighGuid::Player)]--;

    m_session->SetPlayer(nullptr);
}

void Player::CleanupsBeforeDelete(bool finalCleanup)
{
    TradeCancel(false);
    DuelComplete(DUEL_INTERRUPTED);

    Unit::CleanupsBeforeDelete(finalCleanup);

    // clean up player-instance binds, may unload some instance saves
    for (uint8 i = 0; i < MAX_BOUND; ++i)
        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
            itr->second.save->RemovePlayer(this);
}

bool Player::Create(ObjectGuid::LowType guidlow, WorldPackets::Character::CharacterCreateInfo* createInfo)
{
    _Create(ObjectGuid::Create<HighGuid::Player>(guidlow));

    m_name = createInfo->Name;

    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(createInfo->Race, createInfo->Class);
    if (!info)
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid race/class pair (%u/%u) - refusing to do so.",
                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Race, createInfo->Class);
        return false;
    }

    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; i++)
        m_items[i] = nullptr;

    ChrClassesEntry const* cEntry = sChrClassesStore.LookupEntry(createInfo->Class);
    if (!cEntry)
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid character class (%u) - refusing to do so (wrong DBC-files?)",
                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Class);
        return false;
    }

    ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(createInfo->Race);
    if (!rEntry)
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid character Race (%u) - refusing to do so (wrong DBC-files?)",
                GetSession()->GetAccountId(), m_name.c_str(), createInfo->Race);
        return false;
    }

    uint32 startLevel = rEntry->StartingLevel > cEntry->StartingLevel ? rEntry->StartingLevel : cEntry->StartingLevel;
    if (sWorld->getIntConfig(CONFIG_START_PLAYER_LEVEL) > startLevel)
        startLevel = sWorld->getIntConfig(CONFIG_START_PLAYER_LEVEL);

    uint64 money = sWorld->getIntConfig(CONFIG_START_PLAYER_MONEY) * 10000;

    WorldLocation loc(info->mapId, info->positionX, info->positionY, info->positionZ, info->orientation);

    bool loadoutItem = false;
    bool addArtifact = true;
    uint32 itemIlevel = 0;
    auto charTemplate = static_cast<CharacterTemplate const*>(nullptr);
    if (createInfo->TemplateSet.is_initialized())
    {
        
            if (CharacterTemplateData* charTemplateData = GetSession()->GetCharacterTemplateData(*createInfo->TemplateSet))
            {
                if (charTemplateData->active)
                {
                    charTemplate = charTemplateData->charTemplate;
                    startLevel = charTemplateData->level;
                    money = charTemplateData->money;
                    itemIlevel = charTemplateData->iLevel;
                    if (createInfo->Class != CLASS_DEMON_HUNTER)
                        loadoutItem = true;
                    addArtifact = charTemplateData->artifact;
                    charTemplateData->active = false;

                    if (charTemplate)
                        for (auto v : charTemplate->Classes)
                            if (v.ClassID == createInfo->Class)
                            {
                                Relocate(charTemplate->Pos);
                                loc = WorldLocation(charTemplate->MapID, charTemplate->Pos);
                                break;
                            }
                }
            }
        
    }

    Relocate(loc.GetPositionX(), loc.GetPositionY(), loc.GetPositionZ(), loc.GetOrientation());
    SetHomebind(loc, 0);

    if (ChrSpecializationEntry const* defaultSpec = sDB2Manager.GetDefaultChrSpecializationForClass(getClass()))
    {
        SetActiveTalentGroup(defaultSpec->OrderIndex);
        SetPrimarySpecialization(defaultSpec->ID);
    }

    SetMap(sMapMgr->CreateMap(loc.GetMapId(), this));

    uint8 powertype = cEntry->DisplayPower;

    SetFloatValue(UNIT_FIELD_BOUNDING_RADIUS, DEFAULT_WORLD_OBJECT_SIZE);
    SetFloatValue(UNIT_FIELD_COMBAT_REACH, 1.5f);

    setFactionForRace(createInfo->Race);

    if (!IsValidGender(createInfo->Sex))
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::Create: Possible hacking-attempt: Account %u tried creating a character named '%s' with an invalid gender (%hu) - refusing to do so",
            GetSession()->GetAccountId(), m_name.c_str(), createInfo->Sex);
        return false;
    }

    SetRace(createInfo->Race);
    SetClass(createInfo->Class);
    SetGender(createInfo->Sex);
    SetFieldPowerType(powertype);

    InitDisplayIds();
    //if (sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_PVP || sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_RPPVP)
    {
        SetByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_PVP);
        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
    }
    SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_REGENERATE_POWER);
    SetFloatValue(UNIT_FIELD_MOD_CASTING_SPEED, 1.0f);               // fix cast time showed in spell tooltip on client
    SetFloatValue(UNIT_FIELD_MOD_SPELL_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_RANGED_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_TIME_RATE, 1.0f);
    SetFloatValue(UNIT_FIELD_HOVER_HEIGHT, 1.0f);            // default for players in 3.0.3

    for (uint16 i = 0; i < uint16(sItemModifiedAppearanceStore.GetNumRows()/32); ++i)
        AddDynamicValue(PLAYER_DYNAMIC_FIELD_TRANSMOG, 0);

    SetInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, -1);

    SetByteValue(PLAYER_FIELD_BYTES_1, PLAYER_BYTES_1_SKIN_ID, createInfo->Skin);
    SetByteValue(PLAYER_FIELD_BYTES_1, PLAYER_BYTES_1_FACE_ID, createInfo->Face);
    SetByteValue(PLAYER_FIELD_BYTES_1, PLAYER_BYTES_1_HAIR_STYLE_ID, createInfo->HairStyle);
    SetByteValue(PLAYER_FIELD_BYTES_1, PLAYER_BYTES_1_HAIR_COLOR_ID, createInfo->HairColor);
    for (uint32 i = 0; i < PLAYER_CUSTOM_DISPLAY_SIZE; ++i)
        SetByteValue(PLAYER_FIELD_BYTES_2, PLAYER_BYTES_2_OFFSET_CUSTOM_DISPLAY_OPTION + i, createInfo->CustomDisplay[i]);
    SetByteValue(PLAYER_FIELD_BYTES_2, PLAYER_BYTES_2_OFFSET_FACIAL_STYLE, createInfo->FacialHairStyle);

    // SetByteValue(PLAYER_FIELD_BYTES_3, PLAYER_BYTES_3_OFFSET_BANK_BAG_SLOTS, slot);
    SetByteValue(PLAYER_FIELD_BYTES_3, PLAYER_BYTES_3_OFFSET_GENDER, createInfo->Sex);
    // SetByteValue(PLAYER_FIELD_BYTES_3, PLAYER_BYTES_3_OFFSET_INEBRIATION, Drunk);

    SetByteValue(PLAYER_FIELD_BYTES_6, PLAYER_BYTES_6_OFFSET_ARENA_FACTION, 0);
    SetInventorySlotCount(INVENTORY_DEFAULT_SIZE);

    SetUInt32Value(PLAYER_FIELD_REST_INFO + REST_STATE_XP, (GetSession()->IsARecruiter() || GetSession()->GetRecruiterId() != 0) ? REST_STATE_RAF_LINKED : REST_STATE_NOT_RAF_LINKED);
    SetUInt32Value(PLAYER_FIELD_REST_INFO + REST_STATE_HONOR, REST_STATE_NOT_RAF_LINKED);

    SetGuidValue(OBJECT_FIELD_DATA, ObjectGuid::Empty);
    SetUInt32Value(PLAYER_FIELD_GUILD_RANK_ID, 0);
    SetGuildLevel(0);
    SetUInt32Value(PLAYER_FIELD_GUILD_TIME_STAMP, 0);

    for (int i = 0; i < KNOWN_TITLES_SIZE; ++i)
        SetUInt64Value(PLAYER_FIELD_KNOWN_TITLES + i, 0);  // 0=disabled
    SetUInt32Value(PLAYER_FIELD_PLAYER_TITLE, 0);

    SetUInt32Value(PLAYER_FIELD_VIRTUAL_PLAYER_REALM, GetVirtualRealmAddress());

    SetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0);
    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 0);

    //enable change stat at apply aura spell or item mods.
    SetCanModifyStats(true);
    SetUInt32Value(UNIT_FIELD_LEVEL, startLevel);
    SetUInt32Value(UNIT_FIELD_EFFECTIVE_LEVEL, 0);

    InitRunes();
    InitBrackets();

    SetUInt32Value(PLAYER_FIELD_COINAGE, money);

    // start with every map explored
    if (sWorld->getBoolConfig(CONFIG_START_ALL_EXPLORED))
        for (uint16 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; ++i)
            SetFlag(PLAYER_FIELD_EXPLORED_ZONES + i, 0xFFFFFFFF);

    //Reputations if "StartAllReputation" is enabled, -- TODO: Fix this in a better way
    if (sWorld->getBoolConfig(CONFIG_START_ALL_REP))
    {
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(942), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(935), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(936), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1011), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(970), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(967), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(989), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(932), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(934), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1038), 42999);
        GetReputationMgr().SetReputation(sFactionStore.LookupEntry(1077), 42999);

        // Factions depending on team, like cities and some more stuff
        switch (GetTeam())
        {
        case ALLIANCE:
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(72), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(47), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(69), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(930), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(730), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(978), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(54), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(946), 42999);
            break;
        case HORDE:
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(76), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(68), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(81), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(911), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(729), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(941), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(530), 42999);
            GetReputationMgr().SetReputation(sFactionStore.LookupEntry(947), 42999);
            break;
        default:
            break;
        }
    }

    // Played time
    m_Last_tick = 0;
    m_Played_time[PLAYED_TIME_TOTAL] = 0;
    m_Played_time[PLAYED_TIME_LEVEL] = 0;
    m_account_time[PLAYED_TIME_TOTAL] = 0;
    m_account_time[PLAYED_TIME_LEVEL] = 0;

    // base stats and related field values
    InitStatsForLevel();
    InitTaxiNodesForLevel();
    InitTalentForLevel();
    InitPrimaryProfessions();                               // to max set before any spell added

    switch (getPowerType())
    {
        case POWER_MANA:
            UpdateMaxPower(POWER_MANA);                         // Update max Mana (for add bonus from intellect)
            SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
            break;
        default:
            break;
    }

    // original spells
    LearnDefaultSkills();
    
    LearnDefaultSpells();

    // enable basic auras. ToDo: find the way to do it not by hack.
    switch(getClass())
    {
        case CLASS_WARRIOR:
            AddAura(2457, this);   //Battle Stance
            break;
        case CLASS_MONK:
            AddAura(103985, this);  //Stance of the Fierce Tiger
            break;
        default:
            break;
    }

    // original action bar
    for (PlayerCreateInfoActions::const_iterator action_itr = info->action.begin(); action_itr != info->action.end(); ++action_itr)
        addActionButton(action_itr->button, action_itr->action, action_itr->type);

    if (PlayerInfo const* allInfo = sObjectMgr->GetPlayerInfo(RACE_NONE, CLASS_NONE))
        for (PlayerCreateInfoActions::const_iterator action_itr = allInfo->action.begin(); action_itr != allInfo->action.end(); ++action_itr)
            addActionButton(action_itr->button, action_itr->action, action_itr->type);

    uint8 FactionGroup = GetTeamId() == TEAM_HORDE ? FACTION_MASK_HORDE : FACTION_MASK_ALLIANCE;
    if (charTemplate && !charTemplate->Items.empty())
    {
        for (CharacterTemplateItem const& v : charTemplate->Items)
            if ((!v.ClassID || v.ClassID == createInfo->Class) && (!v.FactionGroup || (v.FactionGroup & FactionGroup)) && (!v.RaceMask || v.RaceMask & getRaceMask()))
            {
                if (ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(v.ItemID))
                {
                    if (!addArtifact && pProto->GetArtifactID())
                        continue;

                    std::vector<uint32> bonusListIDs = sObjectMgr->GetItemBonusForLevel(v.ItemID, GetMap()->GetDifficultyLootItemContext(), getLevel(), itemIlevel);
                    StoreNewItemInBestSlots(v.ItemID, v.Count, true, bonusListIDs);
                }
            }
    }
    else if (loadoutItem)
    {
        std::array<std::vector<uint32>, 2> itemsArray = sDB2Manager.GetItemLoadOutItemsByClassID(getClass(), 4);
        for (uint32 itemID : itemsArray[0])
            if (ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(itemID))
                StoreNewItemInBestSlots(itemID, pProto->GetInventoryType() != INVTYPE_BAG  ? 1 : 4);
    }
    else
    {
        CharStartOutfitEntry const* oEntry = nullptr;
        for (CharStartOutfitEntry const* entry : sCharStartOutfitStore)
            if (entry->RaceID == createInfo->Race && entry->ClassID == createInfo->Class && entry->SexID == createInfo->Sex)
            {
                oEntry = entry;
                break;
            }

        if (oEntry)
        {
            for (int j = 0; j < MAX_OUTFIT_ITEMS; ++j)
            {
                if (oEntry->ItemID[j] <= 0)
                    continue;

                uint32 itemId = oEntry->ItemID[j];
                ItemTemplate const* iProto = sObjectMgr->GetItemTemplate(itemId);
                if (!iProto)
                    continue;

                uint32 count = iProto->VendorStackCount;
                if (iProto->GetClass() == ITEM_CLASS_CONSUMABLE && iProto->GetSubClass() == ITEM_SUBCLASS_FOOD_DRINK)
                {
                    switch (iProto->Effects[0]->SpellCategoryID)
                    {
                        case SPELL_CATEGORY_FOOD:
                            count = getClass() == CLASS_DEATH_KNIGHT ? 10 : 4;
                            break;
                        case SPELL_CATEGORY_DRINK:
                            count = 2;
                            break;
                    }

                    if (iProto->GetMaxStackSize() < count)
                        count = iProto->GetMaxStackSize();
                }

                switch (itemId)
                {
                    // Pandaren start weapons, they are given with the first quest
                    case 73207:
                    case 73208:
                    case 73209:
                    case 73210:
                    case 73211:
                    case 73212:
                    case 73213:
                    case 76390:
                    case 76391:
                    case 76392:
                    case 76393:
                        continue;
                    default:
                        break;
                }

                StoreNewItemInBestSlots(itemId, count);
            }
        }

        for (auto const& itr : info->item)
            StoreNewItemInBestSlots(itr.item_id, itr.item_amount, true, itr.item_bonusListIDs);

        if (PlayerInfo const* allInfo = sObjectMgr->GetPlayerInfo(RACE_NONE, CLASS_NONE))
            for (auto const& itr : allInfo->item)
                StoreNewItemInBestSlots(itr.item_id, itr.item_amount, true, itr.item_bonusListIDs);
    }

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); ++i)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            uint16 eDest;
            InventoryResult msg = CanEquipItem(NULL_SLOT, eDest, pItem, false);
            if (msg == EQUIP_ERR_OK)
            {
                RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
                EquipItem(eDest, pItem, true);
            }
            else
            {
                ItemPosCountVec sDest;
                msg = CanStoreItem(NULL_BAG, NULL_SLOT, sDest, pItem, false);
                if (msg == EQUIP_ERR_OK)
                {
                    RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
                    pItem = StoreItem(sDest, pItem, true);
                }
            }
        }
    }

    // all item positions resolved

    //! Important. Should be after apply equipment.
    // apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()
    UpdateMaxHealth();                                      // Update max Health (for add bonus from stamina)
    SetFullHealth();

    // Add item to collection
    AddNonVisibleItemToCollect();

    for (std::list<uint32> ::const_iterator quest_itr = info->quests.begin(); quest_itr != info->quests.end(); ++quest_itr)
    {
        if (Quest const* quest = quest = sQuestDataStore->GetQuestTemplate(*quest_itr))
        {
            AddQuest(quest, NULL);
            CompleteQuest(quest->Id);
            RewardQuest(quest, 0, this);
        }
    }

    if (PlayerInfo const* allInfo = sObjectMgr->GetPlayerInfo(RACE_NONE, CLASS_NONE))
    {
        for (std::list<uint32> ::const_iterator quest_itr = allInfo->quests.begin(); quest_itr != allInfo->quests.end(); ++quest_itr)
        {
            if (Quest const* quest = quest = sQuestDataStore->GetQuestTemplate(*quest_itr))
            {
                AddQuest(quest, NULL);
                CompleteQuest(quest->Id);
                RewardQuest(quest, 0, this);
            }
        }
    }

    if (charTemplate && !charTemplate->Quests.empty())
    {
        for (CharacterTemplateQuest const& v : charTemplate->Quests)
            if ((!v.ClassID || v.ClassID == createInfo->Class) && (!v.FactionGroup || (v.FactionGroup & FactionGroup)) && (!v.RaceMask || v.RaceMask & getRaceMask()))
            {
                if (Quest const* quest = quest = sQuestDataStore->GetQuestTemplate(v.QuestID))
                {
                    AddQuest(quest, NULL);
                    CompleteQuest(quest->Id);
                    RewardQuest(quest, 0, this);
                }
            }
    }

    if (charTemplate && !charTemplate->Spells.empty())
    {
        for (CharacterTemplateSpell const& v : charTemplate->Spells)
            if ((!v.ClassID || v.ClassID == createInfo->Class) && (!v.FactionGroup || (v.FactionGroup & FactionGroup)) && (!v.RaceMask || v.RaceMask & getRaceMask()))
                learnSpell(v.SpellID, false);
    }

    if (charTemplate && !charTemplate->Titles.empty())
    {
        for (CharacterTemplateTitle const& v : charTemplate->Titles)
            if ((!v.ClassID || v.ClassID == createInfo->Class) && (!v.FactionGroup || (v.FactionGroup & FactionGroup)) && (!v.RaceMask || v.RaceMask & getRaceMask()))
                if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(v.TitleID))
                    SetTitle(titleEntry);
    }

    return true;
}

bool Player::StoreNewItemInBestSlots(uint32 titem_id, uint32 titem_amount, bool not_loading/*=true*/, std::vector<uint32> const& bonusListIDs/* = std::vector<uint32>()*/)
{
    std::ostringstream ss;
    for (uint32 bonusListID : bonusListIDs)
        ss << " " << bonusListID;
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: Creating initial item, itemId = %u, count = %u bonusListIDs %s", titem_id, titem_amount, ss.str().c_str());

    // attempt equip by one
    while (titem_amount > 0)
    {
        uint16 eDest;
        InventoryResult msg = CanEquipNewItem(NULL_SLOT, eDest, titem_id, false, not_loading);
        if (msg != EQUIP_ERR_OK)
            break;

        EquipNewItem(eDest, titem_id, true, Item::GenerateItemRandomPropertyId(titem_id, GetLootSpecID()).Id, bonusListIDs);
        AutoUnequipOffhandIfNeed();
        --titem_amount;
    }

    if (titem_amount == 0)
        return true;                                        // equipped

    // attempt store
    ItemPosCountVec sDest;
    // store in main bag to simplify second pass (special bags can be not equipped yet at this moment)
    InventoryResult msg = CanStoreNewItem(INVENTORY_SLOT_BAG_0, NULL_SLOT, sDest, titem_id, titem_amount);
    if (msg == EQUIP_ERR_OK)
    {
        StoreNewItem(sDest, titem_id, true, Item::GenerateItemRandomPropertyId(titem_id, GetLootSpecID()), GuidSet(), bonusListIDs);
        return true;                                        // stored
    }

    // item can't be added
    TC_LOG_ERROR(LOG_FILTER_PLAYER_ITEMS, "STORAGE: Can't equip or store initial item %u for race %u class %u, error msg = %u", titem_id, getRace(), getClass(), msg);
    return false;
}

void Player::ApplyOnItems(uint8 type, std::function<bool(Player*, Item*, uint8, uint8)>&& function)
{
    switch (type)
    {
        case 1:
        {
            for (uint32 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); i++)
                if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (!function(this, item, INVENTORY_SLOT_BAG_0, i))
                        return;

            for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
                if (Bag* bag = GetBagByPos(i))
                    for (uint32 j = 0; j < bag->GetBagSize(); ++j)
                        if (Item* item = GetItemByPos(i, j))
                            if (!function(this, item, i, j))
                                return;
            break;
        }
        case 2:
        {
            for (uint32 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
                if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (!function(this, item, INVENTORY_SLOT_BAG_0, i))
                        return;

            for (uint32 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
                if (Bag* bag = GetBagByPos(i))
                    for (uint32 j = 0; j < bag->GetBagSize(); ++j)
                        if (Item* item = GetItemByPos(i, j))
                            if (!function(this, item, i, j))
                                return;
            break;
        }
        case 3:
        {
            for (uint32 i = REAGENT_SLOT_START; i < REAGENT_SLOT_END; ++i)
                if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (!function(this, item, INVENTORY_SLOT_BAG_0, i))
                        return;
            break;
        }
        default:
            break;
    }
}

void Player::SendMirrorTimer(MirrorTimerType type, uint32 maxValue, uint32 currentValue, int32 regen)
{
    if (int(maxValue) == DISABLED_MIRROR_TIMER)
    {
        if (int(currentValue) != DISABLED_MIRROR_TIMER)
            StopMirrorTimer(type);
        return;
    }

    WorldPackets::Misc::StartMirrorTimer timer;
    timer.Scale = regen;
    timer.MaxValue = maxValue;
    timer.Timer = type;
    timer.SpellID = 0;
    timer.Value = currentValue;
    timer.Paused = false;
    SendDirectMessage(timer.Write());
}

void Player::StopMirrorTimer(MirrorTimerType timer)
{
    m_MirrorTimer[timer] = DISABLED_MIRROR_TIMER;
    SendDirectMessage(WorldPackets::Misc::StopMirrorTimer(timer).Write());
}

bool Player::IsImmuneToEnvironmentalDamage()
{
    // check for GM and death state included in isAttackableByAOE
    return (!isTargetableForAttack(false));
}

uint32 Player::EnvironmentalDamage(EnviromentalDamage type, uint32 damage)
{
    if (IsImmuneToEnvironmentalDamage())
        return 0;

    damage *= GetTotalAuraMultiplier(SPELL_AURA_MOD_ENVIRONMENTAL_DAMAGE_TAKEN);

    // Absorb, resist some environmental damage type
    uint32 absorb = 0;
    uint32 resist = 0;
    if (type == DAMAGE_LAVA)
        CalcAbsorbResist(this, SPELL_SCHOOL_MASK_FIRE, DIRECT_DAMAGE, damage, &absorb, &resist);
    else if (type == DAMAGE_SLIME)
        CalcAbsorbResist(this, SPELL_SCHOOL_MASK_NATURE, DIRECT_DAMAGE, damage, &absorb, &resist);

    damage -= absorb + resist;

    DealDamageMods(this, damage, &absorb);

    WorldPackets::CombatLog::EnvironmentalDamageLog packet;
    packet.Victim = GetGUID();
    packet.Type = type != DAMAGE_FALL_TO_VOID ? type : DAMAGE_FALL;
    packet.Amount = damage;
    packet.Absorbed = absorb;
    packet.Resisted = resist;
    packet.LogData.Initialize(this);
    SendCombatLogMessage(&packet);

    uint32 final_damage = DealDamage(this, damage, NULL, SELF_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);

    if (!isAlive())
    {
        if (type == DAMAGE_FALL)                               // DealDamage not apply item durability loss at self damage
        {
            TC_LOG_DEBUG(LOG_FILTER_PLAYER, "We are fall to death, loosing 10 percents durability");
            if (!GetUInt32Value(PLAYER_FIELD_STURDINESS))
                DurabilityLossAll(0.10f, false, true);
            // durability lost message
            SendDurabilityLoss(this, 10);
        }

        UpdateAchievementCriteria(CRITERIA_TYPE_DEATHS_FROM, 1, type);
    }

    return final_damage;
}

int32 Player::getMaxTimer(MirrorTimerType timer)
{
    switch (timer)
    {
        case FATIGUE_TIMER:
            return MINUTE * IN_MILLISECONDS;
        case BREATH_TIMER:
        {
            if (!isAlive() || HasAuraType(SPELL_AURA_WATER_BREATHING) || GetSession()->GetSecurity() >= AccountTypes(sWorld->getIntConfig(CONFIG_DISABLE_BREATHING)))
                return DISABLED_MIRROR_TIMER;

            return (3 * MINUTE * IN_MILLISECONDS) * GetTotalAuraMultiplier(SPELL_AURA_MOD_WATER_BREATHING);
        }
        case FIRE_TIMER:
        {
            if (!isAlive())
                return DISABLED_MIRROR_TIMER;
            return 1 * IN_MILLISECONDS;
        }
        default:
            return 0;
    }
}

void Player::UpdateMirrorTimers()
{
    // Desync flags for update on next HandleDrowning
    if (m_MirrorTimerFlags)
        m_MirrorTimerFlagsLast = ~m_MirrorTimerFlags;
}

void Player::StopMirrorTimers()
{
    StopMirrorTimer(FATIGUE_TIMER);
    StopMirrorTimer(BREATH_TIMER);
    StopMirrorTimer(FIRE_TIMER);
}

bool Player::IsMirrorTimerActive(MirrorTimerType type)
{
    return m_MirrorTimer[type] == getMaxTimer(type);
}

void Player::HandleDrowning(uint32 time_diff)
{
    //! Why? We need remove state when where is no flag.
    //if (!m_MirrorTimerFlags)
    //    return;

    // In water
    if (m_MirrorTimerFlags & UNDERWATER_INWATER)
    {
        // Vash'jir zones
        if (m_zoneId == 4815 || m_zoneId == 4816 || m_zoneId == 5144 || m_zoneId == 5145 || m_zoneId == 5146)
            return;

        // Breath timer not activated - activate it
        if (m_MirrorTimer[BREATH_TIMER] == DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimer[BREATH_TIMER] = getMaxTimer(BREATH_TIMER);
            SendMirrorTimer(BREATH_TIMER, m_MirrorTimer[BREATH_TIMER], m_MirrorTimer[BREATH_TIMER], -1);
        }
        else                                                              // If activated - do tick
        {
            m_MirrorTimer[BREATH_TIMER]-=time_diff;
            // Timer limit - need deal damage
            if (m_MirrorTimer[BREATH_TIMER] < 0)
            {
                m_MirrorTimer[BREATH_TIMER]+= 1*IN_MILLISECONDS;
                // Calculate and deal damage
                // TODO: Check this formula
                uint32 damage = GetMaxHealth() / 5 + urand(0, GetEffectiveLevel()-1);
                EnvironmentalDamage(DAMAGE_DROWNING, damage);
            }
            else if (!(m_MirrorTimerFlagsLast & UNDERWATER_INWATER))      // Update time in client if need
                SendMirrorTimer(BREATH_TIMER, getMaxTimer(BREATH_TIMER), m_MirrorTimer[BREATH_TIMER], -1);
        }
    }
    else if (m_MirrorTimer[BREATH_TIMER] != DISABLED_MIRROR_TIMER)        // Regen timer
    {
        int32 UnderWaterTime = getMaxTimer(BREATH_TIMER);
        // Need breath regen
        m_MirrorTimer[BREATH_TIMER]+=10*time_diff;
        if (m_MirrorTimer[BREATH_TIMER] >= UnderWaterTime || !isAlive())
            StopMirrorTimer(BREATH_TIMER);
        else if (m_MirrorTimerFlagsLast & UNDERWATER_INWATER)
            SendMirrorTimer(BREATH_TIMER, UnderWaterTime, m_MirrorTimer[BREATH_TIMER], 10);
    }

    // In dark water
    if ((m_MirrorTimerFlags & UNDERWARER_INDARKWATER) && !GetVehicle())
    {
        if (GetMapId() == 530 && GetCurrentZoneID() == 3455)
            return;

        // Fatigue timer not activated - activate it
        if (m_MirrorTimer[FATIGUE_TIMER] == DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimer[FATIGUE_TIMER] = getMaxTimer(FATIGUE_TIMER);
            SendMirrorTimer(FATIGUE_TIMER, m_MirrorTimer[FATIGUE_TIMER], m_MirrorTimer[FATIGUE_TIMER], -1);
        }
        else
        {
            m_MirrorTimer[FATIGUE_TIMER]-=time_diff;
            // Timer limit - need deal damage or teleport ghost to graveyard
            if (m_MirrorTimer[FATIGUE_TIMER] < 0)
            {
                m_MirrorTimer[FATIGUE_TIMER]+= 1*IN_MILLISECONDS;
                if (isAlive())                                              // Calculate and deal damage
                {
                    uint32 damage = GetMaxHealth() / 5 + urand(0, GetEffectiveLevel()-1);
                    EnvironmentalDamage(DAMAGE_EXHAUSTED, damage);
                }
                else if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GHOST))         // Teleport ghost to graveyard
                    RepopAtGraveyard();
            }
            else if (!(m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER))
                SendMirrorTimer(FATIGUE_TIMER, getMaxTimer(FATIGUE_TIMER), m_MirrorTimer[FATIGUE_TIMER], -1);
        }
    }
    else if (m_MirrorTimer[FATIGUE_TIMER] != DISABLED_MIRROR_TIMER)       // Regen timer
    {
        int32 DarkWaterTime = getMaxTimer(FATIGUE_TIMER);
        m_MirrorTimer[FATIGUE_TIMER]+=10*time_diff;
        if (m_MirrorTimer[FATIGUE_TIMER] >= DarkWaterTime || !isAlive())
            StopMirrorTimer(FATIGUE_TIMER);
        else if (m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER)
            SendMirrorTimer(FATIGUE_TIMER, DarkWaterTime, m_MirrorTimer[FATIGUE_TIMER], 10);
    }

    if (m_MirrorTimerFlags & (UNDERWATER_INLAVA /*| UNDERWATER_INSLIME*/) && !(_lastLiquid && _lastLiquid->SpellID))
    {
        // Breath timer not activated - activate it
        if (m_MirrorTimer[FIRE_TIMER] == DISABLED_MIRROR_TIMER)
            m_MirrorTimer[FIRE_TIMER] = getMaxTimer(FIRE_TIMER);
        else
        {
            m_MirrorTimer[FIRE_TIMER] -= time_diff;
            if (m_MirrorTimer[FIRE_TIMER] < 0)
            {
                m_MirrorTimer[FIRE_TIMER]+= 1*IN_MILLISECONDS;
                // Calculate and deal damage
                // TODO: Check this formula
                uint32 damage = CountPctFromMaxHealth(9);
                if (m_MirrorTimerFlags & UNDERWATER_INLAVA)
                    EnvironmentalDamage(DAMAGE_LAVA, damage);
                // need to skip Slime damage in Undercity,
                // maybe someone can find better way to handle environmental damage
                //else if (m_zoneId != 1497)
                //    EnvironmentalDamage(DAMAGE_SLIME, damage);
            }
        }
    }
    else
        m_MirrorTimer[FIRE_TIMER] = DISABLED_MIRROR_TIMER;

    // Recheck timers flag
    m_MirrorTimerFlags&=~UNDERWATER_EXIST_TIMERS;
    for (uint8 i = 0; i< MAX_TIMERS; ++i)
        if (m_MirrorTimer[i] != DISABLED_MIRROR_TIMER)
        {
            m_MirrorTimerFlags|=UNDERWATER_EXIST_TIMERS;
            break;
        }
    m_MirrorTimerFlagsLast = m_MirrorTimerFlags;
}

///The player sobers by 1% every 9 seconds
void Player::HandleSobering()
{
    m_drunkTimer = 0;

    uint8 currentDrunkValue = GetDrunkValue();
    uint8 drunk = currentDrunkValue ? --currentDrunkValue : 0;
    SetDrunkValue(drunk);
}

DrunkenState Player::GetDrunkenstateByValue(uint8 value)
{
    if (value >= 90)
        return DRUNKEN_SMASHED;
    if (value >= 50)
        return DRUNKEN_DRUNK;
    if (value)
        return DRUNKEN_TIPSY;
    return DRUNKEN_SOBER;
}

void Player::SetDrunkValue(uint8 newDrunkValue, uint32 itemId /*= 0*/)
{
    bool isSobering = newDrunkValue < GetDrunkValue();
    uint32 oldDrunkenState = GetDrunkenstateByValue(GetDrunkValue());
    if (newDrunkValue > 100)
        newDrunkValue = 100;

    // select drunk percent or total SPELL_AURA_MOD_FAKE_INEBRIATE amount, whichever is higher for visibility updates
    int32 drunkPercent = std::max<int32>(newDrunkValue, GetTotalAuraModifier(SPELL_AURA_MOD_FAKE_INEBRIATE));
    if (drunkPercent)
    {
        m_invisibilityDetect.AddFlag(INVISIBILITY_DRUNK);
        m_invisibilityDetect.SetValue(INVISIBILITY_DRUNK, drunkPercent);
    }
    else if (!HasAuraType(SPELL_AURA_MOD_FAKE_INEBRIATE) && !newDrunkValue)
        m_invisibilityDetect.DelFlag(INVISIBILITY_DRUNK);

    uint32 newDrunkenState = GetDrunkenstateByValue(newDrunkValue);
    SetByteValue(PLAYER_FIELD_BYTES_3, PLAYER_BYTES_3_OFFSET_INEBRIATION, newDrunkValue);
    UpdateObjectVisibility();

    if (!isSobering)
        m_drunkTimer = 0;   // reset sobering timer

    if (newDrunkenState == oldDrunkenState)
        return;

    WorldPackets::Misc::CrossedInebriationThreshold packet;
    packet.Guid = GetGUID();
    packet.Threshold = newDrunkenState;
    packet.ItemID = itemId;
    SendMessageToSet(packet.Write(), true);
}

void Player::Update(uint32 p_time)
{
    volatile uint32 guidlow = GetGUIDLow();

    SendUpdateData(); // Send packet from queue

    if (!IsInWorld() || IsDelete() || IsPreDelete() || m_isUpdate)
        return;

    m_isUpdate = true;

    // undelivered mail
    if (m_nextMailDelivereTime && m_nextMailDelivereTime <= time(NULL))
    {
        SendNewMail();
        ++unReadMails;

        // It will be recalculate at mailbox open (for unReadMails important non-0 until mailbox open, it also will be recalculated)
        m_nextMailDelivereTime = 0;
    }

    // If this is set during update SetSpellModTakingSpell call is missing somewhere in the code
    // Having this would prevent more aura charges to be dropped, so let's crash
    if (m_spellModTakingSpell)
    {
        TC_LOG_FATAL(LOG_FILTER_SPELLS_AURAS, "Player has m_spellModTakingSpell %u during update!", m_spellModTakingSpell->m_spellInfo->Id);
        m_spellModTakingSpell = NULL;
    }

    //used to implement delayed far teleports
    SetCanDelayTeleport(true);
    Unit::Update(p_time);
    SetCanDelayTeleport(false);

    time_t now = time(NULL);

    if (_wargameRequest != nullptr && (_wargameRequest->CreationDate + 60) < now)
    {
        delete _wargameRequest;
        _wargameRequest = nullptr;
    }

    UpdatePvPFlag(now);

    UpdateContestedPvP(p_time);

    UpdateDuelFlag(p_time);

    CheckDuelDistance();

    UpdateAfkReport(now);

    if (isCharmed())
        if (Unit* charmer = GetCharmer())
            if (charmer->IsCreature() && charmer->isAlive())
                UpdateCharmedAI();

    if (!m_timedquests.empty())
    {
        QuestSet::iterator iter = m_timedquests.begin();
        while (iter != m_timedquests.end())
        {
            QuestStatusData* q_status = getQuestStatus(*iter);
            if (!q_status)
            {
                m_timedquests.erase(iter++);
                continue;
            }
            if (q_status->Timer <= p_time)
            {
                uint32 quest_id  = *iter;
                ++iter;                                     // current iter will be removed in FailQuest
                FailQuest(quest_id);
            }
            else
            {
                q_status->Timer -= p_time;
                m_QuestStatusSave[*iter] = QUEST_DEFAULT_SAVE_TYPE;
                ++iter;
            }
        }
    }

    m_achievementMgr->UpdateTimedAchievements(p_time);

    if (HasUnitState(UNIT_STATE_MELEE_ATTACKING) && !HasUnitState(UNIT_STATE_CASTING))
    {
        if (Unit* victim = getVictim())
        {
            // default combat reach 10
            // TODO add weapon, skill check

            if (isAttackReady(BASE_ATTACK))
            {
                uint32 triggerSpellId = m_overrideAutoattack[BASE_ATTACK];
                uint32 auraId = 0;
                bool isRangedSpell = false;
                float addDist = GetTotalAuraModifier(SPELL_AURA_MOD_AUTO_ATTACK_RANGE);
                bool isWithinMeleeRange = IsWithinMeleeRange(victim, addDist + MELEE_RANGE);

                if (triggerSpellId)
                {
                    if (SpellInfo const* triggerSpellInfo = sSpellMgr->GetSpellInfo(triggerSpellId))
                        isRangedSpell = !(triggerSpellInfo->HasAttribute(SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS));
                }

                if (!isWithinMeleeRange && !isRangedSpell)
                    setAttackTimer(BASE_ATTACK, 100);
                else if (!HasInArc(2*M_PI/3, victim)) // 120 degrees of radiant range
                    setAttackTimer(BASE_ATTACK, 100);
                else
                {
                    m_swingErrorMsg = 0;                    // reset swing error state

                    // prevent base and off attack in same time, delay attack at 0.2 sec
                    if (haveOffhandWeapon())
                        if (getAttackTimer(OFF_ATTACK) < ATTACK_DISPLAY_DELAY)
                            setAttackTimer(OFF_ATTACK, ATTACK_DISPLAY_DELAY);

                    AttackerStateUpdate(victim, BASE_ATTACK, false, triggerSpellId, auraId);
                        resetAttackTimer(BASE_ATTACK);
                }
            }

            if (haveOffhandWeapon() && isAttackReady(OFF_ATTACK))
            {
                uint32 triggerSpellId = m_overrideAutoattack[OFF_ATTACK];
                uint32 auraId = 0;
                bool isRangedSpell = false;
                bool isWithinMeleeRange = IsWithinMeleeRange(victim);

                if (triggerSpellId)
                {
                    if (SpellInfo const* triggerSpellInfo = sSpellMgr->GetSpellInfo(triggerSpellId))
                        isRangedSpell = !(triggerSpellInfo->HasAttribute(SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS));
                }

                if (!isWithinMeleeRange && !isRangedSpell)
                    setAttackTimer(OFF_ATTACK, 100);
                else if (!HasInArc(2*M_PI/3, victim)) // 120 degrees of radiant range
                    setAttackTimer(OFF_ATTACK, 100);
                else
                {
                    // prevent base and off attack in same time, delay attack at 0.2 sec
                    if (getAttackTimer(BASE_ATTACK) < ATTACK_DISPLAY_DELAY)
                        setAttackTimer(BASE_ATTACK, ATTACK_DISPLAY_DELAY);

                    AttackerStateUpdate(victim, OFF_ATTACK, false, triggerSpellId, auraId);
                    resetAttackTimer(OFF_ATTACK);
                }
            }
        }
    }

    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING))
    {
        if (roll_chance_i(3) && GetTimeInnEnter() > 0)      // freeze update
        {
            auto time_inn = time(nullptr) - GetTimeInnEnter();
            if (time_inn >= 10)                             // freeze update
            {
                float bubble = 0.125f*sWorld->getRate(RATE_REST_INGAME);
                SetRestBonus(GetRestBonus() + time_inn * ((float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP) / 72000)*bubble);
                UpdateInnerTime(time(nullptr));
            }
        }
    }

    if (m_weaponChangeTimer > 0)
    {
        if (p_time >= m_weaponChangeTimer)
            m_weaponChangeTimer = 0;
        else
            m_weaponChangeTimer -= p_time;
    }

    if (m_zoneForce)
        UpdateZone(m_zoneId, m_areaId);

    if (m_zoneUpdateTimer > 0 && m_zoneUpdateAllow)
    {
        if (p_time >= m_zoneUpdateTimer)
        {
            m_zoneUpdateAllow = false;

            uint32 newzone, newarea;
            GetZoneAndAreaId(newzone, newarea);

            if (m_zoneId != newzone)
                UpdateZone(newzone, newarea);                // also update area
            else
            {
                // use area updates as well
                // needed for free far all arenas for example
                if (m_areaId != newarea)
                    UpdateArea(newarea);

                m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;
            }
        }
        else
            m_zoneUpdateTimer -= p_time;
    }

    m_timeSyncClient += p_time;

    if (m_timeSyncTimer > 0 && !IsBeingTeleportedFar())
    {
        if (p_time >= m_timeSyncTimer)
            SendTimeSync();
        else
            m_timeSyncTimer -= p_time;
    }

    m_pvpAuraCheckTimer -= p_time;
    if (m_pvpAuraCheckTimer <= 0)
    {
        if (Map* map = GetMap())
        {
			if (sWorld->getBoolConfig(CONFIG_PLAYER_ALLOW_PVP_TALENTS_ALL_THE_TIME) && getLevel() >= 110)
			{
				if (!HasPvpRulesEnabled())
					EnablePvpRules(false);
			}
			else 
			{
				bool hasTemplate = HasAura(SPELL_PRINCIPLES_OF_WAR);

				if (hasTemplate && !HasPvpStatsScalingEnabled() || !hasTemplate && HasPvpStatsScalingEnabled())
					sWorld->AddPvPMysticCount(); // for debug

				if (map->IsBattlegroundOrArena())
				{
					if (!HasPvpStatsScalingEnabled() || !HasPvpRulesEnabled() || !hasTemplate)
					{
						RemoveAurasDueToSpell(SPELL_PRINCIPLES_OF_WAR);
						AddAura(SPELL_PRINCIPLES_OF_WAR, this);
						EnablePvpRules(false);
					}
				}
				else if (map->IsDungeon())
				{
					if (HasPvpStatsScalingEnabled())
					{
						RemoveAurasDueToSpell(SPELL_PRINCIPLES_OF_WAR);
						RemoveAurasDueToSpell(SPELL_PRINCIPLES_OF_WAR_FROM_DUMMY);
					}
					if (HasPvpRulesEnabled())
					{
						RemoveAurasDueToSpell(SPELL_PVP_RULES_ENABLED);
					}
				}
				else
				{
					if (HasAura(SPELL_PRINCIPLES_OF_WAR))
						RemoveAurasDueToSpell(SPELL_PRINCIPLES_OF_WAR);
				}
			}
        }
        
        m_pvpAuraCheckTimer = 10000;
    }

    if (isAlive())
    {
        m_regenTimer += p_time;
        RegenerateAll();

        if (m_playerCommandCooldown)
        {
            m_playerCommandCooldown -= p_time;

            if (m_playerCommandCooldown < 0)
                m_playerCommandCooldown = 0;
        }

        m_statsUpdateTimer += p_time;
        if (m_statsUpdateTimer >= UPDATE_STATS_TIME)
        {
            UpdateStatsByMask();
            m_statsUpdateTimer = 0;
        }

        if (IsAIEnabled && GetAI())
            GetAI()->UpdateAI(p_time);
    }

    if (m_deathState == JUST_DIED)
        KillPlayer();

    if (m_nextSave > 0)
    {
        if (p_time >= m_nextSave)
        {
            // m_nextSave reseted in SaveToDB call
            SaveToDB();
            TC_LOG_DEBUG(LOG_FILTER_PLAYER, "Player '%s' (GUID: %u) saved", GetName(), GetGUIDLow());
        }
        else
            m_nextSave -= p_time;
    }

    //Handle Water/drowning
    HandleDrowning(p_time);

    // Played time
    m_Last_tick += p_time;
    if (m_Last_tick >= IN_MILLISECONDS)
    {
        uint32 tick_update = m_Last_tick / IN_MILLISECONDS;
        // Update items that have just a limited lifetime
        UpdateItemDuration(tick_update);

        // check every second
        UpdateSoulboundTradeItems();

        m_Played_time[PLAYED_TIME_TOTAL] += tick_update;        // Total played time
        m_Played_time[PLAYED_TIME_LEVEL] += tick_update;        // Level played time
        m_account_time[PLAYED_TIME_TOTAL] += tick_update;        // Total played time
        m_account_time[PLAYED_TIME_LEVEL] += tick_update;        // Level played time
        m_Last_tick -= tick_update * IN_MILLISECONDS;
    }

    if (GetDrunkValue())
    {
        m_drunkTimer += p_time;
        if (m_drunkTimer > 9 * IN_MILLISECONDS)
            HandleSobering();
    }

    if (HasPendingBind())
    {
        if (_pendingBindTimer <= p_time)
        {
            // Player left the instance
            if (_pendingBindId == GetInstanceId())
                BindToInstance();
            SetPendingBind(0, 0);
        }
        else
            _pendingBindTimer -= p_time;
    }

    // not auto-free ghost from body in instances
    if (m_deathTimer > 0 && !GetMap()->Instanceable() && !HasAuraType(SPELL_AURA_PREVENT_RESURRECTION))
    {
        if (p_time >= m_deathTimer)
        {
            m_deathTimer = 0;
            BuildPlayerRepop();
            RepopAtGraveyard();
        }
        else
            m_deathTimer -= p_time;
    }

    if (m_knockBackTimer)
    {
        if (m_knockBackTimer + 1000 < getMSTime())
        {
            m_knockBackTimer = 0;
            ClearUnitState(UNIT_STATE_JUMPING);
        }
    }

    UpdateEnchantTime(p_time);
    UpdateHomebindTime(p_time);

    // group update
    // Avoid spam of SMSG_PARTY_MEMBER_STAT
    if (m_groupUpdateDelay < p_time)
    {
        SendUpdateToOutOfRangeGroupMembers();
        m_groupUpdateDelay = 5000;
    }
    else
        m_groupUpdateDelay -= p_time;

    if (GetSession()->IsWardenModuleFailed())
    {
        if (m_clientCheckDelay < p_time)
        {
            SendVersionMismatchWarinings();
            if (!m_clientKickDelay)
                m_clientKickDelay = 25000;
            m_clientCheckDelay = 11000;
        }
        else
            m_clientCheckDelay -= p_time;

        if (m_clientKickDelay)
        {
            if (m_clientKickDelay < p_time)
                GetSession()->KickPlayer();
            else
                m_clientKickDelay -= p_time;
        }
    }

    UpdateSpellCharges(p_time);

    Pet* pet = GetPet();
    if (pet && (HasUnitMovementFlag(MOVEMENTFLAG_FLYING) || !pet->IsWithinDistInMap(this, GetMap()->GetVisibilityRange())) && !pet->isPossessed())
        if (!GetTransport() || GetTransport() != pet->GetTransport()) // waiting full teleport player
            UnsummonPetTemporaryIfAny();
    

    //we should execute delayed teleports only for alive(!) players
    //because we don't want player's ghost teleported from graveyard
    if (IsHasDelayedTeleport() && !IsCanDelayTeleport()/* && isAlive()*/ && !isWatchingMovie())
        SafeTeleport(m_teleport_dest, m_teleport_options);

    // Garrison update
    if (Garrison* garr = GetGarrisonPtr())
        garr->Update(p_time);

    //Send update item data
    UpdateItem();

    GetVignetteMgr().Update();

    if (m_spellInQueue.GCDEnd && !(m_operationsAfterDelayMask & OAD_RESET_SPELL_QUEUE))
    {
        if (m_spellInQueue.GCDEnd < getMSTime())
        {
            SendOperationsAfterDelay(OAD_RESET_SPELL_QUEUE);
            CastSpellInQueue();
        }
    }

    if (NeedPhaseRecalculate)
        GetPhaseMgr().Recalculate();

    if (NeedPhaseUpdate)
        GetPhaseMgr().Update();

    if (NeedUpdateVisibility)
    {
        UpdateObjectVisibility();
        NeedUpdateVisibility = false;
    }

    // Anticheat sanction
    std::stringstream reason;
    CheatAction cheatAction = _cheatData->Update(p_time, reason);
    m_isUpdate = false;

    GetSession()->ProcessAnticheatAction("SAC", reason.str().c_str(), cheatAction);

    sScriptMgr->OnUpdate(this, p_time);
}

void Player::OnDisconnected()
{
    // Anticheat sanction
    std::stringstream reason;
    CheatAction cheatAction = _cheatData->Finalize(reason);
    GetSession()->ProcessAnticheatAction("SAC", reason.str().c_str(), cheatAction);

    if (IsInWorld() && FindMap() && CanFreeMove())
    {
        float height = GetMap()->GetHeight(GetPositionX(), GetPositionY(), GetPositionZ());
        if ((GetPositionZ() < height + 0.1f) && !IsInWater())
            SetStandState(UNIT_STAND_STATE_SIT);
        // Apres avoir ajoute le bot on actualise la position du joueur
        // Et on retire les flags de mouvements (ne pas le voir courir dans le vide !)
        m_movementInfo.RemoveMovementFlag(MOVEMENTFLAG_MASK_MOVING_OR_TURN);
        SendMovementFlagUpdate();
    }

    // Player should be leave from channels
    CleanupChannels();
}

void Player::RelocateToLastClientPosition()
{
    if (m_movementInfo.ClientMoveTime > 0)
    {
        float x = m_movementInfo.Pos.m_positionX;
        float y = m_movementInfo.Pos.m_positionY;
        float z = m_movementInfo.Pos.m_positionZ;
        float o = m_movementInfo.Pos.m_orientation;
        GetMap()->PlayerRelocation(this, x, y, z, o);
        m_positionX = x;
        m_positionY = y;
        m_positionZ = z;
        m_orientation = o;
    }
}

void Player::GetSafePosition(float &x, float &y, float &z, Transport* onTransport) const
{
    if (!onTransport && m_movementInfo.ClientMoveTime >  0)
    {
        x = m_movementInfo.Pos.m_positionX;
        y = m_movementInfo.Pos.m_positionY;
        z = m_movementInfo.Pos.m_positionZ;
    }
    else
        GetPosition(x, y, z, onTransport);
}

void Player::SaveNoUndermapPosition(float x, float y, float z)
{
    _lastSafeX = x;
    _lastSafeY = y;
    _lastSafeZ = z;
    _undermapPosValid = true;
}

bool Player::UndermapRecall()
{
    if (!_undermapPosValid || IsBeingTeleported())
        return false;

    if (GetDistance2d(_lastSafeX, _lastSafeY) > 100.0f)
    {
        _undermapPosValid = false;
        return false;
    }

    NearTeleportTo(_lastSafeX, _lastSafeY, _lastSafeZ+2.0f, GetOrientation(), false, false);
    _undermapPosValid = false;
    return true;
}

SpellModList& Player::GetSpellModList(SpellModOp op)
{
    return m_spellMods[op];
}

void Player::setDeathState(DeathState s)
{
    bool oldIsAlive = isAlive();

    if (s == JUST_DIED)
    {
        if (!oldIsAlive)
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "setDeathState: attempt to kill a dead player %s(%d)", GetName(), GetGUIDLow());
            return;
        }

        if (HaveSpectators())
        {
            SpectatorAddonMsg msg;
            msg.SetPlayer(GetGUID());
            msg.SetStatus(false);
            SendSpectatorAddonMsgToBG(msg);
        }

        // drunken state is cleared on death
        SetDrunkValue(0);

        ClearResurrectRequestData();

        //FIXME: is pet dismissed at dying or releasing spirit? if second, add setDeathState(DEAD) to HandleRepopRequestOpcode and define pet unsummon here with (s == DEAD)
        RemovePet(nullptr);

        // save value before aura remove in Unit::setDeathState
        InitializeSelfResurrectionSpells();

        UpdateAchievementCriteria(CRITERIA_TYPE_DEATH_AT_MAP, 1);
        UpdateAchievementCriteria(CRITERIA_TYPE_DEATH, 1);
        UpdateAchievementCriteria(CRITERIA_TYPE_DEATH_IN_DUNGEON, 1);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE, CRITERIA_CONDITION_NO_DEATH, 1);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_HONORABLE_KILL, CRITERIA_CONDITION_NO_DEATH);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_GET_KILLING_BLOWS, CRITERIA_CONDITION_NO_DEATH);
    }

    Unit::setDeathState(s);

    if (isAlive() && !oldIsAlive)
    {
        ResummonPetTemporaryUnSummonedIfAny();
        ClearDynamicValue(PLAYER_DYNAMIC_FIELD_SELF_RES_SPELLS);
    }
}

void Player::InnEnter(time_t time, uint32 mapid, float x, float y, float z)
{
    inn_pos_mapid = mapid;
    inn_pos_x = x;
    inn_pos_y = y;
    inn_pos_z = z;
    time_inn_enter = time;
}

bool Player::ToggleAFK()
{
    ToggleFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_AFK);
    SetGroupUpdateFlag(GROUP_UPDATE_FLAG_STATUS);

    bool state = HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_AFK);

    // afk player not allowed in battleground
    if (state && InBattleground() && !InArena())
        LeaveBattleground();

    return state;
}

bool Player::ToggleDND()
{
    ToggleFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_DND);
    SetGroupUpdateFlag(GROUP_UPDATE_FLAG_STATUS);

    return HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_DND);
}

bool Player::isAFK() const
{
    return HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_AFK);
}

bool Player::isDND() const
{
    return HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_DND);
}

uint8 Player::GetChatTag() const
{
    uint8 tag = CHAT_TAG_NONE;

    if (isGMChat())
        tag |= CHAT_TAG_GM;
    if (isDND())
        tag |= CHAT_TAG_DND;
    if (isAFK())
        tag |= CHAT_TAG_AFK;
    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_DEVELOPER))
        tag |= CHAT_TAG_DEV;

    return tag;
}

bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientation, uint32 options, uint32 spellID/*=false*/)
{

    if (!GetSession() || GetSession()->PlayerLogout())
        return true;

    if (!MapManager::IsValidMapCoord(mapid, x, y, z, orientation))
    {
        TC_LOG_ERROR(LOG_FILTER_MAPS, "SafeTeleport: invalid map (%d) or invalid coordinates (X: %f, Y: %f, Z: %f, O: %f) given when teleporting player (GUID: %u, name: %s, map: %d, X: %f, Y: %f, Z: %f, O: %f).",
            mapid, x, y, z, orientation, GetGUIDLow(), GetName(), GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
        return false;
    }

    if (AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()) && DisableMgr::IsDisabledFor(DISABLE_TYPE_MAP, mapid, this))
    {
        TC_LOG_ERROR(LOG_FILTER_MAPS, "Player (GUID: %u, name: %s) tried to enter a forbidden map %u", GetGUIDLow(), GetName(), mapid);
        SendTransferAborted(mapid, TRANSFER_ABORT_MAP_NOT_ALLOWED);
        return false;
    }

    if (IsHasDelayedTeleport() && !isAlive())
        return false;

    MapEntry const* mEntry = sMapStore.LookupEntry(mapid);

    // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
    // don't let gm level > 1 either
    if (!InBattleground() && mEntry->IsBattlegroundOrArena())
        return false;

    SetGlobalTeleport(true);
    AddDelayedEvent(100, [this, mapid, x, y, z, orientation, options, spellID]() -> void
    {
        if (!IsHasGlobalTeleport())
            return;

        SetGlobalTeleport(false);
        SafeTeleport(mapid, x, y, z, orientation, options, spellID);
    });

    return true;
}

bool Player::TeleportTo(uint32 mapid, Position const* pos, uint32 options, uint32 spellID)
{
    return TeleportTo(mapid, pos->GetPositionX(), pos->GetPositionY(), pos->GetPositionZ(), pos->GetOrientation(), options, spellID);
}

bool Player::TeleportTo(WorldLocation const& loc, uint32 options)
{
    return TeleportTo(loc.GetMapId(), loc.GetPositionX(), loc.GetPositionY(), loc.GetPositionZ(), loc.GetOrientation(), options);
}

bool Player::TeleportTo(uint32 locEntry, uint32 options)
{
    auto loc = sWorldSafeLocsStore.LookupEntry(locEntry);
    if (!loc)
        return false;
    return TeleportTo(loc->MapID, loc->Loc.X, loc->Loc.Y, loc->Loc.Z, loc->Loc.O, options);
}

bool Player::SafeTeleport(uint32 mapid, float x, float y, float z, float orientation, uint32 options, uint32 spellID/*=false*/)
{
    MapEntry const* mEntry = sMapStore.LookupEntry(mapid);
    if (!GetSession() || !mEntry)
        return false;


    if (IsHasDelayedTeleport() && m_Teleports) // Not teleported if we relocate in zone
        return false;

    // client without expansion support
    if (GetSession()->Expansion() < mEntry->ExpansionID)
    {
        TC_LOG_DEBUG(LOG_FILTER_MAPS, "Player %s using client without required expansion tried teleport to non accessible map %u", GetName(), mapid);

        if (Transport* transport = GetTransport())
        {
            transport->RemovePassenger(this);
            RepopAtGraveyard();                             // teleport to near graveyard if on transport, looks blizz like :)
        }

        SendTransferAborted(mapid, TRANSFER_ABORT_INSUF_EXPAN_LVL, mEntry->ExpansionID);
        return false;                                       // normal client can't teleport to this map...
    }
    TC_LOG_DEBUG(LOG_FILTER_MAPS, "Player %s is being teleported to map %u", GetName(), mapid);

    if (m_vehicle)
        ExitVehicle();

    // reset movement flags at teleport, because player will continue move with these flags after teleport
    if (!(options & TELE_TO_SEAMLESS))
    {
        RemoveUnitMovementFlag(MOVEMENTFLAG_MASK_REMOVE_ON_TELEPORT);
        DisableSpline(!(options & TELE_TO_NOT_DISABLE_MOVE));
    }

    if (Transport* transport = GetTransport())
    {
        if (!(options & TELE_TO_NOT_LEAVE_TRANSPORT))
            transport->RemovePassenger(this);
    }

    // The player was ported to another map and loses the duel immediately.
    // We have to perform this check before the teleport, otherwise the
    // ObjectAccessor won't find the flag.
    if (duel && GetMapId() != mapid && GetMap()->GetGameObject(GetGuidValue(PLAYER_FIELD_DUEL_ARBITER)))
        DuelComplete(DUEL_FLED);

    // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
    Pet* pet = GetPet();

    if (GetMapId() == mapid && !(options & TELE_TO_ZONE_MAP))
    {
        //lets reset far teleport flag if it wasn't reset during chained teleports
        SetSemaphoreTeleportFar(false);
        SetGlobalTeleport(false);
        //setup delayed teleport flag
        SetDelayedTeleportFlag(IsCanDelayTeleport());
        //if teleport spell is casted in Unit::Update() func
        //then we need to delay it until update process will be finished
        if (IsHasDelayedTeleport())
        {
            SetGlobalTeleport(false);
            //lets save teleport destination for player
            m_teleport_dest = WorldLocation(mapid, x, y, z, orientation);
            m_teleport_options = options;
            return true;
        }

        if (!(options & TELE_TO_NOT_UNSUMMON_PET))
        {
            //same map, only remove pet if out of range for new position
            if (pet && !pet->IsWithinDist3d(x, y, z, GetMap()->GetVisibilityRange()))
            {
                UnsummonPetTemporaryIfAny();
                UnsummonCurrentBattlePetIfAny(true);
            }
        }

        if (!(options & TELE_TO_NOT_LEAVE_COMBAT))
            CombatStop();

        // this will be used instead of the current location in SaveToDB
        m_teleport_dest = WorldLocation(mapid, x, y, z, orientation);
        SetFallInformation(0, z);

        // code for finish transfer called in WorldSession::HandleMovementOpcodes()
        // at client packet CMSG_MOVE_TELEPORT_ACK
        SetSemaphoreTeleportNear(true);
        // near teleport, triggering send CMSG_MOVE_TELEPORT_ACK from client at landing
        if (!GetSession()->PlayerLogout())
        {
            Position newPos;
            newPos.Relocate(x, y, z, orientation);
            SendTeleportPacket(newPos); // this automatically relocates to oldPos in order to broadcast the packet in the right place
        }
    }
    else
    {
        //Pandaren start loc
        if (GetMapId() == 860 && GetTeamId() == TEAM_NEUTRAL)
            return false;

        // far teleport to another map
        Map* oldmap = IsInWorld() ? GetMap() : NULL;
        // check if we can enter before stopping combat / removing pet / totems / interrupting spells

        // Check enter rights before map getting to avoid creating instance copy for player
        // this check not dependent from map instance copy and same for all instance copies of selected map
        if (!sMapMgr->CanPlayerEnter(mapid, this, false))
            return false;

        // Seamless teleport can happen only if cosmetic maps match
        if (!oldmap ||
            (oldmap->GetEntry()->CosmeticParentMapID != int32(mapid) && int32(GetMapId()) != mEntry->CosmeticParentMapID &&
            !((oldmap->GetEntry()->CosmeticParentMapID != -1) ^ (oldmap->GetEntry()->CosmeticParentMapID != mEntry->CosmeticParentMapID)) && !(options & TELE_TO_ZONE_MAP)))
            options &= ~TELE_TO_SEAMLESS;

        //I think this always returns true. Correct me if I am wrong.
        // If the map is not created, assume it is possible to enter it.
        // It will be created in the WorldPortAck.
        //Map* map = sMapMgr->FindBaseNonInstanceMap(mapid);
        //if (!map || map->CanEnter(this))
        {
            //lets reset near teleport flag if it wasn't reset during chained teleports
            SetSemaphoreTeleportNear(false);
            SetGlobalTeleport(false);
            //setup delayed teleport flag
            SetDelayedTeleportFlag(IsCanDelayTeleport());
            //if teleport spell is casted in Unit::Update() func
            //then we need to delay it until update process will be finished
            if (IsHasDelayedTeleport() || isWatchingMovie())
            {
                SetSemaphoreTeleportFar(true);
                //lets save teleport destination for player
                m_teleport_dest = WorldLocation(mapid, x, y, z, orientation);
                m_teleport_options = options;
                return true;
            }

            SetSelection(ObjectGuid::Empty);
            CombatStop();
            ResetContestedPvP();

            // remove player from battleground on far teleport (when changing maps)
            if (Battleground const* bg = GetBattleground())
            {
                // Note: at battleground join battleground id set before teleport
                // and we already will found "current" battleground
                // just need check that this is targeted map or leave
                if (bg->GetMapId() != mapid)
                    LeaveBattleground(false);                   // don't teleport to entry point
            }

            sOutdoorPvPMgr->HandlePlayerLeaveZone(GetGUID(), GetCurrentZoneID());
            sBattlefieldMgr->HandlePlayerLeaveZone(GetGUID(), GetCurrentZoneID());
            sOutdoorPvPMgr->HandlePlayerLeaveArea(GetGUID(), m_areaId);

            // remove arena spell coldowns/buffs now to also remove pet's cooldowns before it's temporarily unsummoned
            if (mEntry->IsBattleArena())
            {
                RemoveArenaAuras();
                if (pet)
                    pet->RemoveArenaAuras();
            }

            // remove pet on map change
            if (pet)
                UnsummonPetTemporaryIfAny();

            UnsummonCurrentBattlePetIfAny(true);

            // remove all dyn objects
            RemoveAllDynObjects();
            RemoveAllAreaObjects();

            // stop spellcasting
            // not attempt interrupt teleportation spell at caster teleport
            if (!(options & TELE_TO_SPELL))
                if (IsNonMeleeSpellCast(true))
                    InterruptNonMeleeSpells(true);

            //remove auras before removing from map...
            if(!(options & TELE_TO_ZONE_MAP))
                RemoveAurasWithInterruptFlags(SpellAuraInterruptFlags(AURA_INTERRUPT_FLAG_CHANGE_MAP | AURA_INTERRUPT_FLAG_MOVE | AURA_INTERRUPT_FLAG_TURNING));
            else
                RemoveAurasWithInterruptFlags(SpellAuraInterruptFlags(AURA_INTERRUPT_FLAG_MOVE | AURA_INTERRUPT_FLAG_TURNING));

            RemoveAurasByType(SPELL_AURA_OVERRIDE_SPELLS);
            RemoveAurasByType(SPELL_AURA_MOD_NEXT_SPELL);
            RemoveAurasByType(SPELL_AURA_CLONE_CASTER);
            // RemoveAurasByType(SPELL_AURA_TRANSFORM);

            WorldSessionPtr sess = sWorld->FindSession(GetSession()->GetAccountId());
            if (!sess) // https://pastebin.com/6zD9fzyC
                return false;

            if (options & TELE_TO_SEAMLESS)
            {
                // Send update field before delete form map
                UpdateDataMapType update_players;
                BuildUpdate(update_players);
                WorldPacket packet;
                for (UpdateDataMapType::iterator iter = update_players.begin(); iter != update_players.end(); ++iter)
                {
                    if (iter->second.BuildPacket(&packet))
                        iter->first->SendDirectMessage(&packet);
                    packet.clear();
                }
            }

            if (!sess->PlayerLogout() && !(options & TELE_TO_SEAMLESS))
            {
                if (Map* _map = sMapMgr->CreateMap(mapid, this))
                {
                    sess->SetMap(_map);
                    _map->AddSession(sess);
                    m_teleport_target_map = _map;

                    WorldPackets::Movement::TransferPending transferPending;
                    transferPending.MapID = mapid;
                    if (Transport* transport = GetTransport())
                    {
                        transferPending.Ship = boost::in_place();
                        transferPending.Ship->ID = transport->GetEntry();
                        transferPending.Ship->OriginMapID = GetMapId();
                    }
                    if (spellID)
                    {
                        transferPending.TransferSpellID = boost::in_place();
                        transferPending.TransferSpellID = spellID;
                    }

                    switch (mapid)
                    {
                    case 1460: // Hack for broken Island scenario.
                        transferPending.Ship = boost::in_place();
                        transferPending.Ship->ID = GetTeam() == ALLIANCE ? 251513 : 254124;
                        transferPending.Ship->OriginMapID = GetMapId();

                        transferPending.TransferSpellID = boost::in_place();
                        transferPending.TransferSpellID = GetTeam() == ALLIANCE ? 217273 : 225143;

                        SendDirectMessage(WorldPackets::Misc::CustomLoadScreen(GetTeam() == ALLIANCE ? 217273 : 225143, 0).Write());
                        break;
                    case 1803: // Hack for Seehing shore battleground
                    {
                        auto bg = GetBattleground();
                        if (!bg)
                            break;

                        transferPending.Ship = boost::in_place();
                        transferPending.Ship->OriginMapID = -1;

                        switch (GetBGTeamId())
                        {
                        case TEAM_ALLIANCE:
                            transferPending.Ship->ID = 278407;
                            if (auto gunship = sTransportMgr->GetTransport(bg->GetBgMap(), 278407))
                                gunship->CalculatePassengerPosition(x, y, z);
                            break;
                        case TEAM_HORDE:
                            transferPending.Ship->ID = 279254;
                            if (auto gunship = sTransportMgr->GetTransport(bg->GetBgMap(), 279254))
                                gunship->CalculatePassengerPosition(x, y, z);
                            break;
                        default:
                            break;
                        }
                        break;
                    }
                    default:
                        break;
                    }

                    SendDirectMessage(transferPending.Write());
                }

                //SMSG_CUSTOM_LOAD_SCREEN
            }

            // remove from old map now
            if (oldmap)
                oldmap->RemovePlayerFromMap(this, false);

            m_teleport_dest = WorldLocation(mapid, x, y, z, orientation);
            m_teleport_options = options;
            SetFallInformation(0, z);

            // move packet sent by client always after far teleport
            // code for finish transfer to new map called in WorldSession::HandleWorldPortAck at client packet
            SetSemaphoreTeleportFar(true);

            if (!sess->PlayerLogout())
            {
                if (Map* _map = sMapMgr->CreateMap(mapid, this))
                {
                    sess->SetMap(_map);
                    _map->AddSession(sess);
                    m_teleport_target_map = _map;

                    WorldPackets::Movement::SuspendToken suspendToken;
                    suspendToken.SequenceIndex = m_sequenceIndex; // not incrementing
                    suspendToken.Reason = options & TELE_TO_SEAMLESS ? 2 : 1;
                    SendDirectMessage(suspendToken.Write());
                }
            }
            SendLfgUpdatePlayer();
            sLFGMgr->StopAllOtherQueue(GetGUID(), 0);
            SendLfgUpdatePlayer();
        }
        //else
        //    return false;
    }
    return true;
}

bool Player::SafeTeleport(WorldLocation const& loc, uint32 options)
{
    return SafeTeleport(loc.GetMapId(), loc.GetPositionX(), loc.GetPositionY(), loc.GetPositionZ(), loc.GetOrientation(), options);
}

bool Player::SafeTeleport(uint32 mapid, Position const* pos, uint32 options, uint32 spellID)
{
    return SafeTeleport(mapid, pos->GetPositionX(), pos->GetPositionY(), pos->GetPositionZ(), pos->GetOrientation(), options, spellID);
}

void Player::TeleportToChallenge(uint32 mapid, float x, float y, float z, float orientation)
{
    MapEntry const* mEntry = sMapStore.LookupEntry(mapid);
    if (!GetSession() || !mEntry)
        return;

    TC_LOG_DEBUG(LOG_FILTER_MAPS, "Player %s is being teleported to map %u", GetName(), mapid);

    if (m_vehicle)
        ExitVehicle();

    if (IsMounted())
        Dismount();

    Map* oldmap = GetMap();

    SetSelection(ObjectGuid::Empty);
    CombatStop();
    ResetContestedPvP();

    UnsummonPetTemporaryIfAny();
    UnsummonCurrentBattlePetIfAny(true);

    // remove all dyn objects
    RemoveAllDynObjects();
    RemoveAllAreaObjects();

    // stop spellcasting
    // not attempt interrupt teleportation spell at caster teleport
    if (IsNonMeleeSpellCast(true))
        InterruptNonMeleeSpells(true);

    //remove auras before removing from map...
    RemoveAurasWithInterruptFlags(SpellAuraInterruptFlags(AURA_INTERRUPT_FLAG_MOVE | AURA_INTERRUPT_FLAG_TURNING));
    RemoveAurasByType(SPELL_AURA_OVERRIDE_SPELLS);
    RemoveAurasByType(SPELL_AURA_MOD_NEXT_SPELL);
    RemoveAurasByType(SPELL_AURA_CLONE_CASTER);
    // RemoveAurasByType(SPELL_AURA_TRANSFORM);

    WorldSessionPtr sess = sWorld->FindSession(GetSession()->GetAccountId());
    if (!sess) // https://pastebin.com/6zD9fzyC
        return;

    UpdateDataMapType update_players;
    BuildUpdate(update_players);
    WorldPacket packet;
    for (UpdateDataMapType::iterator iter = update_players.begin(); iter != update_players.end(); ++iter)
    {
        if (iter->second.BuildPacket(&packet))
            iter->first->SendDirectMessage(&packet);
        packet.clear();
    }

    m_teleport_dest = WorldLocation(mapid, x, y, z, orientation);
    m_teleport_options = TELE_TO_SEAMLESS;

    SetSemaphoreTeleportFar(true);

    // remove from old map now
    if (oldmap)
        oldmap->RemovePlayerFromMap(this, false);

    if (!sess->PlayerLogout())
    {
        if (Map* _map = sMapMgr->CreateMap(mapid, this))
        {
            sess->SetMap(_map);
            _map->AddSession(sess);
            m_teleport_target_map = _map;

            WorldPackets::Movement::SuspendToken suspendToken;
            suspendToken.SequenceIndex = m_sequenceIndex; // not incrementing
            suspendToken.Reason = m_teleport_options & TELE_TO_SEAMLESS ? 2 : 1;
            SendDirectMessage(suspendToken.Write());
        }
    }
    SendLfgUpdatePlayer();
    sLFGMgr->StopAllOtherQueue(GetGUID(), 0);
    SendLfgUpdatePlayer();
}

void Player::ZoneTeleport(uint32 zoneId)
{
    if (!GetMap() || !GetMap()->CanCreatedZone())
        return;

    if (!m_zoneId || !zoneId || !IsInWorld())
        return;

    if (GetInstanceId() == zoneId) // Allready in this zone
        return;

    if (IsHasDelayedTeleport() || IsHasGlobalTeleport()) // If teleport allready run, not zone teleport
        return;

    Map* oldmap = GetMap();
    uint32 mapid = GetMap()->GetId();

    SetSelection(ObjectGuid::Empty);
    CombatStop();
    ResetContestedPvP();

    sOutdoorPvPMgr->HandlePlayerLeaveZone(GetGUID(), GetCurrentZoneID());
    sBattlefieldMgr->HandlePlayerLeaveZone(GetGUID(), GetCurrentZoneID());
    sOutdoorPvPMgr->HandlePlayerLeaveArea(GetGUID(), m_areaId);
    sOutdoorPvPMgr->HandlePlayerLeaveMap(GetGUID(), GetCurrentZoneID());

    if (InstanceScript* data_s = GetInstanceScript())
        data_s->OnPlayerLeaveForScript(this);

    UnsummonPetTemporaryIfAny();
    UnsummonCurrentBattlePetIfAny(true);

    // remove all dyn objects
    RemoveAllGameObjects();
    RemoveAllDynObjects();
    RemoveAllAreaObjects();

    // stop spellcasting
    // not attempt interrupt teleportation spell at caster teleport
    if (IsNonMeleeSpellCast(true))
        InterruptNonMeleeSpells(true);

    //remove auras before removing from map...
    RemoveAurasWithInterruptFlags(SpellAuraInterruptFlags(AURA_INTERRUPT_FLAG_MOVE | AURA_INTERRUPT_FLAG_TURNING));
    RemoveAurasByType(SPELL_AURA_OVERRIDE_SPELLS);
    RemoveAurasByType(SPELL_AURA_MOD_NEXT_SPELL);
    RemoveAurasByType(SPELL_AURA_CLONE_CASTER);

    WorldSessionPtr sess = sWorld->FindSession(GetSession()->GetAccountId());
    if (!sess) // https://pastebin.com/6zD9fzyC
        return;

    UpdateDataMapType update_players;
    BuildUpdate(update_players);
    WorldPacket packet;
    for (UpdateDataMapType::iterator iter = update_players.begin(); iter != update_players.end(); ++iter)
    {
        if (iter->second.BuildPacket(&packet))
            iter->first->SendDirectMessage(&packet);
        packet.clear();
    }

    m_teleport_options = TELE_TO_SEAMLESS;
    SetSemaphoreTeleportFar(true);
    SetChangeMap(true);

    m_Teleports = true;

    if (!sess->PlayerLogout())
    {
        CleanupBeforeTeleport();
        TeleportAllControlled();

        if (Unit* veh = GetVehicleBase())
        {
            if (veh->ToCreature())
            {
                GetVehicle()->TeleportAccessory(m_zoneId);
                veh->m_Teleports = true;
                veh->CleanupBeforeTeleport();
                veh->ResetMap();
            }
        }

        if (m_vehicleKit)
            m_vehicleKit->TeleportAccessory(m_zoneId);

        if (Map* _map = sMapMgr->CreateMap(mapid, this))
        {
            sess->SetMap(_map);
            _map->AddSession(sess);

            sess->AddDelayedEvent(500, [sess, _map, oldmap]() -> void
            {
                if (!sess)
                    return;

                Player* player = sess->GetPlayer();
                if (!player)
                    return;

                player->ResetMap();
                player->SetMap(_map);

                if (!player->GetMap()->AddPlayerToMap(player, false))
                {
                    player->ResetMap();
                    player->SetMap(oldmap);
                    player->SetChangeMap(false);
                    player->TeleportTo(player->m_homebindMapId, player->m_homebindX, player->m_homebindY, player->m_homebindZ, player->GetOrientation());
                }

                if (Vehicle* vehicleKit = player->GetVehicleKit())
                    vehicleKit->RestoreAccessory();

                if (Unit* veh = player->GetVehicleBase())
                {
                    if (veh->ToCreature())
                    {
                        veh->SetMap(_map);
                        _map->AddToMap(veh->ToCreature());
                        player->GetVehicle()->RestoreAccessory();
                        veh->m_Teleports = false;
                    }
                }

                player->SetSemaphoreTeleportFar(false);

                player->AddDelayedEvent(100, [player, _map]() -> void
                {
                    if (!player->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_TAXI_FLIGHT))
                    {
                        player->SummonLastSummonedBattlePet();
                        player->RestoreAllControlled();
                    }
                    player->ProcessDelayedOperations();
                    player->ReCreateAreaTriggerObjects();
                    player->ResummonPetTemporaryUnSummonedIfAny();
                });

                player->SetLastWorldStateUpdateTime(time_t(0));
                player->SetChangeMap(false);
                player->m_Teleports = false;

                sOutdoorPvPMgr->HandlePlayerEnterZone(player->GetGUID(), player->GetZoneId());
                sBattlefieldMgr->HandlePlayerEnterZone(player->GetGUID(), player->GetZoneId());
            });
        }
    }
}

void Player::SetPing(uint32 val)
{
    ping = val;
}

uint32 Player::GetPing() const
{
    return ping;
}

bool Player::TeleportToBGEntryPoint()
{
    if (m_bgData.JoinPosition.m_mapId == MAPID_INVALID)
        return false;

    ScheduleDelayedOperation(DELAYED_BG_MOUNT_RESTORE);
    ScheduleDelayedOperation(DELAYED_BG_TAXI_RESTORE);
    ScheduleDelayedOperation(DELAYED_BG_GROUP_RESTORE);

    Battleground *oldBg = GetBattleground();
    bool result = TeleportTo(m_bgData.JoinPosition);

    if (IsSpectator() && result)
    {
        ScheduleDelayedOperation(DELAYED_SPECTATOR_REMOVE);
        if (oldBg)
            oldBg->RemoveSpectator(this);
    }

    return result;
}

void Player::TeleportToHomeBind()
{
    TeleportTo(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, GetOrientation());
}

void Player::ProcessDelayedOperations()
{
    if (m_DelayedOperations == 0)
        return;

    if ((m_DelayedOperations & DELAYED_RESURRECT_PLAYER))
    {
        if (_resurrectionData)
        {
            ResurrectPlayer(0.0f, false);

            if (GetMaxHealth() > _resurrectionData->Health)
                SetHealth(_resurrectionData->Health);
            else
                SetFullHealth();

            if (uint32(GetMaxPower(POWER_MANA)) > _resurrectionData->Mana)
                SetPower(POWER_MANA, _resurrectionData->Mana);
            else
                SetPower(POWER_MANA, GetMaxPower(POWER_MANA));

            SetPower(POWER_RAGE, 0);
            SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
            SetPower(POWER_FURY, GetMaxPower(POWER_FURY));
            SetPower(POWER_PAIN, GetMaxPower(POWER_PAIN));
            SetPower(POWER_LUNAR_POWER, 0, false);
            SetPower(POWER_RUNES, GetMaxPower(POWER_RUNES));

            if (uint32 aura = _resurrectionData->Aura)
                CastSpell(this, aura, true, NULL, NULL, _resurrectionData->GUID);

            SpawnCorpseBones();
            RemoveAurasDueToSpell(160029);
        }
        else
        {
            RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS);
            ResurrectPlayer(0.5f);
            SpawnCorpseBones();
        }
    }

    if (m_DelayedOperations & DELAYED_SAVE_PLAYER)
        SaveToDB();

    if (m_DelayedOperations & DELAYED_SPELL_CAST_DESERTER)
        CastSpell(this, SPELL_BG_DESERTER, true);               // Deserter

    if (m_DelayedOperations & DELAYED_BG_MOUNT_RESTORE)
    {
        if (m_bgData.MountSpellID)
        {
            CastSpell(this, m_bgData.MountSpellID, true);
            m_bgData.MountSpellID = 0;
        }
    }

    if (m_DelayedOperations & DELAYED_BG_TAXI_RESTORE)
    {
        if (m_bgData.HasTaxiPath())
        {
            m_taxi.AddTaxiDestination(m_bgData.TaxiPath[0]);
            m_taxi.AddTaxiDestination(m_bgData.TaxiPath[1]);
            m_bgData.ClearTaxiPath();

            ContinueTaxiFlight();
        }
    }

    if (m_DelayedOperations & DELAYED_BG_GROUP_RESTORE)
    {
        if (Group *g = GetGroup())
            g->SendUpdateToPlayer(GetGUID());
    }

    if (m_DelayedOperations & DELAYED_UPDATE_AFTER_TO_BG)
    {
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_KILL_CREATURE, CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_WIN_BG, CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_DAMAGE_DONE, CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_BE_SPELL_TARGET, CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_CAST_SPELL, CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_BG_OBJECTIVE_CAPTURE, CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_HONORABLE_KILL, CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_HEALING_DONE, CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_GET_KILLING_BLOWS, CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
        m_achievementMgr->ResetAchievementCriteria(CRITERIA_TYPE_SPECIAL_PVP_KILL, CRITERIA_CONDITION_BG_MAP, GetMapId(), true);
    }

    if (m_DelayedOperations & DELAYED_PET_BATTLE_INITIAL)
    {
        if (PetBattle* battle = sPetBattleSystem->GetBattle(_petBattleId))
        {
            uint8 teamID = battle->Teams[PETBATTLE_TEAM_1]->OwnerGuid == GetGUID() ? PETBATTLE_TEAM_1 : PETBATTLE_TEAM_2;

            PetBattleRequest request;
            memcpy(&request, &battle->PvPMatchMakingRequest, sizeof(PetBattleRequest)); //@TODO check that

            auto& matchMakingRequest = battle->PvPMatchMakingRequest;

            if (teamID == PETBATTLE_TEAM_2)
                std::swap(request.TeamPosition[PETBATTLE_TEAM_1], request.TeamPosition[PETBATTLE_TEAM_2]);

            matchMakingRequest.PetBattleCenterPosition.m_positionZ = GetMap()->GetHeight(matchMakingRequest.PetBattleCenterPosition.GetPositionX(), matchMakingRequest.PetBattleCenterPosition.GetPositionZ(), MAX_HEIGHT);

            GetSession()->SendPetBattleFinalizeLocation(&request);

            SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED | UNIT_FLAG_IMMUNE_TO_NPC);
            SetFacingTo(GetAngle(matchMakingRequest.TeamPosition[!teamID].GetPositionX(), matchMakingRequest.TeamPosition[!teamID].GetPositionY()));
            SetRooted(true);

            if (!matchMakingRequest.IsPvPReady[teamID])
                matchMakingRequest.IsPvPReady[teamID] = true;

            if (matchMakingRequest.IsPvPReady[PETBATTLE_TEAM_1] == true && matchMakingRequest.IsPvPReady[PETBATTLE_TEAM_2] == true)
                battle->Begin();
        }
    }

    if (m_DelayedOperations & DELAYED_SPECTATOR_REMOVE)
        SetSpectate(false);

    //we have executed ALL delayed ops, so clear the flag
    m_DelayedOperations = 0;
}

void Player::AddToWorld()
{
    ///- Do not add/remove the player from the object storage
    ///- It will crash when updating the ObjectAccessor
    ///- The player should only be added when logging in
    Unit::AddToWorld();

    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
        if (m_items[i])
            m_items[i]->AddToWorld();

    if (m_areaId)
        AddPlayerToArea(m_areaId);

    GetCheatData()->InitSpeeds(this);
}

void Player::RemoveFromWorld()
{
    if (m_areaId)
        RemovePlayerFromArea(m_areaId);

    // cleanup
    if (IsInWorld())
    {
        ///- Release charmed creatures, unsummon totems and remove pets/guardians
        StopCastingCharm();
        StopCastingBindSight();
        UnsummonPetTemporaryIfAny();
        UnsummonCurrentBattlePetIfAny(true);
        sOutdoorPvPMgr->HandlePlayerLeaveZone(GetGUID(), m_zoneId);
        sBattlefieldMgr->HandlePlayerLeaveZone(GetGUID(), m_zoneId);
        sOutdoorPvPMgr->HandlePlayerLeaveArea(GetGUID(), m_areaId);

        if (m_zoneId)
            m_oldZoneId = m_zoneId; //fix returning to wg
        m_zoneId = 0; //fix returning to wg
        m_extraLookList.clear();
    }

    ///- Do not add/remove the player from the object storage
    ///- It will crash when updating the ObjectAccessor
    ///- The player should only be removed when logging out
    Unit::RemoveFromWorld();

    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
    {
        if (m_items[i] && m_items[i]->IsInWorld())
            m_items[i]->RemoveFromWorld();
    }

    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
        iter->second->RemoveFromWorld();

    if (m_uint32Values)
    {
        if (WorldObject* viewpoint = GetViewpoint())
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player %s has viewpoint %u %u when removed from world", GetName(), viewpoint->GetEntry(), viewpoint->GetTypeId());
            SetViewpoint(viewpoint, false);
        }
    }
}

void Player::RegenerateAll()
{
    m_powerRegenTimer[MAX_POWERS] += m_regenTimer;

    for (ChrClassesXPowerTypesEntry const* powerClassEntry : sChrClassesXPowerTypesStore)
    {
        Powers power = Powers(powerClassEntry->PowerType);
        if (powerClassEntry->ClassID != getClass())
            continue;
        PowerTypeEntry const* powerEntry = sDB2Manager.GetPowerType(power);
        if (!powerEntry)
            continue;

        switch (power)
        {
            case POWER_FOCUS:
                m_powerRegenTimer[power] += m_regenTimer;
                if (m_powerRegenTimer[power] >= 200)
                {
                    Regenerate(power, float(m_powerRegenTimer[power]), powerEntry);
                    m_powerRegenTimer[power] = 0;
                }
                break;
            case POWER_RAGE:
            case POWER_ENERGY:
            case POWER_MANA:
            {
                Regenerate(power, float(m_regenTimer), powerEntry);
                break;
            }
            case POWER_INSANITY:
            {
                if (m_powerCombatTimer[power] > 0)
                {
                    m_powerCombatTimer[power] -= m_regenTimer;

                    if (m_powerCombatTimer[power] < 0)
                        m_powerCombatTimer[power] = 0;
                }

                Regenerate(power, float(m_regenTimer), powerEntry);
                break;
            }
            case POWER_RUNES:
            {
                // Runes act as cooldowns, and they don't need to send any data
                int8 runeCount = 0; //Max run CD in runes = 3
                for (auto runeToRegen : m_runes.CooldownOrder)
                {
                    if (runeCount >= MAX_RECHARGING_RUNES)
                        continue;

                    runeCount++;
                    int32 setCool = GetRuneCooldown(runeToRegen) - m_regenTimer;
                    if (setCool <= 0)
                    {
                        SetRuneCooldown(runeToRegen, 0);
                        // Regenerate(power, 10000.0f, powerEntry);
                        ModifyPower(POWER_RUNES, 1);
                    }
                    else
                        ModRuneCooldown(runeToRegen, m_regenTimer);
                    // TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "RegenerateAll coef %f, setCool %i, i %i GetMaxPower %u", GetRuneCooldownCoef(), setCool, runeToRegen, GetMaxPower(POWER_RUNES));
                }
                break;
            }
            default:
            {
                if (m_powerCombatTimer[power] > 0)
                    m_powerCombatTimer[power] -= m_regenTimer;

                m_powerRegenTimer[power] += m_regenTimer;
                if (m_powerRegenTimer[power] >= 2000)
                {
                    Regenerate(power, float(m_powerRegenTimer[power]), powerEntry);
                    m_powerRegenTimer[power] = 0;
                }
                break;
            }
        }
    }

    //Regenerate bonus health
    if (m_powerRegenTimer[MAX_POWERS] >= 2000)
    {
        // Not in combat or they have regeneration
        if (!isInCombat() || IsPolymorphed() || m_baseHealthRegen ||
            HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT) ||
            HasAuraType(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT))
        {
            RegenerateHealth();
        }
        m_powerRegenTimer[MAX_POWERS] -= 2000;
    }

    m_regenTimer = 0;
}

void Player::Regenerate(Powers power, float regenTimer, PowerTypeEntry const* powerEntry)
{
    uint32 maxValue = GetMaxPower(power);
    if (!maxValue)
        return;

    if (!powerEntry)
        powerEntry = sDB2Manager.GetPowerType(power);

    int32 saveCur = GetPower(power);
    uint32 curValue = saveCur;

    switch (power)
    {
        case POWER_MANA:
        case POWER_FOCUS:
        case POWER_ENERGY:
        case POWER_SOUL_SHARDS:
        if (curValue == maxValue) // stop spamm!
            return;
        default:
            break;
    }

    //Prevent regenerate if power is minimum
    if (powerEntry->CenterPower && powerEntry->CenterPower == curValue)
        return;

    // TODO: possible use of miscvalueb instead of amount
    if (HasAuraTypeWithValue(SPELL_AURA_PREVENT_REGENERATE_POWER, power))
        return;

    if (HasAuraTypeWithValue(SPELL_AURA_INTERRUPT_REGEN, power))
        return;

    // Skip regeneration for power type we cannot have
    uint32 powerIndex = GetPowerIndex(power);
    if (powerIndex == MAX_POWERS || powerIndex >= MAX_POWERS_PER_CLASS)
        return;

    bool inCombat = (m_powerCombatTimer[power] > 0) || isInCombat();
    float addvalue = 0.0f;
    float regenTypeAndMod = 1.0f; // start type regen + or - for power
    float regenValue = (inCombat ? powerEntry->RegenCombat : powerEntry->RegenPeace) * (regenTimer / 1000.0f);

    //Regenerate if power lower that minimum
    if (powerEntry->CenterPower && powerEntry->CenterPower > curValue && regenValue < 0.0f)
        regenValue *= -1.0f;

    addvalue += regenValue;

    switch (power)
    {
        // Regenerate Rage
        case POWER_RAGE:
        {
            regenTypeAndMod = 0.0f;
            float bp = m_addPower[POWER_RAGE];
            m_addPower[POWER_RAGE] = 0;
            if (bp)
                CastCustomSpell(this, 167151, &bp, NULL, NULL, true);
            break;
        }
        default:
            break;
    }

    if (inCombat)
        addvalue += GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER + powerIndex) * (0.001f * regenTimer) * regenTypeAndMod;
    else
        addvalue += GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER + powerIndex) * (0.001f * regenTimer) * regenTypeAndMod;

    if (addvalue < 0.0f)
    {
        if (curValue == 0)
            return;
    }
    else if (addvalue > 0.0f)
    {
        if (saveCur == maxValue)
            return;
    }
    else
        return;

    addvalue += m_powerFraction[powerIndex];
    uint32 integerValue = uint32(fabs(addvalue));
    bool lessCenter = false;

    if (powerEntry->CenterPower && powerEntry->CenterPower > curValue)
        lessCenter = true;

    if (addvalue < 0.0f)
    {
        if (curValue > integerValue)
        {
            curValue -= integerValue;
            m_powerFraction[powerIndex] = addvalue + integerValue;
        }
        else
        {
            curValue = 0;
            m_powerFraction[powerIndex] = 0;
        }

        if (powerEntry->CenterPower)
        {
            if (!lessCenter && powerEntry->CenterPower > curValue)
            {
                curValue = powerEntry->CenterPower;
                m_powerFraction[powerIndex] = 0;
            }
        }

        //Visualization for power
        VisualForPower(power, curValue, int32(integerValue)*-1, maxValue, true);
    }
    else
    {
        curValue += integerValue;

        if (curValue > maxValue)
        {
            curValue = maxValue;
            m_powerFraction[powerIndex] = 0;
        }
        else
            m_powerFraction[powerIndex] = addvalue - integerValue;

        if (powerEntry->CenterPower)
        {
            if (lessCenter && powerEntry->CenterPower < curValue)
            {
                curValue = powerEntry->CenterPower;
                m_powerFraction[powerIndex] = 0;
            }
        }

        //Visualization for power
        VisualForPower(power, curValue, integerValue, maxValue, true);
    }

    switch (power)
    {
        case POWER_MANA:
        case POWER_FOCUS:
        case POWER_ENERGY:
        {
            if ((saveCur != maxValue && curValue == maxValue) || m_powerRegenTimer[MAX_POWERS] >= 2000)
                SetInt32Value(UNIT_FIELD_POWER + powerIndex, curValue);
            else
                UpdateInt32Value(UNIT_FIELD_POWER + powerIndex, curValue);
        }
        break;
        default:
            SetInt32Value(UNIT_FIELD_POWER + powerIndex, curValue);
            break;
    }
}

void Player::RegenerateHealth()
{
    uint32 curValue = GetHealth();
    uint32 maxValue = GetMaxHealth();

    if (curValue >= maxValue)
        return;

    float HealthIncreaseRate = sWorld->getRate(RATE_HEALTH);

    float addvalue = 0.0f;

    // polymorphed case
    if (IsPolymorphed())
        addvalue = (float)GetMaxHealth()/10;
    // normal regen case (maybe partly in combat case)
    else if (!isInCombat() || HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
    {
        addvalue = HealthIncreaseRate;
        if (!isInCombat())
        {
            if (getLevel() < 15)
                addvalue = (0.20f*((float)GetMaxHealth())/getLevel()*HealthIncreaseRate);
            else 
                addvalue = 0.01f*((float)GetMaxHealth())*HealthIncreaseRate;

            addvalue *= GetTotalAuraMultiplier(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT);
            addvalue += GetTotalAuraModifier(SPELL_AURA_MOD_REGEN) * 2 * IN_MILLISECONDS / (5 * IN_MILLISECONDS);
        }
        else if (HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
            ApplyPct(addvalue, GetTotalAuraModifier(SPELL_AURA_MOD_REGEN_DURING_COMBAT));

        if (!IsStandState())
            addvalue *= 1.5f;
    }

    // always regeneration bonus (including combat)
    addvalue += GetTotalAuraModifier(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT);
    addvalue += m_baseHealthRegen / 2.5f;

    if (addvalue < 0)
        addvalue = 0;

    ModifyHealth(int32(addvalue));
}

void Player::ResetAllPowers()
{
    SetHealth(GetMaxHealth());
    SetPower(POWER_ALTERNATE, 0);

    ResetPowers();

    switch (getPowerType())
    {
        case POWER_MANA:
            SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
            break;
        default:
            break;
    }
}

bool Player::CanInteractWithQuestGiver(Object* questGiver)
{
    switch (questGiver->GetTypeId())
    {
        case TYPEID_UNIT:
            return GetNPCIfCanInteractWith(questGiver->GetGUID(), UNIT_NPC_FLAG_QUESTGIVER) != NULL;
        case TYPEID_GAMEOBJECT:
            return GetGameObjectIfCanInteractWith(questGiver->GetGUID(), GAMEOBJECT_TYPE_QUESTGIVER) != NULL;
        case TYPEID_PLAYER:
            return isAlive() && questGiver->ToPlayer()->isAlive();
        case TYPEID_ITEM:
            return isAlive();
        default:
            break;
    }
    return false;
}

Creature* Player::GetNPCIfCanInteractWith(ObjectGuid guid, uint32 npcflagmask, uint32 npcflagmask2)
{
    // unit checks
    if (guid.IsEmpty())
        return NULL;

    if (!IsInWorld())
        return NULL;

    if (isInFlight())
        return NULL;

    // exist (we need look pets also for some interaction (quest/etc)
    Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
    if (!creature)
        return NULL;

    // Deathstate checks
    if (!isAlive() && !(creature->GetCreatureTemplate()->TypeFlags[0] & CREATURE_TYPEFLAGS_GHOST))
        return NULL;

    // alive or spirit healer
    if (!creature->isAlive() && !(creature->GetCreatureTemplate()->TypeFlags[0] & CREATURE_TYPEFLAGS_DEAD_INTERACT))
        return NULL;

    // appropriate npc type
    if (npcflagmask && !creature->HasFlag(UNIT_FIELD_NPC_FLAGS, npcflagmask))
        return NULL;
    if (npcflagmask2 && !creature->HasFlag(UNIT_FIELD_NPC_FLAGS2, npcflagmask2))
        return NULL;

    // not allow interaction under control, but allow with own pets
    if (creature->GetCharmerGUID())
        return NULL;

    // not enemy
    if (creature->IsHostileTo(this) && !creature->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_ENEMY_INTERACT))
        return NULL;

    // not unfriendly
    if (FactionTemplateEntry const* factionTemplate = sFactionTemplateStore.LookupEntry(creature->getFaction()))
        if (factionTemplate->Faction)
            if (FactionEntry const* faction = sFactionStore.LookupEntry(factionTemplate->Faction))
                if (faction->CanHaveReputation() && GetReputationMgr().GetRank(faction) <= REP_UNFRIENDLY)
                    return NULL;

    // not too far
    if (!creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
        return NULL;

    return creature;
}

GameObject* Player::GetGameObjectIfCanInteractWith(ObjectGuid guid, GameobjectTypes type) const
{
    auto go = GetMap()->GetGameObject(guid);
    if (!go)
        return nullptr;

    if (go->GetGoType() == type)
    {
        auto maxdist = go->GetInteractionDistance();
        if (go->HasFlag(GAMEOBJECT_FIELD_FLAGS, GO_FLAG_INTERACT_DISTANCE_USES_TEMPLATE_MODEL))
            maxdist = go->GetGOInfo()->size;

        if (go->IsWithinDistInMap(this, maxdist))
            return go;

        TC_LOG_DEBUG(LOG_FILTER_MAPS, "IsGameObjectOfTypeInRange: GameObject '%s' [GUID: %u] is too far away from player %s [GUID: %u] to be used by him (distance=%f, maximal 10 is allowed)", go->GetGOInfo()->name.c_str(),
            go->GetGUIDLow(), GetName(), GetGUIDLow(), go->GetDistance(this));
    }

    return nullptr;
}

bool Player::IsUnderWater() const
{
    return IsInWater() && GetPositionZ() < (GetMap()->GetWaterLevel(GetPositionX(), GetPositionY()) - 2);
}

void Player::SetInWater(bool apply)
{
    if (m_isInWater == apply)
        return;

    //define player in water by opcodes
    //move player's guid into HateOfflineList of those mobs
    //which can't swim and move guid back into ThreatList when
    //on surface.
    //TODO: exist also swimming mobs, and function must be symmetric to enter/leave water
    m_isInWater = apply;

    // remove auras that need water/land
    RemoveAurasWithInterruptFlags(apply ? AURA_INTERRUPT_FLAG_NOT_ABOVEWATER : AURA_INTERRUPT_FLAG_NOT_UNDERWATER);

    getHostileRefManager().updateThreatTables();
}

bool Player::IsInAreaTriggerRadius(uint32 areatriggerID) const
{
    if (AreaTriggerEntry const* trigger = sAreaTriggerStore.LookupEntry(areatriggerID))
        return IsInAreaTriggerRadius(trigger);

    return false;
}

bool Player::IsInAreaTriggerRadius(AreaTriggerEntry const* trigger) const
{
    if (!trigger || GetMapId() != trigger->ContinentID)
        return false;

    if (trigger->Radius > 0.f)
    {
        if (GetDistance(trigger->Pos.X, trigger->Pos.Y, trigger->Pos.Z) > trigger->Radius)
            return false;
    }
    else
    {
        Position center;
        center.Relocate(trigger->Pos.X, trigger->Pos.Y, trigger->Pos.Z, trigger->BoxYaw);
        if (!IsWithinBox(center, trigger->BoxLength / 2.f, trigger->BoxWidth / 2.f, trigger->BoxHeight / 2.f))
            return false;
    }

    return true;
}

void Player::SetGameMaster(bool on)
{
    setIgnorePhaseIdCheck(on);
    if (on)
    {
        m_ExtraFlags |= PLAYER_EXTRA_GM_ON;
        setFaction(35);
        SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GM);
        SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);

        if (Pet* pet = GetPet())
        {
            pet->setFaction(35);
            pet->getHostileRefManager().setOnlineOfflineState(false);
        }

        RemoveByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);
        SetGroupUpdateFlag(GROUP_UPDATE_FLAG_STATUS);
        ResetContestedPvP();

        getHostileRefManager().setOnlineOfflineState(false);
        CombatStopWithPets();

        SetPhaseMask(uint32(PHASEMASK_ANYWHERE), false);    // see and visible in all phases
        m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, GetSession()->GetSecurity());
    }
    else
    {
        m_ExtraFlags &= ~ PLAYER_EXTRA_GM_ON;
        setFactionForRace(getRace());
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GM);
        RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS);

        if (Pet* pet = GetPet())
        {
            pet->setFaction(getFaction());
            pet->getHostileRefManager().setOnlineOfflineState(true);
        }

        // restore FFA PvP Server state
        if (sWorld->IsFFAPvPRealm())
        {
            SetByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);
            SetGroupUpdateFlag(GROUP_UPDATE_FLAG_STATUS);
        }

        // restore FFA PvP area state, remove not allowed for GM mounts
        UpdateArea(m_areaId);

        getHostileRefManager().setOnlineOfflineState(true);
        m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);

        AddDelayedEvent(100, [this]() -> void
        {
            GetPhaseMgr().AddUpdateFlag(PHASE_UPDATE_FLAG_SERVERSIDE_CHANGED);
            GetPhaseMgr().RemoveUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);
            GetPhaseMgr().Update();
        });
    }

    UpdateObjectVisibility();
}

bool Player::HasPlayerExtraFlag(uint32 flag)
{
    return (m_ExtraFlags & flag);
}

void Player::SetPlayerExtraFlag(uint32 flag, bool addFlag)
{
    if (addFlag)
    {
        m_ExtraFlags |= flag;
        return;
    }

    m_ExtraFlags &= ~flag;
}

bool Player::InvisibleStatusRatingRequirements()
{
    uint16 minRating = sWorld->getIntConfig(CONFIG_PLAYER_INVISIBLE_STATUS_COMMAND);

    if (!minRating)
        return true;

    if (minRating < 3000)
    {
        uint16 curRating = 0;

        if (Bracket* br = getBracket(MS::Battlegrounds::BracketType::Arena2v2))
            curRating = br->getRating();

        if (Bracket* br = getBracket(MS::Battlegrounds::BracketType::Arena3v3))
        {
            if (br->getRating() > curRating)
                curRating = br->getRating();
        }

        if (curRating >= minRating)
            return true;
    }

    SendInvisibleStatusMsg(3);
    return false;
}

bool Player::InvisibleStatusMapRequirements()
{
    if (Map* pMap = GetMap())
    {
        if (pMap->GetId() != 0 && pMap->GetId() != 1 && !pMap->IsBattleArena() || pMap->IsDungeon())
        {
            SendInvisibleStatusMsg(4);
            return false;
        }
    }
    return true;
}

void Player::SendInvisibleStatusMsg(uint8 msgId)
{
    std::ostringstream ss_info;

    switch (msgId)
    {
        case 0: // off
        {
            ss_info << "|cff990000Invisible Status Mod:|cffffffff OFF";
            break;
        }
        case 1: // on
        {
            ss_info << "|cff990000Invisible Status Mod:|cffffffff ON";
            break;
        }
        case 2: // if wisp to other player
        {
            ss_info << "|cff990000You can't write to other players when you use invisible status mod. First you need to write:|cffffffff _invisible off";
            break;
        }
        case 3: // not enough rating
        {
            uint16 minRating = sWorld->getIntConfig(CONFIG_PLAYER_INVISIBLE_STATUS_COMMAND);

            ss_info << "|cff990000Not enough personal arena rating. It's should be not less |cffffffff";
            ss_info << minRating;
            ss_info << " |cff990000in 2v2 or 3v3.";
            break;
        }
        case 4: // Send if player not in Kalimdor, Eastern Kingdoms on Arena
        {
            ss_info << "|cff990000You can't use invisible status mod on this map. It work only on |cffffffff Kalimdor|cff990000, |cffffffffEastern Kingdoms |cff990000or |cffffffffArena";
            break;
        }
        default:
            return;
    }
    
    SendMessageToPlayer(ss_info.str().c_str());
}

bool Player::HaveSpectators()
{
    if (IsSpectator())
        return false;

    if (auto bg = GetBattleground())
    {
        auto itr = bg->GetBattlegroundScoreMap().find(GetGUID());
        if (itr == bg->GetBattlegroundScoreMap().end())
            return false;

        if (bg->IsArena())
        {
            if (bg->GetStatus() != STATUS_IN_PROGRESS)
                return false;

            return bg->HaveSpectators();
        }
    }

    return false;
}

void Player::SendSpectatorAddonMsgToBG(SpectatorAddonMsg& msg)
{
    if (HaveSpectators())
        GetBattleground()->SendSpectateAddonsMsg(msg);
}

bool Player::IsSpectateCanceled()
{
    return _spectateCanceled;
}

void Player::CancelSpectate()
{
    _spectateCanceled = true;
}

Unit* Player::GetSpectateFrom()
{
    return _spectateFrom;
}

bool Player::IsSpectator() const
{
    return _spectatorFlag;
}

bool Player::IsSpectateRemoving() const
{
    return _spectateRemoving;
}

void Player::SetSpectateRemoving(bool _value)
{
    _spectateRemoving = _value;
}

void Player::SetSpectate(bool on)
{
    if (on)
    {
        SetSpeed(MOVE_RUN, 2.5);
        _spectatorFlag = true;

        RemoveAurasByType(SPELL_AURA_MOUNTED);
        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED);

        if (auto pet = GetPet())
            RemovePet(pet);

        UnsummonPetTemporaryIfAny();
        ResetContestedPvP();

        getHostileRefManager().setOnlineOfflineState(false);
        CombatStopWithPets();

        // random dispay id`s
        uint32 morphs[15] = { 25900, 18718, 29348, 22235, 30414, 736, 20582, 28213, 22984, 20918, 32031, 21367, 17822, 23834, 20628 };
        SetDisplayId(morphs[urand(0, 14)]);

        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_ADMINISTRATOR);
    }
    else
    {
        setFactionForRace(getRace());
        RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED);

        if (_spectateFrom)
            SetViewpoint(_spectateFrom, false);

        UpdateArea(m_areaId);

        getHostileRefManager().setOnlineOfflineState(true);
        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
        _spectateCanceled = false;
        _spectatorFlag = false;
        RestoreDisplayId();
        UpdateSpeed(MOVE_RUN, true);
        SetSpectateRemoving(false);
    }

    UpdateObjectVisibility();
}

void Player::SetGMVisible(bool on)
{
    if (on)
    {
        m_ExtraFlags &= ~PLAYER_EXTRA_GM_INVISIBLE;         //remove flag
        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
    }
    else
    {
        m_ExtraFlags |= PLAYER_EXTRA_GM_INVISIBLE;          //add flag

        SetAcceptWhispers(false);
        SetGameMaster(true);

        m_serverSideVisibility.SetValue(SERVERSIDE_VISIBILITY_GM, GetSession()->GetSecurity());
    }
}

bool Player::IsGroupVisibleFor(Player const* p) const
{
    switch (sWorld->getIntConfig(CONFIG_GROUP_VISIBILITY))
    {
        default: return IsInSameGroupWith(p);
        case 1:  return IsInSameRaidWith(p);
        case 2:  return GetTeam() == p->GetTeam();
    }
}

bool Player::IsInSameGroupWith(Player const* p) const
{
    return p == this || (GetGroup() != NULL &&
        GetGroup() == p->GetGroup() &&
        GetGroup()->SameSubGroup(this, p));
}

///- If the player is invited, remove him. If the group if then only 1 person, disband the group.
/// \todo Shouldn't we also check if there is no other invitees before disbanding the group?
void Player::UninviteFromGroup()
{
    Group* group = GetGroupInvite();
    if (!group)
        return;

    group->RemoveInvite(this);

    if (group->GetMembersCount() <= 1)                       // group has just 1 member => disband
    {
        if (group->IsCreated())
        {
            group->Disband(true);
        }
        else
        {
            group->RemoveAllInvites();
            delete group;
        }
    }
}

void Player::RemoveFromGroup(Group* group, ObjectGuid guid, RemoveMethod method /* = GROUP_REMOVEMETHOD_DEFAULT*/, ObjectGuid kicker /* = 0 */, const char* reason /* = NULL */)
{
    if (group)
    {
        if (Scenario* progress = sScenarioMgr->GetScenario(group->m_challengeInstanceID))
        {
            if (Challenge* _challenge = progress->GetChallenge())
            {
                if (guid == group->m_challengeOwner && !_challenge->_complete && _challenge->_run && !m_worldCrashChecker)
                {
                    if (Player* keyOwner = ObjectAccessor::FindPlayer(guid))
                        keyOwner->ChallengeKeyCharded(keyOwner->GetItemByEntry(138019, true), keyOwner->m_challengeKeyInfo.Level, false);
                    else
                        CharacterDatabase.PQuery("UPDATE challenge_key SET KeyIsCharded = 0, InstanceID = 0 WHERE guid = %u", guid.GetGUIDLow());
                }
            }
        }

        group->RemoveMember(guid, false, method, kicker, reason);
        group = NULL;
    }
}

void Player::SendLogXPGain(uint32 givenXP, Unit* victim, uint32 bonusXP, bool recruitAFriend, float groupBonus)
{
    WorldPackets::Character::LogXPGain packet;
    packet.Victim = victim ? victim->GetGUID() : ObjectGuid::Empty;
    packet.Original = givenXP + bonusXP;
    packet.Reason = victim ? 0 : 1;
    packet.Amount = givenXP;
    packet.GroupBonus = groupBonus;
    packet.ReferAFriendBonusType = recruitAFriend ? 1 : 0;
    SendDirectMessage(packet.Write());
}

void Player::GiveXP(uint32 xp, Unit* victim, float groupRate /*= 1.0f*/)
{
    if (xp < 1)
        return;

    if (!isAlive() && !GetBattlegroundId())
        return;

    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_NO_XP_GAIN))
        return;

    if (victim && victim->IsCreature() && !victim->ToCreature()->hasLootRecipient())
        return;

    if (IsForbiddenMapForLevel(GetMapId(), m_zoneId))
        xp = 0;

    if (IsLoXpMap(GetMapId()))
        xp = uint32(xp / (sWorld->getRate(RATE_XP_QUEST)));

    uint8 level = getLevel();

    sScriptMgr->OnGivePlayerXP(this, xp, victim);

    // Favored experience increase START
    float favoredExpMultiplier = 0;
    if ((HasAura(32096) || HasAura(32098)) && (m_zoneId == 3483 || m_zoneId == 3562 || m_zoneId == 3836 || m_zoneId == 3713 || m_zoneId == 3714))
        favoredExpMultiplier = 0.05f; // Thrallmar's Favor and Honor Hold's Favor
    xp = uint32(xp * (1 + favoredExpMultiplier));

    // XP to money conversion processed in Player::RewardQuest
    if (level >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        return;

    uint32 bonusXP = 0;
    float recruitAFriend = GetsAFriendBonus(true);

    // RaF does NOT stack with rested experience
    if (recruitAFriend)
        bonusXP = uint32(recruitAFriend * xp); // xp + bonusXP must add up to 3 * xp for RaF; calculation for quests done client-side
    else
        bonusXP = victim ? GetXPRestBonus(xp) : 0; // XP resting bonus

    SendLogXPGain(xp, victim, bonusXP, recruitAFriend, groupRate);

    uint32 nextLvlXP = GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP);
    uint32 newXP = GetUInt32Value(PLAYER_FIELD_XP) + xp + bonusXP;

    while (newXP >= nextLvlXP && level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
    {
        newXP -= nextLvlXP;

        if (level < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
            GiveLevel(level + 1);

        level = getLevel();
        nextLvlXP = GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP);
    }

    SetXP(newXP);
}

void Player::SetXP(uint32 xp)
{
    SetUInt32Value(PLAYER_FIELD_XP, xp);

    int32 playerLevelDelta = 0;

    // If XP < 50%, player should see scaling creature with -1 level except for level max
    if (getLevel() < MAX_LEVEL && xp < (GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP) / 2))
        playerLevelDelta = -1;

    SetInt32Value(PLAYER_FIELD_SCALING_PLAYER_LEVEL_DELTA, playerLevelDelta);
}

// Give xp when gathering herbalism and mininh
// Formulas found here : http://www.wowwiki.com/Formulas:Gather_XP
void Player::GiveGatheringXP()
{
    uint32 level = getLevel();
    uint32 gain = 0;

    if (level >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        return;

    if (level < 50)
        gain = 12.76f * level;
    else if (level > 49 && level < 60)
        gain = 25 * level - 550;
    else if (level > 59 && level < 70)
        gain = 20 * level - 200;
    else if (level > 69 && level < 80)
        gain = 100 * level - 6600;
    else if (level > 79 && level < 85)
        gain = 750 * level - 58250;
    else if (level > 84 && level < 90)
        gain = 1720 * level - 138800; // (7400 - 14280),  Guessed, TODO : find blizzlike formula (7400 - 14280)

    gain /= 10.0f;

    float GatheringXpRate = 1;

    if (float rate = GetSession()->GetPersonalXPRate())
        GatheringXpRate = rate;
    else if(GetPersonnalXpRate())
        GatheringXpRate = GetPersonnalXpRate();
    else
        GatheringXpRate = sWorld->getRate(RATE_XP_GATHERING);

    gain *= GatheringXpRate;

    GiveXP(gain, NULL);
}

// Update player to next level
// Current player experience not update (must be update by caller)
void Player::GiveLevel(uint8 level)
{
    uint8 oldLevel = getLevel();
    if (level == oldLevel)
        return;

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* item = m_items[i])
            if (CanUseAttackType(GetAttackBySlot(i)))
                _ApplyItemMods(item, i, false);

    PlayerLevelInfo info;
    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), level, &info);

    uint32 basemana = sObjectMgr->GetPlayerClassLevelInfo(getClass(), level);

    WorldPackets::Misc::LevelUpInfo packet;
    packet.Level = level;
    packet.HealthDelta = 0;
    packet.PowerDelta[0] = int32(basemana) - int32(GetCreateMana());
    packet.PowerDelta[1] = 0;
    packet.PowerDelta[2] = 0;
    packet.PowerDelta[3] = 0;
    packet.PowerDelta[4] = 0;
    packet.PowerDelta[5] = 0;

    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        packet.StatDelta[i] = int32(info.stats[i]) - GetCreateStat(Stats(i));

    uint8 const* rowLevels = (getClass() != CLASS_DEATH_KNIGHT) ? (getClass() == CLASS_DEMON_HUNTER ? DHTalentRowLevels : DefaultTalentRowLevels) : DKTalentRowLevels;
    packet.Cp = std::find(rowLevels, rowLevels + MAX_TALENT_TIERS, level) != (rowLevels + MAX_TALENT_TIERS);

    SendDirectMessage(packet.Write());

    SetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(level));

    //update level, max level of skills
    m_Played_time[PLAYED_TIME_LEVEL] = 0;                   // Level Played Time reset
    m_account_time[PLAYED_TIME_LEVEL] = 0;
  
    SetLevel(level);
    
    UpdateSkillsForLevel();
    LearnDefaultSkills();
    LearnDefaultSpells();

    // save base values (bonuses already included in stored stats
    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        SetCreateStat(Stats(i), info.stats[i]);

    SetCreateHealth(0);
    SetCreateMana(basemana);

    InitTalentForLevel();
    InitTaxiNodesForLevel();

    LearnSpecializationSpells();

    UpdateAllStats();
    SendOperationsAfterDelay(OAD_RECALC_ITEMS);

    // set current level health and mana/energy to maximum after applying all mods.
    SetFullHealth();
    SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
    SetPower(POWER_ENERGY, GetMaxPower(POWER_ENERGY));
    if (GetPower(POWER_RAGE) > GetMaxPower(POWER_RAGE))
        SetPower(POWER_RAGE, GetMaxPower(POWER_RAGE));
    SetPower(POWER_FOCUS, 0);

    // update level to hunter/summon pet
    if (Pet* pet = GetPet())
        pet->SynchronizeLevelWithOwner();

    if (MailLevelReward const* mailReward = sObjectMgr->GetMailLevelReward(level, getRaceMask()))
    {
        //- TODO: Poor design of mail system
        SQLTransaction trans = CharacterDatabase.BeginTransaction();
        MailDraft draft(mailReward->mailTemplateId);
        if (MailTemplateEntry const* mailTemplateEntry = sMailTemplateStore.LookupEntry(mailReward->mailTemplateId))
            draft.AddBody(mailTemplateEntry->Body->Str[GetSession()->GetSessionDbLocaleIndex()]);
        draft.SendMailTo(trans, this, MailSender(MAIL_CREATURE, uint64(mailReward->senderEntry)));
        CharacterDatabase.CommitTransaction(trans);
    }

    UpdateAchievementCriteria(CRITERIA_TYPE_REACH_LEVEL);

    AddDelayedEvent(100, [this]() -> void
    {
        PhaseUpdateData phaseUdateData;
        phaseUdateData.AddConditionType(CONDITION_LEVEL);
        GetPhaseMgr().NotifyConditionChanged(phaseUdateData);
    });

    // Refer-A-Friend
    if (GetSession()->GetRecruiterId())
        if (level < sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL))
            if (level % 2 == 0)
            {
                ++m_grantableLevels;

                ToggleByteFlag(PLAYER_FIELD_BYTES_4, PLAYER_BYTES_4_RAF_GRANTABLE_LEVEL, 0x01);
            }

    UpdateAchievementCriteria(CRITERIA_TYPE_PLAYER_LEVEL_UP, level);

    sScriptMgr->OnPlayerLevelChanged(this, oldLevel);

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* item = m_items[i])
            if (CanUseAttackType(GetAttackBySlot(i)))
                _ApplyItemMods(item, i, true);

    RecalculateAmountAllAuras();
}

void Player::InitTalentForLevel()
{
    uint8 level = getLevel();
    if (level < 10)
        ResetTalentSpecialization();

    uint8 talentPointsForLevel = CalculateTalentsPoints();

    if (level < 15)
        ResetTalents(true);
    else
    {
        for (uint8 t = talentPointsForLevel; t < MAX_TALENT_TIERS; ++t)
            for (uint8 c = 0; c < MAX_TALENT_COLUMNS; ++c)
                for (TalentEntry const* talent : sDB2Manager._talentByPos[getClass()][t][c])
                    RemoveTalent(talent);
    }

    SetUInt32Value(PLAYER_FIELD_MAX_TALENT_TIERS, talentPointsForLevel);

    if (!GetSession()->PlayerLoading())
        SendTalentsInfoData(false);                         // update at client
}

void Player::RemoveTalent(TalentEntry const* talent, bool isDelete, bool sendMessage, bool allGroups/* = false*/)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(talent->SpellID);
    if (!spellInfo)
        return;

    if (auto const* mTotalAuraList = GetAuraEffectsByType(SPELL_AURA_ENABLE_EXTRA_TALENT))
    {
        for (auto const& auraEffect : *mTotalAuraList)
        {
            if (auraEffect->GetMiscValue() == talent->ID)
                goto setRemoved;
        }
    }

    removeSpell(talent->SpellID, true, true, sendMessage);

    // search for spells that the talent teaches and unlearn them
    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
    {
        if (spellInfo->EffectMask < uint32(1 << i))
            break;

        if (spellInfo->GetEffect(i, m_spawnMode)->TriggerSpell > 0 && spellInfo->GetEffect(i, m_spawnMode)->Effect == SPELL_EFFECT_LEARN_SPELL)
            removeSpell(spellInfo->GetEffect(i, m_spawnMode)->TriggerSpell, true, true, sendMessage);
    }

    if (talent->OverridesSpellID)
        RemoveOverrideSpell(talent->OverridesSpellID, talent->SpellID);

    setRemoved:

    if (isDelete)
    {
        if (allGroups)
        {
            for (uint8 group = 0; group < MAX_SPECIALIZATIONS; ++group)
            {
                auto const& plrTalent = GetTalentMap(group)->find(talent->ID);
                if (plrTalent != GetTalentMap(group)->end())
                    plrTalent->second = PLAYERSPELL_REMOVED;
            }
        }
        else
        {
            auto const& plrTalent = GetTalentMap(GetActiveTalentGroup())->find(talent->ID);
            if (plrTalent != GetTalentMap(GetActiveTalentGroup())->end())
                plrTalent->second = PLAYERSPELL_REMOVED;
        }
    }
}

void Player::RemovePvPTalent(uint32 spellID, uint8 group, bool isDelete /*= true*/, bool sendMessage /*= true*/)
{
    auto const& talentEntry = sDB2Manager.GetPvpTalentBySpellID(spellID);
    if (!talentEntry)
        return;

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(talentEntry->SpellID);
    if (!spellInfo)
        return;

    removeSpell(talentEntry->SpellID, true, true, sendMessage);

    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
    {
        if (spellInfo->EffectMask < uint32(1 << i))
            break;

        if (spellInfo->GetEffect(i, m_spawnMode)->TriggerSpell > 0 && spellInfo->GetEffect(i, m_spawnMode)->Effect == SPELL_EFFECT_LEARN_SPELL)
            removeSpell(spellInfo->GetEffect(i, m_spawnMode)->TriggerSpell, true, true, sendMessage);
    }

    if (talentEntry->OverrideSpellID)
        RemoveOverrideSpell(talentEntry->OverrideSpellID, talentEntry->SpellID);

    if (isDelete)
    {
        auto const& plrTalent = GetPvPTalentMap(group)->find(talentEntry->SpellID);
        if (plrTalent != GetPvPTalentMap(group)->end())
            plrTalent->second = PLAYERSPELL_REMOVED;
    }
}

void Player::RemoveAllPvPTalent(bool isDelete)
{
    for (uint8 group = 0; group < MAX_SPECIALIZATIONS; ++group)
    {
        PlayerPvPTalentMap* talentPvps = GetPvPTalentMap(group);
        for (PlayerPvPTalentMap::iterator itr = talentPvps->begin(); itr != talentPvps->end();)
        {
            RemovePvPTalent(itr->first, group, isDelete, false);
            ++itr;
        }
    }
}

void Player::TogglePvpTalents(bool enable)
{
    if (getLevel() < 110 || (GetMap()->IsDungeon() && enable && !sWorld->getBoolConfig(CONFIG_PLAYER_ALLOW_PVP_TALENTS_ALL_THE_TIME)))
        return;

    for (auto const& v : *GetPvPTalentMap(GetActiveTalentGroup()))
    {
        auto pvpTalentInfo = sDB2Manager.GetPvpTalentBySpellID(v.first);
        if (!pvpTalentInfo)
            continue;

        if (enable && v.second != PLAYERSPELL_REMOVED || sWorld->getBoolConfig(CONFIG_PLAYER_ALLOW_PVP_TALENTS_ALL_THE_TIME))
        {
            if (pvpTalentInfo->OverrideSpellID)
                AddOverrideSpell(pvpTalentInfo->OverrideSpellID, pvpTalentInfo->SpellID);

            learnSpell(pvpTalentInfo->SpellID, false);
        }
        else
        {
            if (pvpTalentInfo->OverrideSpellID)
                RemoveOverrideSpell(pvpTalentInfo->OverrideSpellID, pvpTalentInfo->SpellID);

            removeSpell(pvpTalentInfo->SpellID, true);
        }
    }
}

void Player::TogglePvpStatsScaling(bool enable)
{
    if (getLevel() < 110)
        return;

    _pvpStatsScalingEnabled = enable;

    if (enable)
    {
        AddAura(SPELL_PVP_STATS_TEMPLATE, this);
        AddAura(SPELL_DISABLE_ITEM_EFFECTS_IN_PVP, this);
    }
    else
    {
        RemoveAurasDueToSpell(SPELL_PVP_STATS_TEMPLATE);
        RemoveAurasDueToSpell(SPELL_DISABLE_ITEM_EFFECTS_IN_PVP);
        DisablePvpRules(false);
        SetCrowdControlSpellId(0);
    }

    SendOperationsAfterDelay(OAD_RECALC_ITEMS);
    RecalcArenaAuras(enable);
}

bool Player::HasPvpStatsScalingEnabled() const
{
    return _pvpStatsScalingEnabled;
}

bool Player::HasPvpRulesTimer() const
{
    return _pvpRulesTimer;
}

void Player::SetPvpRulesTimer(bool enable)
{
    _pvpRulesTimer = enable;
}

bool Player::IsAreaThatActivatesPvpTalents(uint32 areaID) const
{
    if (InBattleground())
        return true;

    if (auto area = sAreaTableStore.LookupEntry(areaID))
    {
        if (area->IsSanctuary())
            return false;

        if (const_cast<Player*>(this)->InFFAPvPArea())
            return true;

        if (!area->ActivatesPvpTalents())
            if (area->ParentAreaID)
                return IsAreaThatActivatesPvpTalents(area->ParentAreaID);

        return area->ActivatesPvpTalents();
    }

    return false;
}

void Player::EnablePvpRules(bool recalcItems /*= true*/)
{
    if (HasPvpRulesEnabled())
    {
        if (HasPvpRulesTimer())
        {
            if (Aura* aura = GetAura(SPELL_PVP_RULES_ENABLED))
            {
                aura->SetMaxDuration(-1);
                aura->SetDuration(-1);
            }
        }
        return;
    }

    if (recalcItems)
    {
        for (auto i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
            if (auto item = m_items[i])
                if (auto pvpItem = sPvpItemStore.LookupEntry(item->GetEntry()))
                    item->SetScaleIlvl(pvpItem->ItemLevelDelta);
    }

    AddAura(SPELL_PVP_RULES_ENABLED, this);

    if (!HasSpell(195710))
        CastSpell(this, 208682, true); //Learn Gladiator's Medallion

    // for (std::pair<ObjectGuid, uint32> ArtIt : AllArtifacts)
        // if (Item* artifact = GetItemByGuid(ArtIt.first))
        // {
            // _ApplyItemBonuses(artifact, artifact->GetSlot(), false);
            // _ApplyItemBonuses(artifact, artifact->GetSlot(), true);
            // // for (uint8 slot = SOCK_ENCHANTMENT_SLOT; slot <= SOCK_ENCHANTMENT_SLOT_3; ++slot)
                // // if (uint32 enchantmentID = artifact->GetEnchantmentId(EnchantmentSlot(slot)))
                    // // artifact->ApplyArtifactPowerEnchantmentBonuses(EnchantmentSlot(slot), enchantmentID, false, this);
        // }

    if (Aura* aura = GetAura(SPELL_PVP_RULES_ENABLED))
    {
        aura->SetMaxDuration(-1);
        aura->SetDuration(-1);
    }
}

void Player::DisablePvpRules(bool recalcItems /*= true*/, bool checkZone/* = true*/)
{
    if ((checkZone && IsAreaThatActivatesPvpTalents(GetCurrentAreaID())) || 
		(sWorld->getBoolConfig(CONFIG_PLAYER_ALLOW_PVP_TALENTS_ALL_THE_TIME) && getLevel() >= 110))
        return;

    // for (std::pair<ObjectGuid, uint32> ArtIt : AllArtifacts)
        // if (Item* artifact = GetItemByGuid(ArtIt.first))
        // {
            // _ApplyItemBonuses(artifact, artifact->GetSlot(), false);
            // _ApplyItemBonuses(artifact, artifact->GetSlot(), true);
            // // for (uint8 slot = SOCK_ENCHANTMENT_SLOT; slot <= SOCK_ENCHANTMENT_SLOT_3; ++slot)
                // // if (uint32 enchantmentID = artifact->GetEnchantmentId(EnchantmentSlot(slot)))
                    // // artifact->ApplyArtifactPowerEnchantmentBonuses(EnchantmentSlot(slot), enchantmentID, true, this);
        // }

    if (!GetCombatTimer())
    {
        if (!HasPvpRulesEnabled())
            return;

        if (HasAura(SPELL_PVP_RULES_ENABLED))
            RemoveAurasDueToSpell(SPELL_PVP_RULES_ENABLED);
        else
            TogglePvpTalents(false);

        if (!m_session->PlayerLogout()) // If we logout item delete, why need recalc stat?
        {
            if (recalcItems)
            {
                for (auto i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
                    if (auto item = m_items[i])
                        item->SetScaleIlvl(0);
            }
        }

    }
    else if (auto aura = GetAura(SPELL_PVP_RULES_ENABLED))
        aura->SetDuration(aura->GetSpellInfo()->GetMaxDuration());
}

bool Player::HasPvpRulesEnabled()
{
    for (auto const& v : *GetPvPTalentMap(GetActiveTalentGroup()))
        if (v.second != PLAYERSPELL_REMOVED && HasSpell(v.first))
            return true;

    if (HasAura(SPELL_PVP_RULES_ENABLED) && getLevel() == 110)
        return true;

    return false;
}

SpellInfo const* Player::GetCastSpellInfo(SpellInfo const* spellInfo, uint32 newSpellId) const
{
    auto spelles = m_spellOverrides.find(newSpellId);
    if (spelles != m_spellOverrides.end())
        if (SpellInfo const* newInfo = sSpellMgr->GetSpellInfo(newSpellId))
            return Unit::GetCastSpellInfo(newInfo);

    auto overrides = m_overrideSpells.find(spellInfo->Id);
    if (overrides != m_overrideSpells.end())
        for (uint32 spellId : overrides->second)
            if (SpellInfo const* newInfo = sSpellMgr->GetSpellInfo(spellId))
                return Unit::GetCastSpellInfo(newInfo);

    return Unit::GetCastSpellInfo(spellInfo);
}

void Player::AddOverrideSpell(uint32 overridenSpellId, uint32 newSpellId)
{
    m_overrideSpells[overridenSpellId].insert(newSpellId);
    m_spellOverrides[newSpellId].insert(overridenSpellId);
}

void Player::RemoveOverrideSpell(uint32 overridenSpellId, uint32 newSpellId)
{
    auto overrides = m_overrideSpells.find(overridenSpellId);
    if (overrides != m_overrideSpells.end())
    {
        overrides->second.erase(newSpellId);
        if (overrides->second.empty())
            m_overrideSpells.erase(overrides);
    }

    auto spelles = m_spellOverrides.find(newSpellId);
    if (spelles != m_spellOverrides.end())
    {
        spelles->second.erase(overridenSpellId);
        if (spelles->second.empty())
            m_spellOverrides.erase(spelles);
    }
}

void Player::LearnSpecializationSpells()
{
    uint32 specializationId = GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID);

    if (std::vector<SpecializationSpellsEntry const*> const* specSpells = sDB2Manager.GetSpecializationSpells(specializationId))
    {
        for (size_t j = 0; j < specSpells->size(); ++j)
        {
            SpecializationSpellsEntry const* specSpell = (*specSpells)[j];
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(specSpell->SpellID);
            if (!spellInfo || spellInfo->SpellLevel > getLevel())
                continue;

            learnSpell(specSpell->SpellID, false);
            if (specSpell->OverridesSpellID)
                AddOverrideSpell(specSpell->OverridesSpellID, specSpell->SpellID);
        }
    }

    setPowerType(GetPowerTypeBySpecId(specializationId));
}

void Player::UnlearnSpellsFromOtherClasses()
{
    if (GetSession()->GetSecurity() != SEC_PLAYER)
        return;

    for (uint32 classId = CLASS_WARRIOR; classId < MAX_CLASSES; ++classId)
    {
        for (uint32 i = 0; i < 4; ++i)
        {
            if (ChrSpecializationEntry const* specialization = sDB2Manager.GetChrSpecializationByIndex(classId, i))
            {
                if (specialization->ID == GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID))
                    continue;

                if (std::vector<SpecializationSpellsEntry const*> const* specSpells = sDB2Manager.GetSpecializationSpells(specialization->ID))
                {
                    for (size_t j = 0; j < specSpells->size(); ++j)
                    {
                        SpecializationSpellsEntry const* specSpell = (*specSpells)[j];
                        if (specSpell->SpellID == 674)
                            continue;

                        removeSpell(specSpell->SpellID, true, true, false);
                        if (specSpell->OverridesSpellID)
                            RemoveOverrideSpell(specSpell->OverridesSpellID, specSpell->SpellID);
                    }
                }

                for (uint32 j = 0; j < MAX_MASTERY_SPELLS; ++j)
                    if (uint32 mastery = specialization->MasterySpellID[j])
                        RemoveAurasDueToSpell(mastery);
            }
        }
    }
}

void Player::SendMountSpells()
{
    bool needSend = false;
    MountContainer const* _mounts = &GetCollectionMgr()->GetAccountMounts();
    if (_mounts->empty())
        return;

    WorldPackets::Spells::LearnedSpells packet;
    for (auto const& mount : *_mounts)
    {
        if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(mount.first))
        {
            if (spellInfo->HasAttribute(SPELL_ATTR7_HORDE_ONLY) && GetTeam() != HORDE)
                continue;
            if (spellInfo->HasAttribute(SPELL_ATTR7_ALLIANCE_ONLY) && GetTeam() != ALLIANCE)
                continue;
            if (MountEntry const* mountEntry = sDB2Manager.GetMount(mount.first))
                if (!ConditionMgr::IsPlayerMeetingCondition(this, mountEntry->PlayerConditionID))
                    continue;

            packet.SpellID.push_back(mount.first);
            needSend = true;
        }
    }
    if (needSend)
    {
        packet.SuppressMessaging = true;
        SendDirectMessage(packet.Write());
    }

    WorldPackets::Misc::AccountMountUpdate mountUpdate;
    mountUpdate.IsFullUpdate = true;
    mountUpdate.Mounts = _mounts;
    SendDirectMessage(mountUpdate.Write());
}

void Player::RemoveSpecializationSpells()
{
    for (uint32 i = 0; i < 4; ++i)
    {
        if (ChrSpecializationEntry const* specialization = sDB2Manager.GetChrSpecializationByIndex(getClass(), i))
        {
            if (std::vector<SpecializationSpellsEntry const*> const* specSpells = sDB2Manager.GetSpecializationSpells(specialization->ID))
            {
                for (size_t j = 0; j < specSpells->size(); ++j)
                {
                    SpecializationSpellsEntry const* specSpell = (*specSpells)[j];
                    removeSpell(specSpell->SpellID, true, true, false);
                    if (specSpell->OverridesSpellID)
                        RemoveOverrideSpell(specSpell->OverridesSpellID, specSpell->SpellID);
                }
            }

            for (uint32 j = 0; j < MAX_MASTERY_SPELLS; ++j)
                if (uint32 mastery = specialization->MasterySpellID[j])
                    RemoveAurasDueToSpell(mastery);
        }
    }
}

void Player::InitStatsForLevel(bool reapplyMods)
{
    if (reapplyMods)                                        //reapply stats values only on .reset stats (level) command
        _RemoveAllStatBonuses();

    PlayerLevelInfo info;
    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), GetEffectiveLevel(), &info);

    SetUInt32Value(PLAYER_FIELD_MAX_LEVEL, MAX_LEVEL);
    SetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(getLevel()));

    // reset before any aura state sources (health set/aura apply)
    SetUInt32Value(UNIT_FIELD_AURA_STATE, 0);
    
    UpdateSkillsForLevel();

    // set default cast time multiplier
    SetFloatValue(UNIT_FIELD_MOD_CASTING_SPEED, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_SPELL_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_RANGED_HASTE, 1.0f);
    SetFloatValue(UNIT_FIELD_MOD_TIME_RATE, 1.0f);

    // reset size before reapply auras
    SetObjectScale(1.0f);

    // save base values (bonuses already included in stored stats
    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        SetCreateStat(Stats(i), info.stats[i]);

    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; ++i)
        SetStat(Stats(i), info.stats[i]);

    SetCreateHealth(0);

    //set create powers
    SetCreateMana(sObjectMgr->GetPlayerClassLevelInfo(getClass(), GetEffectiveLevel()));

    InitStatBuffMods();

    SetUInt32Value(UNIT_FIELD_SCALE_DURATION, 100);
    if (getLevel() != MAX_LEVEL)
        SetInt32Value(PLAYER_FIELD_SCALING_PLAYER_LEVEL_DELTA, -1);
    SetInt32Value(UNIT_FIELD_LOOK_AT_CONTROLLER_ID, -1);

    //reset rating fields values
    for (uint16 index = PLAYER_FIELD_COMBAT_RATINGS; index < PLAYER_FIELD_COMBAT_RATINGS + MAX_COMBAT_RATING; ++index)
        SetUInt32Value(index, 0);

    SetUInt32Value(PLAYER_FIELD_MOD_HEALING_DONE_POS, 0);

    SetFloatValue(PLAYER_FIELD_MOD_HEALING_PERCENT, 1.0f);
    SetFloatValue(PLAYER_FIELD_MOD_PERIODIC_HEALING_DONE_PERCENT, 1.0f);

    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
    {
        SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG + i, 0);
        SetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS + i, 0);
        SetFloatValue(PLAYER_FIELD_MOD_DAMAGE_DONE_PERCENT + i, 1.00f);
    }

    SetFloatValue(PLAYER_FIELD_SPELL_CRIT_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_MOD_SPELL_POWER_PERCENT, 1.0f);

    for (uint8 i = 0; i < 3; ++i)
    {
        SetFloatValue(PLAYER_FIELD_WEAPON_DMG_MULTIPLIERS + i, 1.0f);
        SetFloatValue(PLAYER_FIELD_WEAPON_ATK_SPEED_MULTIPLIERS + i, 1.0f);
    }

    SetFloatValue(PLAYER_FIELD_MOD_HEALING_DONE_PERCENT, 1.0f);

    //reset attack power, damage and attack speed fields
    SetFloatValue(UNIT_FIELD_ATTACK_ROUND_BASE_TIME, 2000.0f);
    SetFloatValue(UNIT_FIELD_ATTACK_ROUND_BASE_TIME + 1, 2000.0f); // offhand attack time
    SetFloatValue(UNIT_FIELD_RANGED_ATTACK_ROUND_BASE_TIME, 2000.0f);

    SetFloatValue(UNIT_FIELD_MIN_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MAX_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MIN_OFF_HAND_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MAX_OFF_HAND_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MIN_RANGED_DAMAGE, 0.0f);
    SetFloatValue(UNIT_FIELD_MAX_RANGED_DAMAGE, 0.0f);

    SetInt32Value(UNIT_FIELD_ATTACK_POWER,            0);
    SetInt32Value(UNIT_FIELD_ATTACK_POWER_MOD_POS,       0);
    SetInt32Value(UNIT_FIELD_ATTACK_POWER_MOD_NEG,       0);
    SetFloatValue(UNIT_FIELD_ATTACK_POWER_MULTIPLIER, 0.0f);
    SetInt32Value(UNIT_FIELD_RANGED_ATTACK_POWER,     0);
    SetFloatValue(UNIT_FIELD_RANGED_ATTACK_POWER_MULTIPLIER, 0.0f);

    // Base crit values (will be recalculated in UpdateAllStats() at loading and in _ApplyAllStatBonuses() at reset
    SetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_OFFHAND_CRIT_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_RANGED_CRIT_PERCENTAGE, 0.0f);

    SetFloatValue(PLAYER_FIELD_PARRY_PERCENTAGE, 0.0f);
    SetFloatValue(PLAYER_FIELD_BLOCK_PERCENTAGE, 0.0f);

    // Static 30% damage blocked
    SetUInt32Value(PLAYER_FIELD_SHIELD_BLOCK, 30);
    SetBaseModValue(SHIELD_BLOCK_VALUE, PCT_MOD, 30);

    // Dodge percentage
    SetFloatValue(PLAYER_FIELD_DODGE_PERCENTAGE, 0.0f);

    // set armor (resistance 0) to original value (create_agility*2)
    SetResistanceBuffMods(SpellSchools(0), true, 0.0f);
    SetResistanceBuffMods(SpellSchools(0), false, 0.0f);
    // set other resistance to original value (0)
    for (uint8 i = 1; i < MAX_SPELL_SCHOOL; ++i)
    {
        SetResistance(SpellSchools(i), 0);
        SetResistanceBuffMods(SpellSchools(i), true, 0.0f);
        SetResistanceBuffMods(SpellSchools(i), false, 0.0f);
    }

    SetUInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, 0);
    SetUInt32Value(PLAYER_FIELD_MOD_TARGET_PHYSICAL_RESISTANCE, 0);
    for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
    {
        SetUInt32Value(UNIT_FIELD_POWER_COST_MODIFIER+i, 0);
        SetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER+i, 0.0f);
    }

    for (uint8 i = 0; i < PlayerAvgItemLevelOffsets::MaxAvgItemLevel; ++i)
        SetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + i, 0.0f);

    // Reset no reagent cost field
    for (uint8 i = 0; i < 4; ++i)
        SetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK + i, 0);
    // Init data for form but skip reapply item mods for form
    InitDataForForm(reapplyMods);

    // save new stats
    InitialPowers(true);

    SetMaxHealth(0);                     // stamina bonus will applied later

    // cleanup mounted state (it will set correctly at aura loading if player saved at mount.
    SetUInt32Value(UNIT_FIELD_MOUNT_DISPLAY_ID, 0);

    // cleanup unit flags (will be re-applied if need at aura load).
    RemoveFlag(UNIT_FIELD_FLAGS,
        UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_REMOVE_CLIENT_CONTROL | UNIT_FLAG_NOT_ATTACKABLE_1 |
        UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC  | UNIT_FLAG_LOOTING          |
        UNIT_FLAG_PET_IN_COMBAT  | UNIT_FLAG_SILENCED     | UNIT_FLAG_PACIFIED         |
        UNIT_FLAG_STUNNED        | UNIT_FLAG_IN_COMBAT    | UNIT_FLAG_DISARMED         |
        UNIT_FLAG_CONFUSED       | UNIT_FLAG_FLEEING      | UNIT_FLAG_NOT_SELECTABLE   |
        UNIT_FLAG_SKINNABLE      | UNIT_FLAG_TAXI_FLIGHT  | UNIT_FLAG_MOUNT);
    SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);   // must be set

    SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_REGENERATE_POWER);// must be set

    // cleanup player flags (will be re-applied if need at aura load), to avoid have ghost flag without ghost aura, for example.
    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_AFK | PLAYER_FLAGS_DND | PLAYER_FLAGS_GM | PLAYER_FLAGS_GHOST | PLAYER_ALLOW_ONLY_ABILITY);

    RemoveStandStateFlags(UNIT_STAND_FLAGS_ALL);                 // one form stealth modified bytes
    RemoveByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP | UNIT_BYTE2_FLAG_SANCTUARY);

    // restore if need some important flags
    SetUInt32Value(PLAYER_FIELD_OVERRIDE_SPELLS_ID, 0);                 // flags empty by default

    SetByteValue(PLAYER_FIELD_BYTES_7, PLAYER_BYTES_5_IGNORE_POWER_REGEN_PREDICTION_MASK, 0);
    SetByteValue(PLAYER_FIELD_BYTES_7, PLAYER_BYTES_5_AURA_VISION, 0);
    SetByteValue(PLAYER_FIELD_BYTES_7, 3, 0);

    if (reapplyMods)                                        // reapply stats values only on .reset stats (level) command
        _ApplyAllStatBonuses();

    // set current level health and mana/energy to maximum after applying all mods.
    SetFullHealth();

    if (GetPower(POWER_RAGE) > GetMaxPower(POWER_RAGE))
        SetPower(POWER_RAGE, GetMaxPower(POWER_RAGE));

    // update level to hunter/summon pet
    if (Pet* pet = GetPet())
        pet->SynchronizeLevelWithOwner();
}

void Player::SendKnownSpells()
{
    WorldPackets::Spells::SendKnownSpells knownSpells;
    knownSpells.InitialLogin = false; /// @todo

    knownSpells.KnownSpells.reserve(m_spells.size());
    for (auto const& spell : m_spells)
    {
        PlayerSpell const* spellPtr = &spell.second;
        if (!spellPtr || spellPtr->state == PLAYERSPELL_REMOVED)
            continue;

        if (!spellPtr->active || spellPtr->disabled)
            continue;

        if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell.first))
            if (spellInfo->HasAura(SPELL_AURA_MOUNTED))
                if (MountEntry const* mountEntry = sDB2Manager.GetMount(spellInfo->Id))
                    if (!ConditionMgr::IsPlayerMeetingCondition(this, mountEntry->PlayerConditionID))
                        continue;

        knownSpells.KnownSpells.push_back(spell.first);
    }

    SendDirectMessage(knownSpells.Write());

    TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "CHARACTER: Sent Send Known Spells");
}

void Player::RemoveMail(uint32 id)
{
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        if ((*itr)->messageID == id)
        {
            //do not delete item, because Player::removeMail() is called when returning mail to sender.
            m_mail.erase(itr);
            return;
        }
    }
}

void Player::SafeRemoveMailFromIgnored(ObjectGuid const& ignoredPlayerGuid)
{
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        if ((*itr)->sender == ignoredPlayerGuid.GetCounter())
            (*itr)->state = MAIL_STATE_DELETED;
    }

    m_mailsUpdated = true;
}

void Player::SendMailResult(uint32 mailId, MailResponseType mailAction, MailResponseResult mailError, uint32 equipError, ObjectGuid::LowType item_guid, uint32 item_count)
{
    WorldPackets::Mail::MailCommandResult result;

    result.MailID = mailId;
    result.Command = mailAction;
    result.ErrorCode = mailError;

    if (mailError == MAIL_ERR_EQUIP_ERROR)
        result.BagResult = equipError;
    else if (mailAction == MAIL_ITEM_TAKEN)
    {
        result.AttachID = item_guid;
        result.QtyInInventory = item_count;
    }

    SendDirectMessage(result.Write());
}

void Player::SendNewMail()
{
    // deliver undelivered mail
    WorldPackets::Mail::NotifyRecievedMail notify;
    notify.Delay = 0.0f;
    SendDirectMessage(notify.Write());
}

void Player::UpdateNextMailTimeAndUnreads()
{
    // calculate next delivery time (min. from non-delivered mails
    // and recalculate unReadMail
    time_t cTime = time(NULL);
    m_nextMailDelivereTime = 0;
    unReadMails = 0;
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        if ((*itr)->deliver_time > cTime)
        {
            if (!m_nextMailDelivereTime || m_nextMailDelivereTime > (*itr)->deliver_time)
                m_nextMailDelivereTime = (*itr)->deliver_time;
        }
        else if (((*itr)->checked & MAIL_CHECK_MASK_READ) == 0)
            ++unReadMails;
    }
}

void Player::AddNewMailDeliverTime(time_t deliver_time)
{
    if (deliver_time <= time(NULL))                          // ready now
    {
        ++unReadMails;
        SendNewMail();
    }
    else                                                    // not ready and no have ready mails
    {
        if (!m_nextMailDelivereTime || m_nextMailDelivereTime > deliver_time)
            m_nextMailDelivereTime = deliver_time;
    }
}

bool Player::AddTalent(TalentEntry const* talent, uint8 index, bool learning)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(talent->SpellID);
    if (!spellInfo)
    {
        // do character spell book cleanup (all characters)
        if (!IsInWorld() && !learning)                       // spell load case
        {
            TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::addSpell: Non-existed in SpellStore spell #%u request, deleting for all characters in `character_spell`.", talent->SpellID);

            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVALID_TALENT);
            stmt->setUInt32(0, talent->ID);
            CharacterDatabase.Execute(stmt);
        }
        else
            TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::addSpell: Non-existed in SpellStore spell #%u request.", talent->SpellID);

        return false;
    }

    if (!SpellMgr::IsSpellValid(spellInfo, this, false))
    {
        // do character spell book cleanup (all characters)
        if (!IsInWorld() && !learning)                       // spell load case
        {
            TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::addTalent: Broken spell #%u learning not allowed, deleting for all characters in `character_talent`.", talent->SpellID);

            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVALID_TALENT);
            stmt->setUInt32(0, talent->ID);
            CharacterDatabase.Execute(stmt);
        }
        else
            TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::addTalent: Broken spell #%u learning not allowed.", talent->SpellID);

        return false;
    }

    if (talent->OverridesSpellID)
        if (!talent->SpecID || talent->SpecID == GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID))
            AddOverrideSpell(talent->OverridesSpellID, talent->SpellID);

    PlayerTalentMap* talents = GetTalentMap(index);
    if (!talents)
        return false;

    PlayerTalentMap::iterator itr = talents->find(talent->ID);
    if (itr != talents->end())
        itr->second = PLAYERSPELL_UNCHANGED;
    else
        (*talents)[talent->ID] = learning ? PLAYERSPELL_NEW : PLAYERSPELL_UNCHANGED;

    return true;
}

bool Player::AddPvPTalent(PvpTalentEntry const* talent, uint8 index)
{
    if (!talent)
        return false;

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(talent->SpellID);
    if (!spellInfo)
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVALID_TALENT_PVP);
        stmt->setUInt32(0, talent->ID);
        CharacterDatabase.Execute(stmt);
        return false;
    }

    if (!SpellMgr::IsSpellValid(spellInfo, this, false))
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVALID_TALENT_PVP);
        stmt->setUInt32(0, talent->ID);
        CharacterDatabase.Execute(stmt);
        return false;
    }

    auto const& itr = GetPvPTalentMap(index)->find(talent->SpellID);
    if (itr != GetPvPTalentMap(index)->end())
        itr->second = PLAYERSPELL_UNCHANGED;
    else
        (*GetPvPTalentMap(index))[talent->SpellID] = PLAYERSPELL_NEW;

    return true;
}

bool Player::addSpell(uint32 spellId, bool active, bool learning, bool dependent, bool disabled, bool loading /*= false*/, uint32 fromSkill /*= 0*/, bool battlePet /*= false*/)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
    {
        // do character spell book cleanup (all characters)
        if (!IsInWorld() && !learning)                       // spell load case
        {
            TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::addSpell: Non-existed in SpellStore spell #%u request, deleting for all characters in `character_spell`.", spellId);
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVALID_SPELL);
            stmt->setUInt32(0, spellId);
            CharacterDatabase.Execute(stmt);
        }
        else
            TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::addSpell: Non-existed in SpellStore spell #%u request.", spellId);

        return false;
    }

    if (spellInfo->HasAttribute(SPELL_ATTR0_CU_CANT_BE_LEARNED))
        return false;

    if (!SpellMgr::IsSpellValid(spellInfo, this, false))
    {
        // do character spell book cleanup (all characters)
        if (!IsInWorld() && !learning)                       // spell load case
        {
            TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::addSpell: Broken spell #%u learning not allowed, deleting for all characters in `character_spell`.", spellId);
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVALID_SPELL);
            stmt->setUInt32(0, spellId);
            CharacterDatabase.Execute(stmt);
        }
        else
            TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::addSpell: Broken spell #%u learning not allowed.", spellId);

        return false;
    }

    if (sSpellMgr->IsSpellForbidden(spellId) && !isGameMaster() && sWorld->getBoolConfig(CONFIG_SPELL_FORBIDDEN))
    {
        std::string banString = "Auto-ban for spell cheat ";
        char buff[2048];

        sprintf(buff, "(spellId : %u)", (uint32)spellId);
        banString += buff;
        sWorld->BanAccount(BAN_CHARACTER, GetName(), "-1", banString, "Auto-Ban");
        return false;
    }
    // Check tallents spell
    if (!disabled)
    {
        //Profession mastery. Fix bracking professtions.
        switch (spellId)
        {
            case 28672: //Alchemy: Transmutation Master
                removeSpell(28675);
                removeSpell(28677);
                break;
            case 28675: //Alchemy: Potion Master
                removeSpell(28672);
                removeSpell(28677);
                break;
            case 28677: //Alchemy: Elixir Master
                removeSpell(28675);
                removeSpell(28677);
                break;
            default:
                break;
        }
    }

    // Validate profession
    if (loading)
    {
        SkillLineAbilityMapBounds spellBounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellInfo->Id);
        for (SkillLineAbilityMap::const_iterator spell_idx = spellBounds.first; spell_idx != spellBounds.second; ++spell_idx)
        {
            if (!IsProfessionSkill(spell_idx->second->SkillLine))
                continue;

            if (!HasSkill(spell_idx->second->SkillLine))
                disabled = true;
        }
    }

    PlayerSpellState state = learning ? PLAYERSPELL_NEW : PLAYERSPELL_UNCHANGED;

    bool dependent_set = false;
    bool disabled_case = false;
    bool superceded_old = false;

    PlayerSpellMap::guarded_ptr itr = m_spells.get(spellId);

    // Remove temporary spell if found to prevent conflicts
    if (itr && itr->second.state == PLAYERSPELL_TEMPORARY)
    {
        itr.release();
        RemoveTemporarySpell(spellId);
    }
    else if (itr)
    {
        PlayerSpell* spellPtr = &itr->second;
        itr.release();

        uint32 next_active_spell_id = 0;
        // fix activate state for non-stackable low rank (and find next spell for !active case)
        if (spellInfo->IsRanked())
        {
            if (uint32 next = sSpellMgr->GetNextSpellInChain(spellId))
            {
                if (HasSpell(next))
                {
                    // high rank already known so this must !active
                    active = false;
                    next_active_spell_id = next;
                }
            }
        }

        // not do anything if already known in expected state
        if (spellPtr->state != PLAYERSPELL_REMOVED && spellPtr->active == active &&
            spellPtr->dependent == dependent && spellPtr->disabled == disabled)
        {
            if (!IsInWorld() && !learning)                   // explicitly load from DB and then exist in it already and set correctly
                spellPtr->state = PLAYERSPELL_UNCHANGED;
            return false;
        }

        // dependent spell known as not dependent, overwrite state
        if (spellPtr->state != PLAYERSPELL_REMOVED && !spellPtr->dependent && dependent)
        {
            spellPtr->dependent = dependent;
            if (spellPtr->state != PLAYERSPELL_NEW)
                spellPtr->state = PLAYERSPELL_CHANGED;
            dependent_set = true;
        }

        // update active state for known spell
        if (spellPtr->active != active && spellPtr->state != PLAYERSPELL_REMOVED && !spellPtr->disabled)
        {
            spellPtr->active = active;

            if (!IsInWorld() && !learning && !dependent_set) // explicitly load from DB and then exist in it already and set correctly
                spellPtr->state = PLAYERSPELL_UNCHANGED;
            else if (spellPtr->state != PLAYERSPELL_NEW)
                spellPtr->state = PLAYERSPELL_CHANGED;

            if (active)
            {
                if (spellInfo->IsPassive() && IsNeedCastPassiveSpellAtLearn(spellInfo))
                    CastSpell (this, spellId, true);
            }
            else if (IsInWorld())
            {
                if (next_active_spell_id)
                {
                    // update spell ranks in spellbook and action bar
                    WorldPackets::Spells::SupercededSpells supercededSpells;
                    supercededSpells.SpellID.emplace_back(next_active_spell_id);
                    supercededSpells.Superceded.emplace_back(spellId);
                    SendDirectMessage(supercededSpells.Write());
                }
                else
                {
                    WorldPackets::Spells::UnlearnedSpells unlearnedSpells;
                    unlearnedSpells.SpellID.push_back(spellId);
                    SendDirectMessage(unlearnedSpells.Write());
                }
            }

            return active;                                  // learn (show in spell book if active now)
        }

        if (spellPtr->disabled != disabled && spellPtr->state != PLAYERSPELL_REMOVED)
        {
            if (spellPtr->state != PLAYERSPELL_NEW)
                spellPtr->state = PLAYERSPELL_CHANGED;
            spellPtr->disabled = disabled;

            if (disabled)
                return false;

            disabled_case = true;
        }
        else switch (spellPtr->state)
        {
            case PLAYERSPELL_UNCHANGED:                     // known saved spell
                return false;
            case PLAYERSPELL_REMOVED:                       // re-learning removed not saved spell
            {
                HandleExcludeCasterSpellList(spellId, false);
                HandleCasterAuraStateSpellList(spellId, false);
                m_spells.erase(spellId);
                state = PLAYERSPELL_CHANGED;
                break;                                      // need re-add
            }
            default:                                        // known not saved yet spell (new or modified)
            {
                // can be in case spell loading but learned at some previous spell loading
                if (!IsInWorld() && !learning && !dependent_set)
                    spellPtr->state = PLAYERSPELL_UNCHANGED;
                return false;
            }
        }
    }

    if (!disabled_case) // skip new spell adding if spell already known (disabled spells case)
    {
        // non talent spell: learn low ranks (recursive call)
        if (uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(spellId))
        {
            if (!IsInWorld() || disabled)                    // at spells loading, no output, but allow save
                addSpell(prev_spell, active, true, true, disabled);
            else                                            // at normal learning
                learnSpell(prev_spell, true);
        }

        PlayerSpell newspell(uint8(state), active, dependent, disabled);

        // replace spells in action bars and spellbook to bigger rank if only one spell rank must be accessible
        if (newspell.active && !newspell.disabled && spellInfo->IsRanked())
        {
            for (PlayerSpellMap::iterator itr2 = m_spells.begin(); itr2 != m_spells.end(); ++itr2)
            {
                PlayerSpell* spellPtr_ = &itr2->second;
                if (spellPtr_->state == PLAYERSPELL_REMOVED)
                    continue;

                SpellInfo const* i_spellInfo = sSpellMgr->GetSpellInfo(itr2->first);
                if (!i_spellInfo)
                    continue;

                if (spellInfo->IsDifferentRankOf(i_spellInfo))
                {
                    if (spellPtr_->active)
                    {
                        if (spellInfo->IsHighRankOf(i_spellInfo))
                        {
                            if (IsInWorld())
                            {
                                WorldPackets::Spells::SupercededSpells supercededSpells;
                                supercededSpells.SpellID.emplace_back(spellId);
                                supercededSpells.Superceded.emplace_back(itr2->first);
                                SendDirectMessage(supercededSpells.Write());
                            }

                            spellPtr_->active = false;
                            if (spellPtr_->state != PLAYERSPELL_NEW)
                                spellPtr_->state = PLAYERSPELL_CHANGED;

                            superceded_old = true;
                        }
                        else
                        {
                            if (IsInWorld())                 // not send spell (re-/over-)learn packets at loading
                            {
                                WorldPackets::Spells::SupercededSpells supercededSpells;
                                supercededSpells.SpellID.emplace_back(itr2->first);
                                supercededSpells.Superceded.emplace_back(spellId);
                                SendDirectMessage(supercededSpells.Write());
                            }

                            // mark new spell as disable (not learned yet for client and will not learned)
                            newspell.active = false;
                            if (newspell.state != PLAYERSPELL_NEW)
                                newspell.state = PLAYERSPELL_CHANGED;
                        }
                    }
                }
            }
        }

        bool _disable = newspell.disabled;
        uint8 __state = newspell.state;
        bool __active = newspell.active;
        bool __dependent = newspell.dependent;
        bool __disabled = newspell.disabled;
        m_spells.erase(spellId);
        m_spells.emplace(spellId, __state, __active, __dependent, __disabled);
        HandleExcludeCasterSpellList(spellId, true);
        HandleCasterAuraStateSpellList(spellId, true);

        // return false if spell disabled
        if (_disable)
            return false;
    }

    // cast talents with SPELL_EFFECT_LEARN_SPELL (other dependent spells will learned later as not auto-learned)
    // note: all spells with SPELL_EFFECT_LEARN_SPELL isn't passive
    if (!loading && sSpellMgr->IsTalent(spellInfo->Id) && spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL))
    {
        // ignore stance requirement for talent learn spell (stance set for spell only for client spell description show)
        CastSpell(this, spellId, true);
    }
    // also cast passive spells (including all talents without SPELL_EFFECT_LEARN_SPELL) with additional checks
    else if (spellInfo->IsPassive())
    {
        if (IsNeedCastPassiveSpellAtLearn(spellInfo))
        {
            if (!IsInWorld() && spellInfo->HasAura(SPELL_AURA_CREATE_AREATRIGGER)) // When player loudin he not in game and AT don`t created
                m_Events.AddEvent(new DelayCastEvent(*this, GetGUID(), spellId, true), m_Events.CalculateTime(2000));
            else
                CastSpell(this, spellId, true);
        }
    }
    else if (spellInfo->HasEffect(SPELL_EFFECT_SKILL_STEP) || spellInfo->HasEffect(SPELL_EFFECT_INCREASE_SKILL))
    {
        CastSpell(this, spellId, true);
        return false;
    }

    // update free primary prof.points (if any, can be none in case GM .learn prof. learning)
    if (uint32 freeProfs = GetFreePrimaryProfessionPoints())
    {
        if (spellInfo->IsPrimaryProfessionFirstRank())
        {
            SetFreePrimaryProfessions(freeProfs-1);

            if (m_profSpells[0].empty())
                m_profSpells[0].insert(spellId);
            else
                m_profSpells[1].insert(spellId);
        }
    }

    if (learning && !dependent)
        AddBattlePet(spellId);

    SkillLineAbilityMapBounds skill_bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellId);
    SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(spellId);
    if (spellLearnSkill)
    {
        // add dependent skills if this spell is not learned from adding skill already
        if (spellLearnSkill->skill != fromSkill)
        {
            uint32 skillValue = GetPureSkillValue(spellLearnSkill->skill);
            uint32 maxSkillValue = GetPureMaxSkillValue(spellLearnSkill->skill);

            if (skillValue < spellLearnSkill->value)
                skillValue = spellLearnSkill->value;

            uint32 newMaxSkillValue = spellLearnSkill->maxvalue == 0 ? GetMaxSkillValueForLevel() : spellLearnSkill->maxvalue;

            if (maxSkillValue < newMaxSkillValue)
                maxSkillValue = newMaxSkillValue;

            SetSkill(spellLearnSkill->skill, spellLearnSkill->step, skillValue, maxSkillValue);
        }
    }
    else
    {
        // not ranked skills
        for (SkillLineAbilityMap::const_iterator _spell_idx = skill_bounds.first; _spell_idx != skill_bounds.second; ++_spell_idx)
        {
            SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(_spell_idx->second->SkillLine);
            if (!pSkill)
                continue;

            if (pSkill->ID == fromSkill)
                continue;

            // Runeforging special case
            if ((_spell_idx->second->AcquireMethod == SKILL_LINE_ABILITY_LEARNED_ON_SKILL_LEARN && !HasSkill(pSkill->ID)) || ((pSkill->ID == SKILL_RUNEFORGING_2) && _spell_idx->second->TrivialSkillLineRankHigh == 0))
                if (SkillRaceClassInfoEntry const* rcInfo = sDB2Manager.GetSkillRaceClassInfo(pSkill->ID, getRace(), getClass()))
                    LearnDefaultSkill(rcInfo);
        }
    }

    // learn dependent spells
    SpellLearnSpellMapBounds spell_bounds = sSpellMgr->GetSpellLearnSpellMapBounds(spellId);

    for (SpellLearnSpellMap::const_iterator itr2 = spell_bounds.first; itr2 != spell_bounds.second; ++itr2)
    {
        if (!itr2->second.autoLearned)
        {
            if (!IsInWorld() || !itr2->second.active)       // at spells loading, no output, but allow save
                addSpell(itr2->second.spell, itr2->second.active, true, true, false);
            else                                            // at normal learning
                learnSpell(itr2->second.spell, true);
        }

        if (itr2->second.overridesSpell && itr2->second.active)
            AddOverrideSpell(itr2->second.overridesSpell, itr2->second.spell);
    }

    for (SkillLineAbilityMap::const_iterator _spell_idx = skill_bounds.first; _spell_idx != skill_bounds.second; ++_spell_idx)
        mSkillSpellCount[_spell_idx->second->SkillLine]++;

    if (!GetSession()->PlayerLoading())
    {
        // not ranked skills
        for (SkillLineAbilityMap::const_iterator _spell_idx = skill_bounds.first; _spell_idx != skill_bounds.second; ++_spell_idx)
        {
            UpdateAchievementCriteria(CRITERIA_TYPE_LEARN_SKILL_LINE, _spell_idx->second->SkillLine, mSkillSpellCount[_spell_idx->second->SkillLine], 0, NULL, this);
            UpdateAchievementCriteria(CRITERIA_TYPE_LEARN_SKILLLINE_SPELLS, _spell_idx->second->SkillLine, mSkillSpellCount[_spell_idx->second->SkillLine], 0, NULL, this);
        }
        UpdateAchievementCriteria(CRITERIA_TYPE_LEARN_SPELL, spellId);
    }

    if (sDB2Manager.GetMount(spellId))
        GetCollectionMgr()->AddMount(spellId, MOUNT_FLAG_NONE, false, !IsInWorld());

    // return true (for send learn packet) only if spell active (in case ranked spells) and not replace old spell
    return active && !disabled && !superceded_old;
}

void Player::AddTemporarySpell(uint32 spellId)
{
    // spell already added - do not do anything
    if (m_spells.contains(spellId))
        return;
    m_spells.emplace(spellId, PLAYERSPELL_TEMPORARY, true, false, false);
    HandleExcludeCasterSpellList(spellId, true);
    HandleCasterAuraStateSpellList(spellId, true);
}

void Player::RemoveTemporarySpell(uint32 spellId)
{
    PlayerSpellMap::guarded_ptr itr = m_spells.get(spellId);
    // spell already not in list - do not do anything
    if (!itr)
        return;
    // spell has other state than temporary - do not change it
    if (itr->second.state != PLAYERSPELL_TEMPORARY)
        return;
    m_spells.erase(spellId);
    HandleExcludeCasterSpellList(spellId, false);
    HandleCasterAuraStateSpellList(spellId, false);
}

bool Player::IsNeedCastPassiveSpellAtLearn(SpellInfo const* spellInfo) const
{
    // note: form passives activated with shapeshift spells be implemented by HandleShapeshiftBoosts instead of spell_learn_spell
    // talent dependent passives activated at form apply have proper stance data
    ShapeshiftForm form = GetShapeshiftForm();
    bool need_cast = (!spellInfo->Shapeshift.ShapeshiftMask || (form && (spellInfo->Shapeshift.ShapeshiftMask & (UI64LIT(1) << (form - 1)))) ||
        (!form && (spellInfo->HasAttribute(SPELL_ATTR2_NOT_NEED_SHAPESHIFT))));

    //Check CasterAuraStates
    return need_cast && (!spellInfo->AuraRestrictions.CasterAuraState || HasAuraState(AuraStateType(spellInfo->AuraRestrictions.CasterAuraState)));
}

void Player::learnSpell(uint32 spell_id, bool dependent, uint32 fromSkill, bool sendMessage)
{
    PlayerSpellMap::guarded_ptr itr = m_spells.get(spell_id);

    bool disabled = itr ? (itr->second.disabled) : false;
    bool active = disabled ? (itr->second.active) : true;

    itr.release();
    bool learning = addSpell(spell_id, active, true, dependent, false);

    // prevent duplicated entires in spell book, also not send if not in world (loading)
    // should send in any time for correct auto-action button setting.
    if (learning/* && IsInWorld()*/)
    {
        WorldPackets::Spells::LearnedSpells packet;
        packet.SpellID.push_back(spell_id);
        if (disabled || !active || !sendMessage)
            packet.SuppressMessaging = true;
        SendDirectMessage(packet.Write());

        sScriptMgr->OnPlayerSpellLearned(this, spell_id);
    }

    // learn all disabled higher ranks and required spells (recursive)
    if (disabled)
    {
        if (uint32 nextSpell = sSpellMgr->GetNextSpellInChain(spell_id))
        {
            PlayerSpellMap::guarded_ptr iter = m_spells.get(nextSpell);
            if (iter && iter->second.disabled)
                learnSpell(nextSpell, false, fromSkill);
        }

        for (auto const& pair : sSpellMgr->GetSpellsRequiringSpellBounds(spell_id))
        {
            PlayerSpellMap::guarded_ptr iter2 = m_spells.get(pair.second);
            if (iter2 && iter2->second.disabled)
                learnSpell(pair.second, false, fromSkill);
        }
    }

    if (const std::vector<SpellTalentLinked> *spell_triggered = sSpellMgr->GetSpelltalentLinked(spell_id))
    {
        for (std::vector<SpellTalentLinked>::const_iterator i = spell_triggered->begin(); i != spell_triggered->end(); ++i)
        {
            Unit* target = ToUnit();
            Unit* caster = ToUnit();

            if(i->caster == 1)
            {
                if (Pet* pet = GetPet())
                    caster = pet->ToUnit();
                else
                    continue;
            }
            if(i->target == 1)
            {
                if (Pet* pet = GetPet())
                    target = pet->ToUnit();
                else
                    continue;
            }

            switch (i->type)
            {
                case 0: //remove or add auras
                {
                    if (i->triger < 0)
                        target->RemoveAurasDueToSpell(-(i->triger));
                    else
                        caster->CastSpell(target, i->triger, true);
                    break;
                }
                case 1: //remove or add spell
                {
                    if (i->triger < 0)
                        removeSpell(-(i->triger));
                    else
                        learnSpell(i->triger, false);
                    break;
                }
                case 2: //remove pet
                {
                    RemovePet(NULL);
                    m_currentPetNumber = 0;
                    m_temporaryUnsummonedPetNumber = 0;
                    break;
                }
                case 3: //Check pet spec
                {
                    if (Pet* pet = GetPet())
                        if (pet->getPetType() == HUNTER_PET)
                            pet->CheckSpecialization();
                    break;
                }
                case 4: // Remove summons
                {
                    if (SpellInfo const* _spellInfo = sSpellMgr->GetSpellInfo(i->triger))
                    {
                        for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
                        {
                            if (_spellInfo->EffectMask < uint32(1 << i))
                                break;

                            if (_spellInfo->Effects[i]->Effect != SPELL_EFFECT_SUMMON)
                                continue;

                            RemoveAllMinionsByFilter(_spellInfo->Effects[i]->MiscValue);
                        }
                    }
                    break;
                }
                case 5: //remove my aura
                {
                    RemoveMyAurasDueToSpell(abs(i->triger));
                    break;
                }
            }
        }
    }

    UpdateMount();
}

void Player::removeSpell(uint32 spell_id, bool disabled, bool learn_low_rank, bool sendMessage)
{
    PlayerSpellMap::guarded_ptr itr = m_spells.get(spell_id);
    if (!itr)
        return;
    PlayerSpell* removeSpellPtr = &itr->second;
    itr.release();

    if (removeSpellPtr->state == PLAYERSPELL_REMOVED || (disabled && removeSpellPtr->disabled) || removeSpellPtr->state == PLAYERSPELL_TEMPORARY)
        return;

    // unlearn non talent higher ranks (recursive)
    if (uint32 nextSpell = sSpellMgr->GetNextSpellInChain(spell_id))
    {
        if (HasSpell(nextSpell))
            removeSpell(nextSpell, disabled, false);
    }

    //unlearn spells dependent from recently removed spells
    for (auto const& pair : sSpellMgr->GetSpellsRequiringSpellBounds(spell_id))
        removeSpell(pair.second, disabled);

    bool cur_active    = removeSpellPtr->active;
    bool cur_dependent = removeSpellPtr->dependent;

    if (disabled)
    {
        removeSpellPtr->disabled = disabled;
        if (removeSpellPtr->state != PLAYERSPELL_NEW)
            removeSpellPtr->state = PLAYERSPELL_CHANGED;
    }
    else
    {
        if (removeSpellPtr->state == PLAYERSPELL_NEW)
            m_spells.erase(spell_id);
        else
            removeSpellPtr->state = PLAYERSPELL_REMOVED;
    }

    RemoveAurasDueToSpell(spell_id);
    RemoveOwnedAura(spell_id);
    HandleExcludeCasterSpellList(spell_id, false);
    HandleCasterAuraStateSpellList(spell_id, false);

    // update free primary prof.points (if not overflow setting, can be in case GM use before .learn prof. learning)
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
    if (spellInfo && spellInfo->IsPrimaryProfessionFirstRank())
    {
        uint32 freeProfs = GetFreePrimaryProfessionPoints()+1;
        if (freeProfs <= sWorld->getIntConfig(CONFIG_MAX_PRIMARY_TRADE_SKILL))
            SetFreePrimaryProfessions(freeProfs);

        m_profSpells[0].erase(spell_id);
        m_profSpells[1].erase(spell_id);
    }

    // remove dependent skill
    SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(spell_id);
    if (spellLearnSkill)
    {
        uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(spell_id);
        if (!prev_spell)                                    // first rank, remove skill
            SetSkill(spellLearnSkill->skill);
        else
        {
            // search prev. skill setting by spell ranks chain
            SpellLearnSkillNode const* prevSkill = sSpellMgr->GetSpellLearnSkill(prev_spell);
            while (!prevSkill && prev_spell)
            {
                prev_spell = sSpellMgr->GetPrevSpellInChain(prev_spell);
                prevSkill = sSpellMgr->GetSpellLearnSkill(sSpellMgr->GetFirstSpellInChain(prev_spell));
            }

            if (!prevSkill)                                 // not found prev skill setting, remove skill
                SetSkill(spellLearnSkill->skill);
            else                                            // set to prev. skill setting values
            {
                uint32 skillValue = GetPureSkillValue(prevSkill->skill);
                uint32 maxSkillValue = GetPureMaxSkillValue(prevSkill->skill);

                if (skillValue > prevSkill->value)
                    skillValue = prevSkill->value;

                SetSkill(prevSkill->skill, prevSkill->step, skillValue, maxSkillValue);
            }
        }
    }

    // remove dependent spells
    SpellLearnSpellMapBounds spell_bounds = sSpellMgr->GetSpellLearnSpellMapBounds(spell_id);

    for (SpellLearnSpellMap::const_iterator itr2 = spell_bounds.first; itr2 != spell_bounds.second; ++itr2)
    {
        removeSpell(itr2->second.spell, disabled);
        if (itr2->second.overridesSpell)
            RemoveOverrideSpell(itr2->second.overridesSpell, itr2->second.spell);
    }

    SkillLineAbilityMapBounds skill_bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spell_id);
    for (SkillLineAbilityMap::const_iterator _spell_idx = skill_bounds.first; _spell_idx != skill_bounds.second; ++_spell_idx)
        mSkillSpellCount[_spell_idx->second->SkillLine]--;

    if (const std::vector<SpellTalentLinked> *spell_triggered = sSpellMgr->GetSpelltalentLinked(-(int32)spell_id))
    {
        for (std::vector<SpellTalentLinked>::const_iterator i = spell_triggered->begin(); i != spell_triggered->end(); ++i)
        {
            Unit* target = ToUnit();
            Unit* caster = ToUnit();

            if(i->caster == 1)
                if (Pet* pet = GetPet())
                    caster = pet->ToUnit();
            if(i->target == 1)
                if (Pet* pet = GetPet())
                    target = pet->ToUnit();

            switch (i->type)
            {
                case 0: //remove or add auras
                {
                    if (i->triger < 0)
                        target->RemoveAurasDueToSpell(-(i->triger));
                    else
                        caster->CastSpell(target, i->triger, true);
                    break;
                }
                case 1: //remove or add spell
                {
                    if (i->triger < 0)
                        removeSpell(-(i->triger));
                    else
                        learnSpell(i->triger, false);
                    break;
                }
                case 2: //remove pet
                {
                    RemovePet(NULL);
                    m_currentPetNumber = 0;
                    m_temporaryUnsummonedPetNumber = 0;
                    break;
                }
                case 3: //Check pet spec
                {
                    if (Pet* pet = GetPet())
                        if (pet->getPetType() == HUNTER_PET)
                            pet->CheckSpecialization();
                    break;
                }
                case 4: // Remove summons
                {
                    if (SpellInfo const* _spellInfo = sSpellMgr->GetSpellInfo(i->triger))
                    {
                        for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
                        {
                            if (_spellInfo->EffectMask < uint32(1 << i))
                                break;

                            if (_spellInfo->Effects[i]->Effect != SPELL_EFFECT_SUMMON)
                                continue;

                            RemoveAllMinionsByFilter(_spellInfo->Effects[i]->MiscValue);
                        }
                    }
                    break;
                }
                case 5: //remove my aura
                {
                    RemoveMyAurasDueToSpell(abs(i->triger));
                    break;
                }
            }
        }
    }

    // activate lesser rank in spellbook/action bar, and cast it if need
    bool prev_activate = false;

    if (uint32 prev_id = sSpellMgr->GetPrevSpellInChain(spell_id))
    {
        if (cur_active && spellInfo->IsRanked())
        {
            // need manually update dependence state (learn spell ignore like attempts)
            PlayerSpellMap::guarded_ptr prev_itr = m_spells.get(prev_id);
            if (prev_itr)
            {
                PlayerSpell* prevRemoveSpellPtr = &prev_itr->second;
                prev_itr.release();
                if (prevRemoveSpellPtr->dependent != cur_dependent)
                {
                    prevRemoveSpellPtr->dependent = cur_dependent;
                    if (prevRemoveSpellPtr->state != PLAYERSPELL_NEW)
                        prevRemoveSpellPtr->state = PLAYERSPELL_CHANGED;
                }

                // now re-learn if need re-activate
                if (cur_active && !prevRemoveSpellPtr->active && learn_low_rank)
                {
                    if (addSpell(prev_id, true, false, prevRemoveSpellPtr->dependent, prevRemoveSpellPtr->disabled))
                    {
                        // downgrade spell ranks in spellbook and action bar
                        WorldPackets::Spells::SupercededSpells supercededSpells;
                        supercededSpells.SpellID.emplace_back(prev_id);
                        supercededSpells.Superceded.emplace_back(spell_id);
                        SendDirectMessage(supercededSpells.Write());
                        prev_activate = true;
                    }
                }
            }
        }
    }

    if (spell_id == 46917 && m_canTitanGrip)
        SetCanTitanGrip(false);
    if (m_canDualWield && spellInfo)
    {
        if (spellInfo->IsPassive())
        {
            for (int i = 0; i < MAX_SPELL_EFFECTS; i++)
            {
                if (spellInfo->EffectMask < uint32(1 << i))
                    break;

                if (spellInfo->Effects[i]->Effect == SPELL_EFFECT_DUAL_WIELD)
                {
                    SetCanDualWield(false);
                    break;
                }
            }
        }
    }

    if (sWorld->getBoolConfig(CONFIG_OFFHAND_CHECK_AT_SPELL_UNLEARN))
        AutoUnequipOffhandIfNeed();

    // remove from spell book if not replaced by lesser rank
    if (!prev_activate)
    {
        WorldPackets::Spells::UnlearnedSpells unlearnedSpells;
        unlearnedSpells.SpellID.push_back(spell_id);
        if (!sendMessage)
            unlearnedSpells.SuppressMessaging = true;
        SendDirectMessage(unlearnedSpells.Write());
    }
}

void Player::RemoveSpellCooldown(uint32 spell_id, bool update /* = false */)
{
    int32 delay = 0;
    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
        if (Spell* spell = GetCurrentSpell(CurrentSpellTypes(i)))
            if (spell->m_spellInfo->Id == spell_id && spell->GetCastTime() > 0)
                delay = (spell->GetStartCastTime() + spell->GetCastTime()) - getMSTime();

    if (delay > 0)
    {
        AddDelayedEvent(delay + 50, [this, spell_id, update]() -> void
        {
            m_spellCooldowns.erase(spell_id);

            if (update)
                SendClearCooldown(spell_id, this);
            // restore spell charges
            ModSpellCharge(spell_id, 1); // Restore only one charges
        });
    }
    else
    {
        m_spellCooldowns.erase(spell_id);

        if (update)
            SendClearCooldown(spell_id, this);
        // restore spell charges
        ModSpellCharge(spell_id, 1); // Restore only one charges
    }
}

// I am not sure which one is more efficient
void Player::RemoveCategoryCooldown(uint32 category)
{
    DB2Manager::SpellCategoryContainer::const_iterator cat = sDB2Manager._spellCategory.find(category);
    if (cat != sDB2Manager._spellCategory.end())
        for (DB2Manager::SpellCategorySet::const_iterator spellID = cat->second.begin(); spellID != cat->second.end(); ++spellID)
            RemoveSpellCooldown(*spellID, true);
}

void Player::RemoveSpellCategoryCooldown(uint32 cat, bool update /* = false */)
{
    auto const& ctSet = sDB2Manager.GetSpellCategory(cat);
    for (SpellCooldowns::iterator i = m_spellCooldowns.begin(); i != m_spellCooldowns.end();)
    {
       if (ctSet->find(i->first) != ctSet->end())
            RemoveSpellCooldown((i++)->first, update);
        else
            ++i;
    }
}

// I am not sure which one is more efficient
void Player::RemoveCategoryCooldownBySpell(uint32 spell_id, bool update /* = false */)
{
    if(SpellInfo const* info = sSpellMgr->GetSpellInfo(spell_id))
    {
        if (info->Categories.Category)
        {
            DB2Manager::SpellCategoryContainer::const_iterator cat = sDB2Manager._spellCategory.find(info->Categories.Category);
            if (cat != sDB2Manager._spellCategory.end())
                for (DB2Manager::SpellCategorySet::const_iterator spellID = cat->second.begin(); spellID != cat->second.end(); ++spellID)
                    RemoveSpellCooldown(*spellID, update);
        }
    }
}

void Player::RemoveArenaSpellCooldowns(bool removeActivePetCooldowns)
{
    // remove cooldowns on spells that have <= 10 min CD

    SpellCooldowns::iterator itr, next;
    for (itr = m_spellCooldowns.begin(); itr != m_spellCooldowns.end(); itr = next)
    {
        next = itr;
        ++next;
        SpellInfo const* entry = sSpellMgr->GetSpellInfo(itr->first);
        // check if spellentry is present and if the cooldown is less or equal to 10 min
        if (entry &&
            entry->Cooldowns.RecoveryTime <= 10 * MINUTE * IN_MILLISECONDS &&
            entry->Cooldowns.CategoryRecoveryTime <= 10 * MINUTE * IN_MILLISECONDS &&
            (entry->Category.Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_DAILY_RESET) == 0)
        {
            // remove & notify
            RemoveSpellCooldown(itr->first, true);
        }
    }

    RestoreSpellCategoryCharges();

    // pet cooldowns
    if (removeActivePetCooldowns)
        if (Pet* pet = GetPet())
        {
            // notify player
            for (CreatureSpellCooldowns::iterator itr2 = pet->m_CreatureSpellCooldowns.begin(); itr2 != pet->m_CreatureSpellCooldowns.end(); ++itr2)
                SendClearCooldown(itr2->first, pet);

            // actually clear cooldowns
            pet->m_CreatureSpellCooldowns.clear();
        }
}

void Player::RemoveAllSpellCooldown()
{
    if (!m_spellCooldowns.empty())
    {
        for (SpellCooldowns::iterator itr = m_spellCooldowns.begin(); itr != m_spellCooldowns.end(); ++itr)
            SendClearCooldown(itr->first, this);

        m_spellCooldowns.clear();
    }

    RestoreSpellCategoryCharges();
}

void Player::_LoadSpellCooldowns(PreparedQueryResult result)
{
    // some cooldowns can be already set at aura loading...

    //QueryResult* result = CharacterDatabase.PQuery("SELECT spell, item, time FROM character_spell_cooldown WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        time_t curTime = time(NULL);

        do
        {
            Field* fields = result->Fetch();
            uint32 spell_id = fields[0].GetUInt32();
            uint32 item_id  = fields[1].GetUInt32();
            time_t db_time  = time_t(fields[2].GetUInt32());

            if (!sSpellMgr->GetSpellInfo(spell_id))
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER_LOADING, "Player %u has unknown spell %u in `character_spell_cooldown`, skipping.", GetGUIDLow(), spell_id);
                continue;
            }

            // skip outdated cooldown
            if (db_time <= curTime)
                continue;

            AddSpellCooldown(spell_id, item_id, (double)db_time);

            TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Player (GUID: %u) spell %u, item %u cooldown loaded (%u secs).", GetGUIDLow(), spell_id, item_id, uint32(db_time-curTime));
        }
        while (result->NextRow());
    }
}

void Player::_SaveSpellCooldowns(SQLTransaction& trans)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_COOLDOWN);
    stmt->setUInt64(0, GetGUIDLow());
    trans->Append(stmt);

    time_t curTime = time(NULL);
    time_t infTime = curTime + infinityCooldownDelayCheck;

    bool first_round = true;
    std::ostringstream ss;

    // remove outdated and save active
    for (SpellCooldowns::iterator itr = m_spellCooldowns.begin(); itr != m_spellCooldowns.end();)
    {
        if (itr->second.end <= curTime)
            m_spellCooldowns.erase(itr++);
        else if (itr->second.end <= infTime)                 // not save locked cooldowns, it will be reset or set at reload
        {
            if (first_round)
            {
                ss << "INSERT INTO character_spell_cooldown (guid, spell, item, time) VALUES ";
                first_round = false;
            }
            // next new/changed record prefix
            else
                ss << ',';
            ss << '(' << GetGUIDLow() << ',' << itr->first << ',' << itr->second.itemid << ',' << uint64(itr->second.end) << ')';
            ++itr;
        }
        else
            ++itr;
    }
    // if something changed execute
    if (!first_round)
        trans->Append(ss.str().c_str());
}

bool Player::HasChargesForSpell(SpellInfo const* spellInfo) const
{
    SpellChargeDataMap::const_iterator itr = m_spellChargeData.find(spellInfo->Categories.ChargeCategory);
    return itr == m_spellChargeData.end() || itr->second.charges > 0;
}

uint8 Player::GetMaxSpellCategoryCharges(SpellCategoryEntry const* categoryEntry) const
{
    int count = categoryEntry->MaxCharges;
    count += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_MAX_CHARGES, categoryEntry->ID);
    return std::max(0, count);
}

uint32 Player::GetSpellCategoryChargesTimer(SpellCategoryEntry const* categoryEntry, SpellInfo const* spellInfo, bool sendSpeedRate/* = false*/) const
{
    uint32 regenTime = categoryEntry->ChargeRecoveryTime;

    regenTime += GetTotalAuraModifierByMiscValue(SPELL_AURA_CHARGE_RECOVERY_MOD, categoryEntry->ID);
    regenTime += GetTotalAuraModifier(SPELL_AURA_MOD_COOLDOWN) * IN_MILLISECONDS;
    regenTime *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_CHARGE_RECOVERY_MULTIPLIER, categoryEntry->ID);
    regenTime *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_CHARGE_RECOVERY_AFFECTED_BY_HASTE_REGEN, categoryEntry->ID);
    regenTime *= GetFloatValue(UNIT_FIELD_MOD_TIME_RATE);
    if (spellInfo)
        regenTime *= const_cast<Player*>(this)->SpellCooldownModByRate(spellInfo, sendSpeedRate);

    return regenTime;
}

uint8 Player::GetMaxSpellCategoryCharges(uint32 category) const
{
    SpellCategoryEntry const* categoryEntry = sSpellCategoryStore.LookupEntry(category);
    return categoryEntry ? GetMaxSpellCategoryCharges(categoryEntry) : 0;
}

void Player::TakeSpellCharge(SpellInfo const* spellInfo)
{
    if (!spellInfo->Categories.ChargeCategory)
        return;

    int32 _delay = 0;
    SpellChargeDataMap::iterator itr = m_spellChargeData.find(spellInfo->Categories.ChargeCategory);
    if (itr == m_spellChargeData.end())
    {
        SpellCategoryEntry const* categoryEntry = sSpellCategoryStore.LookupEntry(spellInfo->Categories.ChargeCategory);
        if (!categoryEntry)
            return;

        int32 maxCharges = GetMaxSpellCategoryCharges(categoryEntry);
        if (!maxCharges)
            return;

        uint32 chargeRegenTime = GetSpellCategoryChargesTimer(categoryEntry, spellInfo, true);
        if (chargeRegenTime == 0) // If no CD, not add to recovery
            return;

        SpellChargeData& data = m_spellChargeData[spellInfo->Categories.ChargeCategory];
        data.categoryEntry = categoryEntry;
        data.chargeRegenTime = chargeRegenTime;
        data.charges = data.maxCharges = maxCharges;
        data.timer = 0;
        data.spellInfo = spellInfo;

        _delay = chargeRegenTime;
        --data.charges;
    }
    else
    {
        SpellCategoryEntry const* categoryEntry = sSpellCategoryStore.LookupEntry(spellInfo->Categories.ChargeCategory);
        if (!categoryEntry)
            return;

        SpellChargeData& data = itr->second;
        if (!data.charges)
            return;

        data.chargeRegenTime = GetSpellCategoryChargesTimer(categoryEntry, spellInfo, true);
        data.maxCharges = GetMaxSpellCategoryCharges(categoryEntry);

        _delay = data.chargeRegenTime;
        --data.charges;
    }

    switch (spellInfo->Id)
    {
        case 2050:
            if (HasAura(238136)) // Cosmic Ripple
            {
                AddDelayedEvent(_delay, [this]() -> void
                {
                    if (this)
                        CastSpell(this, 243241, true);
                });
            }
            break;
    }
}

void Player::UpdateSpellCharges(uint32 diff)
{
    for (SpellChargeDataMap::iterator itr = m_spellChargeData.begin(); itr != m_spellChargeData.end(); ++itr)
    {
        SpellChargeData& data = itr->second;
        if (data.charges == data.maxCharges)
            continue;

        uint32 chargeRegenTime = data.chargeRegenTime;
        data.timer += diff * data.speed;

        while (data.timer >= chargeRegenTime && data.charges < data.maxCharges)
        {
            data.chargeRegenTime = GetSpellCategoryChargesTimer(data.categoryEntry, data.spellInfo);
            data.timer -= data.chargeRegenTime;
            ++data.charges;
            if (data.charges == data.maxCharges)
                data.timer = 0;
        }
    }
}

void Player::RecalculateSpellCategoryCharges(uint32 category)
{
    SpellChargeDataMap::iterator itr = m_spellChargeData.find(category);
    if (itr == m_spellChargeData.end())
        return;

    SpellChargeData& data = itr->second;
    uint8 maxCharges = GetMaxSpellCategoryCharges(data.categoryEntry);
    if (!maxCharges)
    {
        m_spellChargeData.erase(itr);
        return;
    }

    data.maxCharges = maxCharges;
    if (data.charges > maxCharges)
    {
        data.charges = maxCharges;
        data.timer = 0;
    }

    SendSpellChargeData();
}

void Player::RecalculateSpellCategoryRegenTime(uint32 category)
{
    SpellChargeDataMap::iterator itr = m_spellChargeData.find(category);
    if (itr == m_spellChargeData.end())
        return;

    SpellChargeData& data = itr->second;
    // data.chargeRegenTime = GetSpellCategoryChargesTimer(data.categoryEntry);
    uint8 maxCharges = GetMaxSpellCategoryCharges(data.categoryEntry);
    if (!maxCharges)
    {
        m_spellChargeData.erase(itr);
        return;
    }

    // if (data.timer > data.chargeRegenTime)
        // data.timer = data.chargeRegenTime;

    if (!data.timer)
        data.charges = maxCharges;
}

void Player::RestoreSpellCategoryCharges(uint32 categoryId)
{
    for (SpellChargeDataMap::iterator itr = m_spellChargeData.begin(); itr != m_spellChargeData.end(); ++itr)
    {
        SpellChargeData& data = itr->second;

        if (categoryId && data.categoryEntry->ID != categoryId)
            continue;

        data.charges = data.maxCharges;
        data.timer = 0;
    }

    SendSpellChargeData();
}

void Player::ModSpellCharge(uint32 SpellID, int32 num)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(SpellID);
    if (!spellInfo || !num)
        return;

    SpellChargeDataMap::iterator itr = m_spellChargeData.find(spellInfo->Categories.ChargeCategory);
    if (itr != m_spellChargeData.end())
    {
        SpellChargeData& data = itr->second;
        data.charges += num;

        if (data.charges < 0)
            data.charges = 0;

        if (data.maxCharges <= data.charges)
        {
            data.timer = 0;
            data.charges = data.maxCharges;
        }

        WorldPackets::Spells::SetSpellCharges setcharges;
        setcharges.Category = spellInfo->Categories.ChargeCategory;
        setcharges.NextRecoveryTime = data.chargeRegenTime - data.timer;
        setcharges.ConsumedCharges = data.maxCharges - data.charges;
        SendDirectMessage(setcharges.Write());
    }
    else if (num < 0)
    {
        SpellCategoryEntry const* categoryEntry = sSpellCategoryStore.LookupEntry(spellInfo->Categories.ChargeCategory);
        if (!categoryEntry)
            return;

        SpellChargeData& data = m_spellChargeData[spellInfo->Categories.ChargeCategory];
        data.categoryEntry = categoryEntry;
        data.chargeRegenTime = GetSpellCategoryChargesTimer(categoryEntry, spellInfo);
        data.charges = data.maxCharges = GetMaxSpellCategoryCharges(categoryEntry);
        data.timer = 0;

        data.charges += num;

        WorldPackets::Spells::SetSpellCharges setcharges;
        setcharges.Category = spellInfo->Categories.ChargeCategory;
        setcharges.NextRecoveryTime = data.chargeRegenTime - data.timer;
        setcharges.ConsumedCharges = data.maxCharges - data.charges;
        SendDirectMessage(setcharges.Write());
    }
}

void Player::ModSpellChargeCooldown(uint32 SpellID, int32 delta)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(SpellID);
    if (!spellInfo || !delta)
        return;

    SpellChargeDataMap::iterator itr = m_spellChargeData.find(spellInfo->Categories.ChargeCategory);
    if (itr != m_spellChargeData.end())
    {
        SpellChargeData& data = itr->second;

        data.timer += delta;

        if (data.timer >= data.chargeRegenTime && data.charges < data.maxCharges)
        {
            data.timer -= data.chargeRegenTime;
            ++data.charges;
        }

        if (data.charges < 0)
            data.charges = 0;

        if (data.maxCharges <= data.charges)
        {
            data.timer = 0;
            data.charges = data.maxCharges;
        }

        WorldPackets::Spells::SetSpellCharges setcharges;
        setcharges.Category = spellInfo->Categories.ChargeCategory;
        setcharges.NextRecoveryTime = data.chargeRegenTime - data.timer;
        setcharges.ConsumedCharges = data.maxCharges - data.charges;
        SendDirectMessage(setcharges.Write());
    }
}

uint8 Player::GetChargesForSpell(SpellInfo const* spellInfo) const
{
    SpellChargeDataMap::const_iterator itr = m_spellChargeData.find(spellInfo->Categories.ChargeCategory);
    if (itr == m_spellChargeData.end())
    {
        if (SpellCategoryEntry const* categoryEntry = sSpellCategoryStore.LookupEntry(spellInfo->Categories.ChargeCategory))
            return categoryEntry->MaxCharges;
    }
    else
        return itr->second.charges;

    return 0;
}

uint32 Player::GetChargesCooldown(uint32 SpellID) const
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(SpellID);
    if (!spellInfo)
        return 0;

    SpellChargeDataMap::const_iterator itr = m_spellChargeData.find(spellInfo->Categories.ChargeCategory);
    if (itr != m_spellChargeData.end())
        return itr->second.chargeRegenTime - itr->second.timer;

    return 0;
}

bool Player::ResetTalents(bool no_cost)
{
    sScriptMgr->OnPlayerTalentsReset(this, no_cost);

    // not need after this call
    if (HasAtLoginFlag(AT_LOGIN_RESET_TALENTS))
        RemoveAtLoginFlag(AT_LOGIN_RESET_TALENTS, true);

    uint32 cost = 0;

    if (!no_cost && !sWorld->getBoolConfig(CONFIG_NO_RESET_TALENT_COST))
    {
        if (!HasEnoughMoney(uint64(cost)))
        {
            SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY);
            return false;
        }
    }

    RemovePet(NULL);

    for (TalentEntry const* talentInfo : sTalentStore)
        if (talentInfo->ClassID == getClass() && talentInfo->SpellID)
            RemoveTalent(talentInfo, true, true, true);

    RemoveAllPvPTalent();

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    _SaveTalents(trans);
    _SaveSpells(trans);
    CharacterDatabase.CommitTransaction(trans);

    if (!no_cost)
    {
        ModifyMoney(-static_cast<int64>(cost));
        UpdateAchievementCriteria(CRITERIA_TYPE_GOLD_SPENT_FOR_TALENTS, cost);
        UpdateAchievementCriteria(CRITERIA_TYPE_NUMBER_OF_TALENT_RESETS, 1);
    }

    return true;
}

uint32 Player::GetDefaultSpecId() const 
{
    return ASSERT_NOTNULL(sDB2Manager.GetDefaultChrSpecializationForClass(getClass()))->ID;
}

uint32 Player::GetSpecializationRole() const
{
    if (ChrSpecializationEntry const* chrSpec = sChrSpecializationStore.LookupEntry(GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID)))
        return chrSpec->Role;

    return ROLES_DEFAULT;
}

RoleForSoloQ Player::GetRoleForSoloQ() const
{
    switch(GetSpecializationRole())
    {
        case ROLES_DEFAULT:
            return SOLOQ_ROLE_UNKWN;
        case ROLES_HEALER:
            return SOLOQ_ROLE_HEALER;
        case ROLES_DPS:
        {
            switch(getClass())
            {
                case CLASS_WARRIOR:
                case CLASS_PALADIN:
                case CLASS_ROGUE:
                case CLASS_DEATH_KNIGHT:
                case CLASS_MONK:
                case CLASS_DEMON_HUNTER:
                    return SOLOQ_ROLE_MELEE;
                case CLASS_DRUID:
                case CLASS_SHAMAN:
                {
                    switch(GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID))
                    {
                        case SPEC_DRUID_CAT:
                        case SPEC_SHAMAN_ENHANCEMENT:
                            return SOLOQ_ROLE_MELEE;
                        case SPEC_DRUID_BALANCE:
                        case SPEC_SHAMAN_ELEMENTAL:
                            return SOLOQ_ROLE_RANGE;
                        default:
                            return SOLOQ_ROLE_HEALER;
                    }
                }
                case CLASS_HUNTER:
                case CLASS_PRIEST:
                case CLASS_MAGE:
                case CLASS_WARLOCK:
                    return SOLOQ_ROLE_RANGE;
            }
        }
        case ROLES_TANK:
            return SOLOQ_ROLE_UNKWN;
    }
    
    return SOLOQ_ROLE_UNKWN;
}

lfg::LfgRoles Player::GetSpecializationRoleMaskForGroup() const
{
    uint8 roleMask = lfg::LfgRoles::PLAYER_ROLE_NONE;
    if (auto const& group = GetGroup())
        if (group->GetLeaderGUID() == GetGUID())
            roleMask |= lfg::LfgRoles::PLAYER_ROLE_LEADER;

    auto roleID = GetSpecializationRole();
    if (roleID == ROLES_DEFAULT)
        return static_cast<lfg::LfgRoles>(roleMask);

    switch (roleID)
    {
        case ROLES_HEALER:
            roleMask |= lfg::LfgRoles::PLAYER_ROLE_HEALER;
            break;
        case ROLES_DPS:
            roleMask |= lfg::LfgRoles::PLAYER_ROLE_DAMAGE;
            break;
        case ROLES_TANK:
            roleMask |= lfg::LfgRoles::PLAYER_ROLE_TANK;
            break;
        default:
            return static_cast<lfg::LfgRoles>(roleMask);
    }

    return static_cast<lfg::LfgRoles>(roleMask);
}

bool Player::isInTankSpec() const
{
    return GetSpecializationRole() == ROLES_TANK;
}

bool Player::IsRangedDamageDealer(bool allowHeal /*= true*/) const
{
    switch (getClass())
    {
        case CLASS_MAGE:
        case CLASS_WARLOCK:
            return true;
        default:
            break;
    }

    switch (GetSpecializationId())
    {
        case SPEC_DRUID_BALANCE:
        case SPEC_PRIEST_SHADOW:
        case SPEC_PRIEST_DISCIPLINE:
        case SPEC_SHAMAN_ELEMENTAL:
        case SPEC_SHAMAN_RESTORATION:
        case SPEC_HUNTER_BEASTMASTER:
        case SPEC_HUNTER_MARKSMAN:
            return true;
        case SPEC_DRUID_RESTORATION:
        case SPEC_MONK_MISTWEAVER:
        case SPEC_PRIEST_HOLY:
        case SPEC_PALADIN_HOLY:
            return allowHeal;
        default:
            break;
    }

    return false;
}

bool Player::IsMeleeDamageDealer(bool allowTank /*= false*/) const
{
    if (getClass() == CLASS_ROGUE)
        return true;

    switch (GetSpecializationId())
    {
        case SPEC_DRUID_CAT:
        case SPEC_DRUID_RESTORATION:
        case SPEC_SHAMAN_ENHANCEMENT:
        case SPEC_MONK_WINDWALKER:
        case SPEC_MONK_MISTWEAVER:
        case SPEC_WARRIOR_ARMS:
        case SPEC_WARRIOR_FURY:
        case SPEC_DK_UNHOLY:
        case SPEC_DK_FROST:
        case SPEC_PALADIN_RETRIBUTION:
        case SPEC_PALADIN_HOLY:
        case SPEC_DEMON_HUNER_HAVOC:
        case SPEC_HUNTER_SURVIVAL:
            return true;
        case SPEC_DRUID_BEAR:
        case SPEC_MONK_BREWMASTER:
        case SPEC_WARRIOR_PROTECTION:
        case SPEC_DK_BLOOD:
        case SPEC_PALADIN_PROTECTION:
        case SPEC_DEMON_HUNER_VENGEANCE:
            return allowTank;
        default:
            break;
    }

    return false;
}

uint16 Player::GetSpecType()
{
    switch (GetSpecializationId())
    {
        case SPEC_DRUID_CAT:
        case SPEC_HUNTER_BEASTMASTER:
        case SPEC_HUNTER_MARKSMAN:
        case SPEC_HUNTER_SURVIVAL:
        case SPEC_ROGUE_ASSASSINATION:
        case SPEC_ROGUE_COMBAT:
        case SPEC_ROGUE_SUBTLETY:
        case SPEC_SHAMAN_ENHANCEMENT:
        case SPEC_MONK_WINDWALKER:
        case SPEC_DEMON_HUNER_HAVOC:
            return DPS_AGILITY;
        case SPEC_MAGE_ARCANE:
        case SPEC_MAGE_FIRE:
        case SPEC_MAGE_FROST:
        case SPEC_DRUID_BALANCE:
        case SPEC_PRIEST_SHADOW:
        case SPEC_SHAMAN_ELEMENTAL:
        case SPEC_WARLOCK_AFFLICTION:
        case SPEC_WARLOCK_DEMONOLOGY:
        case SPEC_WARLOCK_DESTRUCTION:
            return DPS_INTELLECT;
        case SPEC_PALADIN_RETRIBUTION:
        case SPEC_WARRIOR_ARMS:
        case SPEC_WARRIOR_FURY:
        case SPEC_DK_FROST:
        case SPEC_DK_UNHOLY:
            return DPS_STRENGH;
        case SPEC_PALADIN_HOLY:
        case SPEC_DRUID_RESTORATION:
        case SPEC_PRIEST_DISCIPLINE:
        case SPEC_PRIEST_HOLY:
        case SPEC_SHAMAN_RESTORATION:
        case SPEC_MONK_MISTWEAVER:
            return HEALER_INTELLECT;
        case SPEC_PALADIN_PROTECTION:
        case SPEC_WARRIOR_PROTECTION:
        case SPEC_DK_BLOOD:
            return TANK_STRENGH;
        case SPEC_DEMON_HUNER_VENGEANCE:
        case SPEC_MONK_BREWMASTER:
        case SPEC_DRUID_BEAR:
            return TANK_AGILITY;
    }
    return SPEC_TYPE_DEFAULT;
}

uint8 Player::ConvertLFGRoleToRole(uint8 role)
{
    if (role & lfg::LfgRoles::PLAYER_ROLE_TANK)
        return ROLES_TANK;
    if (role & lfg::LfgRoles::PLAYER_ROLE_HEALER)
        return ROLES_HEALER;
    if (role & lfg::LfgRoles::PLAYER_ROLE_DAMAGE)
        return ROLES_DPS;
    return ROLES_DEFAULT;
}

Mail* Player::GetMail(uint32 id)
{
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
        if ((*itr)->messageID == id)
            return (*itr);

    return NULL;
}

void Player::BuildCreateUpdateBlockForPlayer(UpdateData* data, Player* target) const
{
    if (target == this)
    {
        for (uint8 i = EQUIPMENT_SLOT_START; i < BUYBACK_SLOT_END; ++i)
            if (m_items[i])
                m_items[i]->BuildCreateUpdateBlockForPlayer(data, target);

        for (uint8 i = REAGENT_SLOT_START; i < REAGENT_SLOT_END; ++i)
            if (m_items[i])
                m_items[i]->BuildCreateUpdateBlockForPlayer(data, target);

        for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
            if (m_items[i])
                m_items[i]->BuildCreateUpdateBlockForPlayer(data, target);
    }

    Unit::BuildCreateUpdateBlockForPlayer(data, target);
}

void Player::DestroyForPlayer(Player* target) const
{
    Unit::DestroyForPlayer(target);

    if (target == this)
    {
        for (uint8 i = EQUIPMENT_SLOT_START; i < BUYBACK_SLOT_END; ++i)
            if (m_items[i])
                m_items[i]->DestroyForPlayer(target);

        for (uint8 i = REAGENT_SLOT_START; i < REAGENT_SLOT_END; ++i)
            if (m_items[i])
                m_items[i]->DestroyForPlayer(target);

        for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
            if (m_items[i])
                m_items[i]->DestroyForPlayer(target);
    }
}

bool Player::HasSpell(uint32 spell)
{
    if (!m_spells.contains(spell))
        return false;

    PlayerSpellMap::guarded_ptr itr = m_spells.get(spell);
    if (!itr)
        return false;

    PlayerSpell* spellPtr = &itr->second;
    itr.release();

    return (spellPtr && spellPtr->state != PLAYERSPELL_REMOVED && !spellPtr->disabled);
}

bool Player::HasTalent(uint32 spell, uint8 index) const
{
    PlayerTalentMap::const_iterator itr = GetTalentMap(index)->find(spell);
    return (itr != GetTalentMap(index)->end() && itr->second != PLAYERSPELL_REMOVED);
}

bool Player::HasPvPTalent(uint32 spellID) const
{
    for (auto const& v : *GetPvPTalentMap(GetActiveTalentGroup()))
        if (v.second != PLAYERSPELL_REMOVED && v.first == spellID)
            return true;

    return false;
}

bool Player::HasActiveSpell(uint32 spell)
{
    if (GetCollectionMgr()->HasMount(spell))
        return true;

    if (!m_spells.contains(spell))
        return false;

    PlayerSpellMap::guarded_ptr itr = m_spells.get(spell);
    if (!itr)
        return false;

    PlayerSpell* spellPtr = &itr->second;
    itr.release();

    return (spellPtr && spellPtr->state != PLAYERSPELL_REMOVED && spellPtr->active && !spellPtr->disabled);
}

TrainerSpellState Player::GetTrainerSpellState(TrainerSpell const* trainer_spell) const
{
    if (!trainer_spell)
        return TRAINER_SPELL_RED;

    bool hasSpell = true;
    for (uint8 i = 0; i < MAX_TRAINERSPELL_ABILITY_REQS; ++i)
    {
        if (!trainer_spell->learnedSpell[i])
            continue;

        if (!const_cast<Player*>(this)->HasSpell(trainer_spell->learnedSpell[i]))
        {
            hasSpell = false;
            break;
        }
    }
    // known spell
    if (hasSpell)
        return TRAINER_SPELL_GRAY;

    // check skill requirement
    if (trainer_spell->reqSkill && const_cast<Player*>(this)->GetBaseSkillValue(trainer_spell->reqSkill) < trainer_spell->reqSkillValue)
        return TRAINER_SPELL_RED;

    // check level requirement
    if (getLevel() < trainer_spell->reqLevel)
        return TRAINER_SPELL_RED;

    for (uint8 i = 0; i < MAX_TRAINERSPELL_ABILITY_REQS; ++i)
    {
        if (!trainer_spell->learnedSpell[i])
            continue;

        // check race/class requirement
        if (!IsSpellFitByClassAndRace(trainer_spell->learnedSpell[i]))
            return TRAINER_SPELL_RED;

        if (uint32 prevSpell = sSpellMgr->GetPrevSpellInChain(trainer_spell->learnedSpell[i]))
        {
            // check prev.rank requirement
            if (prevSpell && !const_cast<Player*>(this)->HasSpell(prevSpell))
                return TRAINER_SPELL_RED;
        }

        for (auto const& requirePair : sSpellMgr->GetSpellsRequiredForSpellBounds(trainer_spell->learnedSpell[i]))
            if (!const_cast<Player*>(this)->HasSpell(requirePair.second)) // check additional spell requirement
                return TRAINER_SPELL_RED;
    }

    // check primary prof. limit
    // first rank of primary profession spell when there are no proffesions avalible is disabled
    for (uint8 i = 0; i < MAX_TRAINERSPELL_ABILITY_REQS; ++i)
    {
        if (!trainer_spell->learnedSpell[i])
            continue;
        SpellInfo const* learnedSpellInfo = sSpellMgr->GetSpellInfo(trainer_spell->learnedSpell[i]);
        if (learnedSpellInfo && learnedSpellInfo->IsPrimaryProfessionFirstRank() && (GetFreePrimaryProfessionPoints() == 0))
            return TRAINER_SPELL_GREEN_DISABLED;
    }

    return TRAINER_SPELL_GREEN;
}

/**
 * Deletes a character from the database
 *
 * The way, how the characters will be deleted is decided based on the config option.
 *
 * @see Player::DeleteOldCharacters
 *
 * @param playerguid       the low-GUID from the player which should be deleted
 * @param accountId        the account id from the player
 * @param updateRealmChars when this flag is set, the amount of characters on that realm will be updated in the realmlist
 * @param deleteFinally    if this flag is set, the config option will be ignored and the character will be permanently removed from the database
 */
void Player::DeleteFromDB(ObjectGuid playerguid, uint32 accountId, bool updateRealmChars, bool deleteFinally)
{
    // for not existed account avoid update realm
    if (accountId == 0)
        updateRealmChars = false;

    uint32 charDelete_method = sWorld->getIntConfig(CONFIG_CHARDELETE_METHOD);
    uint32 charDelete_minLvl = sWorld->getIntConfig(CONFIG_CHARDELETE_MIN_LEVEL);

    // if we want to finally delete the character or the character does not meet the level requirement,
    // we set it to mode CHAR_DELETE_REMOVE
    if (deleteFinally || Player::GetLevelFromDB(playerguid) < charDelete_minLvl)
        charDelete_method = CHAR_DELETE_REMOVE;

    ObjectGuid::LowType guid = playerguid.GetCounter();

    // convert corpse to bones if exist (to prevent exiting Corpse in World without DB entry)
    // bones will be deleted by corpse/bones deleting thread shortly
    sObjectAccessor->ConvertCorpseForPlayer(playerguid);

    const CharacterInfo* nameData = sWorld->GetCharacterInfo(playerguid);

    if (nameData && nameData->GuildId)
        if (Guild* guild = sGuildMgr->GetGuildById(nameData->GuildId))
            guild->DeleteMember(playerguid);

    // the player was uninvited already on logout so just remove from group
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GROUP_MEMBER);
    stmt->setUInt64(0, guid);
    PreparedQueryResult resultGroup = CharacterDatabase.Query(stmt);

    if (resultGroup)
        if (Group* group = sGroupMgr->GetGroupByDbStoreId((*resultGroup)[0].GetUInt32()))
            RemoveFromGroup(group, playerguid);

    RemovePetitionsAndSigns(playerguid);

    switch (charDelete_method)
    {
        // Completely remove from the database
        case CHAR_DELETE_REMOVE:
        {
            SQLTransaction trans = CharacterDatabase.BeginTransaction();

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_COD_ITEM_MAIL);
            stmt->setUInt64(0, guid);
            PreparedQueryResult resultMail = CharacterDatabase.Query(stmt);

            if (resultMail)
            {
                do
                {
                    Field* mailFields = resultMail->Fetch();

                    uint32 mail_id       = mailFields[0].GetUInt32();
                    uint8 mailType       = mailFields[1].GetUInt8();
                    uint16 mailTemplateId= mailFields[2].GetUInt16();
                    ObjectGuid::LowType sender        = mailFields[3].GetUInt64();
                    std::string subject  = mailFields[4].GetString();
                    std::string body     = mailFields[5].GetString();
                    uint64 money         = mailFields[6].GetUInt64();
                    bool has_items       = mailFields[7].GetBool();

                    // We can return mail now
                    // So firstly delete the old one
                    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
                    stmt->setUInt32(0, mail_id);
                    trans->Append(stmt);

                    // Mail is not from player
                    if (mailType != MAIL_NORMAL)
                    {
                        if (has_items)
                        {
                            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
                            stmt->setUInt32(0, mail_id);
                            trans->Append(stmt);
                        }
                        continue;
                    }

                    MailDraft draft(subject, body);
                    if (mailTemplateId)
                        draft = MailDraft(mailTemplateId, false);    // items are already included

                    if (has_items)
                    {
                        // Data needs to be at first place for Item::LoadFromDB
                        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAILITEMS);
                        stmt->setUInt32(0, mail_id);
                        if (PreparedQueryResult resultItems = CharacterDatabase.Query(stmt))
                        {
                            do
                            {
                                Field* itemFields = resultItems->Fetch();
                                ObjectGuid::LowType item_guidlow = itemFields[0].GetUInt64();
                                uint32 item_template = itemFields[1].GetUInt32();

                                ItemTemplate const* itemProto = sObjectMgr->GetItemTemplate(item_template);
                                if (!itemProto)
                                {
                                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
                                    stmt->setUInt64(0, item_guidlow);
                                    trans->Append(stmt);
                                    continue;
                                }

                                Item* pItem = NewItemOrBag(itemProto);
                                if (!pItem->LoadFromDB(item_guidlow, playerguid, itemFields, item_template))
                                {
                                    pItem->FSetState(ITEM_REMOVED);
                                    pItem->SaveToDB(trans);              // it also deletes item object!
                                    continue;
                                }

                                draft.AddItem(pItem);
                            }
                            while (resultItems->NextRow());
                        }
                    }

                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
                    stmt->setUInt32(0, mail_id);
                    trans->Append(stmt);

                    uint32 pl_account = ObjectMgr::GetPlayerAccountIdByGUID(playerguid);

                    draft.AddMoney(money).SendReturnToSender(pl_account, guid, sender, trans);
                }
                while (resultMail->NextRow());
            }

            // Unsummon and delete for pets in world is not required: player deleted from CLI or character list with not loaded pet.
            // NOW we can finally clear other DB data related to character
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_PETS);
            stmt->setUInt64(0, guid);
            PreparedQueryResult resultPets = CharacterDatabase.Query(stmt);

            if (resultPets)
            {
                do
                {
                    uint32 petguidlow = (*resultPets)[0].GetUInt32();
                    Pet::DeleteFromDB(petguidlow);
                } while (resultPets->NextRow());
            }

            // Delete char from social list of online chars
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_SOCIAL);
            stmt->setUInt64(0, guid);
            PreparedQueryResult resultFriends = CharacterDatabase.Query(stmt);

            if (resultFriends)
            {
                do
                {
                    if (Player* pFriend = ObjectAccessor::FindPlayer(ObjectGuid::Create<HighGuid::Player>((*resultFriends)[0].GetUInt64())))
                    {
                        if (pFriend->IsInWorld())
                        {
                            pFriend->GetSocial()->RemoveFromSocialList(playerguid, SOCIAL_FLAG_ALL);
                            sSocialMgr->SendFriendStatus(pFriend, FRIEND_REMOVED, playerguid, false);
                        }
                    }
                } while (resultFriends->NextRow());
            }

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_ACCOUNT_DATA);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_DECLINED_NAME);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA_EFFECT);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GIFT);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_OBJECTIVES);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE_GEMS_BY_OWNER);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_REPUTATION);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_COOLDOWN);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_GM_TICKETS);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_FRIEND);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SOCIAL_BY_GUID);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEMS);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_BY_OWNER);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_PET_DECLINEDNAME_BY_OWNER);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENTS);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACHIEVEMENTS);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_EQUIPMENTSETS);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GUILD_EVENTLOG_BY_PLAYER);
            stmt->setUInt64(0, guid);
            stmt->setUInt64(1, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GUILD_BANK_EVENTLOG_BY_PLAYER);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_BGDATA);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GLYPHS);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_DAILY);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILLS);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_BRACKETS_INFO);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE_ARTIFACT_BY_OWNER);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE_ARTIFACT_POWERS_BY_OWNER);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE_MODIFIERS_BY_OWNER);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER_ADVENTURE_QUEST);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHALLENGE_KEY);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHALLENGE_MEMBER);
            stmt->setUInt64(0, guid);
            trans->Append(stmt);

            Garrison::DeleteFromDB(guid, trans);

            sBracketMgr->DeleteBracketInfo(playerguid);
            CharacterDatabase.CommitTransaction(trans);
            break;
        }
        // The character gets unlinked from the account, the name gets freed up and appears as deleted ingame
        case CHAR_DELETE_UNLINK:
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_DELETE_INFO);

            stmt->setUInt64(0, guid);

            CharacterDatabase.Execute(stmt);
            break;
        }
        default:
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::DeleteFromDB: Unsupported delete method: %u.", charDelete_method);
    }

    if (updateRealmChars)
        sWorld->UpdateRealmCharCount(accountId);
}

/**
 * Characters which were kept back in the database after being deleted and are now too old (see config option "CharDelete.KeepDays"), will be completely deleted.
 *
 * @see Player::DeleteFromDB
 */
void Player::DeleteOldCharacters()
{
    uint32 keepDays = sWorld->getIntConfig(CONFIG_CHARDELETE_KEEP_DAYS);
    if (!keepDays)
        return;

    Player::DeleteOldCharacters(keepDays);
}

/**
 * Characters which were kept back in the database after being deleted and are older than the specified amount of days, will be completely deleted.
 *
 * @see Player::DeleteFromDB
 *
 * @param keepDays overrite the config option by another amount of days
 */
void Player::DeleteOldCharacters(uint32 keepDays)
{
    TC_LOG_INFO(LOG_FILTER_PLAYER, "Player::DeleteOldChars: Deleting all characters which have been deleted %u days before...", keepDays);

    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_OLD_CHARS);
    stmt->setUInt32(0, uint32(time(NULL) - time_t(keepDays * DAY)));
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (result)
    {
         TC_LOG_DEBUG(LOG_FILTER_PLAYER, "Player::DeleteOldChars: Found " UI64FMTD " character(s) to delete", result->GetRowCount());
         do
         {
            Field* fields = result->Fetch();
            Player::DeleteFromDB(ObjectGuid::Create<HighGuid::Player>(fields[0].GetUInt64()), fields[1].GetUInt32(), true, true);
         }
         while (result->NextRow());
    }
}

/* Preconditions:
  - a resurrectable corpse must not be loaded for the player (only bones)
  - the player must be in world
*/
void Player::BuildPlayerRepop()
{
    WorldPackets::Misc::PreRessurect packet;
    packet.PlayerGUID = GetGUID();
    SendDirectMessage(packet.Write());

    if (getRace() == RACE_NIGHTELF)
        CastSpell(this, 20584, true);
    CastSpell(this, 8326, true);

    // there must be SMSG.FORCE_RUN_SPEED_CHANGE, SMSG.FORCE_SWIM_SPEED_CHANGE, SMSG.MOVE_WATER_WALK
    // there must be SMSG.STOP_MIRROR_TIMER
    // there we must send 888 opcode

    // the player cannot have a corpse already, only bones which are not returned by GetCorpse
    if (GetCorpse())
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "BuildPlayerRepop: player %s(%d) already has a corpse", GetName(), GetGUIDLow());
        return;
    }

    // create a corpse and place it at the player's location
    CreateCorpse();
    Corpse* corpse = GetCorpse();
    if (!corpse)
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Error creating corpse for Player %s [%u]", GetName(), GetGUIDLow());
        return;
    }
    GetMap()->AddToMap(corpse);

    // convert player body to ghost
    SetHealth(1);

    SetWaterWalking(true);
    if (!GetSession()->isLogingOut())
        SetRooted(false);

    // BG - remove insignia related
    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);

//    SendCorpseReclaimDelay();

    // to prevent cheating
    corpse->ResetGhostTime();

    StopMirrorTimers();                                     //disable timers(bars)

    SetFloatValue(UNIT_FIELD_BOUNDING_RADIUS, float(1.0f));   //see radius of death player?

    // set and clear other
    SetMiscStandValue(UNIT_BYTE1_FLAG_ALWAYS_STAND);
}

void Player::ResurrectPlayer(float restore_percent, bool applySickness)
{
    WorldPackets::Misc::DeathReleaseLoc packet;
    packet.MapID = -1;
    SendDirectMessage(packet.Write());
    
    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS);

    // speed change, land walk

    // remove death flag + set aura
    SetMiscStandValue(0);
    if (getRace() == RACE_NIGHTELF)
        RemoveAurasDueToSpell(20584);                       // speed bonuses

    RemoveAurasDueToSpell(8326);                            // SPELL_AURA_GHOST
    RemoveAurasDueToSpell(225080);                          // Reincarnation
    RemoveAurasDueToSpell(255234);                          // Totemic Revival

    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
        SetFlag(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_REFER_A_FRIEND);

    setDeathState(ALIVE);

    // add the flag to make sure opcode is always sent
    AddUnitMovementFlag(MOVEMENTFLAG_WATERWALKING);
    SetWaterWalking(false);

    SetRooted(false);

    m_deathTimer = 0;

    // set health/powers (0- will be set in caller)
    if (restore_percent > 0.0f)
    {
        restore_percent *= GetTotalAuraMultiplier(SPELL_AURA_MOD_RESURRECTED_HEALTH_BY_GUILD_MEMBER);
        SetHealth(uint32(GetMaxHealth()*restore_percent));
        SetPower(POWER_MANA, uint32(GetMaxPower(POWER_MANA)*restore_percent));
        ResetPowers(restore_percent);
    }

    // trigger update zone for alive state zone updates
    uint32 newzone, newarea;
    GetZoneAndAreaId(newzone, newarea);
    UpdateZone(newzone, newarea);
    sOutdoorPvPMgr->HandlePlayerResurrects(this, newzone);

    if (InBattleground())
    {
        if (Battleground* bg = GetBattleground())
            bg->HandlePlayerResurrect(this);
    }

    SummonLastSummonedBattlePet();

    // update visibility
    UpdateObjectVisibility();

    if (!applySickness)
        return;

    //Characters from level 1-10 are not affected by resurrection sickness.
    //Characters from level 11-19 will suffer from one minute of sickness
    //for each level they are above 10.
    //Characters level 20 and up suffer from ten minutes of sickness.
    int32 startLevel = sWorld->getIntConfig(CONFIG_DEATH_SICKNESS_LEVEL);

    if (int32(getLevel()) >= startLevel)
    {
        // set resurrection sickness
        CastSpell(this, 15007, true);

        // not full duration
        if (int32(getLevel()) < startLevel+9)
        {
            int32 delta = (int32(getLevel()) - startLevel + 1)*MINUTE;

            Aura* aur = GetAura(15007, GetGUID());
            if (aur != NULL)
            {
                aur->SetDuration(delta*IN_MILLISECONDS);
            }
        }
    }
}

void Player::KillPlayer()
{
    // Remove AT movement force
    if (ObjectGuid forceGuid = GetForceGUID())
        if (AreaTrigger const* at = ObjectAccessor::GetAreaTrigger(*this, forceGuid))
            SendMovementForce(at);

    if (IsFlying() && !GetTransport())
        i_motionMaster.MoveFall();

    SetRooted(true);

    StopMirrorTimers();                                     //disable timers(bars)

    setDeathState(CORPSE);
    //SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_IN_PVP);

    SetUInt32Value(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_NONE);
    ApplyModFlag(PLAYER_FIELD_LOCAL_FLAGS, PLAYER_LOCAL_FLAG_RELEASE_TIMER, !sMapStore.LookupEntry(GetMapId())->Instanceable() && !HasAuraType(SPELL_AURA_PREVENT_RESURRECTION));

    // 6 minutes until repop at graveyard
    m_deathTimer = 6 * MINUTE * IN_MILLISECONDS;

    UpdateCorpseReclaimDelay();                             // dependent at use SetDeathPvP() call before kill
    SendCorpseReclaimDelay();

    // don't create corpse at this moment, player might be falling

    // update visibility
    UpdateObjectVisibility();

    UnsummonCurrentBattlePetIfAny(true);
}

void Player::CreateCorpse()
{
    // prevent existence 2 corpse for player
    SpawnCorpseBones();

    Corpse* corpse = new Corpse((m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH) ? CORPSE_RESURRECTABLE_PVP : CORPSE_RESURRECTABLE_PVE);
    SetPvPDeath(false);

    if (!corpse->Create(sObjectMgr->GetGenerator<HighGuid::Corpse>()->Generate(), this))
    {
        delete corpse;
        return;
    }

    uint8 skin = GetSkinValue();
    uint8 face = GetFaceValue();
    uint8 hairstyle = GetHairStyleValue();
    uint8 haircolor = GetHairColorValue();
    uint8 facialhair = GetFacialStyleValue();

    corpse->SetUInt32Value(CORPSE_FIELD_BYTES_1, uint32((0x00) | (getRace() << 8) | (getGender() << 16) | (skin << 24)));
    corpse->SetUInt32Value(CORPSE_FIELD_BYTES_2, uint32((face) | (hairstyle << 8) | (haircolor << 16) | (facialhair << 24)));

    uint32 flags = 0;
    if (IsPvP())
        flags |= CORPSE_FLAG_PVP;
    if (InBattleground() && !InArena())
        flags |= CORPSE_FLAG_SKINNABLE;                      // to be able to remove insignia
    if (IsFFAPvP())
        flags |= CORPSE_FLAG_FFA_PVP;
    if (HasAura(261228)) //Argus: phase 4 - IsAllowingRelease
        flags |= CORPSE_FLAG_HIDE_MODEL;

    corpse->SetUInt32Value(CORPSE_FIELD_FLAGS, flags);
    corpse->SetUInt32Value(CORPSE_FIELD_DISPLAY_ID, GetNativeDisplayId());
    corpse->SetUInt32Value(CORPSE_FIELD_FACTION_TEMPLATE, sChrRacesStore.AssertEntry(getRace())->FactionID);

    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; i++)
    {
        if (m_items[i])
        {
            uint32 itemInventoryType;
            if (ItemEntry const* itemEntry = sItemStore.LookupEntry(m_items[i]->GetVisibleEntry(this)))
                itemInventoryType = itemEntry->InventoryType;
            else
                itemInventoryType = m_items[i]->GetTemplate()->GetInventoryType();

            corpse->SetUInt32Value(CORPSE_FIELD_ITEMS + i, m_items[i]->GetDisplayId(this) | (itemInventoryType << 24));
        }
    }

    // we do not need to save corpses for BG/arenas
    if (!GetMap()->IsBattlegroundOrArena())
        corpse->SaveToDB();

    // register for player, but not show
    sObjectAccessor->AddCorpse(corpse);
}

void Player::SpawnCorpseBones()
{
    if (sObjectAccessor->ConvertCorpseForPlayer(GetGUID()))
        if (!GetSession()->PlayerLogoutWithSave())          // at logout we will already store the player
            SaveToDB();                                     // prevent loading as ghost without corpse
}

Corpse* Player::GetCorpse() const
{
    return sObjectAccessor->GetCorpseForPlayerGUID(GetGUID());
}

void Player::DurabilityLossAll(double percent, bool inventory, bool withMods)
{
    if (withMods)
    {
        int32 mod = std::min(100, GetTotalAuraModifier(SPELL_AURA_MOD_DURABILITY_LOSS));
        percent = percent - (percent * mod / 100.0f);
    }

    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            DurabilityLoss(pItem, percent);

    if (inventory)
    {
        // bags not have durability
        // for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)

        uint8 inventoryEnd = INVENTORY_SLOT_ITEM_START + GetInventorySlotCount();
        for (uint8 i = INVENTORY_SLOT_ITEM_START; i < inventoryEnd; i++)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                DurabilityLoss(pItem, percent);

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
            if (Bag* pBag = GetBagByPos(i))
                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                    if (Item* pItem = GetItemByPos(i, j))
                        DurabilityLoss(pItem, percent);
    }
}

void Player::DurabilityLoss(Item* item, double percent)
{
    if (!item || item->IsSturdiness())
        return;

    uint32 pMaxDurability = item->GetUInt32Value(ITEM_FIELD_MAX_DURABILITY);

    if (!pMaxDurability)
        return;

    uint32 pDurabilityLoss = uint32(pMaxDurability*percent);

    if (pDurabilityLoss < 1)
        pDurabilityLoss = 1;

    DurabilityPointsLoss(item, pDurabilityLoss);
}

void Player::DurabilityPointsLossAll(int32 points, bool inventory)
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            DurabilityPointsLoss(pItem, points);

    if (inventory)
    {
        // bags not have durability
        // for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)

        for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); i++)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                DurabilityPointsLoss(pItem, points);

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
            if (Bag* pBag = (Bag*)GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                    if (Item* pItem = GetItemByPos(i, j))
                        DurabilityPointsLoss(pItem, points);
    }
}

void Player::DurabilityPointsLoss(Item* item, int32 points)
{
    if (!item || item->IsSturdiness())
        return;

    if (HasAuraType(SPELL_AURA_PREVENT_DURABILITY_LOSS))
        return;

    int32 pMaxDurability = item->GetUInt32Value(ITEM_FIELD_MAX_DURABILITY);
    int32 pOldDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
    int32 pNewDurability = pOldDurability - points;

    if (pNewDurability < 0)
        pNewDurability = 0;
    else if (pNewDurability > pMaxDurability)
        pNewDurability = pMaxDurability;

    if (pOldDurability != pNewDurability)
    {
        // modify item stats _before_ Durability set to 0 to pass _ApplyItemMods internal check
        if (pNewDurability == 0 && pOldDurability > 0 && item->IsEquipped())
            _ApplyItemMods(item, item->GetSlot(), false);

        item->SetUInt32Value(ITEM_FIELD_DURABILITY, pNewDurability);

        // modify item stats _after_ restore durability to pass _ApplyItemMods internal check
        if (pNewDurability > 0 && pOldDurability == 0 && item->IsEquipped())
            _ApplyItemMods(item, item->GetSlot(), true);

        item->SetState(ITEM_CHANGED, this);
    }
}

void Player::DurabilityPointLossForEquipSlot(EquipmentSlots slot)
{
    if (HasAuraType(SPELL_AURA_PREVENT_DURABILITY_LOSS_FROM_COMBAT))
        return;

    if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
        DurabilityPointsLoss(pItem, 1);
}

uint32 Player::DurabilityRepairAll(bool cost, float discountMod, bool guildBank)
{
    uint32 TotalCost = 0;
    // equipped, backpack, bags itself
    for (uint8 i = EQUIPMENT_SLOT_START; i < GetInventoryEndSlot(); i++)
        TotalCost += DurabilityRepair(((INVENTORY_SLOT_BAG_0 << 8) | i), cost, discountMod, guildBank);

    // bank, buyback and keys not repaired

    // items in inventory bags
    for (uint8 j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; j++)
        for (uint8 i = 0; i < MAX_BAG_SIZE; i++)
            TotalCost += DurabilityRepair(((j << 8) | i), cost, discountMod, guildBank);
    return TotalCost;
}

uint32 Player::DurabilityRepair(uint16 pos, bool cost, float discountMod, bool guildBank)
{
    Item* item = GetItemByPos(pos);

    uint32 TotalCost = 0;
    if (!item)
        return TotalCost;

    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAX_DURABILITY);
    if (!maxDurability)
        return TotalCost;

    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);

    if (cost)
    {
        uint32 LostDurability = maxDurability - curDurability;
        if (LostDurability > 0)
        {
            ItemTemplate const* ditemProto = item->GetTemplate();

            DurabilityCostsEntry const* dcost = sDurabilityCostsStore.LookupEntry(item->GetItemLevel(getLevel()));
            if (!dcost)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER_ITEMS, "RepairDurability: Wrong item lvl %u", item->GetItemLevel(getLevel()));
                return TotalCost;
            }

            uint32 dQualitymodEntryId = (ditemProto->GetQuality() + 1) * 2;
            DurabilityQualityEntry const* dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
            if (!dQualitymodEntry)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER_ITEMS, "RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
                return TotalCost;
            }

            uint32 dmultiplier = 0;
            if (ditemProto->GetClass() == ITEM_CLASS_WEAPON)
                dmultiplier = dcost->WeaponSubClassCost[ditemProto->GetSubClass()];
            else if (ditemProto->GetClass() == ITEM_CLASS_ARMOR)
                dmultiplier = dcost->ArmorSubClassCost[ditemProto->GetSubClass()];

            uint32 costs = uint32(LostDurability * dmultiplier * double(dQualitymodEntry->Data) * item->GetRepairCostMultiplier()) * discountMod * sWorld->getRate(RATE_REPAIRCOST);
            if (costs == 0)                                   //fix for ITEM_QUALITY_ARTIFACT
                costs = 1;

            if (guildBank)
            {
                if (GetGuildId() == 0)
                {
                    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "You are not member of a guild");
                    return TotalCost;
                }

                Guild* guild = sGuildMgr->GetGuildById(GetGuildId());
                if (!guild)
                    return TotalCost;

                if (!guild->HandleMemberWithdrawMoney(GetSession(), costs, true))
                    return TotalCost;

                TotalCost = costs;

                guild->UpdateAchievementCriteria(CRITERIA_TYPE_SPENT_GOLD_GUILD_REPAIRS, costs, 0, 0, NULL, this);
            }
            else if (!HasEnoughMoney(uint64(costs)))
            {
                TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "You do not have enough money");
                return TotalCost;
            }
            else
                ModifyMoney(-int64(costs));
        }
    }

    item->SetUInt32Value(ITEM_FIELD_DURABILITY, maxDurability);
    item->SetState(ITEM_CHANGED, this);

    // reapply mods for total broken and repaired item if equipped
    if (IsEquipmentPos(pos) && !curDurability)
        _ApplyItemMods(item, pos & 255, true);

    return TotalCost;
}

void Player::RepopAtGraveyard(bool outInstance /*= false*/)
{
    // note: this can be called also when the player is alive
    // for example from WorldSession::HandleMovementOpcodes

    AreaTableEntry const* zone = sAreaTableStore.LookupEntry(GetCurrentAreaID());

    // Such zones are considered unreachable as a ghost and the player must be automatically revived
    if ((!isAlive() && zone && zone->Flags[0] & AREA_FLAG_NEED_FLY) || GetTransport() || GetPositionZ() < GetMap()->GetMinHeight(GetPosition()))
    {
        ResurrectPlayer(0.5f);
        SpawnCorpseBones();
    }

    WorldSafeLocsEntry const* ClosestGrave = NULL;

    // Special handle for battleground maps
    if (Battleground* bg = GetBattleground())
        ClosestGrave = bg->GetClosestGraveYard(this);
    else
    {
        bool _isAllowingRelease = false;

        // Teleport player to the outside if the dungeon is in a state of progress.
        if (InstanceScript* instance = GetInstanceScript())
        {
            if (instance->IsEncounterInProgress())
            {
                if (instance->IsAllowingRelease)
                    _isAllowingRelease = true;
                else
                    outInstance = true;
            }
        }

        if (!outInstance)
        {
            if (InstanceMap* inst = GetMap()->ToInstanceMap())
            {
                if (WorldLocation const* _grave = inst->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ()))
                {
                    // stop countdown until repop
                    m_deathTimer = 0;

                    if (_isAllowingRelease)
                        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS);
                    else
                    {
                        ScheduleDelayedOperation(DELAYED_RESURRECT_PLAYER);
                        SafeTeleport(_grave->GetMapId(), _grave->GetPositionX(), _grave->GetPositionY(), _grave->GetPositionZ() + 2.0f, _grave->GetOrientation());
                    }
                    return;
                }
            }
        }

        if (Battlefield* bf = sBattlefieldMgr->GetBattlefieldToZoneId(GetCurrentZoneID()))
            ClosestGrave = bf->GetClosestGraveYard(this);
        else if (sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetCurrentZoneID()) != nullptr && sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetCurrentZoneID())->GetClosestGraveyard(this) != nullptr)
        {
            if (OutdoorPvP* outdoorPvP = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetCurrentZoneID()))
                ClosestGrave = outdoorPvP->GetClosestGraveyard(this);
        }
        else
            ClosestGrave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam());
    }

    // stop countdown until repop
    m_deathTimer = 0;

    // if grave found and no transport
    if (ClosestGrave && !GetTransport())
    {
        SafeTeleport(ClosestGrave->MapID, ClosestGrave->Loc.X, ClosestGrave->Loc.Y, ClosestGrave->Loc.Z + 2.0f, (ClosestGrave->Loc.O * M_PI) / 180); // Orientation is initially in degrees
        
        if (isDead())                                        // not send if alive, because it used in TeleportTo()
        {
            WorldPackets::Misc::DeathReleaseLoc packet;
            packet.MapID = ClosestGrave->MapID;
            packet.Loc = Position(ClosestGrave->Loc.X, ClosestGrave->Loc.Y, ClosestGrave->Loc.Z);
            SendDirectMessage(packet.Write());
        }
    }
    else if (GetPositionZ() < GetMap()->GetMinHeight(GetPosition()))
        SafeTeleport(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, GetOrientation());

    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IS_OUT_OF_BOUNDS);
    
    if (ClosestGrave && ClosestGrave->MapID == 1101) //deathmatch instant rev
    {
        AddDelayedEvent(1000, [=]() -> void
        {
            RemoveAllAurasOnDeath();
            ResurrectPlayer(1.0f);
            SpawnCorpseBones();
            SaveToDB();
        });
    }
}

bool Player::CanJoinConstantChannelInZone(ChatChannelsEntry const* channel, AreaTableEntry const* zone)
{
    // Player can join LFG anywhere
    if (channel->Flags & CHANNEL_DBC_FLAG_LFG)
        return true;

    if (channel->Flags & CHANNEL_DBC_FLAG_ZONE_DEP && zone->Flags[0] & AREA_FLAG_ARENA_INSTANCE)
        return false;

    if ((channel->Flags & CHANNEL_DBC_FLAG_CITY_ONLY) && (!(zone->Flags[0] & AREA_FLAG_SLAVE_CAPITAL)))
        return false;

    //if ((channel->Flags & CHANNEL_DBC_FLAG_GUILD_REQ) && GetGuildId())
        //return false;

    return true;
}

void Player::JoinedChannel(Channel* c)
{
    AddDelayedEvent(100, [=]() -> void
    {
        m_channels.push_back(c);
    });
}

void Player::LeftChannel(Channel* c)
{
    AddDelayedEvent(100, [=]() -> void
    {
        m_channels.remove(c);
    });
}

void Player::CleanupChannels()
{
    while (!m_channels.empty())
    {
        Channel* ch = *m_channels.begin();
        m_channels.erase(m_channels.begin());               // remove from player's channel list
        ch->LeaveChannel(this, false);                        // not send to client, not remove from player's channel list
        if (ChannelMgr* cMgr = channelMgr(GetTeam()))
            cMgr->LeftChannel(ch->GetName());               // deleted channel if empty
    }
    TC_LOG_DEBUG(LOG_FILTER_CHATSYS, "Player: channels cleaned up!");
}

void Player::UpdateLocalChannels(uint32 newZone)
{
    if (GetSession()->PlayerLoading() && !IsBeingTeleportedFar())
        return;                                              // The client handles it automatically after loading, but not after teleporting

    AreaTableEntry const* current_zone = sAreaTableStore.LookupEntry(newZone);
    if (!current_zone)
        return;

    ChannelMgr* cMgr = channelMgr(GetTeam());
    if (!cMgr)
        return;

    std::string current_zone_name = current_zone->ZoneName->Str[sObjectMgr->GetDBCLocaleIndex()];

    for (ChatChannelsEntry const* channel : sChatChannelsStore)
    {
        Channel* usedChannel = NULL;

        for (JoinedChannelsList::iterator itr = m_channels.begin(); itr != m_channels.end(); ++itr)
        {
            if ((*itr) && (*itr)->GetChannelId() == channel->ID)
            {
                usedChannel = *itr;
                break;
            }
        }

        Channel* removeChannel = NULL;
        Channel* joinChannel = NULL;
        bool sendRemove = true;

        if (CanJoinConstantChannelInZone(channel, current_zone))
        {
            if (!(channel->Flags & CHANNEL_DBC_FLAG_GLOBAL))
            {
                if (channel->Flags & CHANNEL_DBC_FLAG_CITY_ONLY && usedChannel)
                    continue;                            // Already on the channel, as city channel names are not changing

                char new_channel_name_buf[100];
                char const* currentNameExt;

                if (channel->Flags & CHANNEL_DBC_FLAG_CITY_ONLY)
                    currentNameExt = sObjectMgr->GetTrinityStringForDBCLocale(LANG_CHANNEL_CITY);
                else
                    currentNameExt = current_zone_name.c_str();

                snprintf(new_channel_name_buf, 100, channel->Name->Str[GetSession()->GetSessionDbLocaleIndex()], currentNameExt);

                joinChannel = cMgr->GetJoinChannel(new_channel_name_buf, channel->ID);
                if (usedChannel)
                {
                    if (joinChannel != usedChannel)
                    {
                        removeChannel = usedChannel;
                        sendRemove = false;              // Do not send leave channel, it already replaced at client
                    }
                    else
                        joinChannel = NULL;
                }
            }
            else
                joinChannel = cMgr->GetJoinChannel(channel->Name->Str[GetSession()->GetSessionDbLocaleIndex()], channel->ID);
        }
        else
            removeChannel = usedChannel;

        if (joinChannel)
            joinChannel->JoinChannel(this, "");            // Changed Channel: ... or Joined Channel: ...

        if (removeChannel)
        {
            removeChannel->LeaveChannel(this, sendRemove); // Leave old channel
            std::string name = removeChannel->GetName(); // Store name, (*i)erase in LeftChannel
            LeftChannel(removeChannel);                  // Remove from player's channel list
            cMgr->LeftChannel(name);                     // Delete if empty
        }
    }
}

void Player::LeaveLFGChannel()
{
    for (JoinedChannelsList::iterator i = m_channels.begin(); i != m_channels.end(); ++i)
    {
        if ((*i)->IsLFG())
        {
            (*i)->LeaveChannel(this);
            break;
        }
    }
}

void Player::HandleBaseModValue(BaseModGroup modGroup, BaseModType modType, float amount, bool apply)
{
    if (modGroup >= BASEMOD_END || modType >= MOD_END)
    {
        TC_LOG_ERROR(LOG_FILTER_SPELLS_AURAS, "ERROR in HandleBaseModValue(): non existed BaseModGroup of wrong BaseModType!");
        return;
    }

    switch (modType)
    {
        case FLAT_MOD:
            m_auraBaseMod[modGroup][modType] += apply ? amount : -amount;
            break;
        case PCT_MOD:
            ApplyPercentModFloatVar(m_auraBaseMod[modGroup][modType], amount, apply);
            break;
    }

    switch (modGroup)
    {
        case SHIELD_BLOCK_VALUE:           UpdateShieldBlock(); break;
        default: break;
    }

    if (!CanModifyStats())
        return;

    switch (modGroup)
    {
        case CRIT_PERCENTAGE:              UpdateCritPercentage(BASE_ATTACK); break;
        case RANGED_CRIT_PERCENTAGE:       UpdateCritPercentage(RANGED_ATTACK); break;
        case OFFHAND_CRIT_PERCENTAGE:      UpdateCritPercentage(OFF_ATTACK); break;
        default: break;
    }
}

float Player::GetBaseModValue(BaseModGroup modGroup, BaseModType modType) const
{
    if (modGroup >= BASEMOD_END || modType > MOD_END)
    {
        TC_LOG_ERROR(LOG_FILTER_SPELLS_AURAS, "trial to access non existed BaseModGroup or wrong BaseModType!");
        return 0.0f;
    }

    if (modType == PCT_MOD && m_auraBaseMod[modGroup][PCT_MOD] <= 0.0f)
        return 0.0f;

    return m_auraBaseMod[modGroup][modType];
}

float Player::GetTotalBaseModValue(BaseModGroup modGroup) const
{
    if (modGroup >= BASEMOD_END)
    {
        TC_LOG_ERROR(LOG_FILTER_SPELLS_AURAS, "wrong BaseModGroup in GetTotalBaseModValue()!");
        return 0.0f;
    }

    if (m_auraBaseMod[modGroup][PCT_MOD] <= 0.0f)
        return 0.0f;

    return m_auraBaseMod[modGroup][FLAT_MOD] * m_auraBaseMod[modGroup][PCT_MOD];
}

float Player::GetRatingBonusValue(CombatRating cr) const
{
    return float(GetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + cr)) * GetRatingMultiplier(cr);
}

float Player::GetExpertiseDodgeOrParryReduction(WeaponAttackType attType) const
{
    switch (attType)
    {
        case WeaponAttackType::BASE_ATTACK:
            return GetFloatValue(PLAYER_FIELD_MAINHAND_EXPERTISE);
        case WeaponAttackType::OFF_ATTACK:
            return GetFloatValue(PLAYER_FIELD_OFFHAND_EXPERTISE);
        case WeaponAttackType::RANGED_ATTACK:
            return GetFloatValue(PLAYER_FIELD_RANGED_EXPERTISE);
        default:
            break;
    }

    return 0.0f;
}

void Player::ApplyRatingMod(CombatRating cr, int32 value, bool apply)
{
    m_baseRatingValue[cr] +=(apply ? value : -value);

    SendUpdateCR(1 << cr);
}

void Player::UpdateRating(CombatRating cr)
{
    float amount = m_baseRatingValue[cr];
    float otherMod = 0.f;

    if (HasPvpStatsScalingEnabled() && (cr != CR_PARRY && cr != CR_DODGE && cr != CR_BLOCK))
    {
        switch (cr)
        {
            case CR_CRIT_SPELL:
            case CR_CRIT_MELEE:
            case CR_CRIT_RANGED:
            case CR_HASTE_SPELL:
            case CR_HASTE_MELEE:
            case CR_HASTE_RANGED:
            case CR_MASTERY:
            case CR_VERSATILITY_DAMAGE_DONE:
            case CR_VERSATILITY_HEALING_DONE:
            case CR_VERSATILITY_DAMAGE_TAKEN:
            {
                amount = SecondaryStatValue;
                break;
            }
            default:
            {
                amount = 0;
            }
        }

        CalcPvPTemplate(SPELL_AURA_MOD_RATING, amount, otherMod, [cr](AuraEffect const* aurEff) -> bool
        {
            if ((aurEff->GetMiscValue() & (1 << cr)) != 0)
                return true;
            return false;
        });

        amount *= GetPvpStatScalar();
    }
    else
    {
        otherMod += GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << cr));
    }

    amount += otherMod;
    amount *= GetTotalAuraMultiplier(SPELL_AURA_INCREASE_RAITING_BY_PCT, [=](AuraEffect const* aurEff) -> bool
    {
        if (aurEff->GetMiscValue() & (1 << cr))
            return true;
        return false;
    });

    SetUInt32Value(PLAYER_FIELD_COMBAT_RATINGS + cr, uint32(std::max(0.f, amount)));

    bool affectStats = CanModifyStats();

    switch (cr)
    {
        case CR_DODGE:
            UpdateDodgePercentage();
            break;
        case CR_PARRY:
            UpdateParryPercentage();
            break;
        case CR_BLOCK:
            UpdateBlockPercentage();
            break;
        case CR_HIT_MELEE:
            UpdateMeleeHitChances();
            break;
        case CR_HIT_RANGED:
            UpdateRangedHitChances();
            break;
        case CR_HIT_SPELL:
            UpdateSpellHitChances();
            break;
        case CR_CRIT_MELEE:
            if (affectStats)
            {
                UpdateCritPercentage(BASE_ATTACK);
                UpdateCritPercentage(OFF_ATTACK);
            }
            break;
        case CR_CRIT_RANGED:
            if (affectStats)
                UpdateCritPercentage(RANGED_ATTACK);
            break;
        case CR_CRIT_SPELL:
            if (affectStats)
            {
                UpdateSpellCritChance();
                UpdateDodgePercentage(); // Need for aura SPELL_AURA_MOD_DODGE_CHANCE_FROM_CRIT_CHANCE_BY_MASK
                UpdateParryPercentage(); // Need for aura SPELL_AURA_CONVERT_CRIT_RATING_PCT_TO_PARRY_RATING
            }
            break;
        case CR_HASTE_MELEE:                                // Implemented in Player::ApplyRatingMod
            SendUpdateStat(USM_MELEE_HAST | USM_CAST_HAST);
            break;
        case CR_HASTE_RANGED:
            SendUpdateStat(USM_RANGE_HAST | USM_CAST_HAST);
            break;
        case CR_HASTE_SPELL:
            SendUpdateStat(USM_HAST| USM_CAST_HAST);
            break;
        case CR_EXPERTISE:
            if (affectStats)
                UpdateExpertise();
            break;
        case CR_MASTERY:                                    // Implemented in Player::UpdateMasteryPercentage
            UpdateMasteryAuras();
            break;
        case CR_VERSATILITY_DAMAGE_DONE:
        case CR_VERSATILITY_DAMAGE_TAKEN:
            UpdateVersality(cr);
            break;
        case CR_MULTISTRIKE:
        case CR_READINESS:
            break;
        case CR_SPEED:
            UpdateCRSpeed();
            break;
        case CR_LIFESTEAL:
            UpdateLifesteal();
            break;
        case CR_AVOIDANCE:
            UpdateAvoidance();
            break;
        default:
            break;
    }
}

void Player::UpdateItemLevels()
{
    SetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::EquippedAvgItemLevel, GetAverageItemLevelEquipped());
    SetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::TotalAvgItemLevel, GetAverageItemLevelTotal());
    SetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::NonPvPAvgItemLevel, GetAverageItemLevelTotalWithOrWithoutPvPBonus(false));
    SetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::PvPAvgItemLevel, GetAverageItemLevelTotalWithOrWithoutPvPBonus(true));

    if (HasPvpStatsScalingEnabled())
    {
        SendUpdateStat(USM_ALL);
        SendUpdateCR(CR_PVP_UPDATE_MASK);
    }
}

void Player::SetRegularAttackTime()
{
    for (uint8 i = 0; i < MAX_ATTACK; ++i)
    {
        Item* tmpitem = GetWeaponForAttack(WeaponAttackType(i), true);
        if (tmpitem && !tmpitem->CantBeUse())
        {
            ItemTemplate const* proto = tmpitem->GetTemplate();
            if (proto->GetDelay())
                SetAttackTime(WeaponAttackType(i), proto->GetDelay());
        }
        else
            SetAttackTime(WeaponAttackType(i), BASE_ATTACK_TIME);  // If there is no weapon reset attack time to base (might have been changed from forms)
    }
}

//skill+step, checking for max value
bool Player::UpdateSkill(uint32 skill_id, uint32 step)
{
    if (!skill_id)
        return false;

    if (skill_id == SKILL_FIST_WEAPONS)
        skill_id = SKILL_UNARMED;

    SkillStatusData* status = (*mSkillStatusVector)[skill_id];
    if (!status || status->uState == SKILL_DELETED)
        return false;

    uint16 field = status->pos / 2;
    uint8 offset = status->pos & 1; // itr->second.pos % 2

    uint16 value = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset);
    uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset);

    if (!max || !value || value >= max)
        return false;

    if (value < max)
    {
        uint16 new_value = value + step;
        if (new_value > max)
            new_value = max;

        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, new_value);

        if (status->uState != SKILL_NEW)
            status->uState = SKILL_CHANGED;

        UpdateSkillEnchantments(skill_id, value, new_value);
        UpdateAchievementCriteria(CRITERIA_TYPE_REACH_SKILL_LEVEL, skill_id);
        return true;
    }

    return false;
}

inline int SkillGainChance(uint32 SkillValue, uint32 GrayLevel, uint32 GreenLevel, uint32 YellowLevel)
{
    if (SkillValue >= GrayLevel)
        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_GREY)*10;
    if (SkillValue >= GreenLevel)
        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_GREEN)*10;
    if (SkillValue >= YellowLevel)
        return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_YELLOW)*10;
    return sWorld->getIntConfig(CONFIG_SKILL_CHANCE_ORANGE)*10;
}

bool Player::UpdateCraftSkill(uint32 spellid)
{
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_SKILLS, "UpdateCraftSkill spellid %d", spellid);

    SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellid);

    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
    {
        if (_spell_idx->second->SkillLine)
        {
            uint32 SkillValue = GetPureSkillValue(_spell_idx->second->SkillLine);

            // Alchemy Discoveries here
            SpellInfo const* spellEntry = sSpellMgr->GetSpellInfo(spellid);
            if (spellEntry && spellEntry->Categories.Mechanic == MECHANIC_DISCOVERY)
            {
                if (uint32 discoveredSpell = GetSkillDiscoverySpell(_spell_idx->second->SkillLine, spellid, this))
                    learnSpell(discoveredSpell, false);
            }

            uint32 craft_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_CRAFTING);
            int skill_gain_chance = SkillGainChance(SkillValue, _spell_idx->second->TrivialSkillLineRankHigh, (_spell_idx->second->TrivialSkillLineRankHigh + _spell_idx->second->TrivialSkillLineRankLow)/2, _spell_idx->second->TrivialSkillLineRankLow);
            
            // Since 4.0.x, we have bonus skill point reward with somes items ...
            if (_spell_idx->second && _spell_idx->second->NumSkillUps >craft_skill_gain && skill_gain_chance == sWorld->getIntConfig(CONFIG_SKILL_CHANCE_ORANGE)*10)
                craft_skill_gain = _spell_idx->second->NumSkillUps;

            return UpdateSkillPro(_spell_idx->second->SkillLine, skill_gain_chance, craft_skill_gain);
        }
    }
    return false;
}

bool Player::UpdateGatherSkill(uint32 SkillId, uint32 SkillValue, uint32 RedLevel, uint32 Multiplicator)
{
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_SKILLS, "UpdateGatherSkill(SkillId %d SkillLevel %d RedLevel %d)", SkillId, SkillValue, RedLevel);

    uint32 gathering_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_GATHERING);

    // For skinning and Mining chance decrease with level. 1-74 - no decrease, 75-149 - 2 times, 225-299 - 8 times
    switch (SkillId)
    {
        case SKILL_HERBALISM:
        case SKILL_LOCKPICKING:
        case SKILL_JEWELCRAFTING:
        case SKILL_INSCRIPTION:
            return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+100, RedLevel+75, RedLevel+50)*Multiplicator, gathering_skill_gain);
        case SKILL_SKINNING:
        {
            if (sWorld->getIntConfig(CONFIG_SKILL_CHANCE_SKINNING_STEPS) == 0)
                return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+75, RedLevel+50, RedLevel+25)*Multiplicator, gathering_skill_gain);
            return UpdateSkillPro(SkillId, (SkillGainChance(SkillValue, RedLevel+75, RedLevel+50, RedLevel+25)*Multiplicator) >> (SkillValue/sWorld->getIntConfig(CONFIG_SKILL_CHANCE_SKINNING_STEPS)), gathering_skill_gain);
        }
        case SKILL_MINING:
        case SKILL_ARCHAEOLOGY:
        {
            if (sWorld->getIntConfig(CONFIG_SKILL_CHANCE_MINING_STEPS) == 0)
                return UpdateSkillPro(SkillId, SkillGainChance(SkillValue, RedLevel+75, RedLevel+50, RedLevel+25)*Multiplicator, gathering_skill_gain);
            return UpdateSkillPro(SkillId, (SkillGainChance(SkillValue, RedLevel+75, RedLevel+50, RedLevel+25)*Multiplicator) >> (SkillValue/sWorld->getIntConfig(CONFIG_SKILL_CHANCE_MINING_STEPS)), gathering_skill_gain);
        }
    }
    return false;
}

bool Player::UpdateFishingSkill()
{
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_SKILLS, "UpdateFishingSkill");

    uint32 SkillValue = GetPureSkillValue(SKILL_FISHING);

    int32 chance = SkillValue < 225 ? 100 : 250 * 75 / SkillValue;

    uint32 gathering_skill_gain = sWorld->getIntConfig(CONFIG_SKILL_GAIN_GATHERING);

    return UpdateSkillPro(SKILL_FISHING, chance*10, gathering_skill_gain);
}

// levels sync. with spell requirement for skill levels to learn
// bonus abilities in sSkillLineAbilityStore
// Used only to avoid scan DBC at each skill grow
static uint32 bonusSkillLevels[] = {75, 150, 225, 300, 375, 450, 525, 600, 675};
static const size_t bonusSkillLevelsSize = sizeof(bonusSkillLevels) / sizeof(uint32);

bool Player::UpdateSkillPro(uint16 SkillId, int32 Chance, uint32 step)
{
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_SKILLS, "UpdateSkillPro(SkillId %d, Chance %3.1f%%)", SkillId, Chance / 10.0f);
    if (!SkillId)
        return false;

    if (Chance <= 0)                                         // speedup in 0 chance case
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_SKILLS, "Player::UpdateSkillPro Chance=%3.1f%% missed", Chance / 10.0f);
        return false;
    }

    Chance += int32(Chance * GetTotalAuraModifier(SPELL_AURA_INCREASE_SKILL_GAIN_CHANCE) / 100.0f);

    SkillStatusData* status = (*mSkillStatusVector)[SkillId];
    if (!status || status->uState == SKILL_DELETED)
        return false;

    uint16 field = status->pos / 2;
    uint8 offset = status->pos & 1; // itr->second.pos % 2

    uint16 value = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset);
    uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset);

    if (!max || !value || value >= max)
        return false;

    int32 Roll = irand(1, 1000);

    if (Roll <= Chance)
    {
        uint16 new_value = value + step;
        if (new_value > max)
            new_value = max;

        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, new_value);

        if (status->uState != SKILL_NEW)
            status->uState = SKILL_CHANGED;

        for (size_t i = 0; i < bonusSkillLevelsSize; ++i)
        {
            uint32 bsl = bonusSkillLevels[i];
            if (value < bsl && new_value >= bsl)
            {
                learnSkillRewardedSpells(SkillId, new_value);
                break;
            }
        }

        UpdateSkillEnchantments(SkillId, value, new_value);
        UpdateAchievementCriteria(CRITERIA_TYPE_REACH_SKILL_LEVEL, SkillId);
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_SKILLS, "Player::UpdateSkillPro Chance=%3.1f%% taken", Chance / 10.0f);
        return true;
    }

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_SKILLS, "Player::UpdateSkillPro Chance=%3.1f%% missed", Chance / 10.0f);
    return false;
}

void Player::ModifySkillBonus(uint32 skillid, int32 val, bool talent)
{
    SkillStatusData* status = (*mSkillStatusVector)[skillid];
    if (!status || status->uState == SKILL_DELETED)
        return;

    uint16 field = status->pos / 2 + (talent ? PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET : PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET);
    uint8 offset = status->pos & 1;

    uint16 bonus = GetUInt16Value(field, offset);

    SetUInt16Value(field, offset, bonus + val);
}

// This functions sets a skill line value (and adds if doesn't exist yet)
// To "remove" a skill line, set it's values to zero
void Player::SetSkill(uint16 id, uint16 step /*= 0*/, uint16 newVal /*= 0*/, uint16 maxVal /*= 0*/)
{
    if (!id)
        return;

    uint16 currVal;
    SkillStatusData* status = (*mSkillStatusVector)[id];

    //has skill
    if (status && status->uState != SKILL_DELETED)
    {
        uint16 field = status->pos / 2;
        uint8 offset = status->pos & 1;
        currVal = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset);
        if (newVal)
        {
            // if skill value is going down, update enchantments before setting the new value
            if (newVal < currVal)
                UpdateSkillEnchantments(id, currVal, newVal);

            // update step
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset, step);
            // update value
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, newVal);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, maxVal);

            if (status->uState != SKILL_NEW)
                status->uState = SKILL_CHANGED;

            learnSkillRewardedSpells(id, newVal);
            // if skill value is going up, update enchantments after setting the new value
            if (newVal > currVal)
                UpdateSkillEnchantments(id, currVal, newVal);

            UpdateAchievementCriteria(CRITERIA_TYPE_REACH_SKILL_LEVEL, id);
            UpdateAchievementCriteria(CRITERIA_TYPE_LEARN_SKILL_LEVEL, id);
        }
        else                                                //remove
        {
            //remove enchantments needing this skill
            UpdateSkillEnchantments(id, currVal, 0);
            // clear skill fields
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_ID_OFFSET + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset, 0);

            // mark as deleted or simply remove from map if not saved yet
            if (status->uState != SKILL_NEW)
                status->uState = SKILL_DELETED;
            else
            {
                (*mSkillStatusVector)[id] = NULL;
                mSkillStatus.erase(id);
            }

            // remove all spells that related to this skill
            for (SkillLineAbilityEntry const* pAbility : sDB2Manager._skillLineAbilityContainer[id])
                removeSpell(sSpellMgr->GetFirstSpellInChain(pAbility->Spell));

            // Clear profession lines
            if (GetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE) == id)
                SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE, 0);
            else if (GetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + 1) == id)
                SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + 1, 0);
        }
    }
    else if (newVal)                                        //add
    {
        currVal = 0;
        for (uint32 i = 0; i < PLAYER_MAX_SKILLS; ++i)
        {
            uint16 field = i / 2;
            uint8 offset = i & 1; // i % 2

            if (!GetUInt16Value(PLAYER_FIELD_SKILL + field, offset))
            {
                SkillLineEntry const* skillEntry = sSkillLineStore.LookupEntry(id);
                if (!skillEntry)
                {
                    TC_LOG_ERROR(LOG_FILTER_GENERAL, "Skill not found in SkillLineStore: skill #%u", id);
                    return;
                }

                SetUInt16Value(PLAYER_FIELD_SKILL + field, offset, id);
                if (skillEntry->CategoryID == SKILL_CATEGORY_PROFESSION)
                {
                    if (!GetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE))
                        SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE, id);
                    else if (!GetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + 1))
                        SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + 1, id);
                }

                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset, step);
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, newVal);
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, maxVal);

                UpdateSkillEnchantments(id, currVal, newVal);
                UpdateAchievementCriteria(CRITERIA_TYPE_REACH_SKILL_LEVEL, id);
                UpdateAchievementCriteria(CRITERIA_TYPE_LEARN_SKILL_LEVEL, id);

                // insert new entry or update if not deleted old entry yet
                if (status)
                {
                    status->pos = i;
                    status->uState = SKILL_CHANGED;
                }
                else
                {
                    auto insertR = mSkillStatus.insert(std::make_pair(id, SkillStatusData(i, SKILL_NEW)));
                    if (insertR.second)
                        (*mSkillStatusVector)[id] = &insertR.first->second;
                }

                // apply skill bonuses
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset, 0);
                SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset, 0);

                // temporary bonuses
                if (AuraEffectList const* mModSkill = GetAuraEffectsByType(SPELL_AURA_MOD_SKILL))
                    for (AuraEffectList::const_iterator j = mModSkill->begin(); j != mModSkill->end(); ++j)
                        if ((*j)->GetMiscValue() == int32(id))
                            (*j)->HandleEffect(this, AURA_EFFECT_HANDLE_SKILL, true);

                // temporary bonuses
                if (AuraEffectList const* mModSkill2 = GetAuraEffectsByType(SPELL_AURA_MOD_SKILL_2))
                    for (AuraEffectList::const_iterator j = mModSkill2->begin(); j != mModSkill2->end(); ++j)
                        if ((*j)->GetMiscValue() == int32(id))
                            (*j)->HandleEffect(this, AURA_EFFECT_HANDLE_SKILL, true);

                // permanent bonuses
                if (AuraEffectList const* mModSkillTalent = GetAuraEffectsByType(SPELL_AURA_MOD_SKILL_TALENT))
                    for (AuraEffectList::const_iterator j = mModSkillTalent->begin(); j != mModSkillTalent->end(); ++j)
                        if ((*j)->GetMiscValue() == int32(id))
                            (*j)->HandleEffect(this, AURA_EFFECT_HANDLE_SKILL, true);

                // Learn all spells for skill
                learnSkillRewardedSpells(id, newVal);
                return;
            }
        }
    }
}

bool Player::HasSkill(uint32 skill)
{
    if (!skill)
        return false;

    SkillStatusData* status = (*mSkillStatusVector)[skill];
    if (!status || status->uState == SKILL_DELETED)
        return false;

    return true;
}

uint16 Player::GetSkillStep(uint16 skill)
{
    if (!skill)
        return 0;

    SkillStatusData* status = (*mSkillStatusVector)[skill];
    if (!status || status->uState == SKILL_DELETED)
        return 0;

    uint16 field = status->pos / 2;
    uint8 offset = status->pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset);
}

uint16 Player::GetSkillValue(uint32 skill)
{
    if (!skill)
        return 0;

    SkillStatusData* status = (*mSkillStatusVector)[skill];
    if (!status || status->uState == SKILL_DELETED)
        return 0;

    uint16 field = status->pos / 2;
    uint8 offset = status->pos & 1;

    int32 result = int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset));

    return result < 0 ? 0 : result;
}

uint16 Player::GetMaxSkillValue(uint32 skill)
{
    if (!skill)
        return 0;

    SkillStatusData* status = (*mSkillStatusVector)[skill];
    if (!status || status->uState == SKILL_DELETED)
        return 0;

    uint16 field = status->pos / 2;
    uint8 offset = status->pos & 1;

    int32 result = int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset));
    return result < 0 ? 0 : result;
}

uint16 Player::GetPureMaxSkillValue(uint32 skill)
{
    if (!skill)
        return 0;

    SkillStatusData* status = (*mSkillStatusVector)[skill];
    if (!status || status->uState == SKILL_DELETED)
        return 0;

    uint16 field = status->pos / 2;
    uint8 offset = status->pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset);
}

uint16 Player::GetBaseSkillValue(uint32 skill)
{
    if (!skill)
        return 0;

    SkillStatusData* status = (*mSkillStatusVector)[skill];
    if (!status || status->uState == SKILL_DELETED)
        return 0;

    uint16 field = status->pos / 2;
    uint8 offset = status->pos & 1;

    int32 result = int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset));
    result += int32(GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset));
    return result < 0 ? 0 : result;
}

uint16 Player::GetPureSkillValue(uint32 skill)
{
    if (!skill)
        return 0;

    SkillStatusData* status = (*mSkillStatusVector)[skill];
    if (!status || status->uState == SKILL_DELETED)
        return 0;

    uint16 field = status->pos / 2;
    uint8 offset = status->pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset);
}

int16 Player::GetSkillPermBonusValue(uint32 skill)
{
    if (!skill)
        return 0;

    SkillStatusData* status = (*mSkillStatusVector)[skill];
    if (!status || status->uState == SKILL_DELETED)
        return 0;

    uint16 field = status->pos / 2;
    uint8 offset = status->pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset);
}

int16 Player::GetSkillTempBonusValue(uint32 skill)
{
    if (!skill)
        return 0;

    SkillStatusData* status = (*mSkillStatusVector)[skill];
    if (!status || status->uState == SKILL_DELETED)
        return 0;

    uint16 field = status->pos / 2;
    uint8 offset = status->pos & 1;

    return GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset);
}

void Player::SendActionButtons(uint32 state)
{
    WorldPackets::Spells::UpdateActionButtons packet;

    for (uint8 button = 0; button < MAX_ACTION_BUTTONS; ++button)
    {
        ActionButtonList::const_iterator itr = m_actionButtons.find(button);
        if (itr != m_actionButtons.end() && itr->second.uState != ACTIONBUTTON_DELETED)
            packet.ActionButtons[button] = itr->second.packedData;
        else
            packet.ActionButtons[button] = 0;
    }

    packet.Reason = state;

    SendDirectMessage(packet.Write());

    TC_LOG_INFO(LOG_FILTER_NETWORKIO, "Action Buttons for '%u' spec '%u' Sent", GetGUIDLow(), GetActiveTalentGroup());
}

bool Player::IsActionButtonDataValid(uint8 button, uint32 action, uint8 type)
{
    if (button >= MAX_ACTION_BUTTONS)
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER_LOADING, "Action %u not added into button %u for player %s: button must be < %u", action, button, GetName(), MAX_ACTION_BUTTONS);
        return false;
    }

    /*if (action >= MAX_ACTION_BUTTON_ACTION_VALUE)
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER_LOADING, "Action %u not added into button %u for player %s: action must be < %u", action, button, GetName(), MAX_ACTION_BUTTON_ACTION_VALUE);
        return false;
    }*/

    switch (type)
    {
        case ACTION_BUTTON_SPELL:
            if (!sSpellMgr->GetSpellInfo(action))
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER_LOADING, "Spell action %u not added into button %u for player %s: spell not exist", action, button, GetName());
                return false;
            }

            if (!HasSpell(action))
            {
                TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Player::IsActionButtonDataValid Spell action %u not added into button %u for player %s: player don't known this spell", action, button, GetName());
                return false;
            }
            break;
        case ACTION_BUTTON_ITEM:
            if (!sObjectMgr->GetItemTemplate(action))
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER_LOADING, "Item action %u not added into button %u for player %s: item not exist", action, button, GetName());
                return false;
            }
            break;
        case ACTION_BUTTON_MOUNT:
        {
            auto mount = sDB2Manager.GetMountById(action);
            if (!mount)
                return false;

            if (!GetCollectionMgr()->HasMount(mount->SourceSpellID))
                return false;
            break;
        }
        case ACTION_BUTTON_C:
        case ACTION_BUTTON_CMACRO:
        case ACTION_BUTTON_MACRO:
        case ACTION_BUTTON_EQSET:
            break;
        default:
            break;                                          // other cases not checked at this moment
    }

    return true;
}

bool Player::addActionButton(uint8 button, uint32 action, uint8 type, ActionButtonUpdateState state)
{
    if (!IsActionButtonDataValid(button, action, type))
        return false;

    // it create new button (NEW state) if need or return existed
    m_actionButtons.erase(button);
    m_actionButtons.emplace(button, ActionButton(action, type, state));

    TC_LOG_INFO(LOG_FILTER_PLAYER_LOADING, "Player '%u' Added Action '%u' (type %u) to Button '%u'", GetGUIDLow(), action, type, button);
    return true;
}

void Player::removeActionButton(uint8 button)
{
    ActionButtonList::iterator buttonItr = m_actionButtons.find(button);
    if (buttonItr == m_actionButtons.end() || buttonItr->second.uState == ACTIONBUTTON_DELETED)
        return;

    if (buttonItr->second.uState == ACTIONBUTTON_NEW)
        m_actionButtons.erase(buttonItr);                   // new and not saved
    else
        buttonItr->second.uState = ACTIONBUTTON_DELETED;    // saved, will deleted at next save

    TC_LOG_INFO(LOG_FILTER_PLAYER_LOADING, "Action Button '%u' Removed from Player '%u'", button, GetGUIDLow());
}

ActionButton const* Player::GetActionButton(uint8 button)
{
    ActionButtonList::iterator buttonItr = m_actionButtons.find(button);
    if (buttonItr == m_actionButtons.end() || buttonItr->second.uState == ACTIONBUTTON_DELETED)
        return NULL;

    return &buttonItr->second;
}

int8 Player::GetFreeActionButton()
{
    // 12 is max button of first action bar
    for (uint8 i = 0; i < 12; i++)
        if (!GetActionButton(i))
            return i;

    return -1;
}

bool Player::UpdatePosition(float x, float y, float z, float orientation, bool teleport, bool stop /*=false*/)
{
    // half opt method
    int gx=(int)(32-x/SIZE_OF_GRIDS);                       //grid x
    int gy=(int)(32-y/SIZE_OF_GRIDS);                       //grid y

    if (gx >= MAX_NUMBER_OF_GRIDS || gy >= MAX_NUMBER_OF_GRIDS)
    {
        //Ban
        // std::ostringstream ss;
        // ss << "Out of Map " << GetMapId() << " x:" << x << " y:" << y  << " z:" << z;
        // sWorld->BanAccount(BAN_CHARACTER,GetName(),"45d", ss.str().c_str(), "System");
        return false;
    }

    if (!Unit::UpdatePosition(x, y, z, orientation, teleport))
        return false;

    //if (movementInfo.flags & MOVEMENTFLAG_MOVING)
    //    mover->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MOVE);
    //if (movementInfo.flags & MOVEMENTFLAG_TURNING)
    //    mover->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TURNING);
    //AURA_INTERRUPT_FLAG_JUMP not sure

    SetGroupUpdateFlag(GROUP_UPDATE_FLAG_POSITION);

    if (GetTrader() && !IsWithinDistInMap(GetTrader(), INTERACTION_DISTANCE))
        GetSession()->SendCancelTrade();

    CheckAreaExploreAndOutdoor();

    return true;
}

void Player::SaveRecallPosition()
{
    m_recallLoc.m_mapId = GetMapId();
    m_recallLoc.m_positionX = GetPositionX();
    m_recallLoc.m_positionY = GetPositionY();
    m_recallLoc.m_positionZ = GetPositionZ();
    m_recallLoc.m_orientation = GetOrientation();
}

//! WARN! We shouldn't send at login range based packet.
//! For example SMSG_SPELL_EXECUTE_LOG
void Player::SendMessageToSetInRange(WorldPacket const* data, float dist, bool self, GuidUnorderedSet const& ignoredList /*= GuidUnorderedSet()*/)
{
    if (!IsInWorld())
        return;

    if (self)
        SendDirectMessage(data);

    Trinity::MessageDistDeliverer notifier(this, data, dist, false, nullptr, ignoredList);
    Trinity::VisitNearbyWorldObject(this, dist, notifier);
}

void Player::SendMessageToSetInRange(WorldPacket const* data, float dist, bool self, bool own_team_only, GuidUnorderedSet const& ignoredList /*= GuidUnorderedSet()*/)
{
    if (!IsInWorld())
        return;

    if (self)
        SendDirectMessage(data);

    Trinity::MessageDistDeliverer notifier(this, data, dist, own_team_only, nullptr, ignoredList);
    Trinity::VisitNearbyWorldObject(this, dist, notifier);
}

void Player::SendChatMessageToSetInRange(WorldPacket const* data, float dist, bool self, bool own_team_only, GuidUnorderedSet const& ignoredList /*= GuidUnorderedSet()*/)
{
    if (!IsInWorld())
        return;

    if (self)
        GetSession()->SendPacket(data);

    Trinity::MessageDistDeliverer notifier(this, data, dist, own_team_only, nullptr, ignoredList);
    Trinity::VisitNearbyWorldObject(this, dist, notifier);
}

void Player::SendMessageToSet(WorldPacket const* data, Player const* skipped_rcvr, GuidUnorderedSet const& ignoredList /*= GuidUnorderedSet()*/)
{
    if (!IsInWorld())
        return;

    if (skipped_rcvr != this)
        SendDirectMessage(data);

    // we use World::GetMaxVisibleDistance() because i cannot see why not use a distance
    // update: replaced by GetMap()->GetVisibilityDistance()
    Trinity::MessageDistDeliverer notifier(this, data, GetVisibilityRange(), false, skipped_rcvr, ignoredList);
    Trinity::VisitNearbyWorldObject(this, GetVisibilityRange(), notifier);
}

void Player::SendDirectMessage(WorldPacket const* data) const
{
    if (!IsDelete() && m_session)
        m_session->SendPacket(data);
}

void Player::SendCinematicStart(uint32 CinematicSequenceId)
{
    WorldPackets::Misc::TriggerCinematic packet;
    packet.CinematicID = CinematicSequenceId;
    SendDirectMessage(packet.Write());
}

void Player::SendMovieStart(uint32 MovieId)
{
    WorldPackets::Misc::TriggerMovie packet;
    packet.MovieID = MovieId;
    SendDirectMessage(packet.Write());

    // used for chacking plr state.
    setWatchinMovie(true);
    SetCanDelayTeleport(true);
}

bool Player::HasAreaExplored(uint32 AreaID)
{
    AreaTableEntry const* areaEntry = sDB2Manager.FindAreaEntry(AreaID);
    if (!areaEntry)
        return false;

    int offset = areaEntry->AreaBit / 32;
    if (offset >= PLAYER_EXPLORED_ZONES_SIZE)
        return false;

    uint32 val = (uint32)(1 << (areaEntry->AreaBit % 32));
    uint32 currFields = GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + offset);

    return currFields & val;
}

void Player::CheckAreaExploreAndOutdoor()
{
    if (!isAlive())
        return;

    if (isInFlight())
        return;

    bool isOutdoor = false;
    uint32 areaId = GetMap()->GetAreaId(GetPositionX(), GetPositionY(), GetPositionZ(), &isOutdoor);

    // Explore hack. Razorfen Kraul
    if (GetMapId() == 1 && areaId == 491)
        areaId = 5518;

    AreaTableEntry const* areaEntry = sAreaTableStore.LookupEntry(areaId);

    if (sWorld->getBoolConfig(CONFIG_VMAP_INDOOR_CHECK) && !isOutdoor)
        RemoveAurasWithAttribute(SPELL_ATTR0_OUTDOORS_ONLY);

    if (!areaId)
        return;

    if (!areaEntry)
        return;

    uint32 offset = areaEntry->AreaBit / 32;

    if (offset >= PLAYER_EXPLORED_ZONES_SIZE)
        return;

    uint32 val = (uint32)(1 << (areaEntry->AreaBit % 32));
    uint32 currFields = GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + offset);

    if (!(currFields & val))
    {
        SetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + offset, (uint32)(currFields | val));

        UpdateAchievementCriteria(CRITERIA_TYPE_EXPLORE_AREA);

        if (areaEntry->ExplorationLevel > 0)
        {
            GetCheatData()->OnExplore(areaEntry);
            if (getLevel() >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
                SendExplorationExperience(areaId, 0);
            else
            {
                int32 diff = int32(getLevel()) - areaEntry->ExplorationLevel;
                uint32 XP = 0;

                float ExploreXpRate = 1;
                if (float rate = GetSession()->GetPersonalXPRate())
                    ExploreXpRate = rate;
                else if (GetPersonnalXpRate())
                    ExploreXpRate = GetPersonnalXpRate();
                else
                    ExploreXpRate = sWorld->getRate(RATE_XP_EXPLORE);

                if (diff < -5)
                    XP = uint32(sObjectMgr->GetBaseXP(getLevel() + 5) * ExploreXpRate);
                else if (diff > 5)
                    XP = uint32(sObjectMgr->GetBaseXP(areaEntry->ExplorationLevel) * std::max(0, std::min((100 - ((diff - 5) * 5)), 100)) / 100 * ExploreXpRate);
                else
                    XP = uint32(sObjectMgr->GetBaseXP(areaEntry->ExplorationLevel) * ExploreXpRate);

                GiveXP(XP, NULL);
                SendExplorationExperience(areaId, XP);
            }
            TC_LOG_DEBUG(LOG_FILTER_PLAYER, "Player %u discovered a new area: %u", GetGUIDLow(), areaId);

            AddDelayedEvent(100, [this]() -> void
            {
                GetPhaseMgr().RemoveUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);
            });
        }
    }
}

uint32 Player::TeamForRace(uint8 race)
{
    if (ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race))
    {
        switch (rEntry->Alliance)
        {
            case 0: return ALLIANCE;
            case 1: return HORDE;
            case 2: return PANDAREN_NEUTRAL;
        }
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Race (%u) has wrong teamid (%u) in DBC: wrong DBC files?", uint32(race), rEntry->Alliance);
    }
    else
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Race (%u) not found in DBC: wrong DBC files?", uint32(race));

    return ALLIANCE;
}

void Player::SwitchToOppositeTeam(bool apply)
{
    m_team = GetNativeTeam();

    if (apply)
        m_team = (m_team == ALLIANCE) ? HORDE : ALLIANCE;
}

uint32 Player::GetBgQueueTeam() const
{
    if (HasAura(SPELL_MERCENARY_CONTRACT_HORDE))
        return HORDE;

    if (HasAura(SPELL_MERCENARY_CONTRACT_ALLIANCE))
        return ALLIANCE;

    return GetTeam();
}

void Player::setFactionForRace(uint8 race)
{
    m_team = TeamForRace(race);

    ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race);
    setFaction(rEntry ? rEntry->FactionID : 0);
}

ReputationRank Player::GetReputationRank(uint32 faction) const
{
    FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction);
    return GetReputationMgr().GetRank(factionEntry);
}

//Calculate total reputation percent player gain with quest/creature level
int32 Player::CalculateReputationGain(uint32 creatureOrQuestLevel, int32 rep, int32 faction, Quest const* quest, bool noQuestBonus)
{
    float percent = 100.0f;

    // Get the generic rate first
    if (RepRewardRate const* repData = sObjectMgr->GetRepRewardRate(faction))
    {
        float repRate = quest ? repData->quest_rate : repData->creature_rate;
        percent *= repRate;
    }

    float rate = quest ? sWorld->getRate(RATE_REPUTATION_LOWLEVEL_QUEST) : sWorld->getRate(RATE_REPUTATION_LOWLEVEL_KILL);

    if (rate != 1.0f && creatureOrQuestLevel < Trinity::XP::GetGrayLevel(getLevel()))
        percent *= rate;

    float repMod = 0.0f;
    if (!noQuestBonus)
    {
        repMod += GetTotalAuraModifierByMiscValues(SPELL_AURA_MOD_REPUTATION_GAIN, 0, 0); // For default rep
        repMod += GetTotalAuraModifierByMiscValues(SPELL_AURA_MOD_REPUTATION_GAIN, faction, 0);
        if (quest)
        {
            if (quest->IsWorld())
                repMod += GetTotalAuraModifierByMiscValues(SPELL_AURA_MOD_REPUTATION_GAIN, faction, 1);
            repMod += GetTotalAuraModifierByMiscValues(SPELL_AURA_MOD_REPUTATION_GAIN, faction, 3);
        }
    }

    if (!quest)
        repMod += GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_FACTION_REPUTATION_GAIN, faction);

    percent += rep > 0 ? repMod : -repMod;

    if (percent <= 0.0f)
        return 0;

    return int32(rep*percent/100);
}

//Calculates how many reputation points player gains in victim's enemy factions
void Player::RewardReputation(Unit* victim, float rate, bool killer)
{
    if (!victim || victim->IsPlayer())
        return;

    if (victim->ToCreature()->IsReputationGainDisabled())
        return;

    std::vector<ReputationOnKillEntry> const* RepList = sObjectMgr->GetReputationOnKilEntry(victim->ToCreature()->GetCreatureTemplate()->Entry);
    if (!RepList || RepList->empty())
        return;

    uint32 ChampioningFaction = 0;

    if (GetChampioningFaction())
    {
        // support for: Championing - http://www.wowwiki.com/Championing

        Map const* map = GetMap();
        if (map && map->IsDungeon())
        {
            uint32 dungeonLevel = GetChampioningFactionDungeonLevel();
            if (dungeonLevel)
            {
                InstanceTemplate const *instance = sObjectMgr->GetInstanceTemplate(map->GetId());
                if (instance)
                {
                    AccessRequirement const *pAccessRequirement = sObjectMgr->GetAccessRequirement(map->GetId(), (static_cast<InstanceMap const*>(map))->GetDifficultyID());
                    if (pAccessRequirement)
                    {
                        if (!map->IsRaid() && pAccessRequirement->levelMin >= dungeonLevel)
                            ChampioningFaction = GetChampioningFaction();
                    }
                }
            }
            else
                ChampioningFaction = GetChampioningFaction();
        }
    }

    // Favored reputation increase START
    float favored_rep_mult = 0;

    if ((HasAura(32096) || HasAura(32098)) && (m_zoneId == 3483 || m_zoneId == 3562 || m_zoneId == 3836 || m_zoneId == 3713 || m_zoneId == 3714)) favored_rep_mult = 0.25; // Thrallmar's Favor and Honor Hold's Favor

    if (favored_rep_mult > 0) favored_rep_mult *= 2; // Multiplied by 2 because the reputation is divided by 2 for some reason (See "donerep / 2" and "donerep2 / 2") -- if you know why this is done, please update/explain :)
    // Favored reputation increase END

    float recruitAFriend = GetsAFriendBonus(false);

    for (std::vector<ReputationOnKillEntry>::const_iterator Rep = RepList->begin(); Rep != RepList->end(); ++Rep)
    {
        if (Rep->RepFaction)
        {
            int32 donerep = CalculateReputationGain(victim->getLevelForTarget(this), Rep->RepValue, ChampioningFaction ? ChampioningFaction : Rep->RepFaction, nullptr);
            donerep = int32(donerep*(rate + favored_rep_mult));

            if (recruitAFriend)
                donerep = int32(donerep * (1 + sWorld->getRate(RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS)));

            FactionEntry const* factionEntry = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : Rep->RepFaction);
            if (!factionEntry)
                continue;

            uint32 reputationRank = GetReputationMgr().GetRank(factionEntry);
            if (reputationRank < Rep->ReputationCap)
                GetReputationMgr().ModifyReputation(factionEntry, donerep);

            // log Army of the Light and Argussian Reach reputation
            if (factionEntry->ID == 2165 || factionEntry->ID == 2170)
                sLog->outWarden("Player %s (GUID: %u) adds a reputation value %d (%u) for kill creature with entry %u", GetName(), GetGUIDLow(), donerep, factionEntry->ID, victim->ToCreature()->GetEntry());

            //if (Rep->ReputationCap == REP_EXALTED)
                //GetReputationMgr().ModifyParagonReputation(factionEntry, donerep);
        }
        else if (ChampioningFaction) // Implementation for cataclysm with empty default faction
        {
            int32 donerep = CalculateReputationGain(victim->getLevelForTarget(this), Rep->RepValue, ChampioningFaction, nullptr);
            donerep = int32(donerep*(rate + favored_rep_mult));

            if (recruitAFriend)
                donerep = int32(donerep * (1 + sWorld->getRate(RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS)));

            FactionEntry const* factionEntry = sFactionStore.LookupEntry(ChampioningFaction);
            if (!factionEntry)
                continue;

            uint32 reputationRank = GetReputationMgr().GetRank(factionEntry);
            if (reputationRank < Rep->ReputationCap)
                GetReputationMgr().ModifyReputation(factionEntry, donerep);

            // log Army of the Light and Argussian Reach reputation
            if (factionEntry->ID == 2165 || factionEntry->ID == 2170)
                sLog->outWarden("Player %s (GUID: %u) adds a reputation value %d (%u) for kill creature with entry %u", GetName(), GetGUIDLow(), donerep, factionEntry->ID, victim->ToCreature()->GetEntry());

            //if (Rep->ReputationCap == REP_EXALTED)
                //GetReputationMgr().ModifyParagonReputation(factionEntry, donerep);
        }
    }
}

void Player::RewardReputation(Quest const* quest)
{
    float recruitAFriend = GetsAFriendBonus(false);

    for (uint8 i = 0; i < QUEST_REWARD_REPUTATIONS_COUNT; ++i)
    {
        if (!quest->RewardFactionId[i])
            continue;

        FactionEntry const* factionEntry = sFactionStore.LookupEntry(quest->RewardFactionId[i]);
        if (!factionEntry)
            continue;

        int32 rep = 0;
        if (quest->RewardFactionOverride[i])
            rep = CalculateReputationGain(GetQuestLevel(quest), quest->RewardFactionOverride[i] / 100, quest->RewardFactionId[i], quest, true);
        else if (QuestFactionRewardEntry const* pRow = sQuestFactionRewardStore.LookupEntry(((quest->RewardFactionValue[i] < 0) ? 1 : 0) + 1))
            rep = CalculateReputationGain(GetQuestLevel(quest), pRow->Difficulty[abs(quest->RewardFactionValue[i])], quest->RewardFactionId[i], quest);

        if (!rep)
            continue;

        if (recruitAFriend)
            rep = int32(rep * (1 + sWorld->getRate(RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS)));

        uint32 reputationRank = GetReputationMgr().GetRank(factionEntry);

        if (!quest->RewardFactionCapIn[i] || quest->RewardFactionCapIn[i] == REP_EXALTED)
            GetReputationMgr().ModifyParagonReputation(factionEntry, rep);

        // log Army of the Light and Argussian Reach reputation
        if (factionEntry->ID == 2165 || factionEntry->ID == 2170)
            sLog->outWarden("Player %s (GUID: %u) adds a %s reputation value %d (%u) for quest %u", GetName(), GetGUIDLow(), GetReputationMgr().GetRank(factionEntry) == REP_EXALTED ? "paragon" : "", rep, factionEntry->ID, quest->Id);

        if (quest->RewardFactionCapIn[i] && rep > 0 && reputationRank >= quest->RewardFactionCapIn[i])
            continue;

        GetReputationMgr().ModifyReputation(factionEntry, rep, (quest->RewardFactionFlags & (1 << i)) != 0);
    }
}

void Player::RewardGuildReputation(Quest const* quest)
{
    uint32 rep = 0;

    switch (Trinity::GetExpansionForLevel(getLevel()))
    {
        case EXPANSION_CLASSIC:                 rep = 25;  break;
        case EXPANSION_THE_BURNING_CRUSADE:     rep = 50;  break;
        case EXPANSION_WRATH_OF_THE_LICH_KING:  rep = 75;  break;
        case EXPANSION_CATACLYSM:               rep = 100; break;
        case EXPANSION_MISTS_OF_PANDARIA:       rep = 150; break;
        case EXPANSION_WARLORDS_OF_DRAENOR:     rep = 200; break;
        case EXPANSION_LEGION:                  rep = 250; break;
        default:                                rep = 0;   break;
    }

    rep = CalculateReputationGain(GetQuestLevel(quest), rep, REP_GUILD, quest);

    if (GetsAFriendBonus(false))
        rep = int32(rep * (1 + sWorld->getRate(RATE_REPUTATION_RECRUIT_A_FRIEND_BONUS)));

    if (Guild* guild = sGuildMgr->GetGuildById(GetGuildId()))
        guild->RewardReputation(this, rep);
}

void Player::UpdateHonorFields(bool loading /*= false*/)
{
    if (loading)
    {
        if (getLevel() == MAX_LEVEL)
        {
            if (GtHonorLevelEntry const* data = sHonorLevelGameTable.GetRow(m_honorInfo.NextHonorLevel))
            {
                if (m_honorInfo.CurrentHonorAtLevel && m_honorInfo.CurrentHonorAtLevel >= data->Prestige[m_honorInfo.PrestigeLevel])
                {
                    while (m_honorInfo.CurrentHonorAtLevel && m_honorInfo.CurrentHonorAtLevel >= data->Prestige[m_honorInfo.PrestigeLevel])
                    {
                        if (m_honorInfo.HonorLevel == m_honorInfo.MaxHonorLevel)
                            break;

                        m_honorInfo.CurrentHonorAtLevel -= data->Prestige[m_honorInfo.PrestigeLevel];
                        m_honorInfo.IncreaseHonorLevel();

                        if (GtHonorLevelEntry const* data2 = sHonorLevelGameTable.GetRow(m_honorInfo.NextHonorLevel))
                            m_honorInfo.NextHonorAtLevel = data2->Prestige[m_honorInfo.PrestigeLevel];

                        UpdateAchievementCriteria(CRITERIA_TYPE_HONOR_LEVEL_UP, m_honorInfo.HonorLevel);
                        if (m_honorInfo.HonorLevel == m_honorInfo.MaxHonorLevel)
                            break;
                    }
                }
                else
                    m_honorInfo.NextHonorAtLevel = data->Prestige[m_honorInfo.PrestigeLevel];
            }

            SetUInt32Value(PLAYER_FIELD_HONOR, m_honorInfo.CurrentHonorAtLevel);
            SetUInt32Value(PLAYER_FIELD_HONOR_LEVEL, m_honorInfo.HonorLevel);
            SetUInt32Value(PLAYER_FIELD_HONOR_NEXT_LEVEL, m_honorInfo.NextHonorAtLevel);
            SetUInt32Value(PLAYER_FIELD_PRESTIGE, m_honorInfo.PrestigeLevel);
        }
    }

    time_t now = time_t(time(nullptr));
    time_t today = time_t(time(nullptr) / DAY) * DAY;
    if (m_lastHonorUpdateTime < today)
    {
        SetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, m_lastHonorUpdateTime >= time_t(today - DAY) ? MAKE_PAIR32(0, PAIR32_LOPART(GetUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS))) : 0);

        m_killsPerPlayer.clear();
        m_flushKills = true;
    }

    m_lastHonorUpdateTime = now;
}

///Calculate the amount of honor gained based on the victim
///and the size of the group for which the honor is divided
///An exact honor value can also be given (overriding the calcs)
bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvptoken)
{
    // 'Inactive' this aura prevents the player from gaining honor points and battleground tokens
    if (HasAura(SPELL_BG_AURA_PLAYER_INACTIVE))
        return false;

    ObjectGuid victimGuid;
    uint32 victimRank = 0;

    // need call before fields update to have chance move yesterday data to appropriate fields before today data change.
    UpdateHonorFields();

    // Promote to float for calculations
    float honor_f = (float)honor;
    float honorLimitRate = 1.0f;

    if (!InBattleground() && IsPlayer() && (victim) && victim->IsPlayer())
    {
        uint8 limit = 6;

        KillInfo &info = m_killsPerPlayer[victim->GetGUIDLow()];
        // gradually decrease the honor for subsequent kills
        // no honor reward for killing a player more than 'limit' times per day
        honorLimitRate = (float)(limit - info.count) / (float)limit;

        // if the kill is not present in the DB keep in new state so it will be insterted
        // otherwise adding a kill means it will need to be updated
        if (info.state != KILL_NEW)
            info.state = KILL_CHANGED;

        // count the number of times a certain player was killed in one day
        if (info.count < limit)
            ++info.count;

        if (honorLimitRate <= 0.0f)
            return false;
    }

    if (honor_f <= 0)
    {
        if (!victim || victim == this || victim->HasAuraType(SPELL_AURA_NO_PVP_CREDIT))
            return false;

        victimGuid = victim->GetGUID();

        if (Player* plrVictim = victim->ToPlayer())
        {
            if (GetTeam() == plrVictim->GetTeam() && (!sWorld->IsFFAPvPRealm() && !(InBattleground() && sWorld->getBoolConfig(CONFIG_CROSSFACTIONBG))))
                return false;

            uint8 k_level = getLevelForTarget(victim);
            uint8 k_grey = Trinity::XP::GetGrayLevel(k_level);
            uint8 v_level = victim->getLevelForTarget(this);

            if (v_level <= k_grey)
                return false;

            // PLAYER_FIELD_PLAYER_TITLE VALUES DESCRIPTION
            //  [0]      Just name
            //  [1..14]  Alliance honor titles and player name
            //  [15..28] Horde honor titles and player name
            //  [29..38] Other title and player name
            //  [39+]    Nothing
            uint32 victim_title = victim->GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE);
            // Get Killer titles, CharTitlesEntry::bit_index
            // Ranks:
            //  title[1..14]  -> rank[5..18]
            //  title[15..28] -> rank[5..18]
            //  title[other]  -> 0
            if (victim_title == 0)
                victimGuid.Clear();                        // Don't show HK: <rank> message, only log.
            else if (victim_title < 15)
                victimRank = victim_title + 4;
            else if (victim_title < 29)
                victimRank = victim_title - 14 + 4;
            else
                victimGuid.Clear();                        // Don't show HK: <rank> message, only log.

            honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey) * 0.01f);

            ApplyModUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1, true);
            ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);

            UpdateAchievementCriteria(CRITERIA_TYPE_EARN_HONORABLE_KILL);
            UpdateAchievementCriteria(CRITERIA_TYPE_HK_CLASS, victim->getClass());
            UpdateAchievementCriteria(CRITERIA_TYPE_HK_RACE, victim->getRace());
            UpdateAchievementCriteria(CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, GetCurrentAreaID());
            UpdateAchievementCriteria(CRITERIA_TYPE_HONORABLE_KILL, 1, 0, 0, victim);

            if (Guild* guild = sGuildMgr->GetGuildById(GetGuildId()))
                guild->UpdateAchievementCriteria(CRITERIA_TYPE_HONORABLE_KILLS_GUILD, 1, 0, 0, victim, this);

            m_saveKills = true;
        }
		else if (sWorld->getBoolConfig(CONFIG_GAIN_HONOR_GUARD) && victim->ToCreature()->isGuard())
		{
			uint8 k_level = getLevel();
			uint8 k_grey = Trinity::XP::GetGrayLevel(k_level);
			uint8 v_level = victim->getLevel();

			if (v_level <= k_grey)
				return false;

			uint32 victim_title = 0;
			victimGuid = ObjectGuid::Empty;

			honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));

			// count the number of playerkills in one day
			ApplyModUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1, true);
			// and those in a lifetime
			ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
			UpdateAchievementCriteria(CRITERIA_TYPE_EARN_HONORABLE_KILL);
			UpdateAchievementCriteria(CRITERIA_TYPE_HK_CLASS, victim->getClass());
			UpdateAchievementCriteria(CRITERIA_TYPE_HK_RACE, victim->getRace());
			UpdateAchievementCriteria(CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, GetAreaId());
			UpdateAchievementCriteria(CRITERIA_TYPE_HONORABLE_KILL, 1, 0, 0, victim);
		}
		else if (sWorld->getBoolConfig(CONFIG_GAIN_HONOR_ELITE) && victim->ToCreature()->isElite())
		{
			uint8 k_level = getLevel();
			uint8 k_grey = Trinity::XP::GetGrayLevel(k_level);
			uint8 v_level = victim->getLevel();

			if (v_level <= k_grey)
				return false;

			uint32 victim_title = 0;
			victimGuid = ObjectGuid::Empty;
			honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));
			// count the number of playerkills in one day
			ApplyModUInt32Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1, true);

			// and those in a lifetime
			ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
			UpdateAchievementCriteria(CRITERIA_TYPE_EARN_HONORABLE_KILL);
			UpdateAchievementCriteria(CRITERIA_TYPE_HK_CLASS, victim->getClass());
			UpdateAchievementCriteria(CRITERIA_TYPE_HK_RACE, victim->getRace());
			UpdateAchievementCriteria(CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, GetAreaId());
			UpdateAchievementCriteria(CRITERIA_TYPE_HONORABLE_KILL, 1, 0, 0, victim);
		}
        else
        {
            if (!victim->ToCreature()->isRacialLeader())
                return false;

            honor_f = 100.0f;                               // ??? need more info
            victimRank = 19;                               // HK: Leader
        }
    }

    if (victim != NULL)
    {
        honor_f *= sWorld->getRate(RATE_HONOR);
        if (groupsize > 1)
            honor_f /= groupsize;
    }
    else
        honor_f *= sWorld->getRate(RATE_HONOR_QB);

    // Back to int now
    honor = int32(ceilf(honor_f));
    honor *= honorLimitRate; // Anty farm limit

    if (victim)
        honor *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_HONOR_POINTS_GAIN_BY_TYPE_MASK, 1);

    if (auto bg = GetBattleground())
    {
        if (bg->IsSkirmish())
            honor *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_HONOR_POINTS_GAIN_BY_TYPE_MASK, 256);

        honor *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_HONOR_POINTS_GAIN_BY_TYPE_MASK, 512);
        honor *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_HONOR_POINTS_GAIN_BY_TYPE_MASK, 553);
        honor *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_HONOR_POINTS_GAIN_BY_TYPE_MASK, 1004);
    }

    honor *= GetTotalAuraMultiplier(SPELL_AURA_SPELL_AURA_MOD_HONOR_POINTS_GAIN);

    WorldPackets::Combat::PvPCredit credit;
    credit.Honor = honor;
    credit.Rank = victimRank;
    credit.Target = victimGuid;
    SendDirectMessage(credit.Write());

    // add honor points
    if (getLevel() >= MAX_LEVEL)
        CurrencyChanged(CURRENCY_TYPE_HONOR_POINTS, int32(honor));

    if (InBattleground() && honor > 0)
        if (Battleground* bg = GetBattleground())
            bg->UpdatePlayerScore(this, SCORE_BONUS_HONOR, honor, false); //false: prevent looping

    if (sWorld->getBoolConfig(CONFIG_PVP_TOKEN_ENABLE) && pvptoken)
    {
        if (!victim || victim == this || victim->HasAuraType(SPELL_AURA_NO_PVP_CREDIT))
            return true;

        if (victim->IsPlayer())
        {
            // Check if allowed to receive it in current map
            uint8 MapType = sWorld->getIntConfig(CONFIG_PVP_TOKEN_MAP_TYPE);
            if ((MapType == 1 && !InBattleground() && !IsFFAPvP()) || (MapType == 2 && !IsFFAPvP()) || (MapType == 3 && !InBattleground()))
                return true;

            if (GetOutdoorPvP())
                GetOutdoorPvP()->HandleRewardHonor(this);

            if (AddItem(sWorld->getIntConfig(CONFIG_PVP_TOKEN_ID), sWorld->getIntConfig(CONFIG_PVP_TOKEN_COUNT)))
                ChatHandler(this).PSendSysMessage("You have been awarded a token for slaying another player.");
        }
    }

    return true;
}

void Player::_LoadCurrency(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();

        uint16 currencyID = fields[0].GetUInt16();

        CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(currencyID);
        if (!currency)
        {
            CharacterDatabase.PExecute("DELETE FROM character_currency WHERE currency = '%u'", currencyID);
            continue;
        }

        PlayerCurrency cur;
        cur.state = PLAYERCURRENCY_UNCHANGED;
        cur.weekCount = fields[1].GetUInt32();
        cur.totalCount = fields[2].GetUInt32();
        cur.seasonTotal = fields[3].GetUInt32();
        cur.flags = fields[4].GetUInt8() & PLAYERCURRENCY_MASK_USED_BY_CLIENT;
        cur.curentCap = fields[5].GetUInt32();
        cur.currencyEntry = currency;

        _currencyStorage.insert(std::make_pair(currencyID, cur));

    } while (result->NextRow());
}

void Player::_SaveCurrency(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    for (PlayerCurrenciesMap::iterator itr = _currencyStorage.begin(); itr != _currencyStorage.end(); ++itr)
    {
        CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(itr->first);
        if (!entry) // should never happen
            continue;

        switch(itr->second.state)
        {
        case PLAYERCURRENCY_NEW:
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_PLAYER_CURRENCY);
            stmt->setUInt64(0, GetGUIDLow());
            stmt->setUInt16(1, itr->first);
            stmt->setUInt32(2, itr->second.weekCount);
            stmt->setUInt32(3, itr->second.totalCount);
            stmt->setUInt32(4, itr->second.seasonTotal);
            stmt->setUInt8(5, itr->second.flags);
            stmt->setUInt32(6, itr->second.curentCap);
            trans->Append(stmt);
            break;
        case PLAYERCURRENCY_CHANGED:
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_PLAYER_CURRENCY);
            stmt->setUInt32(0, itr->second.weekCount);
            stmt->setUInt32(1, itr->second.totalCount);
            stmt->setUInt32(2, itr->second.seasonTotal);
            stmt->setUInt8(3, itr->second.flags);
            stmt->setUInt32(4, itr->second.curentCap);
            stmt->setUInt64(5, GetGUIDLow());
            stmt->setUInt16(6, itr->first);
            trans->Append(stmt);
            break;
        default:
            break;
        }

        itr->second.state = PLAYERCURRENCY_UNCHANGED;
    }
}

void Player::SendCurrencies()
{
    WorldPackets::Misc::SetupCurrency packet;
    packet.Data.reserve(_currencyStorage.size());
    for (auto const& v : _currencyStorage)
    {
        WorldPackets::Misc::SetupCurrency::Record record;
        record.Type = v.first;
        record.Quantity = v.second.totalCount;
        record.WeeklyQuantity = v.second.weekCount;
        record.MaxWeeklyQuantity = GetCurrencyWeekCap(v.first);
        record.TrackedQuantity = v.second.seasonTotal;
        if (v.second.currencyEntry->Flags & CURRENCY_FLAG_SEND_CAP)
            record.MaxQuantity = GetTotalCurrencyCap(v.first);
        record.Flags = v.second.flags;
        packet.Data.push_back(record);
    }

    SendDirectMessage(packet.Write());
}

void Player::ModifyCurrencyFlag(uint32 id, uint8 flag)
{
    if (!id)
        return;

    if (_currencyStorage.find(id) == _currencyStorage.end())
        return;

    _currencyStorage[id].flags = flag;
    if (_currencyStorage[id].state != PLAYERCURRENCY_NEW)
        _currencyStorage[id].state = PLAYERCURRENCY_CHANGED;
}

void Player::SendPvpRewards()
{
    bool isAlliance = GetTeam() == ALLIANCE;
    WorldPackets::Battleground::RequestPVPRewardsResponse rewardsResponse;

    if (PvpReward* reward = sBattlegroundMgr->GetPvpReward(PvpReward_BG))
    {
        uint32 ItemCA = 0;
        uint32 questId = isAlliance ? reward->QuestAlose : reward->QuestHLose;
        if (!HasWinToday(PvpReward_BG))
        {
            ItemCA = reward->ItemCAFirst;
            questId = isAlliance ? reward->QuestAFirst : reward->QuestHFirst;
        }
        else
        {
            ItemCA = reward->ItemCAWin;
            questId = isAlliance ? reward->QuestAWin : reward->QuestHWin;
        }

        if (ItemCA)
            rewardsResponse.RandomBGRewards.Item.push_back(ItemCA);

        uint32 ChestID = isAlliance ? reward->ChestA : reward->ChestH;
        if (ChestID)
            rewardsResponse.RandomBGRewards.Item.push_back(ChestID);

        if (!reward->ItemsA.empty())
            rewardsResponse.RandomBGRewards.Item.push_back(Trinity::Containers::SelectRandomContainerElement(isAlliance ? reward->ItemsA : reward->ItemsH));

        if (Quest const* quest = sQuestDataStore->GetQuestTemplate(questId))
        {
            if (quest->RewardHonor)
                rewardsResponse.RandomBGRewards.RewardHonor = quest->RewardHonor;
            if (quest->RewardSpell)
                rewardsResponse.RandomBGRewards.RewardSpellID = quest->RewardSpell;
            for (uint32 i = 0; i < QUEST_REWARD_CURRENCY_COUNT; ++i)
            {
                if (quest->RewardCurrencyId[i])
                    rewardsResponse.RandomBGRewards.Currency.emplace_back(quest->RewardCurrencyId[i], quest->RewardCurrencyCount[i]);
            }
        }
    }

    if (PvpReward* reward = sBattlegroundMgr->GetPvpReward(PvpReward_RBG))
    {
        uint32 ItemCA = 0;
        uint32 questId = isAlliance ? reward->QuestAlose : reward->QuestHLose;
        if (!HasWinToday(PvpReward_RBG))
        {
            ItemCA = reward->ItemCAFirst;
            questId = isAlliance ? reward->QuestAFirst : reward->QuestHFirst;
        }
        else
        {
            ItemCA = reward->ItemCAWin;
            questId = isAlliance ? reward->QuestAWin : reward->QuestHWin;
        }

        if (ItemCA)
            rewardsResponse.RatedBGRewards.Item.push_back(ItemCA);

        uint32 ChestID = isAlliance ? reward->ChestA : reward->ChestH;
        if (ChestID)
            rewardsResponse.RatedBGRewards.Item.push_back(ChestID);

        if (!reward->ItemsA.empty())
            rewardsResponse.RatedBGRewards.Item.push_back(Trinity::Containers::SelectRandomContainerElement(isAlliance ? reward->ItemsA : reward->ItemsH));

        if (Quest const* quest = sQuestDataStore->GetQuestTemplate(questId))
        {
            if (quest->RewardHonor)
                rewardsResponse.RatedBGRewards.RewardHonor = quest->RewardHonor;
            if (quest->RewardSpell)
                rewardsResponse.RatedBGRewards.RewardSpellID = quest->RewardSpell;
            for (uint32 i = 0; i < QUEST_REWARD_CURRENCY_COUNT; ++i)
            {
                if (quest->RewardCurrencyId[i])
                    rewardsResponse.RatedBGRewards.Currency.emplace_back(quest->RewardCurrencyId[i], quest->RewardCurrencyCount[i]);
            }
        }
    }

    if (PvpReward* reward = sBattlegroundMgr->GetPvpReward(PvpReward_Skirmish))
    {
        uint32 ItemCA = 0;
        uint32 questId = isAlliance ? reward->QuestAlose : reward->QuestHLose;
        if (!HasWinToday(PvpReward_Skirmish))
        {
            ItemCA = reward->ItemCAFirst;
            questId = isAlliance ? reward->QuestAFirst : reward->QuestHFirst;
        }
        else
        {
            ItemCA = reward->ItemCAWin;
            questId = isAlliance ? reward->QuestAWin : reward->QuestHWin;
        }

        if (ItemCA)
            rewardsResponse.ArenaSkirmishRewards.Item.push_back(ItemCA);

        uint32 ChestID = isAlliance ? reward->ChestA : reward->ChestH;
        if (ChestID)
            rewardsResponse.ArenaSkirmishRewards.Item.push_back(ChestID);

        if (!reward->ItemsA.empty())
            rewardsResponse.ArenaSkirmishRewards.Item.push_back(Trinity::Containers::SelectRandomContainerElement(isAlliance ? reward->ItemsA : reward->ItemsH));

        if (Quest const* quest = sQuestDataStore->GetQuestTemplate(questId))
        {
            if (quest->RewardHonor)
                rewardsResponse.ArenaSkirmishRewards.RewardHonor = quest->RewardHonor;
            if (quest->RewardSpell)
                rewardsResponse.ArenaSkirmishRewards.RewardSpellID = quest->RewardSpell;
            for (uint32 i = 0; i < QUEST_REWARD_CURRENCY_COUNT; ++i)
            {
                if (quest->RewardCurrencyId[i])
                    rewardsResponse.ArenaSkirmishRewards.Currency.emplace_back(quest->RewardCurrencyId[i], quest->RewardCurrencyCount[i]);
            }
        }
    }

    if (PvpReward* reward = sBattlegroundMgr->GetPvpReward(PvpReward_Arena_2v2))
    {
        uint32 ItemCA = 0;
        uint32 questId = isAlliance ? reward->QuestAlose : reward->QuestHLose;
        if (!HasWinToday(PvpReward_Arena_2v2))
        {
            ItemCA = reward->ItemCAFirst;
            questId = isAlliance ? reward->QuestAFirst : reward->QuestHFirst;
        }
        else
        {
            ItemCA = reward->ItemCAWin;
            questId = isAlliance ? reward->QuestAWin : reward->QuestHWin;
        }

        if (ItemCA)
            rewardsResponse.ArenaRewards2v2.Item.push_back(ItemCA);

        uint32 ChestID = isAlliance ? reward->ChestA : reward->ChestH;
        if (ChestID)
            rewardsResponse.ArenaRewards2v2.Item.push_back(ChestID);

        if (!reward->ItemsA.empty())
            rewardsResponse.ArenaRewards2v2.Item.push_back(Trinity::Containers::SelectRandomContainerElement(isAlliance ? reward->ItemsA : reward->ItemsH));

        if (Quest const* quest = sQuestDataStore->GetQuestTemplate(questId))
        {
            if (quest->RewardHonor)
                rewardsResponse.ArenaRewards2v2.RewardHonor = quest->RewardHonor;
            if (quest->RewardSpell)
                rewardsResponse.ArenaRewards2v2.RewardSpellID = quest->RewardSpell;
            for (uint32 i = 0; i < QUEST_REWARD_CURRENCY_COUNT; ++i)
            {
                if (quest->RewardCurrencyId[i])
                    rewardsResponse.ArenaRewards2v2.Currency.emplace_back(quest->RewardCurrencyId[i], quest->RewardCurrencyCount[i]);
            }
        }
    }

    if (PvpReward* reward = sBattlegroundMgr->GetPvpReward(PvpReward_Arena_3v3))
    {
        uint32 ItemCA = 0;
        uint32 questId = isAlliance ? reward->QuestAlose : reward->QuestHLose;
        if (!HasWinToday(PvpReward_Arena_3v3))
        {
            ItemCA = reward->ItemCAFirst;
            questId = isAlliance ? reward->QuestAFirst : reward->QuestHFirst;
        }
        else
        {
            ItemCA = reward->ItemCAWin;
            questId = isAlliance ? reward->QuestAWin : reward->QuestHWin;
        }

        if (ItemCA)
            rewardsResponse.ArenaRewards3v3.Item.push_back(ItemCA);

        uint32 ChestID = isAlliance ? reward->ChestA : reward->ChestH;
        if (ChestID)
            rewardsResponse.ArenaRewards3v3.Item.push_back(ChestID);

        if (!reward->ItemsA.empty())
            rewardsResponse.ArenaRewards3v3.Item.push_back(Trinity::Containers::SelectRandomContainerElement(isAlliance ? reward->ItemsA : reward->ItemsH));

        if (Quest const* quest = sQuestDataStore->GetQuestTemplate(questId))
        {
            if (quest->RewardHonor)
                rewardsResponse.ArenaRewards3v3.RewardHonor = quest->RewardHonor;
            if (quest->RewardSpell)
                rewardsResponse.ArenaRewards3v3.RewardSpellID = quest->RewardSpell;
            for (uint32 i = 0; i < QUEST_REWARD_CURRENCY_COUNT; ++i)
            {
                if (quest->RewardCurrencyId[i])
                    rewardsResponse.ArenaRewards3v3.Currency.emplace_back(quest->RewardCurrencyId[i], quest->RewardCurrencyCount[i]);
            }
        }
    }

    if (PvpReward* reward = sBattlegroundMgr->GetPvpReward(PvpReward_Brawl))
    {
        uint32 ItemCA = 0;
        uint32 questId = isAlliance ? reward->QuestAlose : reward->QuestHLose;
        if (!HasWinToday(PvpReward_Brawl))
        {
            ItemCA = reward->ItemCAFirst;
            questId = isAlliance ? reward->QuestAFirst : reward->QuestHFirst;
        }
        else
        {
            ItemCA = reward->ItemCAWin;
            questId = isAlliance ? reward->QuestAWin : reward->QuestHWin;
        }

        if (ItemCA)
            rewardsResponse.BrawlRewardsBattleground.Item.push_back(ItemCA);

        uint32 ChestID = isAlliance ? reward->ChestA : reward->ChestH;
        if (ChestID)
            rewardsResponse.BrawlRewardsBattleground.Item.push_back(ChestID);

        if (!reward->ItemsA.empty())
            rewardsResponse.BrawlRewardsBattleground.Item.push_back(Trinity::Containers::SelectRandomContainerElement(isAlliance ? reward->ItemsA : reward->ItemsH));

        if (Quest const* quest = sQuestDataStore->GetQuestTemplate(questId))
        {
            if (quest->RewardHonor)
                rewardsResponse.BrawlRewardsBattleground.RewardHonor = quest->RewardHonor;
            if (quest->RewardSpell)
                rewardsResponse.BrawlRewardsBattleground.RewardSpellID = quest->RewardSpell;
            for (uint32 i = 0; i < QUEST_REWARD_CURRENCY_COUNT; ++i)
            {
                if (quest->RewardCurrencyId[i])
                    rewardsResponse.BrawlRewardsBattleground.Currency.emplace_back(quest->RewardCurrencyId[i], quest->RewardCurrencyCount[i]);
            }
        }
    }

    if (PvpReward* reward = sBattlegroundMgr->GetPvpReward(PvpReward_BrawlArena))
    {
        uint32 ItemCA = 0;
        uint32 questId = isAlliance ? reward->QuestAlose : reward->QuestHLose;
        if (!HasWinToday(PvpReward_BrawlArena))
        {
            ItemCA = reward->ItemCAFirst;
            questId = isAlliance ? reward->QuestAFirst : reward->QuestHFirst;
        }
        else
        {
            ItemCA = reward->ItemCAWin;
            questId = isAlliance ? reward->QuestAWin : reward->QuestHWin;
        }

        if (ItemCA)
            rewardsResponse.BrawlRewardsArena.Item.push_back(ItemCA);

        uint32 ChestID = isAlliance ? reward->ChestA : reward->ChestH;
        if (ChestID)
            rewardsResponse.BrawlRewardsArena.Item.push_back(ChestID);

        if (!reward->ItemsA.empty())
            rewardsResponse.BrawlRewardsArena.Item.push_back(Trinity::Containers::SelectRandomContainerElement(isAlliance ? reward->ItemsA : reward->ItemsH));

        if (Quest const* quest = sQuestDataStore->GetQuestTemplate(questId))
        {
            if (quest->RewardHonor)
                rewardsResponse.BrawlRewardsArena.RewardHonor = quest->RewardHonor;
            if (quest->RewardSpell)
                rewardsResponse.BrawlRewardsArena.RewardSpellID = quest->RewardSpell;
            for (uint32 i = 0; i < QUEST_REWARD_CURRENCY_COUNT; ++i)
            {
                if (quest->RewardCurrencyId[i])
                    rewardsResponse.BrawlRewardsArena.Currency.emplace_back(quest->RewardCurrencyId[i], quest->RewardCurrencyCount[i]);
            }
        }
    }

    rewardsResponse.HasRatedBGWinToday = HasWinToday(PvpReward_RBG);
    rewardsResponse.HasArenaSkirmishWinToday = HasWinToday(PvpReward_Skirmish);
    rewardsResponse.HasArena2v2WinToday = HasWinToday(PvpReward_Arena_2v2);
    rewardsResponse.HasArena3v3WinToday = HasWinToday(PvpReward_Arena_3v3);
    rewardsResponse.HasBrawlBattlegroundWinToday = HasWinToday(PvpReward_Brawl);
    rewardsResponse.HasBrawlArenaWinToday = HasWinToday(PvpReward_BrawlArena);

    SendDirectMessage(rewardsResponse.Write());
}

uint32 Player::GetCurrency(uint32 id) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return 0;

    return itr->second.totalCount;
}

uint32 Player::GetCurrencyOnWeek(uint32 id) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return 0;

    return itr->second.weekCount;
}

uint32 Player::GetCurrencyOnSeason(uint32 id) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
        return 0;

    return itr->second.seasonTotal;
}

bool Player::HasCurrency(uint32 id, uint32 count) const
{
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(id);
    return itr != _currencyStorage.end() && itr->second.totalCount >= count;
}

void Player::ModifyCurrency(uint32 id, int32 count, bool sendInChat/* = false*/, bool ignoreMultipliers/* = false*/, bool modifyWeek/* = true*/, bool modifySeason/* = true*/, bool sendToast/* = false*/, bool refund/* = false*/)
{
    if (!count)
        return;

    CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(id);
    if (!currency)
        return;

    if (id == CURRENCY_TYPE_HONOR_POINTS && getLevel() < MAX_LEVEL)
        return;

    if (!ignoreMultipliers)
        count *= GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_CURRENCY_GAIN, id);

    if (id == 1508 || id == 1533)
    {
        // if patch 7.3+ is not enabled we convert Wakening Essence and Veiled Argunite to gold
        if (count > 0 && sWorld->getIntConfig(CONFIG_LEGION_ENABLED_PATCH) < 3)
        {
            SendMessageToPlayer("Patch 7.3+ content is not enabled (yet) on this server, any Wakening Essence and Veiled Argunite that you earn get converted into gold.");
            int32 moneyCount = count * 5000;
            ModifyMoney(moneyCount);
            return;
        }
    }

    if (id == 1342 || id == 1226)
    {
        // if patch 7.2+ is not enabled we convert Legionfall War Supplies and Nethershards to gold
        if (count > 0 && sWorld->getIntConfig(CONFIG_LEGION_ENABLED_PATCH) < 2)
        {
            SendMessageToPlayer("Patch 7.2+ content is not enabled (yet) on this server, any Legionfall War Supplies and Nethershards that you earn get converted into gold.");
            int32 moneyCount = (id == 1342 ? count * 2500 : count * 10);
            ModifyMoney(moneyCount);
            return;
        }
    }

    if (id == 1160)
    {
        if (auto decency = GetCurrency(1161))
        {
            if (decency > 5)
                decency = 5;

            count -= count * decency * 10 / 100;
        }
        if (auto ecur = GetCurrency(1160))
        {
            if (ecur >= 5500 && !HasAchieved(12460))
                if (AchievementEntry const* achiev = sAchievementStore.LookupEntry(12460))
                    CompletedAchievement(achiev);
        }
    }

    uint32 oldTotalCount = 0;
    uint32 oldWeekCount = 0;
    uint32 oldSeasonTotalCount = 0;

    PlayerCurrenciesMap::iterator itr = _currencyStorage.find(id);
    if (itr == _currencyStorage.end())
    {
        PlayerCurrency cur;
        cur.state = PLAYERCURRENCY_NEW;
        cur.totalCount = 0;
        cur.weekCount = 0;
        cur.seasonTotal = 0;
        cur.flags = 0;
        cur.currencyEntry = currency;
        cur.curentCap = 0;
        _currencyStorage[id] = cur;
        itr = _currencyStorage.find(id);
    }
    else
    {
        oldTotalCount = itr->second.totalCount;
        oldWeekCount = itr->second.weekCount;
        oldSeasonTotalCount = itr->second.seasonTotal;
    }

    // count can't be more then weekCap if used (weekCap > 0)
    if (modifyWeek && currency->MaxEarnablePerWeek && (count > int32(currency->MaxEarnablePerWeek)))
        count = currency->MaxEarnablePerWeek;

    // count can't be more then totalCap if used (totalCap > 0)
    uint32 totalCap = GetTotalCurrencyCap(id);

    if (totalCap && (count > int32(totalCap)))
        count = totalCap;

    int32 newTotalCount = int32(oldTotalCount) + count;
    if (newTotalCount < 0)
        newTotalCount = 0;

    int32 newWeekCount = int32(oldWeekCount) + (count > 0 ? count : 0);
    if (newWeekCount < 0)
        newWeekCount = 0;

    if (!modifyWeek)
        newWeekCount = oldWeekCount;

    // if we get more then weekCap just set to limit
    if (modifyWeek && currency->MaxEarnablePerWeek && (int32(currency->MaxEarnablePerWeek) < newWeekCount))
    {
        newWeekCount = int32(currency->MaxEarnablePerWeek);
        // weekCap - oldWeekCount always >= 0 as we set limit before!
        if(newTotalCount > int32(oldTotalCount))
            newTotalCount = oldTotalCount;
        else
            newTotalCount = oldTotalCount + (currency->MaxEarnablePerWeek - oldWeekCount);
    }

    // if we get more then totalCap set to maximum;
    if (totalCap && (int32(totalCap) < newTotalCount))
    {
        newTotalCount = int32(totalCap);
        newWeekCount = currency->MaxEarnablePerWeek;
    }

    int32 newSeasonTotalCount = int32(oldSeasonTotalCount) + (modifySeason && count > 0 ? count : 0);

    if (uint32(newTotalCount) != oldTotalCount)
    {
        if (itr->second.state != PLAYERCURRENCY_NEW)
            itr->second.state = PLAYERCURRENCY_CHANGED;

        itr->second.totalCount = newTotalCount;
        itr->second.weekCount = newWeekCount;
        itr->second.seasonTotal = newSeasonTotalCount;

        // probably excessive checks
        if (IsInWorld() && !GetSession()->PlayerLoading())
        {
            if (count > 0 && !refund)
                UpdateAchievementCriteria(CRITERIA_TYPE_CURRENCY, id, count);

            CurrencyChanged(id, count);

            WorldPackets::Misc::SetCurrency packet;
            packet.Type = id;
            packet.Quantity = newTotalCount;
            packet.SuppressChatLog = !sendInChat;
            packet.WeeklyQuantity = newWeekCount;
            packet.TrackedQuantity = itr->second.seasonTotal;
            if (currency->Flags & CURRENCY_FLAG_SEND_CAP)
                packet.MaxQuantity = GetTotalCurrencyCap(id);
            SendDirectMessage(packet.Write());

            if (sendToast)
                SendDisplayToast(id, ToastType::CURRENCY, false, count, DisplayToastMethod::DISPLAY_TOAST_ENTRY_LOOT_PERSONAL_1);
        }
    }
}

uint32 Player::GetTotalCurrencyCap(uint32 currencyID)
{
    auto currency = sCurrencyTypesStore.LookupEntry(currencyID);
    if (!currency)
        return 0;

    if (currencyID == CURRENCY_TYPE_ARTIFACT_KNOWLEDGE)
        return sWorld->getWorldState(WS_CURRENT_ARTIFACT_KNOWLEDGE);

    auto baseCap = currency->MaxQty;
    PlayerCurrenciesMap::const_iterator itr = _currencyStorage.find(currencyID);
    if (itr != _currencyStorage.end())
        return baseCap + itr->second.curentCap;

    return baseCap;
}

void Player::ModCurrnecyCap(uint32 currencyID, uint32 value)
{
    CurrencyTypesEntry const* currency = sCurrencyTypesStore.LookupEntry(currencyID);
    if (!currency)
        return;

    uint32 oldTotalCount = 0;
    uint32 oldWeekCount = 0;
    uint32 oldSeasonTotalCount = 0;
    uint32 curentCap = value;

    PlayerCurrenciesMap::iterator itr = _currencyStorage.find(currencyID);
    if (itr == _currencyStorage.end())
    {
        PlayerCurrency cur;
        cur.state = PLAYERCURRENCY_NEW;
        cur.totalCount = 0;
        cur.weekCount = 0;
        cur.seasonTotal = 0;
        cur.flags = 0;
        cur.currencyEntry = currency;
        cur.curentCap = value;
        _currencyStorage[currencyID] = cur;
    }
    else
    {
        itr->second.curentCap += value;
        if (itr->second.state != PLAYERCURRENCY_NEW)
            itr->second.state = PLAYERCURRENCY_CHANGED;

        oldTotalCount = itr->second.totalCount;
        oldWeekCount = itr->second.weekCount;
        oldSeasonTotalCount = itr->second.seasonTotal;
        curentCap = itr->second.curentCap;
    }

    WorldPackets::Misc::SetCurrency packet;
    packet.Type = currencyID;
    packet.Quantity = oldTotalCount;
    packet.SuppressChatLog = false;
    packet.WeeklyQuantity = oldWeekCount;
    packet.TrackedQuantity = oldSeasonTotalCount;
    if (currency->Flags & CURRENCY_FLAG_SEND_CAP)
        packet.MaxQuantity = currency->MaxQty + curentCap;
    SendDirectMessage(packet.Write());
}

void Player::SetCurrency(uint32 id, uint32 count, bool sendInChat)
{
    ModifyCurrency(id, int32(count) - GetCurrency(id), !sendInChat);
}

uint32 Player::GetCurrencyWeekCap(uint32 id)
{
    if (CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(id))
        return entry->MaxEarnablePerWeek;

    return 0;
}

void Player::ResetCurrencyWeekCap()
{
    for (PlayerCurrenciesMap::iterator itr = _currencyStorage.begin(); itr != _currencyStorage.end(); ++itr)
    {
        itr->second.weekCount = 0;
        itr->second.state = PLAYERCURRENCY_CHANGED;
    }

    SendDirectMessage(WorldPackets::Misc::NullSMsg(SMSG_RESET_WEEKLY_CURRENCY).Write());
}

void Player::UpdateConquestCurrencyCap(uint32 currency)
{
    WorldPackets::Misc::SetMaxWeeklyQuantity packet;
    packet.Type = currency;
    packet.MaxWeeklyQuantity = GetCurrencyWeekCap(currency);
    SendDirectMessage(packet.Write());
}

void Player::SetInGuild(ObjectGuid::LowType guildId)
{
    if (guildId)
        SetGuidValue(OBJECT_FIELD_DATA, ObjectGuid::Create<HighGuid::Guild>(guildId));
    else
        SetGuidValue(OBJECT_FIELD_DATA, ObjectGuid::Empty);

    ApplyModFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GUILD_LEVEL_ENABLED, guildId != 0 && sWorld->getBoolConfig(CONFIG_GUILD_LEVELING_ENABLED));
    SetUInt16Value(OBJECT_FIELD_TYPE, 1, guildId != 0);
}

ObjectGuid::LowType Player::GetGuildIdFromDB(ObjectGuid guid)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
    stmt->setUInt64(0, guid.GetCounter());
    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
        return result->Fetch()[0].GetUInt64();

    return UI64LIT(0);
}

uint8 Player::GetRankFromDB(ObjectGuid guid)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_MEMBER);
    stmt->setUInt64(0, guid.GetCounter());
    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
        return result->Fetch()[1].GetUInt8();

    return UI64LIT(0);
}

uint32 Player::GetZoneIdFromDB(ObjectGuid guid)
{
    ObjectGuid::LowType guidLow = guid.GetCounter();
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_ZONE);
    stmt->setUInt64(0, guidLow);
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return 0;
    Field* fields = result->Fetch();
    uint32 zone = fields[0].GetUInt16();

    if (!zone)
    {
        // stored zone is zero, use generic and slow zone detection
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_POSITION_XYZ);
        stmt->setUInt64(0, guidLow);
        PreparedQueryResult result = CharacterDatabase.Query(stmt);

        if (!result)
            return 0;
        fields = result->Fetch();
        uint32 map = fields[0].GetUInt16();
        float posx = fields[1].GetFloat();
        float posy = fields[2].GetFloat();
        float posz = fields[3].GetFloat();

        if (!sMapStore.LookupEntry(map))
            return 0;

        zone = sMapMgr->GetZoneId(map, posx, posy, posz);

        if (zone > 0)
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ZONE);

            stmt->setUInt16(0, uint16(zone));
            stmt->setUInt64(1, guidLow);

            CharacterDatabase.Execute(stmt);
        }
    }

    return zone;
}

uint32 Player::GetLevelFromDB(ObjectGuid guid)
{
    const CharacterInfo* nameData = sWorld->GetCharacterInfo(guid);
    if (!nameData)
        return 0;

    return nameData->Level;
}

void Player::UpdateArea(uint32 newArea)
{
    AreaTableEntry const* area = sAreaTableStore.LookupEntry(newArea);
    
    //! new area on garrison not has flag2 - 0x20
    if (GetMap()->IsGarrison() && !Garrison::GetAreaIdForTeam(GetTeam(), area) && !GetSession()->PlayerLoading())
    {
        //remove from garrison
        TeleportTo(1116, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation(), TELE_TO_SEAMLESS);
    }
    else if (!GetMap()->IsGarrison() && Garrison::GetAreaIdForTeam(GetTeam(), area)) // Add to garrison.
    {
        if (Garrison* garr = GetGarrisonPtr())
        {
            if (garr->GetGarrisonMapID() != -1 && garr->GetGarrisonMapID() != GetMap()->GetId())
            {
                // As some area in garrison not in same place.
                Map* newMap = sMapMgr->CreateMap(garr->GetGarrisonMapID(), this);
                if (newMap && newMap->CanEnter(this))
                    TeleportTo(garr->GetGarrisonMapID(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation(), TELE_TO_SEAMLESS);
            }
        }
    }

    ChaeckSeamlessTeleport(newArea, true);


    uint32 newAreaForUpdate = m_areaId;
    AddDelayedEvent(100, [=]() -> void
    {
        UpdateAchievementCriteria(CRITERIA_TYPE_ENTER_AREA, newArea);
        UpdateAchievementCriteria(CRITERIA_TYPE_LEAVE_AREA, newAreaForUpdate);
    });

    UpdateAreaQuestTasks(newArea, m_areaId);

    // FFA_PVP flags are area and not zone id dependent
    // so apply them accordingly
    if (m_areaId)
        m_oldAreaId = m_areaId;
    m_areaId = newArea;

    if (Unit* veh = GetVehicleBase())
        if (!veh->IsPlayer())
            veh->m_areaId = newArea;

    if (m_oldAreaId != m_areaId)
    {
        sOutdoorPvPMgr->HandlePlayerLeaveArea(GetGUID(), m_oldAreaId);
        sOutdoorPvPMgr->HandlePlayerEnterArea(GetGUID(), m_areaId);

        if (m_oldAreaId)
            RemovePlayerFromArea(m_oldAreaId);
        if (m_areaId)
            AddPlayerToArea(m_areaId);
    }

    AddDelayedEvent(100, [this]() -> void
    {
        GetPhaseMgr().AddUpdateFlag(PHASE_UPDATE_FLAG_AREA_UPDATE);
    });

    pvpInfo.inFFAPvPArea = area && (area->Flags[0] & AREA_FLAG_ARENA);

    UpdatePvPState(true);

    //Hack OO: Galakras. Fix me
    if (GetMapId() == 1136)
        SendInitWorldStates(m_zoneId, newArea);

    UpdateAreaDependentAuras(newArea);

	if (sWorld->getBoolConfig(CONFIG_PLAYER_ALLOW_PVP_TALENTS_ALL_THE_TIME) && getLevel() >= 110)
	{
		if (!HasPvpRulesEnabled())
			EnablePvpRules(false);
	}
	else
	{
		if (IsAreaThatActivatesPvpTalents(newArea))
			EnablePvpRules(!InArena() && !InBattleground());
		else
			DisablePvpRules(true, false);
	}

    PrepareAreaQuest(newArea);

    // previously this was in UpdateZone (but after UpdateArea) so nothing will break
    pvpInfo.inNoPvPArea = false;
    if (area && area->IsSanctuary() && !InFFAPvPArea())    // in sanctuary
    {
        SetByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_SANCTUARY);
        pvpInfo.inNoPvPArea = true;
        CombatStopWithPets();
    }
    else
        RemoveByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_SANCTUARY);

    if(m_serverSideVisibility.GetValue(SERVERSIDE_VISIBILITY_DUEL) > 0)
    {
        SetByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_SANCTUARY);
        pvpInfo.inNoPvPArea = true;
        CombatStopWithPets();
    }

    if (area && (area->Flags[0] & ((GetTeam() == ALLIANCE) ? AREA_FLAG_REST_ZONE_ALLIANCE : AREA_FLAG_REST_ZONE_HORDE)))
    {
        SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
        SetRestType(REST_TYPE_IN_FACTION_AREA);
        InnEnter(time(0), GetMapId(), 0, 0, 0);
    }
    else if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) && GetRestType() == REST_TYPE_IN_FACTION_AREA)
    {
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
        SetRestType(REST_TYPE_NO);
    }

    AddDelayedEvent(100, [this]() -> void
    {
        GetPhaseMgr().RemoveUpdateFlag(PHASE_UPDATE_FLAG_AREA_UPDATE);
    });
}

void Player::UpdateZone(uint32 newZone, uint32 newArea)
{
    if (!IsInWorld())
        return;

    if (m_zoneForce)
    {
        m_zoneId = 0;
        m_areaId = 0;
        m_zoneForce = false;
    }

    AddDelayedEvent(100, [this]() -> void
    {
        GetPhaseMgr().AddUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);
    });

    ChaeckSeamlessTeleport(newZone);

    if (m_zoneId != newZone)
    {
        if (!IsBeingTeleported())
        {
            // Check valid player level
            if (IsForbiddenMapForLevel(GetMapId(), newZone))
            {
                if (isInFlight())
                {
                    GetMotionMaster()->MovementExpired();
                    CleanupAfterTaxiFlight(false);
                }

                if (GetTeam() == ALLIANCE)
                    TeleportTo(0, -8833.37f, 628.62f, 94.00f, 1.06f);
                else
                    TeleportTo(1, 1569.59f, -4397.63f, 16.06f, 0.54f);

                return;
            }
        }

        sOutdoorPvPMgr->HandlePlayerLeaveZone(GetGUID(), m_zoneId);
        sOutdoorPvPMgr->HandlePlayerEnterZone(GetGUID(), newZone);
        sBattlefieldMgr->HandlePlayerLeaveZone(GetGUID(), m_zoneId);
        sBattlefieldMgr->HandlePlayerEnterZone(GetGUID(), newZone);

        AddDelayedEvent(300, [this, newZone, newArea]() -> void
        {
            SendInitWorldStates(newZone, newArea);              // only if really enters to new zone, not just area change, works strange...
        });
    }

    // group update
    if (GetGroup())
    {
        //SetGroupUpdateFlag(GROUP_UPDATE_FULL);
        SetGroupUpdateFlag(GROUP_UPDATE_FLAG_ZONE);
        if (Pet* pet = GetPet())
            pet->SetGroupUpdateFlag(GROUP_UPDATE_PET_FULL);
    }

    if (newZone != (m_zoneId ? m_zoneId : m_oldZoneId))
        UpdateAreaQuestTasks(newZone, m_zoneId ? m_zoneId : m_oldZoneId);

    if (m_zoneId)
        m_oldZoneId = m_zoneId;
    m_zoneId    = newZone;
    m_zoneUpdateTimer = ZONE_UPDATE_INTERVAL;

    if (Unit* veh = GetVehicleBase())
        if (!veh->IsPlayer())
            veh->m_zoneId = m_zoneId;

    sScriptMgr->OnPlayerUpdateZone(this, newZone, newArea);

    // zone changed, so area changed as well, update it
    UpdateArea(newArea);

    AreaTableEntry const* zone = sAreaTableStore.LookupEntry(newZone);
    if (!zone)
        return;

    if (sWorld->getBoolConfig(CONFIG_WEATHER))
        GetMap()->GetOrGenerateZoneDefaultWeather(newZone);

    GetMap()->SendZoneDynamicInfo(newZone, this);

    // in PvP, any not controlled zone (except zone->team == 6, default case)
    // in PvE, only opposition team capital
    switch (zone->FactionGroupMask)
    {
        case AREATEAM_ALLY:
            pvpInfo.inHostileArea = GetTeam() != ALLIANCE && (sWorld->IsPvPRealm() || zone->Flags[0] & AREA_FLAG_CAPITAL);
            break;
        case AREATEAM_HORDE:
            pvpInfo.inHostileArea = GetTeam() != HORDE && (sWorld->IsPvPRealm() || zone->Flags[0] & AREA_FLAG_CAPITAL);
            break;
        case AREATEAM_NONE:
            // overwrite for battlegrounds, maybe batter some zone flags but current known not 100% fit to this
            pvpInfo.inHostileArea = sWorld->IsPvPRealm() || InBattleground() || zone->Flags[0] & AREA_FLAG_WINTERGRASP;
            break;
        default:                                            // 6 in fact
            pvpInfo.inHostileArea = false;
            break;
    }

    if (zone->Flags[0] & AREA_FLAG_CAPITAL)                     // Is in a capital city
    {
        if (!pvpInfo.inHostileArea || zone->IsSanctuary())
        {
            SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
            SetRestType(REST_TYPE_IN_CITY);
            InnEnter(time(0), GetMapId(), 0, 0, 0);
        }
        pvpInfo.inNoPvPArea = true;
    }
    else
    {
        if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING))
        {
            if (GetRestType() == REST_TYPE_IN_TAVERN)        // Still inside a tavern or has recently left
            {
                // Remove rest state if we have recently left a tavern.
                if (GetMapId() != GetInnPosMapId() || GetExactDist(GetInnPosX(), GetInnPosY(), GetInnPosZ()) > 1.0f)
                {
                    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
                    SetRestType(REST_TYPE_NO);
                }
            }
            else if (GetRestType() != REST_TYPE_IN_FACTION_AREA)
            {
                RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
                SetRestType(REST_TYPE_NO);
            }
        }
    }

    UpdatePvPState();

    // remove items with area/map limitations (delete only for alive player to allow back in ghost mode)
    // if player resurrected at teleport this will be applied in resurrect code
    if (isAlive())
        DestroyZoneLimitedItem(true, newZone);

    // check some item equip limitations (in result lost CanTitanGrip at talent reset, for example)
    AutoUnequipOffhandIfNeed();

    // recent client version not send leave/join channel packets for built-in local channels
    UpdateLocalChannels(newZone);

    PrepareAreaQuest(newZone);

    UpdateZoneDependentAuras(newZone);

    ZoneTeleport(newZone);

    AddDelayedEvent(100, [this]() -> void
    {
        GetPhaseMgr().RemoveUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);
    });
}

bool Player::IsOutdoorPvPActive()
{
    return true;
    //return isAlive() && !HasInvisibilityAura() && !HasStealthAura() && IsPvP() && !HasUnitMovementFlag(MOVEMENTFLAG_FLYING) && !isInFlight();
}

//If players are too far away from the duel flag... they lose the duel
void Player::CheckDuelDistance()
{
    if (!duel)
        return;

    if (GameObject* arbiter = GetMap()->GetGameObject(duel->arbiter))
    {
        if (!duel->outOfBoundTimer)
        {
            if (!IsWithinDistInMap(arbiter, 50.0f))
            {
                duel->outOfBoundTimer = getMSTime();
                SendDirectMessage(WorldPackets::Duel::DuelOutOfBounds().Write());
            }
        }
        else
        {
            if (IsWithinDistInMap(arbiter, 40.0f))
            {
                duel->outOfBoundTimer = 0;
                SendDirectMessage(WorldPackets::Duel::DuelInBounds().Write());
            }
            else if (getMSTime() >= (duel->outOfBoundTimer + 10 * IN_MILLISECONDS))
                DuelComplete(DUEL_FLED);
        }
    }
}

// called from loser of duel
void Player::DuelComplete(DuelCompleteType type)
{
    // duel not requested
    if (!duel || m_duelLock)
        return;

    Player* dueler = ObjectAccessor::FindPlayer(duel->opponent);

    if (!dueler)
        return;

    m_duelLock = true;
    TC_LOG_DEBUG(LOG_FILTER_UNITS, "Duel Complete: WinnerName %s, BeatenName %s", dueler->GetName(), GetName());

    // Remove Duel Flag object
    if (GameObject* obj = GetMap()->GetGameObject(duel->arbiter))
    {
        if (Player* initiator = ObjectAccessor::FindPlayer(duel->initiator))
            initiator->RemoveGameObject(obj, true);
    }

    if (type != DUEL_INTERRUPTED)
    {
        WorldPackets::Duel::DuelWinner duelWinner;
        duelWinner.BeatenName = GetName();
        duelWinner.WinnerName = dueler->GetName();
        duelWinner.BeatenVirtualRealmAddress = GetVirtualRealmAddress();
        duelWinner.WinnerVirtualRealmAddress = GetVirtualRealmAddress();
        duelWinner.Fled = (type == DUEL_FLED);
        SendMessageToSet(duelWinner.Write(), true);
    }

    DisablePvpRules();
    dueler->DisablePvpRules();

    sScriptMgr->OnPlayerDuelEnd(dueler, this, type);

    switch (type)
    {
        case DUEL_FLED:
        {
            // if initiator and duel->opponent are on the same team
            // or initiator and duel->opponent are not PvP enabled, forcibly stop attacking
            if (GetTeam() == dueler->GetTeam())
            {
                AttackStop();
                dueler->AttackStop();
            }
            else
            {
                if (!IsPvP())
                    AttackStop();
                if (!dueler->IsPvP())
                    dueler->AttackStop();
            }

            // Victory
            dueler->CastSpell(dueler, 52852, true);
            break;
        }
        case DUEL_FINISHED:
        {
            UpdateAchievementCriteria(CRITERIA_TYPE_LOSE_DUEL, 1);
            dueler->UpdateAchievementCriteria(CRITERIA_TYPE_WIN_DUEL, 1);
            // Credit for quest Death's Challenge
            if (getClass() == CLASS_DEATH_KNIGHT && dueler->GetQuestStatus(12733) == QUEST_STATUS_INCOMPLETE)
                dueler->CastSpell(dueler, 52994, true);

            break;
        }
        default:
            break;
    }

    WorldPackets::Duel::DuelComplete duelCompleted;
    duelCompleted.Started = type != DUEL_INTERRUPTED;
    WorldPacket const* duelCompletedPacket = duelCompleted.Write();
    SendDirectMessage(duelCompletedPacket);

    if (dueler->GetSession())
        dueler->SendDirectMessage(duelCompletedPacket);

    /* remove auras */
    ObjectGuid myGuid = GetGUID();
    AuraApplicationMap &itsAuras = dueler->GetAppliedAuras();
    for (AuraApplicationMap::iterator i = itsAuras.begin(); i != itsAuras.end();)
    {
        Aura const* aura = i->second->GetBase();
        if (!i->second->IsPositive() && aura->GetCasterGUID() == myGuid/* && aura->GetApplyTime() >= duel->startTime*/)
            dueler->RemoveAura(i);
        else
            ++i;
    }

    AuraApplicationMap &myAuras = GetAppliedAuras();
    for (AuraApplicationMap::iterator i = myAuras.begin(); i != myAuras.end();)
    {
        Aura const* aura = i->second->GetBase();
        if (aura && !i->second->IsPositive() && aura->GetCasterGUID() == dueler->GetGUID()/* && aura->GetApplyTime() >= duel->startTime*/)
            RemoveAura(i);
        else
            ++i;
    }

    // Honor points after duel (the winner) - ImpConfig
    //if (uint32 amount = sWorld->getIntConfig(CONFIG_HONOR_AFTER_DUEL))
        //dueler->RewardHonor(NULL, 1, amount);

    //cleanups
    SetGuidValue(PLAYER_FIELD_DUEL_ARBITER, ObjectGuid::Empty);
    SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 0);
    dueler->SetGuidValue(PLAYER_FIELD_DUEL_ARBITER, ObjectGuid::Empty);
    dueler->SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 0);

    delete dueler->duel;
    dueler->duel = nullptr;
    delete duel;
    duel = nullptr;

    m_duelLock = false;
}

//---------------------------------------------------------//

void Player::_ApplyItemMods(Item* item, uint8 slot, bool apply)
{
    if (slot >= INVENTORY_SLOT_BAG_END || !item)
        return;

    ItemTemplate const* proto = item->GetTemplate();
    if (!proto)
        return;

    // not apply/remove mods for broken item
    if (item->CantBeUse())
        return;

    if (proto->GetFlags3() & ITEM_FLAG3_PVP_TOURNAMENT_GEAR && !InTournaments())
        return;

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "applying mods for item %u ", item->GetGUIDLow());

    if (proto->GetSocketType(0))                              //only (un)equipping of items with sockets can influence metagems, so no need to waste time with normal items
        CorrectMetaGemEnchants(slot, apply);

    if (!apply)
        _ApplyOrRemoveItemEquipDependentAuras(item->GetGUID(), false);
    else
        AddDelayedEvent(100, [=]() -> void
        {
            if (this && item)
                _ApplyOrRemoveItemEquipDependentAuras(item->GetGUID(), true);
        });

    if (apply)
    {
        ApplyArtifactPowers(item, apply);
        _ApplyItemBonuses(item, slot, apply);
    }
    else
    {
        _ApplyItemBonuses(item, slot, apply);
        ApplyArtifactPowers(item, apply);
    }
    ApplyItemEquipSpell(item, apply);
    ApplyEnchantment(item, apply);

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "_ApplyItemMods complete.");
}

void Player::_ApplyItemBonuses(Item* item, uint8 slot, bool apply)
{
    ItemTemplate const* proto = item->GetTemplate();
    if (slot >= INVENTORY_SLOT_BAG_END || !proto)
        return;

    if (proto->GetFlags3() & ITEM_FLAG3_PVP_TOURNAMENT_GEAR && !InTournaments())
        return;

    if (apply == item->GetModsApplied())
        return;

    item->SetModsApplied(apply);

    uint32 itemLevel = item->GetItemLevel(GetEffectiveLevel());
    float combatRatingMultiplier = 1.0f;
    if (GtCombatRatingsMultByILvl const* ratingMult = sCombatRatingsMultByILvlGameTable.GetRow(itemLevel))
    {
        switch (proto->GetInventoryType())
        {
            case INVTYPE_WEAPON:
            case INVTYPE_SHIELD:
            case INVTYPE_RANGED:
            case INVTYPE_2HWEAPON:
            case INVTYPE_WEAPONMAINHAND:
            case INVTYPE_WEAPONOFFHAND:
            case INVTYPE_HOLDABLE:
            case INVTYPE_RANGEDRIGHT:
                combatRatingMultiplier = ratingMult->WeaponMultiplier;
                break;
            case INVTYPE_TRINKET:
                combatRatingMultiplier = ratingMult->TrinketMultiplier;
                break;
            case INVTYPE_NECK:
            case INVTYPE_FINGER:
                combatRatingMultiplier = ratingMult->JewelryMultiplier;
                break;
            default:
                combatRatingMultiplier = ratingMult->ArmorMultiplier;
                break;
        }
    }

    // req. check at equip, but allow use for extended range if range limit max level, set proper level
    for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
    {
        int32 statType = item->GetItemStatType(i);
        if (statType == -1)
            continue;
 
        int32 val = item->GetItemStatValue(i, HasPvpRulesEnabled());
        if (val == 0)
            continue;

        #ifdef WIN32
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "_ApplyItemBonuses statType %i val %i apply %u GetEntry %u", statType, val, apply, item->GetEntry());
        #endif

        switch (statType)
        {
            case ITEM_MOD_MANA:
                HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_HEALTH:                           // modify HP
                HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_AGILITY:                          // modify agility
                HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_STRENGTH:                         //modify strength
                HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_INTELLECT:                        //modify intellect
                HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_SPIRIT:                           //modify spirit
                break;
            case ITEM_MOD_STAMINA:                          //modify stamina
                HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_DEFENSE_SKILL_RATING:
                ApplyRatingMod(CR_DEFENSE_SKILL, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_DODGE_RATING:
                ApplyRatingMod(CR_DODGE, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_PARRY_RATING:
                ApplyRatingMod(CR_PARRY, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_BLOCK_RATING:
                ApplyRatingMod(CR_BLOCK, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_HIT_MELEE_RATING:
                ApplyRatingMod(CR_HIT_MELEE, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_HIT_RANGED_RATING:
                ApplyRatingMod(CR_HIT_RANGED, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_HIT_SPELL_RATING:
                ApplyRatingMod(CR_HIT_SPELL, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_CRIT_MELEE_RATING:
                ApplyRatingMod(CR_CRIT_MELEE, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_CRIT_RANGED_RATING:
                ApplyRatingMod(CR_CRIT_RANGED, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_CRIT_SPELL_RATING:
                ApplyRatingMod(CR_CRIT_SPELL, int32(val * combatRatingMultiplier), apply);
                break;
            // case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
            // case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
            //case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
            //    break;
            //case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
            //    ApplyRatingMod(CR_CRIT_TAKEN_MELEE, int32(val), apply);
            //    break;
            case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
                ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE, int32(val), apply);
                break;
            // case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
            // break;
            case ITEM_MOD_HASTE_MELEE_RATING:
                ApplyRatingMod(CR_HASTE_MELEE, int32(val), apply);
                break;
            case ITEM_MOD_HASTE_RANGED_RATING:
                ApplyRatingMod(CR_HASTE_RANGED, int32(val), apply);
                break;
            case ITEM_MOD_HASTE_SPELL_RATING:
                ApplyRatingMod(CR_HASTE_SPELL, int32(val), apply);
                break;
            case ITEM_MOD_HIT_RATING:
                ApplyRatingMod(CR_HIT_MELEE, int32(val * combatRatingMultiplier), apply);
                ApplyRatingMod(CR_HIT_RANGED, int32(val * combatRatingMultiplier), apply);
                ApplyRatingMod(CR_HIT_SPELL, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_CRIT_RATING:
                ApplyRatingMod(CR_CRIT_MELEE, int32(val * combatRatingMultiplier), apply);
                ApplyRatingMod(CR_CRIT_RANGED, int32(val * combatRatingMultiplier), apply);
                ApplyRatingMod(CR_CRIT_SPELL, int32(val * combatRatingMultiplier), apply);
                break;
            //case ITEM_MOD_HIT_TAKEN_RATING:
            //case ITEM_MOD_CRIT_TAKEN_RATING:
            //    break;
            case ITEM_MOD_RESILIENCE_RATING:
                ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_PVP_POWER:
                break;
            case ITEM_MOD_HASTE_RATING:
                ApplyRatingMod(CR_HASTE_MELEE, int32(val * combatRatingMultiplier), apply);
                ApplyRatingMod(CR_HASTE_RANGED, int32(val * combatRatingMultiplier), apply);
                ApplyRatingMod(CR_HASTE_SPELL, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_EXPERTISE_RATING:
                ApplyRatingMod(CR_EXPERTISE, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_ATTACK_POWER:
                HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(val), apply);
                HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
                break;
            case ITEM_MOD_RANGED_ATTACK_POWER:
                HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(val), apply);
                break;
            case ITEM_MOD_MANA_REGENERATION:
                ApplyManaRegenBonus(int32(val), apply);
                break;
            case ITEM_MOD_SPELL_POWER:
                ApplySpellPowerBonus(int32(val), apply);
                break;
            case ITEM_MOD_HEALTH_REGEN:
                ApplyHealthRegenBonus(int32(val), apply);
                break;
            case ITEM_MOD_SPELL_PENETRATION:
                ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, -val, apply);
                m_spellPenetrationItemMod += apply ? val : -val;
                break;
            case ITEM_MOD_MASTERY_RATING:
                ApplyRatingMod(CR_MASTERY, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_FIRE_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_FIRE, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_FROST_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_FROST, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_HOLY_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_HOLY, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_SHADOW_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_SHADOW, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_NATURE_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_NATURE, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_ARCANE_RESISTANCE:
                HandleStatModifier(UNIT_MOD_RESISTANCE_ARCANE, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_VERSATILITY:
                ApplyRatingMod(CR_VERSATILITY_DAMAGE_DONE, int32(val * combatRatingMultiplier), apply);
                ApplyRatingMod(CR_VERSATILITY_DAMAGE_TAKEN, int32(val * combatRatingMultiplier), apply);
                ApplyRatingMod(CR_VERSATILITY_HEALING_DONE, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_CR_MULTISTRIKE:
                ApplyRatingMod(CR_MULTISTRIKE, int32(val), apply);
                break;
            case ITEM_MOD_CR_READINESS:
                ApplyRatingMod(CR_READINESS, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_CR_SPEED:
                ApplyRatingMod(CR_SPEED, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_CR_LIFESTEAL:
                ApplyRatingMod(CR_LIFESTEAL, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_CR_AVOIDANCE:
                ApplyRatingMod(CR_AVOIDANCE, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_CR_AMPLIFY:
                break;
            case ITEM_MOD_CR_STURDINESS: // items with this should not lose durability on player death - dynamic stat?
                ApplyRatingMod(CR_STURDINESS, int32(val * combatRatingMultiplier), apply);
                break;
            case ITEM_MOD_CR_CLEAVE:
                break;
            case ITEM_MOD_AGI_STR_INT:
                HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(val), apply);
                HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(val), apply);
                HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_AGI_STR:
                HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(val), apply);
                HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_AGI_INT:
                HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(val), apply);
                HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(val), apply);
                break;
            case ITEM_MOD_STR_INT:
                HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(val), apply);
                HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(val), apply);
                break;
        }
    }

    // If set ScalingStatValue armor get it or use item armor
    if (uint32 armor = item->GetArmor())
    {
        UnitModifierType modType = TOTAL_VALUE;
        if (proto->GetClass() == ITEM_CLASS_ARMOR)
        {
            switch (proto->GetSubClass())
            {
                case ITEM_SUBCLASS_ARMOR_CLOTH:
                case ITEM_SUBCLASS_ARMOR_LEATHER:
                case ITEM_SUBCLASS_ARMOR_MAIL:
                case ITEM_SUBCLASS_ARMOR_PLATE:
                case ITEM_SUBCLASS_ARMOR_SHIELD:
                    modType = BASE_VALUE;
                break;
            }
        }
        HandleStatModifier(UNIT_MOD_ARMOR, modType, float(armor), apply);
    }

    if (proto->GetQualityModifier() > 0)
        HandleStatModifier(UNIT_MOD_ARMOR, TOTAL_VALUE, float(proto->GetQualityModifier()), apply);

    WeaponAttackType attType = BASE_ATTACK;

    if (slot == EQUIPMENT_SLOT_MAINHAND && (proto->GetInventoryType() == INVTYPE_RANGED || proto->GetInventoryType() == INVTYPE_THROWN || proto->GetInventoryType() == INVTYPE_RANGEDRIGHT))
        attType = RANGED_ATTACK;
    else if (slot == EQUIPMENT_SLOT_OFFHAND)
        attType = OFF_ATTACK;

    if (CanUseAttackType(attType))
        _ApplyWeaponDamage(slot, item, apply);
}

void Player::_ApplyWeaponDamage(uint8 slot, Item* item, bool apply)
{
    ItemTemplate const* proto = item->GetTemplate();
    WeaponAttackType attType = BASE_ATTACK;
    float damage = 0.0f;

    if (slot == EQUIPMENT_SLOT_MAINHAND && (proto->GetInventoryType() == INVTYPE_RANGED || proto->GetInventoryType() == INVTYPE_THROWN || proto->GetInventoryType() == INVTYPE_RANGEDRIGHT))
        attType = RANGED_ATTACK;
    else if (slot == EQUIPMENT_SLOT_OFFHAND)
        attType = OFF_ATTACK;

    float minDamage = 0.0f;
    float maxDamage = 0.0f;
    proto->GetDamage(item->GetItemLevel(GetEffectiveLevel(), HasPvpRulesEnabled()), minDamage, maxDamage);

    if (minDamage > 0)
    {
        damage = apply ? minDamage : BASE_MINDAMAGE;
        SetBaseWeaponDamage(attType, MINDAMAGE, damage);
    }

    if (maxDamage  > 0)
    {
        damage = apply ? maxDamage : BASE_MAXDAMAGE;
        SetBaseWeaponDamage(attType, MAXDAMAGE, damage);
    }

    SpellShapeshiftFormEntry const* shapeshift = sSpellShapeshiftFormStore.LookupEntry(GetShapeshiftForm());
    if (proto->GetDelay() && !(shapeshift && shapeshift->CombatRoundTime))
        SetAttackTime(attType, apply ? proto->GetDelay() : BASE_ATTACK_TIME);

    if (CanModifyStats() && (damage || proto->GetDelay()))
        UpdateDamagePhysical(attType);
}

void Player::_ApplyOrRemoveItemEquipDependentAuras(ObjectGuid const& itemGUID, bool apply)
{
    if (apply)
    {
        if (!isAlive())
            return;

        for (PlayerSpellMap::iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
        {
            PlayerSpell* spellPtr_ = &itr->second;
            if (!spellPtr_ || spellPtr_->state == PLAYERSPELL_REMOVED || spellPtr_->disabled)
                continue;

            uint32 SpellId = itr->first;
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(SpellId);
            if (!spellInfo)
                continue;

            switch (spellInfo->EquippedItemClass)
            {
                case ITEM_CLASS_WEAPON:
                case ITEM_CLASS_ARMOR:
                {
                    if (spellInfo->IsPassive() && !HasAura(SpellId))
                    {
                        if (spellInfo->HasAttribute(SPELL_ATTR8_ARMOR_SPECIALIZATION))
                        {
                            if (CheckItemForArmorSpecialization(spellInfo))
                                CastSpell(this, SpellId, true);
                        }
                        else if (CheckItemEquipDependentSpell(spellInfo))
                            CastSpell(this, SpellId, true);
                    }
                }
                default:
                    continue;
            }
        }

        // Only for Armor Specialization Spell
        std::vector<uint32> RemoveAurasList;
        for (AuraApplicationMap::const_iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)
        {
            Aura const* aura = iter->second->GetBase();
            SpellInfo const* spellInfo = aura->GetSpellInfo();
            if (!spellInfo)
                continue;

            switch (spellInfo->EquippedItemClass)
            {
                case ITEM_CLASS_WEAPON:
                case ITEM_CLASS_ARMOR:
                {
                    if (spellInfo->HasAttribute(SPELL_ATTR8_ARMOR_SPECIALIZATION))
                    {
                        if (!CheckItemForArmorSpecialization(spellInfo))
                            RemoveAurasList.push_back(aura->GetId());
                    }
                }
                default:
                    continue;
            }
        }

        for (std::vector<uint32>::iterator itr = RemoveAurasList.begin(); itr != RemoveAurasList.end(); ++itr)
            RemoveAurasDueToSpell(*itr);
    }
    else
    {
        std::vector<uint32> RemoveAurasList;

        for (AuraApplicationMap::const_iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end(); ++iter)
        {
            Aura const* aura = iter->second->GetBase();
            SpellInfo const* spellInfo = aura->GetSpellInfo();
            if (!spellInfo)
                continue;

            switch (spellInfo->EquippedItemClass)
            {
                case ITEM_CLASS_WEAPON:
                case ITEM_CLASS_ARMOR:
                {
                    if (spellInfo->HasAttribute(SPELL_ATTR8_ARMOR_SPECIALIZATION))
                    {
                        if (!CheckItemForArmorSpecialization(spellInfo))
                            RemoveAurasList.push_back(aura->GetId());
                    }
                    else if (!CheckItemEquipDependentSpell(spellInfo, itemGUID))
                        RemoveAurasList.push_back(aura->GetId());
                }
                default:
                    continue;
            }
        }

        for (std::vector<uint32>::iterator itr = RemoveAurasList.begin(); itr != RemoveAurasList.end(); ++itr)
            RemoveAurasDueToSpell(*itr);
    }
}

bool Player::CheckItemEquipDependentSpell(SpellInfo const* spellInfo, ObjectGuid const& itemGUID)
{
    switch (spellInfo->EquippedItemClass)
    {
        case ITEM_CLASS_WEAPON:
        {
            bool onlyDual = (spellInfo->EquippedItemInventoryTypeMask & (1 << INVTYPE_WEAPON));
            uint8 resemblance = 0;

            for (uint8 i = EQUIPMENT_SLOT_MAINHAND; i < EQUIPMENT_SLOT_TABARD; ++i)
                if (Item* checkItem = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (itemGUID.IsEmpty() || itemGUID != checkItem->GetGUID())
                        if (ItemTemplate const* checkItemTemplate = checkItem->GetTemplate())
                            if (spellInfo->EquippedItemSubClassMask == 0 || (spellInfo->EquippedItemSubClassMask & (1 << checkItemTemplate->GetSubClass())))
                                resemblance++;

            if (onlyDual && resemblance > 1 || !onlyDual && resemblance > 0)
                return true;

            break;
        }
        case ITEM_CLASS_ARMOR:
        {
            int32 resemblanceMask = 0;
            for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_MAINHAND; ++i)
                if (Item* checkItem = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (itemGUID.IsEmpty() || itemGUID != checkItem->GetGUID())
                        if (ItemTemplate const* checkItemTemplate = checkItem->GetTemplate())
                            if (spellInfo->EquippedItemSubClassMask == 0 || (spellInfo->EquippedItemSubClassMask & (1 << checkItemTemplate->GetSubClass())))
                                resemblanceMask |= (1 << checkItemTemplate->GetInventoryType());

            if (resemblanceMask & spellInfo->EquippedItemInventoryTypeMask)
                return true;

            break;
        }
    }

    return false;
}

void Player::ApplyItemEquipSpell(Item* item, bool apply, bool form_change)
{
    if (!item)
        return;

    ItemTemplate const* proto = item->GetTemplate();
    if (!proto)
        return;

    for (ItemEffectEntry const* effectData : proto->Effects)
    {
        if (apply && effectData->TriggerType != ITEM_SPELLTRIGGER_ON_EQUIP)
            continue;

        SpellInfo const* spellproto = sSpellMgr->GetSpellInfo(effectData->SpellID);
        if (!spellproto)
            continue;

        if (spellproto->HasAura(SPELL_AURA_MOD_XP_PCT) && !GetCollectionMgr()->CanApplyHeirloomXpBonus(item->GetEntry(), getLevel()) && sDB2Manager.GetHeirloomByItemId(item->GetEntry()))
            continue;

        if (apply && effectData->ChrSpecializationID && effectData->ChrSpecializationID != GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID))
            continue;

        ApplyEquipSpell(spellproto, item, apply, form_change);
    }
}

void Player::ApplyEquipSpell(SpellInfo const* spellInfo, Item* item, bool apply, bool form_change)
{
    bool isArtifact = item && item->GetTemplate() && item->GetTemplate()->GetArtifactID();
    if (apply)
    {
        if (GetSession()->PlayerLogout())
            return;

        if (HasPvpStatsScalingEnabled() && !isArtifact)
            return;

        // Cannot be used in this stance/form
        if (spellInfo->CheckShapeshift(GetShapeshiftForm()) != SPELL_CAST_OK)
            return;

        if (form_change)                                    // check aura active state from other form
        {
            AuraApplicationMap const& auras = GetAppliedAuras();
            for (AuraApplicationMap::const_iterator itr = auras.lower_bound(spellInfo->Id); itr != auras.upper_bound(spellInfo->Id); ++itr)
                if (!item || itr->second->GetBase()->GetCastItemGUID() == item->GetGUID())
                    return;
        }

        TC_LOG_DEBUG(LOG_FILTER_PLAYER, "WORLD: cast %s Equip spellId - %i", (item ? "item" : "itemset"), spellInfo->Id);

        if(item)
        {
            //change bonus for custom item
            switch(item->GetTemplate()->GetId())
            {
                case 1:
                {
                    float bp = 100.f;
                    CastCustomSpell(this, spellInfo->Id, &bp, &bp, &bp, true, item);
                    return;
                }
                case 2:
                {
                    float bp = 90.f;
                    CastCustomSpell(this, spellInfo->Id, &bp, &bp, &bp, true, item);
                    return;
                }
                case 3:
                {
                    float bp = 80.f;
                    CastCustomSpell(this, spellInfo->Id, &bp, &bp, &bp, true, item);
                    return;
                }
                case 4:
                {
                    float bp = 70.f;
                    CastCustomSpell(this, spellInfo->Id, &bp, &bp, &bp, true, item);
                    return;
                }
                case 5:
                {
                    float bp = 60.f;
                    CastCustomSpell(this, spellInfo->Id, &bp, &bp, &bp, true, item);
                    return;
                }
                case 6:
                {
                    float bp = 50.f;
                    CastCustomSpell(this, spellInfo->Id, &bp, &bp, &bp, true, item);
                    return;
                }
                case 7:
                {
                    float bp = 40.f;
                    CastCustomSpell(this, spellInfo->Id, &bp, &bp, &bp, true, item);
                    return;
                }
                case 8:
                {
                    float bp = 30.f;
                    CastCustomSpell(this, spellInfo->Id, &bp, &bp, &bp, true, item);
                    return;
                }
                case 9:
                {
                    float bp = 20.f;
                    CastCustomSpell(this, spellInfo->Id, &bp, &bp, &bp, true, item);
                    return;
                }
                case 10:
                {
                    float bp = 10.f;
                    CastCustomSpell(this, spellInfo->Id, &bp, &bp, &bp, true, item);
                    return;
                }
            }
        }
        CastSpell(this, spellInfo, true, item);
        HandleItemSpellList(spellInfo->Id, true);
        HandleCasterAuraStateSpellList(spellInfo->Id, true);
    }
    else
    {
        if (form_change)                                     // check aura compatibility
        {
            // Cannot be used in this stance/form
            if (spellInfo->CheckShapeshift(GetShapeshiftForm()) == SPELL_CAST_OK)
                return;                                     // and remove only not compatible at form change
        }

        HandleItemSpellList(spellInfo->Id, false);
        HandleCasterAuraStateSpellList(spellInfo->Id, false);

        if (spellInfo->HasAura(SPELL_AURA_OVERRIDE_PET_SPECS))
        {
            if (Pet* pet = GetPet())
                pet->RemoveAurasDueToSpell(spellInfo->Id);
        }

        if (item)
            RemoveAurasDueToItemSpell(item, spellInfo->Id);  // un-apply all spells, not only at-equipped
        else
            RemoveAurasDueToSpell(spellInfo->Id);           // un-apply spell (item set case)
    }
}

bool Player::CheckItemForArmorSpecialization(SpellInfo const* spellInfo) const
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_MAINHAND; ++i)
    {
        Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (!item)
            continue;

        ItemTemplate const* proto = item->GetTemplate();
        if (!proto)
            continue;

        if (spellInfo->EquippedItemInventoryTypeMask != 0 && !(spellInfo->EquippedItemInventoryTypeMask & (1 << proto->GetInventoryType())))
            continue;

        if (spellInfo->EquippedItemSubClassMask != 0 && !(spellInfo->EquippedItemSubClassMask & (1 << proto->GetSubClass())))
            return false;
    }

    return true;
}

void Player::UpdateEquipSpellsAtFormChange()
{
    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i] && !m_items[i]->CantBeUse() && CanUseAttackType(GetAttackBySlot(i)))
        {
            ApplyItemEquipSpell(m_items[i], false, true);     // remove spells that not fit to form
            ApplyItemEquipSpell(m_items[i], true, true);      // add spells that fit form but not active
        }
    }

    for (ItemSetEffect const* eff : *ItemSetEff)
    {
        if (!eff)
            continue;

        for (ItemSetSpellEntry const* itemSetSpell : eff->SetBonuses)
        {
            if (!itemSetSpell)
                continue;
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itemSetSpell->SpellID);
            if (!spellInfo)
                continue;

            if (itemSetSpell->ChrSpecID && itemSetSpell->ChrSpecID != GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID))
                ApplyEquipSpell(spellInfo, nullptr, false, false);  // item set aura is not for current spec
            else
            {
                ApplyEquipSpell(spellInfo, nullptr, false, false); // remove spells that not fit to form - removal is skipped if shapeshift condition is satisfied
                ApplyEquipSpell(spellInfo, nullptr, true, false);  // add spells that fit form but not active
            }
        }
    }
}

void Player::ApplyArtifactPowers(Item* item, bool apply)
{
    if (!item->GetTemplate()->GetArtifactID())
        return;

    for (ItemDynamicFieldArtifactPowers const& artifactPower : item->GetArtifactPowers())
    {
        uint8 rank = artifactPower.CurrentRankWithBonus;
        if (!rank)
            continue;

        if (sArtifactPowerStore.AssertEntry(artifactPower.ArtifactPowerId)->Flags & ARTIFACT_POWER_FLAG_SCALES_WITH_NUM_POWERS)
            rank = 1;

        if (ArtifactPowerRankEntry const* artifactPowerRank = sDB2Manager.GetArtifactPowerRank(artifactPower.ArtifactPowerId, rank - 1))
            ApplyArtifactPowerRank(item, artifactPowerRank, apply);
    }

    if (ArtifactAppearanceEntry const* artifactAppearance = sArtifactAppearanceStore.LookupEntry(item->GetModifier(ITEM_MODIFIER_ARTIFACT_APPEARANCE_ID)))
        if (artifactAppearance->OverrideShapeshiftDisplayID && GetShapeshiftForm() == ShapeshiftForm(artifactAppearance->OverrideShapeshiftFormID))
            RestoreDisplayId();
}

void Player::ApplyArtifactPowerRank(Item* artifact, ArtifactPowerRankEntry const* artifactPowerRank, bool apply)
{
    if (!artifactPowerRank)
        return;

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(artifactPowerRank->SpellID);
    if (!spellInfo)
        return;

    if (spellInfo->IsPassive())
    {
        if (AuraApplication* powerAura = GetAuraApplication(artifactPowerRank->SpellID, ObjectGuid::Empty, artifact->GetGUID()))
        {
            if (apply)
            {
                for (AuraEffect* auraEffect : powerAura->GetBase()->GetAuraEffects())
                    if (auraEffect && powerAura->HasEffect(auraEffect->GetEffIndex()))
                        auraEffect->ChangeAmount(artifactPowerRank->AuraPointsOverride ? artifactPowerRank->AuraPointsOverride : auraEffect->GetSpellEffectInfo()->CalcValue());
            }
            else
            {
                RemoveAura(powerAura);
            }
        }
        else if (apply)
        {
            CustomSpellValues csv;
            if (artifactPowerRank->AuraPointsOverride)
                for (uint32 i = 0; i < MAX_SPELL_EFFECTS; ++i)
                {
                    if (spellInfo->EffectMask < uint32(1 << i))
                        break;

                    if (spellInfo->GetEffect(i))
                        csv.AddSpellMod(SpellValueMod(SPELLVALUE_BASE_POINT0 + i), artifactPowerRank->AuraPointsOverride);
                }

            CastCustomSpell(artifactPowerRank->SpellID, csv, this, true, artifact);
        }
    }
    else
    {
        if (apply)
        {
            if (!HasSpell(artifactPowerRank->SpellID))
                AddTemporarySpell(artifactPowerRank->SpellID);

            WorldPackets::Spells::LearnedSpells learnedSpells;
            learnedSpells.SuppressMessaging = true;
            learnedSpells.SpellID.push_back(artifactPowerRank->SpellID);
            SendDirectMessage(learnedSpells.Write());
        }
        else if (!apply)
        {
            RemoveTemporarySpell(artifactPowerRank->SpellID);

            WorldPackets::Spells::UnlearnedSpells unlearnedSpells;
            unlearnedSpells.SuppressMessaging = true;
            unlearnedSpells.SpellID.push_back(artifactPowerRank->SpellID);
            SendDirectMessage(unlearnedSpells.Write());
        }
    }
}

void Player::CastItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx)
{
    if (!target || !target->isAlive() || target == this)
        return;

    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        // If usable, try to cast item spell
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (!item->CantBeUse() && CanUseAttackType(attType))
                if (ItemTemplate const* proto = item->GetTemplate())
                {
                    // Additional check for weapons
                    if (proto->GetClass() == ITEM_CLASS_WEAPON)
                    {
                        // offhand item cannot proc from main hand hit etc
                        EquipmentSlots slot;
                        switch (attType)
                        {
                            case BASE_ATTACK:   slot = EQUIPMENT_SLOT_MAINHAND; break;
                            case OFF_ATTACK:    slot = EQUIPMENT_SLOT_OFFHAND;  break;
                            case RANGED_ATTACK: slot = EQUIPMENT_SLOT_MAINHAND;   break;
                            default: slot = EQUIPMENT_SLOT_END; break;
                        }
                        if (slot != i)
                            continue;
                        // Check if item is useable (forms or disarm)
                        if (attType == BASE_ATTACK)
                            if (!IsUseEquipedWeapon(true) && !IsInFeralForm())
                                continue;
                    }
                    CastItemCombatSpell(target, attType, procVictim, procEx, item, proto);
                }
    }
}

void Player::CastItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto)
{
    // Can do effect if any damage done to target
    if (procVictim & PROC_FLAG_TAKEN_DAMAGE)
    //if (damageInfo->procVictim & PROC_FLAG_TAKEN_ANY_DAMAGE)
    {
        for (ItemEffectEntry const* effectData : proto->Effects)
        {
            if (effectData->TriggerType != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
                continue;

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(effectData->SpellID);
            if (!spellInfo)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER_ITEMS, "WORLD: unknown Item spellid %i", effectData->SpellID);
                continue;
            }

            // not allow proc extra attack spell at extra attack
            if (m_extraAttacks && spellInfo->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
                return;

            float chance = (float)spellInfo->GetAuraOptions(m_spawnMode)->ProcChance;

            if (proto->SpellPPMRate)
            {
                if (effectData->SpellID == 52781) // Persuasive Strike
                {
                    switch (target->GetEntry())
                    {
                        default:
                            return;
                        case 28939:
                        case 28940:
                        case 28610:
                            break;
                    }
                }
                chance = GetPPMProcChance(GetAttackTime(attType), proto->SpellPPMRate, spellInfo);
            }
            else if (chance > 100.0f)
                chance = GetWeaponProcChance();

            if (roll_chance_f(chance))
                CastSpell(target, spellInfo->Id, true, item);
        }
    }

    // item combat enchantments
    for (uint8 e_slot = 0; e_slot < MAX_ENCHANTMENT_SLOT; ++e_slot)
    {
        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
        if (!pEnchant)
            continue;

        for (uint8 s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
        {
            if (pEnchant->Effect[s] != ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL)
                continue;

            SpellEnchantProcEntry const* entry = sSpellMgr->GetSpellEnchantProcEvent(enchant_id);
            if (entry && entry->procEx)
            {
                // Check hit/crit/dodge/parry requirement
                if ((entry->procEx & procEx) == 0)
                    continue;
            }
            else
            {
                // Can do effect if any damage done to target
                if (!(procVictim & PROC_FLAG_TAKEN_DAMAGE))
                //if (!(damageInfo->procVictim & PROC_FLAG_TAKEN_ANY_DAMAGE))
                    continue;
            }

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(pEnchant->EffectArg[s]);
            if (!spellInfo)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER_ITEMS, "Player::CastItemCombatSpell(GUID: %u, name: %s, enchant: %i): unknown spell %i is casted, ignoring...",
                    GetGUIDLow(), GetName(), pEnchant->ID, pEnchant->EffectArg[s]);
                continue;
            }

            float chance = pEnchant->EffectPointsMin[s] != 0 ? float(pEnchant->EffectPointsMin[s]) : GetWeaponProcChance();

            if (entry)
            {
                if (entry->PPMChance)
                    chance = GetPPMProcChance(proto->GetDelay(), entry->PPMChance, spellInfo);
                else if (entry->customChance)
                    chance = (float)entry->customChance;
            }

            // Apply spell mods
            ApplySpellMod(pEnchant->EffectArg[s], SPELLMOD_CHANCE_OF_SUCCESS, chance);

            if (roll_chance_f(chance))
            {
                if (spellInfo->IsPositive())
                    CastSpell(this, spellInfo, true, item);
                else
                    CastSpell(target, spellInfo, true, item);
            }
        }
    }
}

void Player::CastItemUseSpell(Item* item, SpellCastTargets const& targets, int32* misc, ObjectGuid SpellGuid)
{
    ItemTemplate const* proto = item->GetTemplate();
    if (!proto || !IsInWorld() || !item->IsInWorld())
        return;

    volatile uint32 itemEntry = item->GetEntry();
    volatile uint32 itemGuidLow = item->GetGUIDLow();

    // special learning case
    if (proto->Effects.size() >= 2 && !proto->Effects.empty())
    {
        if (proto->Effects[0]->SpellID == 483 || proto->Effects[0]->SpellID == 55884)
        {
            uint32 learn_spell_id = proto->Effects[0]->SpellID;
            uint32 learning_spell_id = proto->Effects[1]->SpellID;

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(learn_spell_id);
            if (!spellInfo)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::CastItemUseSpell: Item (Entry: %u) in have wrong spell id %u, ignoring ", proto->GetId(), learn_spell_id);
                SendEquipError(EQUIP_ERR_INTERNAL_BAG_ERROR, item);
                return;
            }

            TriggerCastData triggerData;
            triggerData.castItem = item;
            triggerData.spellGuid = SpellGuid;
            triggerData.SubType = SPELL_CAST_TYPE_ITEM;

            Spell* spell = new Spell(this, spellInfo, triggerData);
            spell->SetSpellValue(SPELLVALUE_BASE_POINT0, learning_spell_id);
            spell->prepare(&targets);
            return;
        }
    }

    // use triggered flag only for items with many spell casts and for not first cast
    uint8 count = 0;

    for (ItemEffectEntry const* effectData : proto->Effects)
    {
        if (effectData->TriggerType != ITEM_SPELLTRIGGER_ON_USE)
            continue;

        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(effectData->SpellID);
        if (!spellInfo)
            continue;

        TriggerCastData triggerData;
        triggerData.triggerFlags = (count > 0) ? TriggerCastFlags(TRIGGERED_FULL_MASK &~ (TRIGGERED_CAST_DIRECTLY | TRIGGERED_IGNORE_SPELL_AND_CATEGORY_CD)) : TRIGGERED_NONE;
        triggerData.castItem = item;
        triggerData.miscData0 = misc[0];
        triggerData.miscData1 = misc[1];
        triggerData.spellGuid = SpellGuid;
        triggerData.SubType = SPELL_CAST_TYPE_ITEM;

        Spell* spell = new Spell(this, spellInfo, triggerData);
        spell->prepare(&targets);

        ++count;
    }

    if (count)
        return;

    // Item enchantments spells casted at use
    for (uint8 e_slot = 0; e_slot < MAX_ENCHANTMENT_SLOT; ++e_slot)
    {
        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
        if (!pEnchant)
            continue;
        for (uint8 s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
        {
            if (pEnchant->Effect[s] != ITEM_ENCHANTMENT_TYPE_USE_SPELL)
                continue;

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(pEnchant->EffectArg[s]);
            if (!spellInfo)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::CastItemUseSpell Enchant %i, cast unknown spell %i", pEnchant->ID, pEnchant->EffectArg[s]);
                continue;
            }

            TriggerCastData triggerData;
            triggerData.triggerFlags = (count > 0) ? TriggerCastFlags(TRIGGERED_FULL_MASK &~ (TRIGGERED_CAST_DIRECTLY | TRIGGERED_IGNORE_SPELL_AND_CATEGORY_CD)) : TRIGGERED_NONE;
            triggerData.castItem = item;
            triggerData.miscData0 = misc[0];
            triggerData.miscData1 = misc[1];
            triggerData.spellGuid = SpellGuid;
            triggerData.SubType = SPELL_CAST_TYPE_ITEM;

            Spell* spell = new Spell(this, spellInfo, triggerData);
            spell->prepare(&targets);
            ++count;
        }
    }
}

void Player::_RemoveAllItemMods()
{
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "_RemoveAllItemMods start.");

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            if (m_items[i]->CantBeUse() || !CanUseAttackType(GetAttackBySlot(i)) || !m_items[i]->GetTemplate())
                continue;

            _ApplyItemBonuses(m_items[i], i, false);
        }
    }

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            ItemTemplate const* proto = m_items[i]->GetTemplate();
            if (!proto)
                continue;

            // item set bonuses not dependent from item broken state
            if (proto->GetItemSet())
                RemoveItemsSetItem(this, proto);

            if (m_items[i]->CantBeUse() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ApplyItemEquipSpell(m_items[i], false);
            ApplyEnchantment(m_items[i], false);
            ApplyArtifactPowers(m_items[i], false);
        }
    }

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "_RemoveAllItemMods complete.");
}

void Player::_ApplyAllItemMods()
{
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "_ApplyAllItemMods start.");

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (auto const& item = m_items[i])
        {
            ItemTemplate const* proto = item->GetTemplate();
            if (!proto)
                continue;

            // item set bonuses not dependent from item broken state
            if (proto->GetItemSet())
                AddItemsSetItem(this, item);

            if (item->CantBeUse() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            ApplyItemEquipSpell(item, true);
            ApplyArtifactPowers(item, true);
            ApplyEnchantment(item, true);
        }
    }

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (auto const& item = m_items[i])
        {
            if (item->CantBeUse() || !CanUseAttackType(GetAttackBySlot(i)))
                continue;

            _ApplyItemBonuses(item, i, true);
        }
    }

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "_ApplyAllItemMods complete.");
}

void Player::RescaleAllItemsIfNeeded(bool keepHPPct /*= false*/)
{
    float healthPct = GetHealthPct();

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* item = m_items[i])
            if (CanUseAttackType(GetAttackBySlot(i)))
            {
                if (ItemTemplate const* temp = item->GetTemplate())
                {
                    if (temp->GetItemSet())
                        RemoveItemsSetItem(this, temp);
                }

                _ApplyItemMods(item, i, false);
            }

    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* item = m_items[i])
            if (CanUseAttackType(GetAttackBySlot(i)))
            {
                if (ItemTemplate const* temp = item->GetTemplate())
                {
                    if (temp->GetItemSet())
                        AddItemsSetItem(this, item);
                }

                _ApplyItemMods(item, i, true);
            }

    if (keepHPPct)
        SetHealth(std::max(uint64(1ull), uint64(healthPct * (float)GetMaxHealth() / 100.0f)));

    SendOperationsAfterDelay(OAD_RECALC_ITEM_LVL);

    std::vector<Item*> arts;

    if (Item* art = GetArtifactWeapon())
        arts.push_back(art);

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); ++i)
    {
        if (Item* pItem = m_items[i])
        {
            if (ItemTemplate const* temp = pItem->GetTemplate())
            {
                if (temp->GetArtifactID())
                    arts.push_back(pItem);
            }
        }
    }
            
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
            {
                if (Item* pItem = pBag->GetItemByPos(j))
                {
                    if (ItemTemplate const* temp = pItem->GetTemplate())
                    {
                        if (temp->GetArtifactID())
                            arts.push_back(pItem);
                    }
                }
            }
        }
    }

    if (!arts.empty())
    {
        bool hasPvpScaling = HasPvpStatsScalingEnabled();

        for (auto itr : arts)
        {
            itr->HandleAllBonusTraits(this, !hasPvpScaling);
        }
    }
}

/*  If in a battleground a player dies, and an enemy removes the insignia, the player's bones is lootable
    Called by remove insignia spell effect    */
void Player::RemovedInsignia(Player* looterPlr)
{
    if (!GetBattlegroundId() && GetMapId() != 1191)
        return;

    // If not released spirit, do it !
    if (m_deathTimer > 0)
    {
        m_deathTimer = 0;
        BuildPlayerRepop();
        RepopAtGraveyard();
    }

    // We have to convert player corpse to bones, not to be able to resurrect there
    // SpawnCorpseBones isn't handy, 'cos it saves player while he in BG
    Corpse* bones = sObjectAccessor->ConvertCorpseForPlayer(GetGUID(), true);
    if (!bones)
        return;

    // Now we must make bones lootable, and send player loot
    bones->SetFlag(CORPSE_FIELD_DYNAMIC_FLAGS, CORPSE_DYNFLAG_LOOTABLE);

    // We store the level of our player in the gold field
    // We retrieve this information at Player::SendLoot()
    bones->loot.gold = getLevel();
    bones->lootRecipient = looterPlr;
    looterPlr->SendLoot(bones->GetGUID(), LOOT_INSIGNIA);
}

void Player::SendLootRelease(ObjectGuid object, ObjectGuid owner)
{
    WorldPackets::Loot::LootReleaseResponse response;
    response.LootObj = object;
    response.Owner = owner;
    SendDirectMessage(response.Write());
}

//! part of handling in Garrison::CompleteShipments
void Player::SendLoot(ObjectGuid guid, LootType loot_type, bool AoeLoot, uint8 pool)
{
    ObjectGuid lguid = GetLootGUID();
    if ((guid.IsCorpse() || guid.IsItem() || guid.IsGameObject()) && lguid)
        m_session->DoLootRelease(lguid);

    Loot* loot = NULL;
    Loot* lootPesonal = NULL;
    PermissionTypes permission = ALL_PERMISSION;
    ItemQualities groupThreshold = ITEM_QUALITY_POOR;

    // TC_LOG_DEBUG(LOG_FILTER_LOOT, "Player::SendLoot guid %u, loot_type %u", guid, loot_type);
    if (guid.IsGameObject())
    {
        GameObject* go = GetMap()->GetGameObject(guid);

        // not check distance for GO in case owned GO (fishing bobber case, for example)
        // And permit out of range GO with no owner in case fishing hole
        if (!go || (loot_type != LOOT_FISHINGHOLE && (loot_type != LOOT_FISHING || go->GetOwnerGUID() != GetGUID()) && !go->IsWithinDistInMap(this, INTERACTION_DISTANCE)) || (loot_type == LOOT_CORPSE && go->GetRespawnTime() && go->isSpawnedByDefault()))
        {
            SendLootRelease(guid);
            return;
        }

        //! Handler on  Garrison::CompleteShipments
        if (go->GetGOInfo()->type == GAMEOBJECT_TYPE_GARRISON_SHIPMENT)
            return;

        lootPesonal = &personalLoot[guid];
        loot = &go->loot;

        bool personal = go->IsPersonal();

        if (go->getLootState() == GO_READY || personal)
        {
            uint32 lootid = go->GetEntry();

            //TODO: fix this big hack
            if ((go->GetEntry() == BG_AV_OBJECTID_MINE_N || go->GetEntry() == BG_AV_OBJECTID_MINE_S))
                if (Battleground* bg = GetBattleground())
                    if (bg->GetTypeID(true) == MS::Battlegrounds::BattlegroundTypeId::BattlegroundAlteracValley)
                        if (!(((BattlegroundAlteracValley*)bg)->PlayerCanDoMineQuest(go->GetEntry(), GetTeam())))
                        {
                            SendLootRelease(guid, loot->GetGUID());
                            return;
                        }

            if (lootid)
            {
                if(personal)
                {
                    TC_LOG_DEBUG(LOG_FILTER_LOOT, "Player::SendLoot DungeonEncounter %i dungeonEncounterID %i", go->GetGOInfo()->chest.DungeonEncounter, lootPesonal->dungeonEncounterID);

                    if (!lootPesonal->dungeonEncounterID) // This loot generate in Unit::GeneratePersonalLoot
                    {
                        lootPesonal->clear();
                        lootPesonal->personal = true;
                        lootPesonal->objType = 3;
                        if(PersonalLootData const* plData = sObjectMgr->GetPersonalLootData(go->GetEntry()))
                        {
                            lootPesonal->chance = plData->chance;
                            lootPesonal->isBoss = true;
                        }
                        lootPesonal->FillLoot(lootid, LootTemplates_Gameobject, this, true, false, go);

                        uint32 mingold = go->GetGOInfo()->MinGold;
                        uint32 maxgold = go->GetGOInfo()->MaxGold;
                        lootPesonal->generateMoneyLoot(mingold, maxgold, GetMap()->IsDungeon());
                    }
                }
                else
                {
                    loot->clear();
                    loot->objType = 3;

                    Group* group = GetGroup();
                    bool groupRules = (group && go->GetGOInfo()->type == GAMEOBJECT_TYPE_CHEST && go->GetGOInfo()->chest.usegrouplootrules);

                    // check current RR player and get next if necessary
                    if (groupRules)
                        group->UpdateLooterGuid(go, true);

                    loot->FillLoot(lootid, LootTemplates_Gameobject, this, !groupRules, false, go);

                    // get next RR player (for next loot)
                    if (groupRules)
                        group->UpdateLooterGuid(go);
                }
                loot->shipmentBuildingType = go->garrBuildingType;

                // TC_LOG_DEBUG(LOG_FILTER_LOOT, "Player::SendLoot guid %u, personal %u pguid %u lguid %u", guid, personal, personalLoot.GetGUIDLow(), loot->GetGUIDLow());
            }

            if (loot_type == LOOT_FISHING)
                go->getFishLoot(loot, this);

            if (go->GetGOInfo()->type == GAMEOBJECT_TYPE_CHEST && go->GetGOInfo()->chest.usegrouplootrules && !personal)
            {
                if (Group* group = GetGroup())
                {
                    groupThreshold = group->GetThreshold();
                    switch (group->GetLootMethod())
                    {
                        case GROUP_LOOT:
                            // GroupLoot: rolls items over threshold. Items with quality < threshold, round robin
                            group->GroupLoot(loot, go);
                            break;
                        case MASTER_LOOT:
                            group->MasterLoot(loot, go);
                            break;
                        default:
                            break;
                    }
                }
            }

            go->SetLootState(GO_ACTIVATED, this);
        }

        if (go->getLootState() == GO_ACTIVATED)
        {
            if(personal)
                permission = ALL_PERMISSION;
            else if (Group* group = GetGroup())
            {
                groupThreshold = group->GetThreshold();
                switch (group->GetLootMethod())
                {
                    case PERSONAL_LOOT:
                        permission = OWNER_PERMISSION;
                        break;
                    case MASTER_LOOT:
                        permission = MASTER_PERMISSION;
                        break;
                    case FREE_FOR_ALL:
                        permission = ALL_PERMISSION;
                        break;
                    default:
                        permission = GROUP_PERMISSION;
                        break;
                }
            }
            else
                permission = ALL_PERMISSION;
        }
    }
    else if (guid.IsItem())
    {
        Item* item = GetItemByGuid(guid);

        if (!item)
        {
            SendLootRelease(guid);
            return;
        }

        permission = OWNER_PERMISSION;

        loot = &personalLoot[guid];

        if (!item->m_lootGenerated)
        {
            item->m_lootGenerated = true;
            loot->clear();
            loot->objEntry = item->GetEntry();
            loot->objGuid = item->GetGUID();

            switch (loot_type)
            {
                case LOOT_DISENCHANTING:
                {
                    uint32 disenchantLootId = 0;
                    if (ItemDisenchantLootEntry const* itemDisenchantLoot = item->GetDisenchantLoot(this))
                        disenchantLootId = itemDisenchantLoot->ID;
                    else
                    {
                        // special disenchant
                        if (item->GetTemplate()->GetFlags2() & ITEM_FLAG2_DISENCHANT_TO_LOOT_TABLE)
                            if (LootTemplates_Disenchant.HaveLootFor(item->GetEntry()))
                                disenchantLootId = item->GetEntry();
                    }

                    if (disenchantLootId)
                        loot->FillLoot(disenchantLootId, LootTemplates_Disenchant, this, true);
                    break;
                }
                case LOOT_PROSPECTING:
                    loot->FillLoot(item->GetEntry(), LootTemplates_Prospecting, this, true);
                    break;
                case LOOT_MILLING:
                    loot->FillLoot(item->GetEntry(), LootTemplates_Milling, this, true);
                    break;
                default:
                    if (item->GetQuality() >= ITEM_QUALITY_EPIC) // Need more research
                    {
                        loot->_isItemLoot = true;
                        switch (item->GetDescriptionID())
                        {
                            case 13193: // Raid normal
                                loot->_itemContext = 3;
                                break;
                            case 1641: // Raid LFG
                                loot->_itemContext = 4;
                                break;
                            case 2015: // Raid heroic
                                loot->_itemContext = 5;
                                break;
                            case 13145: // Raid mythic
                                loot->_itemContext = 6;
                                break;
                        }
                    }
                    loot->objType = 2;
                    loot->generateMoneyLoot(item->GetTemplate()->MinMoneyLoot, item->GetTemplate()->MaxMoneyLoot, GetMap()->IsDungeon());
                    loot->FillLoot(item->GetEntry(), LootTemplates_Item, this, true, loot->gold != 0);
                    break;
            }
        }
    }
    else if (guid.IsCorpse())                          // remove insignia
    {
        Corpse* bones = ObjectAccessor::GetCorpse(*this, guid);

        if (!bones || !(loot_type == LOOT_CORPSE || loot_type == LOOT_INSIGNIA) || bones->GetType() != CORPSE_BONES)
        {
            SendLootRelease(guid);
            return;
        }

        loot = &personalLoot[guid];

        if (auto outdoorPvP = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(GetCurrentZoneID()))
            if (outdoorPvP->GetTypeId() == OutdoorPvPTypes::OUTDOOR_PVP_ASHRAN)
                outdoorPvP->FillCustomPvPLoots(this, *loot, bones->GetOwnerGUID());

        if (!bones->lootForBody)
        {
            bones->lootForBody = true;
            uint32 pLevel = bones->loot.gold;
            bones->loot.clear();
            if (GetBattleground())
                loot->FillLoot(1, LootTemplates_Creature, this, true, false, bones);
            // It may need a better formula
            // Now it works like this: lvl10: ~6copper, lvl70: ~9silver
            bones->loot.gold = uint32(urand(50, 150) * 0.016f * pow(float(pLevel)/5.76f, 2.5f) * (GetMap()->IsDungeon() && sWorld->getBoolConfig(CONFIG_DROP_DUNGEON_ONLY_X1)? 1.0f : sWorld->getRate(RATE_DROP_MONEY)));
        }

        if (bones->lootRecipient != this)
            permission = NONE_PERMISSION;
        else
            permission = OWNER_PERMISSION;
    }
    else
    {
        Creature* creature = GetMap()->GetCreature(guid);

        if (!creature || creature->isAlive() != (loot_type == LOOT_PICKPOCKETING))
        {
            SendLootRelease(guid);
            return;
        }

        // must be in range and creature must be alive for pickpocket and must be dead for another loot
        Unit *looter = creature->GetOtherRecipient();
        if (!looter)
            looter = this;

        if (!creature->IsWithinDistInMap(looter, LOOT_DISTANCE))
        {
            SendLootRelease(guid);
            return;
        }

        lootPesonal = &personalLoot[guid];
        loot = &creature->loot;

        if (loot_type == LOOT_PICKPOCKETING)
        {
            if (!creature->lootForPickPocketed)
            {
                creature->lootForPickPocketed = true;
                loot->clear();

                if (uint32 lootid = creature->GetCreatureTemplate()->pickpocketLootId)
                    loot->FillLoot(lootid, LootTemplates_Pickpocketing, this, true, false, creature);

                if (!IsFriendlyTo(creature))
                {
                    // Generate extra money for pick pocket loot
                    const uint32 a = urand(0, creature->getLevelForTarget(this)/2);
                    const uint32 b = urand(0, getLevelForTarget(creature)/2);
                    lootPesonal->gold = uint32(10 * (a + b) * (GetMap()->IsDungeon() && sWorld->getBoolConfig(CONFIG_DROP_DUNGEON_ONLY_X1)  ? 1.0f : sWorld->getRate(RATE_DROP_MONEY)));
                    sLootMgr->AddLoot(lootPesonal);
                }
                permission = OWNER_PERMISSION;
            }
        }
        else
        {
            // the player whose group may loot the corpse
            Player* recipient = creature->GetLootRecipient();
            if (!recipient)
                return;

            if (!creature->lootForBody && !creature->IsPersonal())
            {
                creature->lootForBody = true;

                // for creature, loot is filled when creature is killed.

                if (Group* group = recipient->GetGroup())
                {
                    groupThreshold = group->GetThreshold();
                    switch (group->GetLootMethod())
                    {
                        case GROUP_LOOT:
                            // GroupLoot: rolls items over threshold. Items with quality < threshold, round robin
                            group->GroupLoot(loot, creature);
                            break;
                        case MASTER_LOOT:
                            group->MasterLoot(loot, creature);
                            break;
                        default:
                            break;
                    }
                }
            }

            // possible only if creature->lootForBody && loot->empty() at spell cast check
            if (loot_type == LOOT_SKINNING)
            {
                loot->clear();
                loot->FillLoot(creature->GetCreatureTemplate()->SkinLootId, LootTemplates_Skinning, this, true, false, creature);
                permission = OWNER_PERMISSION;
            }
            // set group rights only for loot_type != LOOT_SKINNING
            else
            {
                if(creature->IsPersonal() || creature->HasInLootList(GetGUID()))
                    permission = OWNER_PERMISSION;
                else if (Group* group = GetGroup())
                {
                    groupThreshold = group->GetThreshold();
                    if (group == recipient->GetGroup())
                    {
                        switch (group->GetLootMethod())
                        {
                            case MASTER_LOOT:
                                permission = MASTER_PERMISSION;
                                break;
                            case PERSONAL_LOOT:
                            case FREE_FOR_ALL:
                                permission = ALL_PERMISSION;
                                break;
                            default:
                                permission = GROUP_PERMISSION;
                                break;
                        }
                    }
                    else
                        permission = NONE_PERMISSION;
                }
                else if (recipient == this)
                    permission = OWNER_PERMISSION;
                else
                    permission = NONE_PERMISSION;
            }
        }
    }

    if (pool == 0)
        SetLootGUID(guid);

    // LOOT_INSIGNIA and LOOT_FISHINGHOLE unsupported by client
    switch (loot_type)
    {
        case LOOT_INSIGNIA:    loot_type = LOOT_SKINNING; break;
        case LOOT_FISHINGHOLE: loot_type = LOOT_FISHING; break;
        case LOOT_FISHING_JUNK: loot_type = LOOT_FISHING; break;
        default: break;
    }

    // need know merged fishing/corpse loot type for achievements
    loot->loot_type = loot_type;

    if (loot_type == LOOT_SKINNING && guid.GetEntry() == 103675) // For world quest complete
    {
        loot->AutoStoreItems();
        RemoveLoot(guid);
        CastSpell(this, 205285, false);
        return;
    }

    if (guid.IsGameObject())
    {
        GameObject *go = GetMap()->GetGameObject(guid);
        if (go)
        {
            switch (go->GetGoType())
            {
                case GAMEOBJECT_TYPE_CHEST:
                {
                    uint32 spell = go->GetGOInfo()->chest.spell;

                    if(go->GetGOInfo()->chest.chestPersonalLoot)
                    {
                        if(PersonalLootData const* plData = sObjectMgr->GetPersonalLootData(go->GetEntry()))
                        {
                            if(plData->respawn == TYPE_RESPAWN)
                                AddPlayerLootCooldown(go->GetGOInfo()->entry, go->GetGUIDLow());
                            else
                                AddPlayerLootCooldown(go->GetGOInfo()->entry, go->GetGUIDLow(), TYPE_GO, false);
                        }
                        else
                        {
                            if (go->GetGOInfo()->HasQuestItem() && GetMap()->GetDifficultyID() == DIFFICULTY_NONE)
                                AddPlayerLootCooldown(go->GetEntry(), go->GetGUIDLow(), TYPE_GUID, InInstance());
                            else
                                AddPlayerLootCooldown(go->GetEntry(), go->GetGUIDLow(), TYPE_GO, InInstance());
                        }
                    }
                    if (spell)
                        CastSpell(this, spell, false);
                    break;
                }
                case GAMEOBJECT_TYPE_GATHERING_NODE:
                    if (uint32 spell = go->GetGOInfo()->gatheringNode.spell)
                        CastSpell(this, spell, false);
                    break;
                default:
                    break;
            }
        }
    }

    //! 6.0.3
    if (permission != NONE_PERMISSION)
    {
        // Aoe loot
        WorldPackets::Loot::LootResponse packet;
        packet.LootObj = loot->GetGUID();
        packet.AcquireReason = loot_type;
        packet.Owner = guid;
        if (Group* group = GetGroup())
        {
            packet.LootMethod = group->GetLootMethod();
            packet.Threshold = group->GetLootThreshold();
        }
        packet.AELooting = AoeLoot;
        loot->isOpen = true;
        loot->BuildLootResponse(packet, this, permission, groupThreshold);

        SendDirectMessage(packet.Write());
        if (AoeLoot)
            SendDirectMessage(WorldPackets::Loot::NullSMsg(SMSG_AE_LOOT_TARGET_ACK).Write());

        // Personal loot
        if (lootPesonal)
        {
            WorldPackets::Loot::LootResponse packetPers;
            packetPers.LootObj = lootPesonal->GetGUID();
            packetPers.AcquireReason = loot_type;
            packetPers.Owner = guid;
            packetPers.AELooting = true;
            lootPesonal->BuildLootResponse(packetPers, this, ALL_PERMISSION, groupThreshold);
            SendDirectMessage(packetPers.Write());
            lootPesonal->isOpen = true;
            SendDirectMessage(WorldPackets::Loot::NullSMsg(SMSG_AE_LOOT_TARGET_ACK).Write());
        }
    }
    else
        SendLootError(guid, loot->GetGUID(), LOOT_ERROR_DIDNT_KILL);

    // add 'this' player as one of the players that are looting 'loot'
    if (permission != NONE_PERMISSION)
        loot->AddLooter(GetGUID());

    if (loot_type == LOOT_CORPSE && !guid.IsItem())
        SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_LOOTING);
}

void Player::AddTrackingQuestIfNeeded(ObjectGuid sourceGuid)
{
    uint32 trackingQuest = 0;

    if (sourceGuid.IsUnit())
        if (auto creatureSource = sObjectAccessor->FindCreature(sourceGuid))
            trackingQuest = creatureSource->GetTrackingQuestID();

    if (sourceGuid.IsGameObject())
        if (auto gameObjectSource = sObjectAccessor->FindGameObject(sourceGuid))
            trackingQuest = gameObjectSource->GetGOInfo()->GetTrackingQuestId();

    if (trackingQuest == 0)
        return;

    auto quest = sQuestDataStore->GetQuestTemplate(trackingQuest);
    if (quest == nullptr)
        return;
    
    if (CanTakeQuest(quest, false))
        CompleteQuest(trackingQuest);
}

void Player::SendLootError(ObjectGuid guid, ObjectGuid lGuid, LootError error)
{
    WorldPackets::Loot::LootResponse packet;
    packet.LootObj = guid;
    packet.Owner = lGuid;
    packet.LootMethod = LOOT_NONE;
    packet.FailureReason = error;
    SendDirectMessage(packet.Write());
}

void Player::SendNotifyLootMoneyRemoved(Loot* loot)
{
    WorldPackets::Loot::CoinRemoved removed;
    removed.LootObj = loot->GetGUID();
    SendDirectMessage(removed.Write());
}

void Player::SendNotifyLootItemRemoved(uint8 lootSlot, Loot* loot)
{
    WorldPackets::Loot::LootRemoved packet;
    packet.Owner = loot->objGuid;
    packet.LootObj = loot->GetGUID();
    packet.LootListID = lootSlot + 1;
    SendDirectMessage(packet.Write());
}

void Player::SendUpdateWorldState(uint32 variableID, uint32 value, bool hidden /*= false*/)
{
    WorldPackets::WorldState::UpdateWorldState packet;
    packet.Value = value;
    packet.VariableID = static_cast<WorldStates>(variableID);
    packet.Hidden = hidden;
    SendDirectMessage(packet.Write());
}

void Player::SendInitWorldStates(uint32 zoneid, uint32 areaid)
{
    WorldPackets::WorldState::InitWorldStates packet;

    packet.MapID = GetMapId();
    packet.AreaID = zoneid;
    packet.SubareaID = areaid;

    if (auto* worldStates = sWorldStateMgr.GetInitWorldStates(this))
    {
        for (auto& ws : *worldStates)
            packet.Worldstates.emplace_back(ws->VariableID, ws->Value);
        delete worldStates;
    }

    if (auto bf = sBattlefieldMgr->GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_WG))
        bf->FillInitialWorldStates(packet);

    if (auto bf = sBattlefieldMgr->GetBattlefieldByBattleId(BATTLEFIELD_BATTLEID_TB))
        bf->FillInitialWorldStates(packet);
    
    if (auto pvp = sOutdoorPvPMgr->GetOutdoorPvPToZoneId(zoneid))
        pvp->FillInitialWorldStates(packet);
        
    if (auto bg = GetBattleground())
        bg->FillInitialWorldStates(packet);
    
    if (auto instance = GetInstanceScript())
        instance->FillInitialWorldStates(packet);

    uint32 expirationTimer = MS::Utilities::Globals::InSeconds::Week;

    if (sBattlegroundMgr->IsBrawlActive(expirationTimer))
    {
        switch (sBattlegroundMgr->GetBrawlIternalGroup())
        {
        case 0:
            packet.Worldstates.emplace_back(static_cast<WorldStates>(13119), 3);
            break;
        case 1:
            packet.Worldstates.emplace_back(static_cast<WorldStates>(13119), 10);
            break;
        case 4:
            packet.Worldstates.emplace_back(static_cast<WorldStates>(13119), 8);
            break;
        case 5:
            packet.Worldstates.emplace_back(static_cast<WorldStates>(13119), 4);
            break;
        case 6:
            packet.Worldstates.emplace_back(static_cast<WorldStates>(13119), 11);
            break;
        case 2:
        case 7:
            packet.Worldstates.emplace_back(static_cast<WorldStates>(13119), 0);
            break;
        case 3:
        case 8:
            packet.Worldstates.emplace_back(static_cast<WorldStates>(13119), 4);
            break;
        }
    }

    SendDirectMessage(packet.Write());

    if (getLevel() >= MAX_LEVEL)
    {
        if (WorldQuestMap const* worldQuestInfo = sQuestDataStore->GetWorldQuestMap())
        {
            for (WorldQuestMap::const_iterator itr = worldQuestInfo->begin(); itr != worldQuestInfo->end(); ++itr)
            {
                for (std::map<uint32 /*QuestID*/, WorldQuest>::const_iterator iter = itr->second.begin(); iter != itr->second.end(); ++iter)
                {
                    WorldQuest const* worldQuest = &iter->second;
                    if (!worldQuest || WorldQuestCompleted(worldQuest->QuestID))
                        continue;

                    if (!worldQuest->quest || !worldQuest->quest->IsEmissary() || (FindQuestSlot(iter->first) < MAX_QUEST_LOG_SIZE))
                        continue;

                    if (sQuestDataStore->WorldLegionInvasionZoneID && sQuestDataStore->WorldLegionInvasionZoneID == worldQuest->quest->QuestSortID && !worldQuest->worldQuest->PrimaryID && !worldQuest->quest->IsLegionInvasion())
                        continue;

                    if (CanAddQuest(worldQuest->quest, true))
                    {
                        AddQuest(worldQuest->quest, NULL);
                        UpdateQuestObjectiveData(worldQuest->quest);
                    }
                }
            }
        }
    }
}

uint32 Player::GetXPRestBonus(uint32 xp)
{
    uint32 rested_bonus = (uint32)GetRestBonus();           // xp for each rested bonus

    if (rested_bonus > xp)                                   // max rested_bonus == xp or (r+x) = 200% xp
        rested_bonus = xp;

    SetRestBonus(GetRestBonus() - rested_bonus);

    TC_LOG_DEBUG(LOG_FILTER_PLAYER, "Player gain %u xp (+ %u Rested Bonus). Rested points=%f", xp+rested_bonus, rested_bonus, GetRestBonus());
    return rested_bonus;
}

void Player::SetBindPoint(ObjectGuid guid)
{
    SendDirectMessage(WorldPackets::Misc::BinderConfirm(guid).Write());
}

void Player::SendTalentWipeConfirm(ObjectGuid guid, RespecType type /*= RESPEC_TYPE_TALENTS*/)
{
    WorldPackets::Misc::RespecWipeConfirm wipeConfirm;
    wipeConfirm.RespecMaster = guid;
    wipeConfirm.respecType = type;
    wipeConfirm.Cost = 0;
    SendDirectMessage(wipeConfirm.Write());
}

/*********************************************************/
/***                    STORAGE SYSTEM                 ***/
/*********************************************************/

void Player::SetVirtualItemSlot(uint8 i, Item* item)
{
    ASSERT(i < 3);
    if (i < 2 && item)
    {
        if (!item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
            return;
        uint32 charges = item->GetEnchantmentCharges(TEMP_ENCHANTMENT_SLOT);
        if (charges == 0)
            return;
        if (charges > 1)
            item->SetEnchantmentCharges(TEMP_ENCHANTMENT_SLOT, charges-1);
        else if (charges <= 1)
        {
            ApplyEnchantment(item, TEMP_ENCHANTMENT_SLOT, false);
            item->ClearEnchantment(TEMP_ENCHANTMENT_SLOT);
        }
    }
}

void Player::SetSheath(SheathState sheathed)
{
    switch (sheathed)
    {
        case SHEATH_STATE_MELEE: // prepared melee weapon
            SetVirtualItemSlot(0, GetWeaponForAttack(BASE_ATTACK, true));
            SetVirtualItemSlot(1, GetWeaponForAttack(OFF_ATTACK, true));
            SetVirtualItemSlot(2, nullptr);
            break;
        case SHEATH_STATE_RANGED: // prepared ranged weapon
            SetVirtualItemSlot(0, nullptr);
            SetVirtualItemSlot(1, nullptr);
            SetVirtualItemSlot(2, GetWeaponForAttack(RANGED_ATTACK, true));
            break;
        case SHEATH_STATE_UNARMED: // no prepared weapon
        default:
            for (uint8 i = 0; i < 3; ++i)
                SetVirtualItemSlot(i, nullptr);
            break;
    }

    Unit::SetSheath(sheathed);                              // this must visualize Sheath changing for other players...
}

uint8 Player::FindEquipSlot(ItemTemplate const* proto, uint32 slot, bool swap) const
{
    uint8 playerClass = getClass();

    uint8 slots[4];
    slots[0] = NULL_SLOT;
    slots[1] = NULL_SLOT;
    slots[2] = NULL_SLOT;
    slots[3] = NULL_SLOT;
    switch (proto->GetInventoryType())
    {
        case INVTYPE_HEAD:
            slots[0] = EQUIPMENT_SLOT_HEAD;
            break;
        case INVTYPE_NECK:
            slots[0] = EQUIPMENT_SLOT_NECK;
            break;
        case INVTYPE_SHOULDERS:
            slots[0] = EQUIPMENT_SLOT_SHOULDERS;
            break;
        case INVTYPE_BODY:
            slots[0] = EQUIPMENT_SLOT_BODY;
            break;
        case INVTYPE_CHEST:
            slots[0] = EQUIPMENT_SLOT_CHEST;
            break;
        case INVTYPE_ROBE:
            slots[0] = EQUIPMENT_SLOT_CHEST;
            break;
        case INVTYPE_WAIST:
            slots[0] = EQUIPMENT_SLOT_WAIST;
            break;
        case INVTYPE_LEGS:
            slots[0] = EQUIPMENT_SLOT_LEGS;
            break;
        case INVTYPE_FEET:
            slots[0] = EQUIPMENT_SLOT_FEET;
            break;
        case INVTYPE_WRISTS:
            slots[0] = EQUIPMENT_SLOT_WRISTS;
            break;
        case INVTYPE_HANDS:
            slots[0] = EQUIPMENT_SLOT_HANDS;
            break;
        case INVTYPE_FINGER:
            slots[0] = EQUIPMENT_SLOT_FINGER1;
            slots[1] = EQUIPMENT_SLOT_FINGER2;
            break;
        case INVTYPE_TRINKET:
            slots[0] = EQUIPMENT_SLOT_TRINKET1;
            slots[1] = EQUIPMENT_SLOT_TRINKET2;
            break;
        case INVTYPE_CLOAK:
            slots[0] = EQUIPMENT_SLOT_BACK;
            break;
        case INVTYPE_WEAPON:
        {
            slots[0] = EQUIPMENT_SLOT_MAINHAND;

            // suggest offhand slot only if know dual wielding
            // (this will be replace mainhand weapon at auto equip instead unwonted "you don't known dual wielding" ...
            if (CanDualWield() || proto->GetSubClass() == ITEM_SUBCLASS_WEAPON_WARGLAIVES)
                slots[1] = EQUIPMENT_SLOT_OFFHAND;
            break;
        }
        case INVTYPE_SHIELD:
            slots[0] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_RANGED:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
            {
                if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                {
                    if (mhWeaponProto->GetSubClass() == ITEM_SUBCLASS_WEAPON_STAFF)
                    {
                        const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                        break;
                    }
                }
            }

            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
            {
                if (proto->GetSubClass() == ITEM_SUBCLASS_WEAPON_STAFF)
                {
                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                    break;
                }
            }
            break;
        case INVTYPE_2HWEAPON:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
            {
                if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                {
                    if (mhWeaponProto->GetSubClass() == ITEM_SUBCLASS_WEAPON_STAFF)
                    {
                        const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                        break;
                    }
                }
            }

            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
            {
                if (proto->GetSubClass() == ITEM_SUBCLASS_WEAPON_STAFF)
                {
                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                    break;
                }
            }
            if (CanDualWield() && CanTitanGrip() && proto->GetSubClass() != ITEM_SUBCLASS_WEAPON_STAFF)
                slots[1] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_TABARD:
            slots[0] = EQUIPMENT_SLOT_TABARD;
            break;
        case INVTYPE_WEAPONMAINHAND:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            if (proto->GetSubClass() == ITEM_SUBCLASS_WEAPON_WARGLAIVES)
                slots[1] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_WEAPONOFFHAND:
            slots[0] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_HOLDABLE:
            slots[0] = EQUIPMENT_SLOT_OFFHAND;
            break;
        case INVTYPE_THROWN:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
            {
                if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                {
                    if (mhWeaponProto->GetSubClass() == ITEM_SUBCLASS_WEAPON_POLEARM || mhWeaponProto->GetSubClass() == ITEM_SUBCLASS_WEAPON_STAFF)
                    {
                        const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                        break;
                    }
                }
            }

            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
            {
                if (proto->GetSubClass() == ITEM_SUBCLASS_WEAPON_POLEARM || proto->GetSubClass() == ITEM_SUBCLASS_WEAPON_STAFF)
                {
                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                    break;
                }
            }
            break;
        case INVTYPE_RANGEDRIGHT:
            slots[0] = EQUIPMENT_SLOT_MAINHAND;
            if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
            {
                if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                {
                    if (mhWeaponProto->GetSubClass() == ITEM_SUBCLASS_WEAPON_POLEARM || mhWeaponProto->GetSubClass() == ITEM_SUBCLASS_WEAPON_STAFF)
                    {
                        const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                        break;
                    }
                }
            }

            if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
            {
                if (proto->GetSubClass() == ITEM_SUBCLASS_WEAPON_POLEARM || proto->GetSubClass() == ITEM_SUBCLASS_WEAPON_STAFF)
                {
                    const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                    break;
                }
            }
            break;
        case INVTYPE_BAG:
            slots[0] = INVENTORY_SLOT_BAG_START + 0;
            slots[1] = INVENTORY_SLOT_BAG_START + 1;
            slots[2] = INVENTORY_SLOT_BAG_START + 2;
            slots[3] = INVENTORY_SLOT_BAG_START + 3;
            break;
        case INVTYPE_RELIC:
        {
           if (playerClass == CLASS_PALADIN || playerClass == CLASS_DRUID ||
               playerClass == CLASS_SHAMAN || playerClass == CLASS_DEATH_KNIGHT)
           {
               slots[0] = EQUIPMENT_SLOT_MAINHAND;
               if (Item* mhWeapon = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
               {
                   if (ItemTemplate const* mhWeaponProto = mhWeapon->GetTemplate())
                   {
                       if (mhWeaponProto->GetSubClass() == ITEM_SUBCLASS_WEAPON_POLEARM || mhWeaponProto->GetSubClass() == ITEM_SUBCLASS_WEAPON_STAFF)
                       {
                           const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                           break;
                       }
                   }
               }

               if (GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
               {
                   if (proto->GetSubClass() == ITEM_SUBCLASS_WEAPON_POLEARM || proto->GetSubClass() == ITEM_SUBCLASS_WEAPON_STAFF)
                   {
                       const_cast<Player*>(this)->AutoUnequipOffhandIfNeed(true);
                       break;
                   }
               }
           }
           break;
        }
        default:
            return NULL_SLOT;
    }

    if (slot != NULL_SLOT)
    {
        if (swap || !GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
            for (uint8 i = 0; i < 4; ++i)
                if (slots[i] == slot)
                    return slot;
    }
    else
    {
        // search free slot at first
        for (uint8 i = 0; i < 4; ++i)
            if (slots[i] != NULL_SLOT && !GetItemByPos(INVENTORY_SLOT_BAG_0, slots[i]))
                // in case 2hand equipped weapon (without titan grip) offhand slot empty but not free
                if (slots[i] != EQUIPMENT_SLOT_OFFHAND || !IsTwoHandUsed())
                    return slots[i];

        // if not found free and can swap return first appropriate from used
        for (uint8 i = 0; i < 4; ++i)
            if (slots[i] != NULL_SLOT && swap)
                return slots[i];
    }

    // no free position
    return NULL_SLOT;
}

uint8 Player::GetGuessedEquipSlot(ItemTemplate const* proto) const
{
    switch (proto->GetInventoryType())
    {
    case INVTYPE_HEAD:
        return EQUIPMENT_SLOT_HEAD;
    case INVTYPE_NECK:
        return EQUIPMENT_SLOT_NECK;
    case INVTYPE_SHOULDERS:
        return EQUIPMENT_SLOT_SHOULDERS;
    case INVTYPE_BODY:
        return EQUIPMENT_SLOT_BODY;
    case INVTYPE_CHEST:
        return EQUIPMENT_SLOT_CHEST;
    case INVTYPE_ROBE:
        return EQUIPMENT_SLOT_CHEST;
    case INVTYPE_WAIST:
        return EQUIPMENT_SLOT_WAIST;
    case INVTYPE_LEGS:
        return EQUIPMENT_SLOT_LEGS;
    case INVTYPE_FEET:
        return EQUIPMENT_SLOT_FEET;
    case INVTYPE_WRISTS:
        return EQUIPMENT_SLOT_WRISTS;
    case INVTYPE_HANDS:
        return EQUIPMENT_SLOT_HANDS;
    case INVTYPE_FINGER:
        return EQUIPMENT_SLOT_FINGER1;
    case INVTYPE_TRINKET:
        return EQUIPMENT_SLOT_TRINKET1;
    case INVTYPE_CLOAK:
        return EQUIPMENT_SLOT_BACK;
    case INVTYPE_WEAPON:
        return EQUIPMENT_SLOT_MAINHAND;
    case INVTYPE_SHIELD:
        return EQUIPMENT_SLOT_OFFHAND;
    case INVTYPE_RANGED:
        return EQUIPMENT_SLOT_MAINHAND;
    case INVTYPE_2HWEAPON:
        return EQUIPMENT_SLOT_MAINHAND;
    case INVTYPE_TABARD:
        return EQUIPMENT_SLOT_TABARD;
    case INVTYPE_WEAPONMAINHAND:
        return EQUIPMENT_SLOT_MAINHAND;
    case INVTYPE_WEAPONOFFHAND:
        return EQUIPMENT_SLOT_OFFHAND;
    case INVTYPE_HOLDABLE:
        return EQUIPMENT_SLOT_OFFHAND;
    case INVTYPE_THROWN:
        return EQUIPMENT_SLOT_MAINHAND;
    case INVTYPE_RANGEDRIGHT:
        return EQUIPMENT_SLOT_MAINHAND;
    case INVTYPE_BAG:
        return INVENTORY_SLOT_BAG_START;
    default:
        return NULL_SLOT;
    }
}

InventoryResult Player::CanUnequipItems(uint32 item, uint32 count) const
{
    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item))
        if (uint32 artifactID = proto->GetArtifactID())
            if (ArtifactEntry const* entry = sArtifactStore.LookupEntry(artifactID))
                if (entry->ChrSpecializationID != GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID))
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;

    uint32 tempcount = 0;

    InventoryResult res = EQUIP_ERR_OK;

    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == item)
            {
                InventoryResult ires = CanUnequipItem(INVENTORY_SLOT_BAG_0 << 8 | i, false);
                if (ires == EQUIP_ERR_OK)
                {
                    tempcount += pItem->GetCount();
                    if (tempcount >= count)
                        return EQUIP_ERR_OK;
                }
                else
                    res = ires;
            }

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == item)
            {
                tempcount += pItem->GetCount();
                if (tempcount >= count)
                    return EQUIP_ERR_OK;
            }

    for (uint8 i = REAGENT_SLOT_START; i < REAGENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == item)
            {
                tempcount += pItem->GetCount();
                if (tempcount >= count)
                    return EQUIP_ERR_OK;
            }

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == item)
            {
                tempcount += pItem->GetCount();
                if (tempcount >= count)
                    return EQUIP_ERR_OK;
            }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = GetItemByPos(i, j))
                    if (pItem->GetEntry() == item)
                    {
                        tempcount += pItem->GetCount();
                        if (tempcount >= count)
                            return EQUIP_ERR_OK;
                    }

    // not found req. item count and have unequippable items
    return res;
}

uint32 Player::GetItemCount(uint32 item, bool inBankAlso, Item* skipItem) const
{
    uint32 count = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < GetInventoryEndSlot(); i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem &&  pItem->GetEntry() == item)
                count += pItem->GetCount();

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCount(item, skipItem);

    if (skipItem && skipItem->GetTemplate()->GetGemProperties())
        for (uint8 i = EQUIPMENT_SLOT_START; i < GetInventoryEndSlot(); ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetTemplate()->GetSocketType(0))
                    count += pItem->GetGemCountWithID(item);

    if (inBankAlso)
    {
        // checking every item from 39 to 74 (including bank bags)
        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetEntry() == item)
                    count += pItem->GetCount();

        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
            if (Bag* pBag = GetBagByPos(i))
                count += pBag->GetItemCount(item, skipItem);

        if (skipItem && skipItem->GetTemplate()->GetGemProperties())
            for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; ++i)
                if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (pItem != skipItem && pItem->GetTemplate()->GetSocketType(0))
                        count += pItem->GetGemCountWithID(item);
    }

    for (uint8 i = REAGENT_SLOT_START; i < REAGENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem &&  pItem->GetEntry() == item)
                count += pItem->GetCount();

    if (skipItem && skipItem->GetTemplate()->GetGemProperties())
        for (uint8 i = REAGENT_SLOT_START; i < REAGENT_SLOT_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetSocketColor(0))
                    count += pItem->GetGemCountWithID(item);

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem &&  pItem->GetEntry() == item)
                count += pItem->GetCount();

    if (skipItem && skipItem->GetTemplate()->GetGemProperties())
        for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem != skipItem && pItem->GetSocketColor(0))
                    count += pItem->GetGemCountWithID(item);
    return count;
}

uint32 Player::GetItemCountWithLimitCategory(uint32 limitCategory, Item* skipItem) const
{
    uint32 count = 0;
    for (int i = EQUIPMENT_SLOT_START; i < GetInventoryEndSlot(); ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem)
                if (ItemTemplate const* pProto = pItem->GetTemplate())
                    if (pProto->GetLimitCategory() == limitCategory)
                        count += pItem->GetCount();

    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCountWithLimitCategory(limitCategory, skipItem);

    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem)
                if (ItemTemplate const* pProto = pItem->GetTemplate())
                    if (pProto->GetLimitCategory() == limitCategory)
                        count += pItem->GetCount();

    for (int i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCountWithLimitCategory(limitCategory, skipItem);

    for (uint8 i = REAGENT_SLOT_START; i < REAGENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem)
                if (ItemTemplate const* pProto = pItem->GetTemplate())
                    if (pProto->GetLimitCategory() == limitCategory)
                        count += pItem->GetCount();

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem != skipItem)
                if (ItemTemplate const* pProto = pItem->GetTemplate())
                    if (pProto->GetLimitCategory() == limitCategory)
                        count += pItem->GetCount();

    return count;
}

uint32 Player::GetItemCountByQuality(uint8 Quality, int8 Expansion, bool inBankAlso) const
{
    uint32 count = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < GetInventoryEndSlot(); i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (ItemTemplate const* pProto = pItem->GetTemplate())
                if (pProto->GetQuality() == Quality && (Expansion == -1 || Expansion == pProto->GetExpansion()))
                    count += pItem->GetCount();

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            count += pBag->GetItemCountByQuality(Quality, Expansion);

    if (inBankAlso)
    {
        // checking every item from 39 to 74 (including bank bags)
        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (ItemTemplate const* pProto = pItem->GetTemplate())
                    if (pProto->GetQuality() == Quality && (Expansion == -1 || Expansion == pProto->GetExpansion()))
                        count += pItem->GetCount();

        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
            if (Bag* pBag = GetBagByPos(i))
                count += pBag->GetItemCountByQuality(Quality, Expansion);
    }

    for (uint8 i = REAGENT_SLOT_START; i < REAGENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (ItemTemplate const* pProto = pItem->GetTemplate())
                if (pProto->GetQuality() == Quality && (Expansion == -1 || Expansion == pProto->GetExpansion()))
                    count += pItem->GetCount();

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (ItemTemplate const* pProto = pItem->GetTemplate())
                if (pProto->GetQuality() == Quality && (Expansion == -1 || Expansion == pProto->GetExpansion()))
                    count += pItem->GetCount();

    if (!m_mailsLoaded)
        const_cast<Player*>(this)->_LoadMail();

    for (ItemMap::iterator iter = const_cast<Player*>(this)->mMitems.begin(); iter != const_cast<Player*>(this)->mMitems.end(); ++iter)
        if (Item* pItem = iter->second)
            if (ItemTemplate const* pProto = pItem->GetTemplate())
                if (pProto->GetQuality() == Quality && (Expansion == -1 || Expansion == pProto->GetExpansion()))
                    count += pItem->GetCount();

    return count;
}

Item* Player::GetItemByGuid(ObjectGuid guid) const
{
    // if (!IsInWorld())
        // return nullptr;

    for (uint8 i = EQUIPMENT_SLOT_START; i < GetInventoryEndSlot(); ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;

    for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;

    for (uint8 i = REAGENT_SLOT_START; i < REAGENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetGUID() == guid)
                return pItem;

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetGUID() == guid)
                        return pItem;

    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetGUID() == guid)
                        return pItem;

    return nullptr;
}

Item* Player::GetItemByPos(uint16 pos) const
{
    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;
    return GetItemByPos(bag, slot);
}

Item* Player::GetItemByPos(uint8 bag, uint8 slot) const
{
    if (bag == INVENTORY_SLOT_BAG_0 && slot < PLAYER_SLOT_END && (slot < BUYBACK_SLOT_START || slot >= BUYBACK_SLOT_END))
        return m_items[slot];
    if (Bag* pBag = GetBagByPos(bag))
        return pBag->GetItemByPos(slot);

    return nullptr;
}

Bag* Player::GetBagByPos(uint8 bag) const
{
    if ((bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END) || (bag >= BANK_SLOT_BAG_START && bag < BANK_SLOT_BAG_END))
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, bag))
            return item->ToBag();

    return nullptr;
}

Item* Player::GetUseableItemByPos(uint8 bag, uint8 slot) const
{
    if (!CanUseAttackType(GetAttackBySlot(slot)))
        return NULL;
    return GetItemByPos(bag, slot);
}

Item* Player::GetWeaponForAttack(WeaponAttackType attackType, bool useable /*= false*/) const
{
    uint8 slot;
    switch (attackType)
    {
        case BASE_ATTACK:   slot = EQUIPMENT_SLOT_MAINHAND; break;
        case OFF_ATTACK:    slot = EQUIPMENT_SLOT_OFFHAND;  break;
        case RANGED_ATTACK: slot = EQUIPMENT_SLOT_MAINHAND;   break;
        default: return NULL;
    }

    Item* item = NULL;
    if (useable)
        item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, slot);
    else
        item = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
    if (!item || item->GetTemplate()->GetClass() != ITEM_CLASS_WEAPON)
        return NULL;

    if (!useable)
        return item;

    if (item->CantBeUse() || IsInFeralForm())
        return NULL;

    return item;
}

Item* Player::GetShield(bool useable) const
{
    Item* item = NULL;
    if (useable)
        item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    else
        item = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    if (!item || item->GetTemplate()->GetClass() != ITEM_CLASS_ARMOR)
        return NULL;

    if (!useable)
        return item;

    if (item->CantBeUse())
        return NULL;

    return item;
}

Item* Player::GetChildItemByGuid(ObjectGuid guid) const
{
    for (uint8 i = EQUIPMENT_SLOT_START; i < GetInventoryEndSlot(); ++i)
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (item->GetGUID() == guid)
                return item;

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (item->GetGUID() == guid)
                return item;

    return nullptr;
}

uint8 Player::GetAttackBySlot(uint8 slot)
{
    switch (slot)
    {
        case EQUIPMENT_SLOT_MAINHAND: return BASE_ATTACK;
        case EQUIPMENT_SLOT_OFFHAND:  return OFF_ATTACK;
        default:                      return MAX_ATTACK;
    }
}

bool Player::IsInventoryPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && slot == NULL_SLOT)
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_ITEM_START && slot < INVENTORY_SLOT_ITEM_END))
        return true;
    if (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END)
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= REAGENT_SLOT_START && slot < REAGENT_SLOT_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= CHILD_EQUIPMENT_SLOT_START && slot < CHILD_EQUIPMENT_SLOT_END))
        return true;
    return false;
}

bool Player::IsEquipmentPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && (slot < EQUIPMENT_SLOT_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END))
        return true;
    return false;
}

bool Player::IsBankPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_ITEM_START && slot < BANK_SLOT_ITEM_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END))
        return true;
    if (bag >= BANK_SLOT_BAG_START && bag < BANK_SLOT_BAG_END)
        return true;
    return false;
}

bool Player::IsReagentBankPos(uint8 bag, uint8 slot)
{
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= REAGENT_SLOT_START && slot < REAGENT_SLOT_END))
        return true;
    return false;
}

bool Player::IsBagPos(uint16 pos)
{
    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END))
        return true;
    if (bag == INVENTORY_SLOT_BAG_0 && (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END))
        return true;
    return false;
}

bool Player::IsChildEquipmentPos(uint8 bag, uint8 slot)
{
    return bag == INVENTORY_SLOT_BAG_0 && (slot >= CHILD_EQUIPMENT_SLOT_START && slot < CHILD_EQUIPMENT_SLOT_END);
}
bool Player::IsValidPos(uint8 bag, uint8 slot, bool explicit_pos)
{
    // post selected
    if (bag == NULL_BAG && !explicit_pos)
        return true;

    if (bag == INVENTORY_SLOT_BAG_0)
    {
        // any post selected
        if (slot == NULL_SLOT && !explicit_pos)
            return true;

        // equipment
        if (slot < EQUIPMENT_SLOT_END)
            return true;

        // bag equip slots
        if (slot >= INVENTORY_SLOT_BAG_START && slot < INVENTORY_SLOT_BAG_END)
            return true;

        // backpack slots
        if (slot >= INVENTORY_SLOT_ITEM_START && slot < GetInventoryEndSlot())
            return true;

        // bank main slots
        if (slot >= BANK_SLOT_ITEM_START && slot < BANK_SLOT_ITEM_END)
            return true;

        // bank bag slots
        if (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END)
            return true;

        // bank reagent slots
        if (slot >= REAGENT_SLOT_START && slot < REAGENT_SLOT_END)
            return true;

        return false;
    }

    // bag content slots
    // bank bag content slots
    if (Bag* pBag = GetBagByPos(bag))
    {
        // any post selected
        if (slot == NULL_SLOT && !explicit_pos)
            return true;

        return slot < pBag->GetBagSize();
    }

    // where this?
    return false;
}

bool Player::HasToken(uint8 tokenType, uint32 count) const
{    
    if (!GetCanUseDonate()) // if this there, then will cancel next buying by all steps
    {
        ChatHandler chH = ChatHandler(const_cast<Player*>(this));
        chH.PSendSysMessage(20079);
        return false;
    }
    
    if (sWorld->getBoolConfig(CONFIG_DONATE_ON_TESTS))
        return true;
    
    if (GetSession()->GetTokenBalance(tokenType) >= count)
        return true;

	ChatHandler chH = ChatHandler(const_cast<Player*>(this));
	chH.PSendSysMessage(20000, count);
    return false;
}

bool Player::ChangeTokenCount(uint8 tokenType, int64 change, uint8 buyType, uint64 productId)
{
    if (sWorld->getBoolConfig(CONFIG_DONATE_ON_TESTS)) // if test, then free donate
        return true;

    if (change < 0 && !HasToken(tokenType, change * -1))
        return false;
    
    ModifyCanUseDonate(false); // prevent others buying, while processing this buy
    
    SQLTransaction trans = LoginDatabase.BeginTransaction();
    
    PreparedStatement* stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_OR_UPD_TOKEN);
    stmt->setUInt32(0, GetSession()->GetAccountId());
    stmt->setUInt8(1, tokenType);
    stmt->setInt64(2, change);
    stmt->setInt64(3, change);
    trans->Append(stmt);
    
    //INSERT INTO `account_donate_token_log` (`accountId`, `realmId`, `characterId`, `change`, `tokenType`, `buyType`, `productId`) VALUES (?, ?, ?, ?, ?, ?, ?)
    stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_LOG_USE_DONATE_TOKEN);
    stmt->setUInt32(0, GetSession()->GetAccountId());
    stmt->setUInt32(1, GetSession()->_realmID);
    stmt->setUInt64(2, GetGUID().GetCounter());
    stmt->setInt64(3, change);
    stmt->setUInt8(4, tokenType);
    stmt->setUInt8(5, buyType);
    stmt->setUInt64(6, productId);
    trans->Append(stmt);

    uint32 guid = GetGUIDLow();
    LoginDatabase.CommitTransaction(trans, [guid, tokenType, change]() -> void
    {
        if (Player* target = sObjectMgr->GetPlayerByLowGUID(guid))
        {
            target->GetSession()->ChangeTokenBalance(tokenType, change);
            target->ModifyCanUseDonate(true); // succes, return this
            ChatHandler chH = ChatHandler(target);
            chH.PSendSysMessage(20062, change * -1);
            target->GetSession()->GetBattlePayMgr()->SendPointsBalance();
        }
    }); 
    
    return true;
}

std::string Player::GetInfoForDonate() const
{
    std::ostringstream info;

    info <<
    "Player info: acc = " << GetSession()->GetAccountId() <<
    ", bnet_acc = " << GetSession()->GetAccountId() <<
    ", char_guid = " << GetGUIDLow()  <<
    ", tokens = " << GetSession()->GetTokenBalance(sWorld->getIntConfig(CONFIG_DONATE_VENDOR_TOKEN_TYPE));

    return info.str();
}

void Player::SetInventorySlotCount(uint8 slots)
{
    ASSERT(slots <= (INVENTORY_SLOT_ITEM_END - INVENTORY_SLOT_ITEM_START));

    if (slots < GetInventorySlotCount())
    {
        std::vector<Item*> unstorableItems;

        for (uint8 slot = INVENTORY_SLOT_ITEM_START + slots; slot < INVENTORY_SLOT_ITEM_END; ++slot)
            if (Item* unstorableItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
                unstorableItems.push_back(unstorableItem);

        if (!unstorableItems.empty())
        {
            std::size_t fullBatches = unstorableItems.size() / MAX_MAIL_ITEMS;
            std::size_t remainder = unstorableItems.size() % MAX_MAIL_ITEMS;
            SQLTransaction trans = CharacterDatabase.BeginTransaction();

            auto sendItemsBatch = [this, &trans, &unstorableItems](std::size_t batchNumber, std::size_t batchSize)
            {
                MailDraft draft(GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM), "There were problems with equipping item(s).");
                for (std::size_t j = 0; j < batchSize; ++j)
                    draft.AddItem(unstorableItems[batchNumber * MAX_MAIL_ITEMS + j]);

                draft.SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);
            };

            for (std::size_t batch = 0; batch < fullBatches; ++batch)
                sendItemsBatch(batch, MAX_MAIL_ITEMS);

            if (remainder)
                sendItemsBatch(fullBatches, remainder);

            CharacterDatabase.CommitTransaction(trans);

            SendDirectMessage(WorldPackets::Item::CharacterInventoryOverflowWarning().Write());
        }
    }

    SetByteValue(PLAYER_FIELD_BYTES_7, PLAYER_BYTES_5_NUM_BACKPACK_SLOTS, slots);
    _inventoryEndSlot = INVENTORY_SLOT_ITEM_START + GetInventorySlotCount();
}

uint8 Player::GetInventoryEndSlot() const
{
    return _inventoryEndSlot;
}

bool Player::HasItemCount(uint32 item, uint32 count, bool inBankAlso) const
{
    uint32 tempcount = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < GetInventoryEndSlot(); i++)
    {
        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                Item* pItem = GetItemByPos(i, j);
                if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
                {
                    tempcount += pItem->GetCount();
                    if (tempcount >= count)
                        return true;
                }
            }
        }
    }

    if (inBankAlso)
    {
        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
        {
            Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
            if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                tempcount += pItem->GetCount();
                if (tempcount >= count)
                    return true;
            }
        }
        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
        {
            if (Bag* pBag = GetBagByPos(i))
            {
                for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                {
                    Item* pItem = GetItemByPos(i, j);
                    if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
                    {
                        tempcount += pItem->GetCount();
                        if (tempcount >= count)
                            return true;
                    }
                }
            }
        }
    }

    for (uint8 i = REAGENT_SLOT_START; i < REAGENT_SLOT_END; i++)
    {
        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }
    }

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; i++)
    {
        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }
    }

    return false;
}

void Player::DepositItemToReagentBank()
{
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); i++)
    {
        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem && !pItem->IsInTrade())
            MoveItemReagentBank(pItem);
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                Item* pItem = GetItemByPos(i, j);
                if (pItem && !pItem->IsInTrade())
                    MoveItemReagentBank(pItem);
            }
        }
    }
}

void Player::MoveItemReagentBank(Item* item)
{
    ItemPosCountVec dest;
    InventoryResult msg = CanBankReagentItem(NULL_BAG, NULL_SLOT, dest, item, false);
    if (msg != EQUIP_ERR_OK)
        return;

    RemoveItem(item->GetBagSlot(), item->GetSlot(), true);
    StoreItem(dest, item, true);
}

bool Player::HasItemOrGemWithIdEquipped(uint32 item, uint32 count, uint8 except_slot) const
{
    uint32 tempcount = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == except_slot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem && pItem->GetEntry() == item)
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }
    }

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(item);
    if (pProto && pProto->GetGemProperties())
    {
        for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
        {
            if (i == except_slot)
                continue;

            Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
            if (pItem && pItem->GetTemplate()->GetSocketType(0))
            {
                tempcount += pItem->GetGemCountWithID(item);
                if (tempcount >= count)
                    return true;
            }
        }
    }

    return false;
}

bool Player::HasItemOrGemWithLimitCategoryEquipped(uint32 limitCategory, uint32 count, uint8 except_slot) const
{
    uint32 tempcount = 0;
    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == except_slot)
            continue;

        Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (!pItem)
            continue;

        ItemTemplate const* pProto = pItem->GetTemplate();
        if (!pProto)
            continue;

        if (pProto->GetLimitCategory() == limitCategory)
        {
            tempcount += pItem->GetCount();
            if (tempcount >= count)
                return true;
        }

        if (pProto->GetSocketType(0) || pItem->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT))
        {
            tempcount += pItem->GetGemCountWithLimitCategory(limitCategory);
            if (tempcount >= count)
                return true;
        }
    }

    return false;
}

bool Player::CanUseReagentBank() const
{
    return HasFlag(PLAYER_FIELD_PLAYER_FLAGS_EX, PLAYER_FLAGS_EX_REAGENT_BANK_UNLOCKED);
}

InventoryResult Player::CanTakeMoreSimilarItems(uint32 entry, uint32 count, Item* pItem, uint32* no_space_count, bool quest) const
{
    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
    if (!pProto)
    {
        if (no_space_count)
            *no_space_count = count;
        return EQUIP_ERR_ITEM_MAX_COUNT;
    }

    if (pItem && pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    // no maximum
    if ((pProto->GetMaxCount() <= 0 && pProto->GetLimitCategory() == 0) || pProto->GetMaxCount() == 2147483647)
        return EQUIP_ERR_OK;

    if (pProto->GetMaxCount() > 0)
    {
        uint32 curcount = GetItemCount(pProto->GetId(), true, pItem);
        if (quest)
        {
            if (curcount >= uint32(pProto->GetMaxCount()))
            {
                if (no_space_count)
                    *no_space_count = count + curcount - pProto->GetMaxCount();
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
        else if (curcount + count > uint32(pProto->GetMaxCount()))
        {
            if (no_space_count)
                *no_space_count = count + curcount - pProto->GetMaxCount();
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    // check unique-equipped limit
    if (pProto->GetLimitCategory())
    {
        ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(pProto->GetLimitCategory());
        if (!limitEntry)
        {
            if (no_space_count)
                *no_space_count = count;
            return EQUIP_ERR_NOT_EQUIPPABLE;
        }

        if (limitEntry->Flags == ITEM_LIMIT_CATEGORY_MODE_HAVE)
        {
            uint32 curcount = GetItemCountWithLimitCategory(pProto->GetLimitCategory(), pItem);
            if (curcount + count > uint32(limitEntry->Quantity))
            {
                if (no_space_count)
                    *no_space_count = count + curcount - limitEntry->Quantity;
                return EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED_IS;
            }
        }
    }

    return EQUIP_ERR_OK;
}

uint8 Player::GetItemLimitCategoryQuantity(ItemLimitCategoryEntry const* limitEntry) const
{
    uint8 limit = limitEntry->Quantity;

    if (auto limitConditions = sDB2Manager.GetItemLimitCategoryConditions(limitEntry->ID))
        for (auto limitCondition : *limitConditions)
            if (sConditionMgr->IsPlayerMeetingCondition(const_cast<Player*>(this), limitCondition->PlayerConditionID, false))
                limit += limitCondition->AddQuantity;

    return limit;
}

InventoryResult Player::CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const
{
    Item* pItem2 = GetItemByPos(bag, slot);

    // ignore move item (this slot will be empty at move)
    if (pItem2 == pSrcItem)
        pItem2 = NULL;

    uint32 need_space;

    if (pSrcItem)
    {
        if (pSrcItem->IsNotEmptyBag() && !IsBagPos(uint16(bag) << 8 | slot))
            return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

        if (pSrcItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_CHILD) && !IsEquipmentPos(bag, slot) && !IsChildEquipmentPos(bag, slot))
            return EQUIP_ERR_WRONG_BAG_TYPE_3;

        if (!pSrcItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_CHILD) && IsChildEquipmentPos(bag, slot))
            return EQUIP_ERR_WRONG_BAG_TYPE_3;
    }

    // empty specific slot - check item fit to slot
    if (!pItem2 || swap)
    {
        if (bag == INVENTORY_SLOT_BAG_0)
        {
            // prevent cheating
            if ((slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END) || slot >= PLAYER_SLOT_END)
                return EQUIP_ERR_WRONG_BAG_TYPE;
        }
        else
        {
            Bag* pBag = GetBagByPos(bag);
            if (!pBag)
                return EQUIP_ERR_WRONG_BAG_TYPE;

            ItemTemplate const* pBagProto = pBag->GetTemplate();
            if (!pBagProto)
                return EQUIP_ERR_WRONG_BAG_TYPE;

            if (slot >= pBagProto->GetContainerSlots())
                return EQUIP_ERR_WRONG_BAG_TYPE;

            if (!ItemCanGoIntoBag(pProto, pBagProto))
                return EQUIP_ERR_WRONG_BAG_TYPE;
        }

        // non empty stack with space
        need_space = pProto->GetMaxStackSize();
    }
    // non empty slot, check item type
    else
    {
        // can be merged at least partly
        InventoryResult res  = pItem2->CanBeMergedPartlyWith(pProto);
        if (res != EQUIP_ERR_OK)
            return res;

        // free stack space or infinity
        need_space = pProto->GetMaxStackSize() - pItem2->GetCount();
    }

    if (need_space > count)
        need_space = count;

    ItemPosCount newPosition = ItemPosCount((bag << 8) | slot, need_space);
    if (!newPosition.isContainedIn(dest))
    {
        dest.push_back(newPosition);
        count -= need_space;
    }
    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem_InBag(uint8 bag, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const
{
    // skip specific bag already processed in first called CanStoreItem_InBag
    if (bag == skip_bag)
        return EQUIP_ERR_WRONG_BAG_TYPE;

    // skip not existed bag or self targeted bag
    Bag* pBag = GetBagByPos(bag);
    if (!pBag || pBag == pSrcItem)
        return EQUIP_ERR_WRONG_BAG_TYPE;

    if (pSrcItem)
    {
        if (pSrcItem->IsNotEmptyBag())
            return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

        if (pSrcItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_CHILD))
            return EQUIP_ERR_WRONG_BAG_TYPE_3;
    }

    ItemTemplate const* pBagProto = pBag->GetTemplate();
    if (!pBagProto)
        return EQUIP_ERR_WRONG_BAG_TYPE;

    // specialized bag mode or non-specilized
    if (non_specialized != (pBagProto->GetClass() == ITEM_CLASS_CONTAINER && pBagProto->GetSubClass() == ITEM_SUBCLASS_CONTAINER))
        return EQUIP_ERR_WRONG_BAG_TYPE;

    if (!ItemCanGoIntoBag(pProto, pBagProto))
        return EQUIP_ERR_WRONG_BAG_TYPE;

    for (uint32 j = 0; j < pBag->GetBagSize(); j++)
    {
        // skip specific slot already processed in first called CanStoreItem_InSpecificSlot
        if (j == skip_slot)
            continue;

        Item* pItem2 = GetItemByPos(bag, j);

        // ignore move item (this slot will be empty at move)
        if (pItem2 == pSrcItem)
            pItem2 = NULL;

        // if merge skip empty, if !merge skip non-empty
        if ((pItem2 != NULL) != merge)
            continue;

        uint32 need_space = pProto->GetMaxStackSize();

        if (pItem2)
        {
            // can be merged at least partly
            uint8 res  = pItem2->CanBeMergedPartlyWith(pProto);
            if (res != EQUIP_ERR_OK)
                continue;

            // descrease at current stacksize
            need_space -= pItem2->GetCount();
        }

        if (need_space > count)
            need_space = count;

        ItemPosCount newPosition = ItemPosCount((bag << 8) | j, need_space);
        if (!newPosition.isContainedIn(dest))
        {
            dest.push_back(newPosition);
            count -= need_space;

            if (count==0)
                return EQUIP_ERR_OK;
        }
    }
    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem_InInventorySlots(uint8 slot_begin, uint8 slot_end, ItemPosCountVec &dest, ItemTemplate const* pProto, uint32& count, bool merge, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const
{
    //this is never called for non-bag slots so we can do this
    if (pSrcItem && pSrcItem->IsNotEmptyBag())
        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

    for (uint32 j = slot_begin; j < slot_end; j++)
    {
        // skip specific slot already processed in first called CanStoreItem_InSpecificSlot
        if (INVENTORY_SLOT_BAG_0 == skip_bag && j == skip_slot)
            continue;

        Item* pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, j);

        // ignore move item (this slot will be empty at move)
        if (pItem2 == pSrcItem)
            pItem2 = NULL;

        // if merge skip empty, if !merge skip non-empty
        if ((pItem2 != NULL) != merge)
            continue;

        uint32 need_space = pProto->GetMaxStackSize();

        if (pItem2)
        {
            // can be merged at least partly
            uint8 res  = pItem2->CanBeMergedPartlyWith(pProto);
            if (res != EQUIP_ERR_OK)
                continue;

            // descrease at current stacksize
            need_space -= pItem2->GetCount();
        }

        if (need_space > count)
            need_space = count;

        ItemPosCount newPosition = ItemPosCount((INVENTORY_SLOT_BAG_0 << 8) | j, need_space);
        if (!newPosition.isContainedIn(dest))
        {
            dest.push_back(newPosition);
            count -= need_space;

            if (count==0)
                return EQUIP_ERR_OK;
        }
    }
    return EQUIP_ERR_OK;
}

InventoryResult Player::CanStoreItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, uint32 entry, uint32 count, Item* pItem, bool swap, uint32* no_space_count, bool quest) const
{
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanStoreItem bag = %u, slot = %u, item = %u, count = %u quest = %u", bag, slot, entry, count, quest);

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
    if (!pProto)
    {
        if (no_space_count)
            *no_space_count = count;
        return swap ? EQUIP_ERR_CANT_SWAP :EQUIP_ERR_ITEM_NOT_FOUND;
    }

    if (pItem)
    {
        // item used
        if (pItem->m_lootGenerated)
        {
            if (no_space_count)
                *no_space_count = count;
            return EQUIP_ERR_LOOT_GONE;
        }

        if (pItem->IsBindedNotWith(this))
        {
            if (no_space_count)
                *no_space_count = count;
            return EQUIP_ERR_NOT_OWNER;
        }
    }

    // check count of items (skip for auto move for same player from bank)
    uint32 no_similar_count = 0;                            // can't store this amount similar items
    InventoryResult res = CanTakeMoreSimilarItems(entry, count, pItem, &no_similar_count, quest);
    if (res != EQUIP_ERR_OK)
    {
        if (count == no_similar_count)
        {
            if (no_space_count)
                *no_space_count = no_similar_count;
            return res;
        }
        count -= no_similar_count;
    }

    // in specific slot
    if (bag != NULL_BAG && slot != NULL_SLOT)
    {
        res = CanStoreItem_InSpecificSlot(bag, slot, dest, pProto, count, swap, pItem);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    // not specific slot or have space for partly store only in specific slot

    // in specific bag
    if (bag != NULL_BAG)
    {
        // search stack in bag for merge to
        if (pProto->GetStackable() != 1)
        {
            if (bag == INVENTORY_SLOT_BAG_0)               // inventory
            {
                res = CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, dest, pProto, count, true, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }

                res = CanStoreItem_InInventorySlots(REAGENT_SLOT_START, REAGENT_SLOT_END, dest, pProto, count, true, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }

                res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, GetInventoryEndSlot(), dest, pProto, count, true, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
            else                                            // equipped bag
            {
                // we need check 2 time (specialized/non_specialized), use NULL_BAG to prevent skipping bag
                res = CanStoreItem_InBag(bag, dest, pProto, count, true, false, pItem, NULL_BAG, slot);
                if (res != EQUIP_ERR_OK)
                    res = CanStoreItem_InBag(bag, dest, pProto, count, true, true, pItem, NULL_BAG, slot);

                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
        }

        // search free slot in bag for place to
        if (bag == INVENTORY_SLOT_BAG_0)                     // inventory
        {
            if (pItem && pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_CHILD))
            {
                res = CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, dest, pProto, count, false, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
            /*else if (pProto->IsCraftingReagent() && CanUseReagentBank())
            {
                res = CanStoreItem_InInventorySlots(REAGENT_SLOT_START, REAGENT_SLOT_END, dest, pProto, count, false, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                {
                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return res;
                }

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }*/ // it doesn't work that way!

            res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, GetInventoryEndSlot(), dest, pProto, count, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
            {
                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return res;
            }

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
        else                                                // equipped bag
        {
            res = CanStoreItem_InBag(bag, dest, pProto, count, false, false, pItem, NULL_BAG, slot);
            if (res != EQUIP_ERR_OK)
                res = CanStoreItem_InBag(bag, dest, pProto, count, false, true, pItem, NULL_BAG, slot);

            if (res != EQUIP_ERR_OK)
            {
                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return res;
            }

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
    }

    // not specific bag or have space for partly store only in specific bag

    // search stack for merge to
    if (pProto->GetStackable() != 1)
    {
        res = CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, dest, pProto, count, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }

        res = CanStoreItem_InInventorySlots(REAGENT_SLOT_START, REAGENT_SLOT_END, dest, pProto, count, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }

        res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, GetInventoryEndSlot(), dest, pProto, count, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }

        if (pProto->GetBagFamily())
        {
            for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
            {
                res = CanStoreItem_InBag(i, dest, pProto, count, true, false, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                    continue;

                if (count == 0)
                {
                    if (no_similar_count == 0)
                        return EQUIP_ERR_OK;

                    if (no_space_count)
                        *no_space_count = count + no_similar_count;
                    return EQUIP_ERR_ITEM_MAX_COUNT;
                }
            }
        }

        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, true, true, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
    }

    // search free slot - special bag case
    if (pProto->GetBagFamily())
    {
        for (uint32 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, false, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
            {
                if (no_similar_count == 0)
                    return EQUIP_ERR_OK;

                if (no_space_count)
                    *no_space_count = count + no_similar_count;
                return EQUIP_ERR_ITEM_MAX_COUNT;
            }
        }
    }

    if (pItem && pItem->IsNotEmptyBag())
        return EQUIP_ERR_BAG_IN_BAG;

    if (pItem && pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_CHILD))
    {
        res = CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, dest, pProto, count, false, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }
    /*else if (pProto->IsCraftingReagent() && CanUseReagentBank())
    {
        res = CanStoreItem_InInventorySlots(REAGENT_SLOT_START, REAGENT_SLOT_END, dest, pProto, count, false, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
        {
            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return res;
        }

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }*/ // it doesn't work that way!

    // search free slot
    res = CanStoreItem_InInventorySlots(INVENTORY_SLOT_ITEM_START, GetInventoryEndSlot(), dest, pProto, count, false, pItem, bag, slot);
    if (res != EQUIP_ERR_OK)
    {
        if (no_space_count)
            *no_space_count = count + no_similar_count;
        return res;
    }

    if (count == 0)
    {
        if (no_similar_count == 0)
            return EQUIP_ERR_OK;

        if (no_space_count)
            *no_space_count = count + no_similar_count;
        return EQUIP_ERR_ITEM_MAX_COUNT;
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        res = CanStoreItem_InBag(i, dest, pProto, count, false, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            continue;

        if (count == 0)
        {
            if (no_similar_count == 0)
                return EQUIP_ERR_OK;

            if (no_space_count)
                *no_space_count = count + no_similar_count;
            return EQUIP_ERR_ITEM_MAX_COUNT;
        }
    }

    if (no_space_count)
        *no_space_count = count + no_similar_count;

    return EQUIP_ERR_INV_FULL;
}

//////////////////////////////////////////////////////////////////////////
InventoryResult Player::CanStoreItems(Item** pItems, int count, uint32& ItemID) const
{
    Item* pItem2;

    uint8 inventoryEnd = GetInventoryEndSlot();
    // fill space table
    int inv_slot_items[INVENTORY_SLOT_ITEM_END - INVENTORY_SLOT_ITEM_START];
    int inv_bags[INVENTORY_SLOT_BAG_END - INVENTORY_SLOT_BAG_START][MAX_BAG_SIZE];

    memset(inv_slot_items, 0, sizeof(inv_slot_items));
    memset(inv_bags, 0, sizeof(inv_bags));

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < inventoryEnd; i++)
    {
        pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (pItem2 && !pItem2->IsInTrade())
            inv_slot_items[i - INVENTORY_SLOT_ITEM_START] = pItem2->GetCount();
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                pItem2 = GetItemByPos(i, j);
                if (pItem2 && !pItem2->IsInTrade())
                    inv_bags[i - INVENTORY_SLOT_BAG_START][j] = pItem2->GetCount();
            }

    // check free space for all items
    for (int k = 0; k < count; ++k)
    {
        Item* pItem = pItems[k];

        // no item
        if (!pItem)
            continue;

        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanStoreItems %i. item = %u, count = %u", k + 1, pItem->GetEntry(), pItem->GetCount());
        ItemTemplate const* pProto = pItem->GetTemplate();

        // strange item
        if (!pProto)
            return EQUIP_ERR_ITEM_NOT_FOUND;

        ItemID = pItem->GetEntry();
        // item used
        if (pItem->m_lootGenerated)
            return EQUIP_ERR_LOOT_GONE;

        // item it 'bind'
        if (pItem->IsBindedNotWith(this))
            return EQUIP_ERR_NOT_OWNER;

        ItemTemplate const* pBagProto;

        // item is 'one item only'
        InventoryResult res = CanTakeMoreSimilarItems(pItem);
        if (res != EQUIP_ERR_OK)
            return res;

        // search stack for merge to
        if (pProto->GetStackable() != 1)
        {
            bool b_found = false;

            for (int t = INVENTORY_SLOT_ITEM_START; t < inventoryEnd; ++t)
            {
                pItem2 = GetItemByPos(INVENTORY_SLOT_BAG_0, t);
                if (pItem2 && pItem2->CanBeMergedPartlyWith(pProto) == EQUIP_ERR_OK && inv_slot_items[t-INVENTORY_SLOT_ITEM_START] + pItem->GetCount() <= pProto->GetMaxStackSize())
                {
                    inv_slot_items[t-INVENTORY_SLOT_ITEM_START] += pItem->GetCount();
                    b_found = true;
                    break;
                }
            }
            if (b_found)
                continue;

            for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
            {
                if (Bag* bag = GetBagByPos(t))
                {
                    if (ItemCanGoIntoBag(pItem->GetTemplate(), bag->GetTemplate()))
                    {
                        for (uint32 j = 0; j < bag->GetBagSize(); j++)
                        {
                            pItem2 = GetItemByPos(t, j);
                            if (pItem2 && pItem2->CanBeMergedPartlyWith(pProto) == EQUIP_ERR_OK && inv_bags[t-INVENTORY_SLOT_BAG_START][j] + pItem->GetCount() <= pProto->GetMaxStackSize())
                            {
                                inv_bags[t-INVENTORY_SLOT_BAG_START][j] += pItem->GetCount();
                                b_found = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (b_found)
                continue;
        }

        // special bag case
        if (pProto->GetBagFamily())
        {
            bool b_found = false;

            for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
            {
                if (Bag* bag = GetBagByPos(t))
                {
                    pBagProto = bag->GetTemplate();

                    // not plain container check
                    if (pBagProto && (pBagProto->GetClass() != ITEM_CLASS_CONTAINER || pBagProto->GetSubClass() != ITEM_SUBCLASS_CONTAINER) && ItemCanGoIntoBag(pProto, pBagProto))
                    {
                        for (uint32 j = 0; j < bag->GetBagSize(); j++)
                        {
                            if (inv_bags[t-INVENTORY_SLOT_BAG_START][j] == 0)
                            {
                                inv_bags[t-INVENTORY_SLOT_BAG_START][j] = 1;
                                b_found = true;
                                break;
                            }
                        }
                    }
                }
            }
            if (b_found)
                continue;
        }

        // search free slot
        bool b_found = false;
        for (int t = INVENTORY_SLOT_ITEM_START; t < inventoryEnd; ++t)
        {
            if (inv_slot_items[t-INVENTORY_SLOT_ITEM_START] == 0)
            {
                inv_slot_items[t-INVENTORY_SLOT_ITEM_START] = 1;
                b_found = true;
                break;
            }
        }
        if (b_found)
            continue;

        // search free slot in bags
        for (int t = INVENTORY_SLOT_BAG_START; !b_found && t < INVENTORY_SLOT_BAG_END; ++t)
        {
            if (Bag* bag = GetBagByPos(t))
            {
                pBagProto = bag->GetTemplate();

                // special bag already checked
                if (pBagProto && (pBagProto->GetClass() != ITEM_CLASS_CONTAINER || pBagProto->GetSubClass() != ITEM_SUBCLASS_CONTAINER))
                    continue;

                for (uint32 j = 0; j < bag->GetBagSize(); j++)
                {
                    if (inv_bags[t-INVENTORY_SLOT_BAG_START][j] == 0)
                    {
                        inv_bags[t-INVENTORY_SLOT_BAG_START][j] = 1;
                        b_found = true;
                        break;
                    }
                }
            }
        }

        // no free slot found?
        if (!b_found)
            return EQUIP_ERR_INV_FULL;
    }

    ItemID = 0;
    return EQUIP_ERR_OK;
}

//////////////////////////////////////////////////////////////////////////
InventoryResult Player::CanEquipNewItem(uint8 slot, uint16 &dest, uint32 item, bool swap, bool not_loading) const
{
    dest = 0;
    Item* pItem = Item::CreateItem(item, 1, this);
    if (pItem)
    {
        InventoryResult result = CanEquipItem(slot, dest, pItem, swap, not_loading);
        delete pItem;
        return result;
    }

    return EQUIP_ERR_ITEM_NOT_FOUND;
}

InventoryResult Player::CanEquipItem(uint8 slot, uint16 &dest, Item* pItem, bool swap, bool not_loading) const
{
    dest = 0;
    if (pItem)
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanEquipItem slot = %u, item = %u, count = %u", slot, pItem->GetEntry(), pItem->GetCount());
        ItemTemplate const* pProto = pItem->GetTemplate();
        if (pProto)
        {
            // item used
            if (pItem->m_lootGenerated)
                return EQUIP_ERR_LOOT_GONE;

            if (pItem->IsBindedNotWith(this))
                return EQUIP_ERR_NOT_OWNER;

            // check count of items (skip for auto move for same player from bank)
            InventoryResult res = CanTakeMoreSimilarItems(pItem);
            if (res != EQUIP_ERR_OK)
                return res;

            // check this only in game
            if (not_loading)
            {
                // May be here should be more stronger checks; STUNNED checked
                // ROOT, CONFUSED, DISTRACTED, FLEEING this needs to be checked.
                if (HasUnitState(UNIT_STATE_STUNNED))
                    return EQUIP_ERR_GENERIC_STUNNED;

                // do not allow equipping gear except weapons, offhands, projectiles, relics in
                // - combat
                // - in-progress arenas
                if (!pProto->CanChangeEquipStateInCombat())
                {
                    if (isInCombat())
                        return EQUIP_ERR_NOT_IN_COMBAT;

                    if (Battleground* bg = GetBattleground())
                        if (bg->IsArena() && bg->GetStatus() == STATUS_IN_PROGRESS)
                            return EQUIP_ERR_NOT_DURING_ARENA_MATCH;
                }

                if (pProto->GetClass() == ITEM_CLASS_WEAPON && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED))
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;

                if (isInCombat() && (pProto->GetClass() == ITEM_CLASS_WEAPON || pProto->GetInventoryType() == INVTYPE_RELIC) && m_weaponChangeTimer != 0)
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;         // maybe exist better err

                if (IsNonMeleeSpellCast(false))
                    return EQUIP_ERR_CLIENT_LOCKED_OUT;
            }

            ScalingStatDistributionEntry const* ssd = pItem->GetScalingStatDistribution() ? sScalingStatDistributionStore.LookupEntry(pItem->GetScalingStatDistribution()) : nullptr;
            if (ssd && ssd->MaxLevel < MAX_LEVEL && ssd->MaxLevel < getLevel() && !sDB2Manager.GetHeirloomByItemId(pProto->GetId()))
                return EQUIP_ERR_NOT_EQUIPPABLE;

            uint8 eslot = FindEquipSlot(pProto, slot, swap);
            if (eslot == NULL_SLOT)
                return EQUIP_ERR_NOT_EQUIPPABLE;

            res = CanUseItem(pItem, not_loading);
            if (res != EQUIP_ERR_OK)
                return res;

            if (!swap && GetItemByPos(INVENTORY_SLOT_BAG_0, eslot))
                return EQUIP_ERR_NO_SLOT_AVAILABLE;

            // if swap ignore item (equipped also)
            InventoryResult res2 = CanEquipUniqueItem(pItem, swap ? eslot : uint8(NULL_SLOT));
            if (res2 != EQUIP_ERR_OK)
                return res2;

            // check unique-equipped special item classes
            if (pProto->GetClass() == ITEM_CLASS_QUIVER)
                for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
                    if (Item* pBag = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                        if (pBag != pItem)
                            if (ItemTemplate const* pBagProto = pBag->GetTemplate())
                                if (pBagProto->GetClass() == pProto->GetClass() && (!swap || pBag->GetSlot() != eslot))
                                    return (pBagProto->GetSubClass() == ITEM_SUBCLASS_AMMO_POUCH) ? EQUIP_ERR_ONLY_ONE_AMMO : EQUIP_ERR_ONLY_ONE_QUIVER;

            uint32 type = pProto->GetInventoryType();

            if (eslot == EQUIPMENT_SLOT_OFFHAND)
            {
                // Do not allow polearm to be equipped in the offhand (rare case for the only 1h polearm 41750)
                if (type == INVTYPE_WEAPON && pProto->GetSubClass() == ITEM_SUBCLASS_WEAPON_POLEARM)
                    return EQUIP_ERR_2HSKILLNOTFOUND;
                if (type == INVTYPE_WEAPON)
                {
                    if (!CanDualWield())
                        return EQUIP_ERR_2HSKILLNOTFOUND;
                }
                else if (type == INVTYPE_WEAPONOFFHAND)
                {
                    if (!CanDualWield() && !(pProto->GetFlags3() & ITEM_FLAG3_ALWAYS_ALLOW_DUAL_WIELD))
                        return EQUIP_ERR_2HSKILLNOTFOUND;
                }
                else if (type == INVTYPE_2HWEAPON)
                {
                    if (!CanDualWield() || !CanTitanGrip())
                        return EQUIP_ERR_2HSKILLNOTFOUND;
                }

                if (IsTwoHandUsed())
                    return EQUIP_ERR_2HANDED_EQUIPPED;
            }

            // equip two-hand weapon case (with possible unequip 2 items)
            if (type == INVTYPE_2HWEAPON)
            {
                if (eslot == EQUIPMENT_SLOT_OFFHAND)
                {
                    if (!CanTitanGrip())
                        return EQUIP_ERR_NOT_EQUIPPABLE;
                }
                else if (eslot != EQUIPMENT_SLOT_MAINHAND)
                    return EQUIP_ERR_NOT_EQUIPPABLE;

                if (!CanTitanGrip())
                {
                    // offhand item must can be stored in inventory for offhand item and it also must be unequipped
                    Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
                    ItemPosCountVec off_dest;
                    if (offItem && (!not_loading ||
                        CanUnequipItem(uint16(INVENTORY_SLOT_BAG_0) << 8 | EQUIPMENT_SLOT_OFFHAND, false) != EQUIP_ERR_OK ||
                        CanStoreItem(NULL_BAG, NULL_SLOT, off_dest, offItem, false) != EQUIP_ERR_OK))
                        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_INV_FULL;
                }
            }
            dest = ((INVENTORY_SLOT_BAG_0 << 8) | eslot);
            return EQUIP_ERR_OK;
        }
    }

    return !swap ? EQUIP_ERR_ITEM_NOT_FOUND : EQUIP_ERR_CANT_SWAP;
}

InventoryResult Player::CanEquipChildItem(Item* parentItem) const
{
    Item* childItem = GetChildItemByGuid(parentItem->GetChildItem());
    if (!childItem)
        return EQUIP_ERR_OK;

    ItemChildEquipmentEntry const* childEquipement = sDB2Manager.GetItemChildEquipment(parentItem->GetEntry());
    if (!childEquipement)
        return EQUIP_ERR_OK;

    Item* dstItem = GetItemByPos(INVENTORY_SLOT_BAG_0, childEquipement->ChildItemEquipSlot);
    if (!dstItem)
        return EQUIP_ERR_OK;

    uint16 childDest = (INVENTORY_SLOT_BAG_0 << 8) | childEquipement->ChildItemEquipSlot;
    InventoryResult msg = CanUnequipItem(childDest, !childItem->IsBag());
    if (msg != EQUIP_ERR_OK)
        return msg;

    // check dest->src move possibility
    uint16 src = parentItem->GetPos();
    ItemPosCountVec dest;
    if (IsInventoryPos(src))
    {
        msg = CanStoreItem(parentItem->GetBagSlot(), NULL_SLOT, dest, dstItem, true);
        if (msg != EQUIP_ERR_OK)
            msg = CanStoreItem(NULL_BAG, NULL_SLOT, dest, dstItem, true);
    }
    else if (IsBankPos(src))
    {
        msg = CanBankItem(parentItem->GetBagSlot(), NULL_SLOT, dest, dstItem, true);
        if (msg != EQUIP_ERR_OK)
            msg = CanBankItem(NULL_BAG, NULL_SLOT, dest, dstItem, true);
    }
    else if (IsEquipmentPos(src))
        return EQUIP_ERR_CANT_SWAP;

    return msg;
}

InventoryResult Player::CanUnequipItem(uint16 pos, bool swap) const
{
    // Applied only to equipped items and bank bags
    if (!IsEquipmentPos(pos) && !IsBagPos(pos))
        return EQUIP_ERR_OK;

    Item* pItem = GetItemByPos(pos);

    // Applied only to existed equipped item
    if (!pItem)
        return EQUIP_ERR_OK;
    

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanUnequipItem slot = %u, item = %u, count = %u", pos, pItem->GetEntry(), pItem->GetCount());

    ItemTemplate const* pProto = pItem->GetTemplate();
    if (!pProto)
        return EQUIP_ERR_ITEM_NOT_FOUND;

    // item used
    if (pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    // do not allow unequipping gear except weapons, offhands, projectiles, relics in
    // - combat
    // - in-progress arenas
    if (!pProto->CanChangeEquipStateInCombat())
    {
        if (isInCombat())
            return EQUIP_ERR_NOT_IN_COMBAT;

        if (Battleground* bg = GetBattleground())
            if (bg->IsArena() && bg->GetStatus() == STATUS_IN_PROGRESS)
                return EQUIP_ERR_NOT_DURING_ARENA_MATCH;
    }

    if (pProto->GetClass() == ITEM_CLASS_WEAPON && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED))
        return EQUIP_ERR_CLIENT_LOCKED_OUT;

    if (!swap && pItem->IsNotEmptyBag())
        return EQUIP_ERR_DESTROY_NONEMPTY_BAG;

    return EQUIP_ERR_OK;
}

InventoryResult Player::CanBankItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, Item* pItem, bool swap, bool not_loading) const
{
    if (!pItem)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    uint32 count = pItem->GetCount();

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanBankItem bag = %u, slot = %u, item = %u, count = %u", bag, slot, pItem->GetEntry(), pItem->GetCount());
    ItemTemplate const* pProto = pItem->GetTemplate();
    if (!pProto)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    // item used
    if (pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    if (pItem->IsBindedNotWith(this))
        return EQUIP_ERR_NOT_OWNER;

    // Currency tokens are not supposed to be swapped out of their hidden bag
    if(pItem->IsCurrencyToken())
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Possible hacking attempt: Player %s [guid: %u] tried to move token [guid: %u, entry: %u] out of the currency bag!",
                GetName(), GetGUIDLow(), pItem->GetGUIDLow(), pProto->GetId());
        return EQUIP_ERR_CANT_SWAP;
    }

    // check count of items (skip for auto move for same player from bank)
    InventoryResult res = CanTakeMoreSimilarItems(pItem);
    if (res != EQUIP_ERR_OK)
        return res;

    // in specific slot
    if (bag != NULL_BAG && slot != NULL_SLOT)
    {
        if (slot >= BANK_SLOT_BAG_START && slot < BANK_SLOT_BAG_END)
        {
            if (!pItem->IsBag())
                return EQUIP_ERR_WRONG_SLOT;

            if (slot - BANK_SLOT_BAG_START >= GetBankBagSlotsValue())
                return EQUIP_ERR_NO_BANK_SLOT;

            res = CanUseItem(pItem, not_loading);
            if (res != EQUIP_ERR_OK)
                return res;
        }

        res = CanStoreItem_InSpecificSlot(bag, slot, dest, pProto, count, swap, pItem);
        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;
    }

    // not specific slot or have space for partly store only in specific slot

    // in specific bag
    if (bag != NULL_BAG)
    {
        if (pItem->IsNotEmptyBag())
            return EQUIP_ERR_BAG_IN_BAG;

        // search stack in bag for merge to
        if (pProto->GetStackable() != 1)
        {
            if (bag == INVENTORY_SLOT_BAG_0)
            {
                res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                    return res;

                if (count == 0)
                    return EQUIP_ERR_OK;
            }
            else
            {
                res = CanStoreItem_InBag(bag, dest, pProto, count, true, false, pItem, NULL_BAG, slot);
                if (res != EQUIP_ERR_OK)
                    res = CanStoreItem_InBag(bag, dest, pProto, count, true, true, pItem, NULL_BAG, slot);

                if (res != EQUIP_ERR_OK)
                    return res;

                if (count == 0)
                    return EQUIP_ERR_OK;
            }
        }

        // search free slot in bag
        if (bag == INVENTORY_SLOT_BAG_0)
        {
            res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                return res;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
        else
        {
            res = CanStoreItem_InBag(bag, dest, pProto, count, false, false, pItem, NULL_BAG, slot);
            if (res != EQUIP_ERR_OK)
                res = CanStoreItem_InBag(bag, dest, pProto, count, false, true, pItem, NULL_BAG, slot);

            if (res != EQUIP_ERR_OK)
                return res;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
    }

    // not specific bag or have space for partly store only in specific bag

    // search stack for merge to
    if (pProto->GetStackable() != 1)
    {
        // in slots
        res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;

        // in special bags
        if (pProto->GetBagFamily())
        {
            for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
            {
                res = CanStoreItem_InBag(i, dest, pProto, count, true, false, pItem, bag, slot);
                if (res != EQUIP_ERR_OK)
                    continue;

                if (count == 0)
                    return EQUIP_ERR_OK;
            }
        }

        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, true, true, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
    }

    // search free place in special bag
    if (pProto->GetBagFamily())
    {
        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
        {
            res = CanStoreItem_InBag(i, dest, pProto, count, false, false, pItem, bag, slot);
            if (res != EQUIP_ERR_OK)
                continue;

            if (count == 0)
                return EQUIP_ERR_OK;
        }
    }

    // search free space
    res = CanStoreItem_InInventorySlots(BANK_SLOT_ITEM_START, BANK_SLOT_ITEM_END, dest, pProto, count, false, pItem, bag, slot);
    if (res != EQUIP_ERR_OK)
        return res;

    if (count == 0)
        return EQUIP_ERR_OK;

    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
    {
        res = CanStoreItem_InBag(i, dest, pProto, count, false, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            continue;

        if (count == 0)
            return EQUIP_ERR_OK;
    }
    return EQUIP_ERR_BANK_FULL;
}

InventoryResult Player::CanBankReagentItem(uint8 bag, uint8 slot, ItemPosCountVec &dest, Item* pItem, bool swap, bool not_loading) const
{
    if (!CanUseReagentBank())
        return EQUIP_ERR_REAGENT_BANK_LOCKED;

    if (!pItem)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    uint32 count = pItem->GetCount();

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanBankReagentItem bag = %u, slot = %u, item = %u, count = %u", bag, slot, pItem->GetEntry(), pItem->GetCount());

    ItemTemplate const* pProto = pItem->GetTemplate();
    if (!pProto)
        return swap ? EQUIP_ERR_CANT_SWAP : EQUIP_ERR_ITEM_NOT_FOUND;

    if (!pProto->IsCraftingReagent())
        return EQUIP_ERR_CANT_SWAP;

    // item used
    if (pItem->m_lootGenerated)
        return EQUIP_ERR_LOOT_GONE;

    if (pItem->IsBindedNotWith(this))
        return EQUIP_ERR_NOT_OWNER;

    // Currency tokens are not supposed to be swapped out of their hidden bag
    if(pItem->IsCurrencyToken())
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Possible hacking attempt: Player %s [guid: %u] tried to move token [guid: %u, entry: %u] out of the currency bag!",
                GetName(), GetGUIDLow(), pItem->GetGUIDLow(), pProto->GetId());
        return EQUIP_ERR_CANT_SWAP;
    }

    // check count of items (skip for auto move for same player from bank)
    InventoryResult res = CanTakeMoreSimilarItems(pItem);
    if (res != EQUIP_ERR_OK)
        return res;

    // search stack for merge to
    if (pProto->GetStackable() != 1)
    {
        // in slots
        res = CanStoreItem_InInventorySlots(REAGENT_SLOT_START, REAGENT_SLOT_END, dest, pProto, count, true, pItem, bag, slot);
        if (res != EQUIP_ERR_OK)
            return res;

        if (count == 0)
            return EQUIP_ERR_OK;
    }

    // search free space
    res = CanStoreItem_InInventorySlots(REAGENT_SLOT_START, REAGENT_SLOT_END, dest, pProto, count, false, pItem, bag, slot);
    if (res != EQUIP_ERR_OK)
        return res;

    if (count == 0)
        return EQUIP_ERR_OK;

    return EQUIP_ERR_REAGENT_BANK_FULL;
}

InventoryResult Player::CanUseItem(Item* pItem, bool not_loading) const
{
    if (pItem)
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: CanUseItem item = %u", pItem->GetEntry());

        if (!isAlive() && not_loading)
            return EQUIP_ERR_PLAYER_DEAD;

        if (getLevel() < pItem->GetRequiredLevel())
            return EQUIP_ERR_CANT_EQUIP_LEVEL_I;

        //if (isStunned())
        //    return EQUIP_ERR_GENERIC_STUNNED;

        if (ItemTemplate const* pProto = pItem->GetTemplate())
        {
            if (pItem->IsBindedNotWith(this))
                return EQUIP_ERR_NOT_OWNER;

            InventoryResult res = CanUseItem(pProto);
            if (res != EQUIP_ERR_OK)
                return res;

            if (pItem->GetSkill() != 0)
            {
                bool allowEquip = false;
                uint32 itemSkill = pItem->GetSkill();
                // Armor that is binded to account can "morph" from plate to mail, etc. if skill is not learned yet.
                if (pProto->GetQuality() == ITEM_QUALITY_HEIRLOOM && pProto->GetClass() == ITEM_CLASS_ARMOR && !const_cast<Player*>(this)->HasSkill(itemSkill))
                {
                    // TODO: when you right-click already equipped item it throws EQUIP_ERR_PROFICIENCY_NEEDED.

                    // In fact it's a visual bug, everything works properly... I need sniffs of operations with
                    // binded to account items from off server.

                    switch (getClass())
                    {
                        case CLASS_HUNTER:
                        case CLASS_SHAMAN:
                            allowEquip = (itemSkill == SKILL_MAIL);
                            break;
                        case CLASS_PALADIN:
                        case CLASS_WARRIOR:
                            allowEquip = (itemSkill == SKILL_PLATE_MAIL);
                            break;
                    }
                }
                if (!allowEquip && const_cast<Player*>(this)->GetSkillValue(itemSkill) == 0)
                    return EQUIP_ERR_PROFICIENCY_NEEDED;
            }

            if (pProto->GetMinFactionID() && uint32(GetReputationRank(pProto->GetMinFactionID())) < pProto->GetMinReputation())
                return EQUIP_ERR_CANT_EQUIP_REPUTATION;

            return EQUIP_ERR_OK;
        }
    }
    return EQUIP_ERR_ITEM_NOT_FOUND;
}

InventoryResult Player::CanUseItem(ItemTemplate const* proto) const
{
    // Used by group, function NeedBeforeGreed, to know if a prototype can be used by a player

    if (proto)
    {
        if ((proto->GetFlags2() & ITEM_FLAG2_FACTION_HORDE) && GetTeam() != HORDE)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        if ((proto->GetFlags2() & ITEM_FLAG2_FACTION_ALLIANCE) && GetTeam() != ALLIANCE)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
            return EQUIP_ERR_CANT_EQUIP_EVER;

        if (proto->GetRequiredSkill() != 0)
        {
            if (const_cast<Player*>(this)->GetSkillValue(proto->GetRequiredSkill()) == 0)
                return EQUIP_ERR_PROFICIENCY_NEEDED;
            if (const_cast<Player*>(this)->GetSkillValue(proto->GetRequiredSkill()) < proto->GetRequiredSkillRank())
                return EQUIP_ERR_CANT_EQUIP_SKILL;
        }

        if (proto->GetRequiredAbility() != 0 && !const_cast<Player*>(this)->HasSpell(proto->GetRequiredAbility()))
            return EQUIP_ERR_PROFICIENCY_NEEDED;

        // If World Event is not active, prevent using event dependant items
        if (proto->GetRequiredHoliday() && !IsHolidayActive((HolidayIds)proto->GetRequiredHoliday()))
            return EQUIP_ERR_CLIENT_LOCKED_OUT;

        if (ArtifactEntry const* artifact = sArtifactStore.LookupEntry(proto->GetArtifactID()))
            if (artifact->ChrSpecializationID && artifact->ChrSpecializationID != GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID))
                return EQUIP_ERR_CANT_USE_ITEM;

        return EQUIP_ERR_OK;
    }

    return EQUIP_ERR_ITEM_NOT_FOUND;
}

std::list<uint32> Player::GetSpecListByClass(uint32 classId) const
{
    switch (classId)
    {
        case CLASS_WARRIOR:
            return std::list<uint32>{SPEC_WARRIOR_ARMS,SPEC_WARRIOR_FURY,SPEC_WARRIOR_PROTECTION};
        case CLASS_PALADIN:
            return std::list<uint32>{SPEC_PALADIN_HOLY,SPEC_PALADIN_PROTECTION,SPEC_PALADIN_RETRIBUTION};
        case CLASS_HUNTER:
            return std::list<uint32>{SPEC_HUNTER_BEASTMASTER,SPEC_HUNTER_MARKSMAN,SPEC_HUNTER_SURVIVAL};
        case CLASS_ROGUE:
            return std::list<uint32>{SPEC_ROGUE_ASSASSINATION,SPEC_ROGUE_COMBAT,SPEC_ROGUE_SUBTLETY};
        case CLASS_PRIEST:
            return std::list<uint32>{SPEC_PRIEST_DISCIPLINE,SPEC_PRIEST_HOLY,SPEC_PRIEST_SHADOW};
        case CLASS_DEATH_KNIGHT:
            return std::list<uint32>{SPEC_DK_BLOOD,SPEC_DK_FROST,SPEC_DK_UNHOLY};
        case CLASS_SHAMAN:
            return std::list<uint32>{SPEC_SHAMAN_ELEMENTAL,SPEC_SHAMAN_ENHANCEMENT,SPEC_SHAMAN_RESTORATION};
        case CLASS_MAGE:
            return std::list<uint32>{SPEC_MAGE_ARCANE,SPEC_MAGE_FIRE,SPEC_MAGE_FROST};
        case CLASS_WARLOCK:
            return std::list<uint32>{SPEC_WARLOCK_AFFLICTION,SPEC_WARLOCK_DEMONOLOGY,SPEC_WARLOCK_DESTRUCTION};
        case CLASS_MONK:
            return std::list<uint32>{SPEC_MONK_BREWMASTER,SPEC_MONK_WINDWALKER,SPEC_MONK_MISTWEAVER};
        case CLASS_DRUID:
            return std::list<uint32>{SPEC_DRUID_BALANCE,SPEC_DRUID_CAT,SPEC_DRUID_BEAR,SPEC_DRUID_RESTORATION};
        case CLASS_DEMON_HUNTER:
            return std::list<uint32>{SPEC_DEMON_HUNER_HAVOC,SPEC_DEMON_HUNER_VENGEANCE};
    }
    return std::list<uint32>{GetLootSpecID()};
}

bool Player::CanGetItemForLoot(ItemTemplate const* proto, bool specCheck) const
{
    if (!proto)
        return false;

    // TC_LOG_DEBUG(LOG_FILTER_LOOT, "CanGetItemForLoot 0 ItemId %u ItemSpecExist %u IsNotNeedCheck %u specCheck %u", proto->ItemId, proto->ItemSpecExist, proto->IsNotNeedCheck(), specCheck);

    if (GetMap()->IsDungeon()) // Special for zone loot system check
        if (proto->GetBaseRequiredLevel() > getLevel())
            return false;

    if (proto->IsNotNeedCheck())
        return true;

    if (proto->GetId() == 138019) // Mythic Keystone can looting one for week
        if (const_cast<Player*>(this)->m_challengeKeyInfo.IsActive())
            return false;

    std::list<uint32> specList{GetLootSpecID()};
    if (!specCheck)
        specList = GetSpecListByClass(getClass());

    if(proto->ItemSpecExist)
    {
        bool allGood = false;
        for (auto& specId : specList)
        {
            if (proto->IsUsableBySpecialization(specId, getLevel()))
                allGood = true;
        }
        if (!allGood)
            return false;
    }

    const static uint32 item_weapon_skills[MAX_ITEM_SUBCLASS_WEAPON] =
    {
        SKILL_AXES,     SKILL_2H_AXES,  SKILL_BOWS,          SKILL_GUNS,            SKILL_MACES,
        SKILL_2H_MACES, SKILL_POLEARMS, SKILL_SWORDS,        SKILL_2H_SWORDS,       SKILL_WARGLAIVES,
        SKILL_STAVES,   0,              0,                   SKILL_FIST_WEAPONS,    0,
        SKILL_DAGGERS,  SKILL_THROWN,   SKILL_ASSASSINATION, SKILL_CROSSBOWS,       SKILL_WANDS,
        SKILL_FISHING
    }; //Copy from function Item::GetSkill()

    if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
        return false;

    if (proto->GetRequiredAbility() != 0 && !const_cast<Player*>(this)->HasSpell(proto->GetRequiredAbility()))
        return false;

    if (proto->GetRequiredSkill() != 0)
    {
        if (!const_cast<Player*>(this)->GetSkillValue(proto->GetRequiredSkill()))
            return false;
        if (const_cast<Player*>(this)->GetSkillValue(proto->GetRequiredSkill()) < proto->GetRequiredSkillRank())
            return false;
    }

    if (proto->GetClass() == ITEM_CLASS_WEAPON && const_cast<Player*>(this)->GetSkillValue(item_weapon_skills[proto->GetSubClass()]) == 0)
        return false;

    uint8 _class = getClass();

    if (proto->GetClass() == ITEM_CLASS_ARMOR && proto->GetSubClass() > ITEM_SUBCLASS_ARMOR_MISCELLANEOUS && proto->GetSubClass() < ITEM_SUBCLASS_ARMOR_COSMETIC && proto->GetInventoryType() != INVTYPE_CLOAK)
    {
        if (_class == CLASS_WARRIOR || _class == CLASS_PALADIN || _class == CLASS_DEATH_KNIGHT)
        {
            if (getLevel() < 40)
            {
                if (proto->GetSubClass() != ITEM_SUBCLASS_ARMOR_MAIL)
                    return false;
            }
            else if (proto->GetSubClass() != ITEM_SUBCLASS_ARMOR_PLATE)
                return false;
        }
        else if (_class == CLASS_HUNTER || _class == CLASS_SHAMAN)
        {
            if (getLevel() < 40)
            {
                if (proto->GetSubClass() != ITEM_SUBCLASS_ARMOR_LEATHER)
                    return false;
            }
            else if (proto->GetSubClass() != ITEM_SUBCLASS_ARMOR_MAIL)
                return false;
        }

        if (_class == CLASS_ROGUE || _class == CLASS_DRUID || _class == CLASS_DEMON_HUNTER || _class == CLASS_MONK)
            if (proto->GetSubClass() != ITEM_SUBCLASS_ARMOR_LEATHER)
                return false;

        if (_class == CLASS_MAGE || _class == CLASS_PRIEST || _class == CLASS_WARLOCK)
            if (proto->GetSubClass() != ITEM_SUBCLASS_ARMOR_CLOTH)
                return false;
    }

    if (proto->GetClass() == ITEM_CLASS_GEM && proto->GetSubClass() == ITEM_SUBCLASS_GEM_ARTIFACT_RELIC)
    {
        bool allGood = false;
        for (auto& playerSpecID : specList)
        {
            if (CheckGemForSpec(proto, playerSpecID))
                allGood = true;
        }

        if (!allGood)
            return false;
    }

    return true;
}

bool Player::CheckGemForSpec(ItemTemplate const* proto, uint32 playerSpecID) const
{
    if (GemPropertiesEntry const* gem = sGemPropertiesStore.LookupEntry(proto->GetGemProperties()))
    {
        if (gem->Type & SOCKET_COLOR_RELIC_IRON)
        {
            switch (playerSpecID)
            {
                case SPEC_WARRIOR_ARMS:
                case SPEC_WARRIOR_FURY:
                case SPEC_WARRIOR_PROTECTION:
                case SPEC_DK_BLOOD:
                case SPEC_DEMON_HUNER_VENGEANCE:
                case SPEC_HUNTER_BEASTMASTER:
                case SPEC_HUNTER_SURVIVAL:
                case SPEC_MONK_BREWMASTER:
                case SPEC_MONK_WINDWALKER:
                case SPEC_PALADIN_PROTECTION:
                case SPEC_ROGUE_ASSASSINATION:
                case SPEC_ROGUE_COMBAT:
                case SPEC_SHAMAN_ENHANCEMENT:
                    return true;
                default:
                    return false;
            }
        }
        if (gem->Type & SOCKET_COLOR_RELIC_BLOOD)
        {
            switch (playerSpecID)
            {
                case SPEC_DK_BLOOD:
                case SPEC_DK_UNHOLY:
                case SPEC_HUNTER_SURVIVAL:
                case SPEC_HUNTER_MARKSMAN:
                case SPEC_DRUID_CAT:
                case SPEC_DRUID_BEAR:
                case SPEC_PRIEST_SHADOW:
                case SPEC_ROGUE_COMBAT:
                case SPEC_ROGUE_ASSASSINATION:
                case SPEC_WARLOCK_AFFLICTION:
                case SPEC_WARRIOR_ARMS:
                case SPEC_WARRIOR_PROTECTION:
                    return true;
                default:
                    return false;
            }
        }
        if (gem->Type & SOCKET_COLOR_RELIC_SHADOW)
        {
            switch (playerSpecID)
            {
                case SPEC_WARRIOR_ARMS:
                case SPEC_DK_BLOOD:
                case SPEC_DK_FROST:
                case SPEC_DK_UNHOLY:
                case SPEC_DEMON_HUNER_HAVOC:
                case SPEC_PRIEST_SHADOW:
                case SPEC_PRIEST_DISCIPLINE:
                case SPEC_ROGUE_ASSASSINATION:
                case SPEC_ROGUE_SUBTLETY:
                case SPEC_WARLOCK_AFFLICTION:
                case SPEC_WARLOCK_DEMONOLOGY:
                    return true;
                default:
                    return false;
            }
        }
        if (gem->Type & SOCKET_COLOR_RELIC_FEL)
        {
            switch (playerSpecID)
            {
                case SPEC_DEMON_HUNER_HAVOC:
                case SPEC_DEMON_HUNER_VENGEANCE:
                case SPEC_ROGUE_SUBTLETY:
                case SPEC_WARLOCK_DEMONOLOGY:
                case SPEC_WARLOCK_DESTRUCTION:
                    return true;
                default:
                    return false;
            }
        }
        if (gem->Type & SOCKET_COLOR_RELIC_ARCANE)
        {
            switch (playerSpecID)
            {
                case SPEC_DEMON_HUNER_VENGEANCE:
                case SPEC_MAGE_ARCANE:
                case SPEC_MAGE_FIRE:
                case SPEC_MAGE_FROST:
                case SPEC_DRUID_BALANCE:
                case SPEC_PALADIN_PROTECTION:
                case SPEC_HUNTER_BEASTMASTER:
                    return true;
                default:
                    return false;
            }
        }
        if (gem->Type & SOCKET_COLOR_RELIC_FROST)
        {
            switch (playerSpecID)
            {
                case SPEC_MAGE_ARCANE:
                case SPEC_MAGE_FROST:
                case SPEC_DK_FROST:
                case SPEC_DRUID_CAT:
                case SPEC_DRUID_RESTORATION:
                case SPEC_MONK_MISTWEAVER:
                case SPEC_SHAMAN_ELEMENTAL:
                case SPEC_SHAMAN_RESTORATION:
                    return true;
                default:
                    return false;
            }
        }
        if (gem->Type & SOCKET_COLOR_RELIC_FIRE)
        {
            switch (playerSpecID)
            {
                case SPEC_DK_UNHOLY:
                case SPEC_DRUID_BEAR:
                case SPEC_MAGE_FIRE:
                case SPEC_PALADIN_RETRIBUTION:
                case SPEC_SHAMAN_ENHANCEMENT:
                case SPEC_WARLOCK_DEMONOLOGY:
                case SPEC_WARLOCK_DESTRUCTION:
                case SPEC_WARRIOR_FURY:
                case SPEC_WARRIOR_PROTECTION:
                    return true;
                default:
                    return false;
            }
        }
        if (gem->Type & SOCKET_COLOR_RELIC_WATER)
        {
            switch (playerSpecID)
            {
                case SPEC_MAGE_FROST:
                case SPEC_DRUID_RESTORATION:
                case SPEC_SHAMAN_RESTORATION:
                case SPEC_MONK_MISTWEAVER:
                    return true;
                default:
                    return false;
            }
        }
        if (gem->Type & SOCKET_COLOR_RELIC_LIFE)
        {
            switch (playerSpecID)
            {
                case SPEC_PALADIN_HOLY:
                case SPEC_DRUID_BALANCE:
                case SPEC_DRUID_CAT:
                case SPEC_DRUID_BEAR:
                case SPEC_DRUID_RESTORATION:
                case SPEC_HUNTER_MARKSMAN:
                case SPEC_PRIEST_HOLY:
                case SPEC_SHAMAN_RESTORATION:
                case SPEC_MONK_BREWMASTER:
                case SPEC_MONK_WINDWALKER:
                case SPEC_MONK_MISTWEAVER:
                    return true;
                default:
                    return false;
            }
        }
        if (gem->Type & SOCKET_COLOR_RELIC_WIND)
        {
            switch (playerSpecID)
            {
                case SPEC_WARRIOR_FURY:
                case SPEC_ROGUE_COMBAT:
                case SPEC_MONK_BREWMASTER:
                case SPEC_MONK_WINDWALKER:
                case SPEC_MONK_MISTWEAVER:
                case SPEC_HUNTER_BEASTMASTER:
                case SPEC_HUNTER_MARKSMAN:
                case SPEC_HUNTER_SURVIVAL:
                case SPEC_SHAMAN_ELEMENTAL:
                case SPEC_SHAMAN_ENHANCEMENT:
                    return true;
                default:
                    return false;
            }
        }
        if (gem->Type & SOCKET_COLOR_RELIC_HOLY)
        {
            switch (playerSpecID)
            {
                case SPEC_PALADIN_HOLY:
                case SPEC_PALADIN_PROTECTION:
                case SPEC_PALADIN_RETRIBUTION:
                case SPEC_PRIEST_DISCIPLINE:
                case SPEC_PRIEST_HOLY:
                    return true;
                default:
                    return false;
            }
        }
    }

    return false;
}

// Return stored item (if stored to stack, it can diff. from pItem). And pItem ca be deleted in this case.
Item* Player::StoreNewItem(ItemPosCountVec const& dest, uint32 itemID, bool update, ItemRandomEnchantmentId const& randomPropertyId /*= {}*/, GuidSet const& allowedLooters /*= GuidSet()*/, std::vector<uint32> const& bonusListIDs /*= std::vector<uint32>()*/, uint32 context/* = 0*/, bool isRefunde)
{
    uint32 count = 0;
    for (auto itr = dest.cbegin(); itr != dest.cend(); ++itr)
        count += itr->count;

    auto item = Item::CreateItem(itemID, count, this);
    if (!item)
        return nullptr;

    item->SetUInt32Value(ITEM_FIELD_CONTEXT, context);
    if (isRefunde)
        item->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE);

    item->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_NEW_ITEM);
    item->SetItemRandomProperties(randomPropertyId);

    if (uint32 upgradeID = sDB2Manager.GetRulesetItemUpgrade(itemID))
        item->SetModifier(ITEM_MODIFIER_UPGRADE_ID, upgradeID);

    for (uint32 bonusListID : bonusListIDs)
        item->AddBonuses(bonusListID);

    item->SetFixedLevel(getLevel()); // Need use after bonus add

    item = StoreItem(dest, item, update);
    if (!item)
        return nullptr;

    if (item->GetTemplate()->IsLegendaryLoot())
        AllLegendarys.insert(item->GetEntry());

    ItemAddedQuestCheck(itemID, count);
    UpdateAchievementCriteria(CRITERIA_TYPE_RECEIVE_EPIC_ITEM, itemID, count);
    UpdateAchievementCriteria(CRITERIA_TYPE_OWN_ITEM, itemID, 1);

    if (sDB2Manager.GetHeirloomByItemId(itemID))
    {
        if (!_collectionMgr->HasHeirloom(itemID))
            UpdateAchievementCriteria(CRITERIA_TYPE_OWN_HEIRLOOMS);

        _collectionMgr->AddHeirloom(itemID, 0);
    }

    if (GetMap()->IsDungeonOrRaid() && allowedLooters.size() > 1 && item->GetTemplate()->GetMaxStackSize() == 1 && item->IsSoulBound())
    {
        item->SetSoulboundTradeable(allowedLooters);
        item->SetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME, GetTotalPlayedTime());
        AddTradeableItem(item);

        // save data
        std::ostringstream ss;
        auto itr = allowedLooters.cbegin();
        ss << *itr;
        for (++itr; itr != allowedLooters.end(); ++itr)
            ss << ' ' << *itr;
        ss << ' ';

        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_ITEM_BOP_TRADE);
        stmt->setUInt64(0, item->GetGUIDLow());
        stmt->setString(1, ss.str());
        CharacterDatabase.Execute(stmt);
    }

    if (ItemChildEquipmentEntry const* childItemEntry = sDB2Manager.GetItemChildEquipment(itemID))
    {
        if (ItemTemplate const* childTemplate = sObjectMgr->GetItemTemplate(childItemEntry->ChildItemID))
        {
            ItemPosCountVec childDest;
            CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, childDest, childTemplate, count, false, nullptr, NULL_BAG, NULL_SLOT);
            if (Item* childItem = StoreNewItem(childDest, childTemplate->GetId(), update))
            {
                childItem->SetGuidValue(ITEM_FIELD_CREATOR, item->GetGUID());
                childItem->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_CHILD);
                item->SetChildItem(childItem->GetGUID());
            }
        }
    }

    if (item->GetTemplate()->GetArtifactID())
    {
        auto artifactDataItr = GlobalArtifactData.find(item->GetEntry());
        if (artifactDataItr != GlobalArtifactData.end())
            item->LoadArtifactData(this, artifactDataItr->second);

        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ITEM_INSTANCE_ARTIFACT_XP);
        stmt->setUInt64(0, GetGUIDLow());
        stmt->setUInt32(1, item->GetEntry());
        if (PreparedQueryResult artifactsResult = CharacterDatabase.Query(stmt))
            item->SetUInt64Value(ITEM_FIELD_ARTIFACT_XP, artifactsResult->Fetch()[0].GetUInt64());

        ObjectGuid itemGUID = item->GetGUID();
        AddDelayedEvent(3000, [this, itemGUID]() -> void
        {
            if (Item* item = GetItemByGuid(itemGUID))
                UnLockThirdSocketIfNeed(item);
        });
    }

    return item;
}

std::vector<Item*> Player::GetItemListByEntry(uint32 entry, bool inBankAlso) const
{
    std::vector<Item*> itemList = std::vector<Item*>();

    for (int i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); ++i)
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (item->GetEntry() == entry)
                itemList.push_back(item);

    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* item = pBag->GetItemByPos(j))
                    if (item->GetEntry() == entry)
                        itemList.push_back(item);

    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (item->GetEntry() == entry)
                itemList.push_back(item);

    if (inBankAlso)
    {
        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
            if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (item->GetEntry() == entry)
                    itemList.push_back(item);
    }

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (item->GetEntry() == entry)
                itemList.push_back(item);

    return itemList;
}

Item* Player::StoreItem(ItemPosCountVec const& dest, Item* pItem, bool update)
{
    if (!pItem)
        return NULL;

    Item* lastItem = pItem;
    for (ItemPosCountVec::const_iterator itr = dest.begin(); itr != dest.end();)
    {
        uint16 pos = itr->pos;
        uint32 count = itr->count;

        ++itr;

        if (itr == dest.end())
        {
            lastItem = _StoreItem(pos, pItem, count, false, update);
            break;
        }

        lastItem = _StoreItem(pos, pItem, count, true, update);
    }

    //! can be null if we add garrison follower (cast spell: SPELL_EFFECT_ADD_GARRISON_FOLLOWER)
    if (lastItem)
        AutoUnequipChildItem(lastItem);

    return lastItem;
}

static bool castItemSpells(Item* pItem, Player* player, uint8 bag)
{
    bool res = true;
    pItem->protected_remove_state = 1;

    const ItemTemplate* proto = pItem->GetTemplate();
    for (ItemEffectEntry const* effectData : proto->Effects)
        if (effectData->TriggerType == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE && effectData->SpellID) // On obtain trigger
            if (bag == INVENTORY_SLOT_BAG_0 || (bag >= INVENTORY_SLOT_BAG_START && bag < INVENTORY_SLOT_BAG_END))
                if (!player->HasAura(effectData->SpellID))
                {
                    if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(effectData->SpellID))
                    {
                        //! Shouln't be triggered as at cast some spell take reagents. for expl. item - 140584
                        player->CastSpell(player, spellInfo, false, pItem);

                        //! small hack. as where is problem with taking reagents at loading player. 
                        for (uint32 x = 0; x < MAX_SPELL_REAGENTS; ++x)
                        {
                            if (spellInfo->Reagents.Reagent[x] <= 0)
                                continue;

                            uint32 itemid = spellInfo->Reagents.Reagent[x];
                            if (itemid == proto->GetId())
                            {
                                res = false;
                                pItem->protected_remove_state = 2;
                                break;
                            }
                        }

                        //! with protected_remove_state hack SPELL_EFFECT_ADD_GARRISON_FOLLOWER possible not need any more.
                        if (spellInfo->HasEffect(SPELL_EFFECT_ADD_GARRISON_FOLLOWER))
                            res = false;
                    }
                }

    //! at cast spell's this item could be reagent.
    if (pItem->protected_remove_state == 2)
    {
        uint32 count = 1;
        pItem->protected_remove_state = 0;  //allow delete now.
        player->DestroyItemCount(pItem, count, true);
        return false;
    }

    //! this part need. like part at state 2.
    pItem->protected_remove_state = 0;
    return res;
}

// Return stored item (if stored to stack, it can diff. from pItem). And pItem ca be deleted in this case.
Item* Player::_StoreItem(uint16 pos, Item* pItem, uint32 count, bool clone, bool update)
{
    if (!pItem)
        return NULL;

    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: StoreItem bag = %u, slot = %u, item = %u, count = %u, guid = %u", bag, slot, pItem->GetEntry(), count, pItem->GetGUIDLow());

    Item* pItem2 = GetItemByPos(bag, slot);

    if (!pItem2)
    {
        if (clone)
            pItem = pItem->CloneItem(count, this);
        else
            pItem->SetCount(count);

        if (!pItem)
            return NULL;

        if (pItem->GetBonding() == BIND_WHEN_PICKED_UP || pItem->GetBonding() == BIND_QUEST_ITEM || (pItem->GetBonding() == BIND_WHEN_EQUIPED && IsBagPos(pos)))
            pItem->SetBinding(true);

        Bag* pBag = (bag == INVENTORY_SLOT_BAG_0) ? NULL : GetBagByPos(bag);
        if (!pBag)
        {
            m_items[slot] = pItem;
            SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), pItem->GetGUID());
            pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, GetGUID());
            pItem->SetGuidValue(ITEM_FIELD_OWNER, GetGUID());

            pItem->SetSlot(slot);
            pItem->SetContainer(NULL);
        }
        else
            pBag->StoreItem(slot, pItem, update);

        if (IsInWorld() && update)
        {
            pItem->AddToWorld();
            pItem->SendUpdateToPlayer(this);
        }

        pItem->SetState(ITEM_CHANGED, this);
        if (pBag)
            pBag->SetState(ITEM_CHANGED, this);

        AddEnchantmentDurations(pItem);
        AddItemDurations(pItem);

        if (!castItemSpells(pItem, this, bag))
            return NULL;
        return pItem;
    }
    if(pItem->GetEntry() != pItem2->GetEntry())
        return NULL;

    if (pItem2->GetBonding() == BIND_WHEN_PICKED_UP || pItem2->GetBonding() == BIND_QUEST_ITEM || (pItem2->GetBonding() == BIND_WHEN_EQUIPED && IsBagPos(pos)))
        pItem2->SetBinding(true);

    if ((pItem2->GetCount() + count) <= pItem2->GetTemplate()->GetMaxStackSize())
        pItem2->SetCount(pItem2->GetCount() + count);

    if (IsInWorld() && update)
        pItem2->SendUpdateToPlayer(this);

    if (!clone)
    {
        // delete item (it not in any slot currently)
        if (IsInWorld() && update)
        {
            pItem->RemoveFromWorld();
            pItem->DestroyForPlayer(this);
        }

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);

        pItem->SetOwnerGUID(GetGUID());                 // prevent error at next SetState in case trade/mail/buy from vendor
        pItem->SetNotRefundable(this);
        pItem->ClearSoulboundTradeable(this);
        RemoveTradeableItem(pItem);
        pItem->SetState(ITEM_REMOVED, this);
    }

    AddEnchantmentDurations(pItem2);

    pItem2->SetState(ITEM_CHANGED, this);

    if (!castItemSpells(pItem2, this, bag))
        return NULL;
    return pItem2;
}

Item* Player::EquipNewItem(uint16 pos, uint32 item, bool update, int32 randomPropertyId /*= 0*/, std::vector<uint32> const& bonusListIDs /*= std::vector<uint32>()*/, uint32 context, bool isRefunde/* = false*/)
{
    if (Item* pItem = Item::CreateItem(item, 1, this))
    {
        pItem->SetItemRandomProperties(ItemRandomEnchantmentId(ItemRandomEnchantmentType::Property, randomPropertyId));

        for (uint32 bonusListID : bonusListIDs)
            pItem->AddBonuses(bonusListID);

        pItem->SetUInt32Value(ITEM_FIELD_CONTEXT, context);
        if (isRefunde)
            pItem->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE);

        ItemAddedQuestCheck(item, 1);
        UpdateAchievementCriteria(CRITERIA_TYPE_RECEIVE_EPIC_ITEM, item, 1);
        return EquipItem(pos, pItem, update);
    }

    return NULL;
}

Item* Player::EquipItem(uint16 pos, Item* pItem, bool update)
{
    if (pItem->GetTemplate()->GetFlags3() & ItemFlags3::ITEM_FLAG3_PVP_TOURNAMENT_GEAR)
    {
        if (!GetBattleground() || !GetBattleground()->IsWargame())
            pItem->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_DISABLE);
    }
    else if (GetBattleground() && GetBattleground()->UseTournamentRules())
        pItem->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_DISABLE);

    AddEnchantmentDurations(pItem);
    AddItemDurations(pItem);

    uint8 bag = pos >> 8;
    uint8 slot = pos & 255;

    Item* pItem2 = GetItemByPos(bag, slot);

    if (!pItem2)
    {
        VisualizeItem(slot, pItem);

        if (isAlive())
        {
            ItemTemplate const* pProto = pItem->GetTemplate();

            // item set bonuses applied only at equip and removed at unequip, and still active for broken items
            if (pProto && pProto->GetItemSet())
                AddItemsSetItem(this, pItem);

            _ApplyItemMods(pItem, slot, true);

            if (pProto && isInCombat() && (pProto->GetClass() == ITEM_CLASS_WEAPON || pProto->GetInventoryType() == INVTYPE_RELIC) && m_weaponChangeTimer == 0)
            {
                uint32 cooldownSpell = getClass() == CLASS_ROGUE ? 6123 : 6119;
                SpellInfo const* spellProto = sSpellMgr->GetSpellInfo(cooldownSpell);

                if (!spellProto)
                    TC_LOG_ERROR(LOG_FILTER_PLAYER, "Weapon switch cooldown spell %u couldn't be found in Spell.dbc", cooldownSpell);
                else
                {
                    m_weaponChangeTimer = spellProto->Cooldowns.StartRecoveryTime;

                    GetGlobalCooldownMgr().AddGlobalCooldown(spellProto, m_weaponChangeTimer);

                    SendSpellCooldown(cooldownSpell, 0, m_weaponChangeTimer, SpellCooldownFlags::INCLUDE_GCD);
                }
            }
        }

        if (IsInWorld() && update)
        {
            pItem->AddToWorld();
            pItem->SendUpdateToPlayer(this);
        }

        SetItemCooldown(pItem, 30);

        // update expertise and armor penetration - passive auras may need it
        UpdateExpertise();
    }
    else
    {
        pItem2->SetCount(pItem2->GetCount() + pItem->GetCount());
        if (IsInWorld() && update)
            pItem2->SendUpdateToPlayer(this);

        // delete item (it not in any slot currently)
        //pItem->DeleteFromDB();
        if (IsInWorld() && update)
        {
            pItem->RemoveFromWorld();
            pItem->DestroyForPlayer(this);
        }

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);

        pItem->SetOwnerGUID(GetGUID());                     // prevent error at next SetState in case trade/mail/buy from vendor
        pItem->SetNotRefundable(this);
        pItem->ClearSoulboundTradeable(this);
        RemoveTradeableItem(pItem);
        pItem->SetState(ITEM_REMOVED, this);
        pItem2->SetState(ITEM_CHANGED, this);

        SetItemCooldown(pItem2, 30);

        return pItem2;
    }

    // only for full equip instead adding to stack
    UpdateAchievementCriteria(CRITERIA_TYPE_EQUIP_ITEM, pItem->GetEntry());
    UpdateAchievementCriteria(CRITERIA_TYPE_EQUIP_EPIC_ITEM, pItem->GetEntry(), slot);
    return pItem;
}

void Player::EquipChildItem(uint8 parentBag, uint8 parentSlot, Item* parentItem)
{
    if (ItemChildEquipmentEntry const* itemChildEquipment = sDB2Manager.GetItemChildEquipment(parentItem->GetEntry()))
    {
        if (Item* childItem = GetChildItemByGuid(parentItem->GetChildItem()))
        {
            uint16 childDest = (INVENTORY_SLOT_BAG_0 << 8) | itemChildEquipment->ChildItemEquipSlot;
            if (childItem->GetPos() != childDest)
            {
                childItem->CopyArtifactDataFromParent(parentItem);
                Item* dstItem = GetItemByPos(childDest);
                if (!dstItem)                                      // empty slot, simple case
                {
                    RemoveItem(childItem->GetBagSlot(), childItem->GetSlot(), true);
                    EquipItem(childDest, childItem, true);
                    AutoUnequipOffhandIfNeed();
                }
                else                                                    // have currently equipped item, not simple case
                {
                    uint8 dstbag = dstItem->GetBagSlot();
                    uint8 dstslot = dstItem->GetSlot();

                    InventoryResult msg = CanUnequipItem(childDest, !childItem->IsBag());
                    if (msg != EQUIP_ERR_OK)
                    {
                        SendEquipError(msg, dstItem);
                        return;
                    }

                    // check dest->src move possibility but try to store currently equipped item in the bag where the parent item is
                    ItemPosCountVec sSrc;
                    uint16 eSrc = 0;
                    if (IsInventoryPos(parentBag, parentSlot))
                    {
                        msg = CanStoreItem(parentBag, NULL_SLOT, sSrc, dstItem, true);
                        if (msg != EQUIP_ERR_OK)
                            msg = CanStoreItem(NULL_BAG, NULL_SLOT, sSrc, dstItem, true);
                    }
                    else if (IsBankPos(parentBag, parentSlot))
                    {
                        msg = CanBankItem(parentBag, NULL_SLOT, sSrc, dstItem, true);
                        if (msg != EQUIP_ERR_OK)
                            msg = CanBankItem(NULL_BAG, NULL_SLOT, sSrc, dstItem, true);
                    }
                    else if (IsEquipmentPos(parentBag, parentSlot))
                    {
                        msg = CanEquipItem(parentSlot, eSrc, dstItem, true);
                        if (msg == EQUIP_ERR_OK)
                            msg = CanUnequipItem(eSrc, true);
                    }

                    if (msg != EQUIP_ERR_OK)
                    {
                        SendEquipError(msg, dstItem, childItem);
                        return;
                    }

                    // now do moves, remove...
                    RemoveItem(dstbag, dstslot, false);
                    RemoveItem(childItem->GetBagSlot(), childItem->GetSlot(), false);

                    // add to dest
                    EquipItem(childDest, childItem, true);

                    // add to src
                    if (IsInventoryPos(parentBag, parentSlot))
                        StoreItem(sSrc, dstItem, true);
                    else if (IsBankPos(parentBag, parentSlot))
                        BankItem(sSrc, dstItem, true);
                    else if (IsEquipmentPos(parentBag, parentSlot))
                        EquipItem(eSrc, dstItem, true);

                    AutoUnequipOffhandIfNeed();
                }
            }
        }
    }
}

void Player::AutoUnequipChildItem(Item* parentItem)
{
    if (sDB2Manager.GetItemChildEquipment(parentItem->GetEntry()))
    {
        if (Item* childItem = GetChildItemByGuid(parentItem->GetChildItem()))
        {
            if (IsChildEquipmentPos(childItem->GetPos()))
                return;

            ItemPosCountVec dest;
            uint32 count = childItem->GetCount();
            InventoryResult result = CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, dest, childItem->GetTemplate(), count, false, childItem, NULL_BAG, NULL_SLOT);
            if (result != EQUIP_ERR_OK)
                return;

            RemoveItem(childItem->GetBagSlot(), childItem->GetSlot(), true);
            StoreItem(dest, childItem, true);
        }
    }
}

void Player::QuickEquipItem(uint16 pos, Item* pItem)
{
    if (pItem)
    {
        AddEnchantmentDurations(pItem);
        AddItemDurations(pItem);

        uint8 slot = pos & 255;
        VisualizeItem(slot, pItem);

        if (IsInWorld())
        {
            pItem->AddToWorld();
            pItem->SendUpdateToPlayer(this);
        }

        UpdateAchievementCriteria(CRITERIA_TYPE_EQUIP_ITEM, pItem->GetEntry());
        UpdateAchievementCriteria(CRITERIA_TYPE_EQUIP_EPIC_ITEM, pItem->GetEntry(), slot);
    }
}

void Player::SetVisibleItemSlot(uint8 slot, Item* pItem)
{
    if (pItem)
    {
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + VISIBLE_ITEM_ENTRY_OFFSET + (slot * 2), pItem->GetVisibleEntry(this));
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + VISIBLE_ITEM_ENCHANTMENT_OFFSET + (slot * 2), 0, pItem->GetVisibleAppearanceModId(this));
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + VISIBLE_ITEM_ENCHANTMENT_OFFSET + (slot * 2), 1, pItem->GetVisibleItemVisual(this));
    }
    else
    {
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + VISIBLE_ITEM_ENTRY_OFFSET + (slot * 2), 0);
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + VISIBLE_ITEM_ENCHANTMENT_OFFSET + (slot * 2), 0);
    }
}

void Player::VisualizeItem(uint8 slot, Item* pItem)
{
    if (!pItem)
        return;

    // check also  BIND_WHEN_PICKED_UP and BIND_QUEST_ITEM for .additem or .additemset case by GM (not binded at adding to inventory)
    if (pItem->GetBonding() == BIND_WHEN_EQUIPED || pItem->GetBonding() == BIND_WHEN_PICKED_UP || pItem->GetBonding() == BIND_QUEST_ITEM)
        pItem->SetBinding(true);

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: EquipItem slot = %u, item = %u", slot, pItem->GetEntry());

    m_items[slot] = pItem;
    SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), pItem->GetGUID());
    pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, GetGUID());
    pItem->SetGuidValue(ITEM_FIELD_OWNER, GetGUID());
    pItem->SetSlot(slot);
    pItem->SetContainer(NULL);

    if (slot < EQUIPMENT_SLOT_END)
        SetVisibleItemSlot(slot, pItem);

    SendOperationsAfterDelay(OAD_RECALC_ITEM_LVL);

    pItem->SetState(ITEM_CHANGED, this);
}

void Player::RemoveItem(uint8 bag, uint8 slot, bool update)
{
    // note: removeitem does not actually change the item
    // it only takes the item out of storage temporarily
    // note2: if removeitem is to be used for delinking
    // the item must be removed from the player's updatequeue

    Item* pItem = GetItemByPos(bag, slot);
    if (pItem)
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: RemoveItem bag = %u, slot = %u, item = %u", bag, slot, pItem->GetEntry());

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);
        RemoveTradeableItem(pItem);

        if (bag == INVENTORY_SLOT_BAG_0)
        {
            if (slot < INVENTORY_SLOT_BAG_END)
            {
                ItemTemplate const* pProto = pItem->GetTemplate();
                // item set bonuses applied only at equip and removed at unequip, and still active for broken items

                if (pProto && pProto->GetItemSet())
                    RemoveItemsSetItem(this, pProto);

                _ApplyItemMods(pItem, slot, false);

                // remove item dependent auras and casts (only weapon and armor slots)
                if (slot < EQUIPMENT_SLOT_END)
                {
                    RemoveItemDependentAurasAndCasts(pItem);

                    // remove held enchantments, update expertise
                    if (slot == EQUIPMENT_SLOT_MAINHAND)
                    {
                        if (pItem->GetItemSuffixFactor())
                        {
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_3);
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_4);
                        }
                        else
                        {
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_0);
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_1);
                        }
                    }
                }
            }

            m_items[slot] = NULL;
            SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), ObjectGuid::Empty);

            UpdateExpertise();

            if (slot < EQUIPMENT_SLOT_END)
                SetVisibleItemSlot(slot, NULL);
        }
        else if (Bag* pBag = GetBagByPos(bag))
            pBag->RemoveItem(slot, update);

        pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, ObjectGuid::Empty);
        // pItem->SetUInt64Value(ITEM_FIELD_OWNER, 0); not clear owner at remove (it will be set at store). This used in mail and auction code
        pItem->SetSlot(NULL_SLOT);

        SendOperationsAfterDelay(OAD_RECALC_ITEM_LVL);

        if (IsInWorld() && update)
            pItem->SendUpdateToPlayer(this);
    }
}

void Player::RemoveItem(Item* pItem, bool update)
{
    // note: removeitem does not actually change the item
    // it only takes the item out of storage temporarily
    // note2: if removeitem is to be used for delinking
    // the item must be removed from the player's updatequeue

    if (pItem)
    {
        uint8 bag = pItem->GetBagSlot();
        uint8 slot = pItem->GetSlot();

        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: RemoveItem bag = %u, slot = %u, item = %u", bag, slot, pItem->GetEntry());

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);
        RemoveTradeableItem(pItem);

        if (bag == INVENTORY_SLOT_BAG_0)
        {
            if (slot < INVENTORY_SLOT_BAG_END)
            {
                ItemTemplate const* pProto = pItem->GetTemplate();
                // item set bonuses applied only at equip and removed at unequip, and still active for broken items

                if (pProto && pProto->GetItemSet())
                    RemoveItemsSetItem(this, pProto);

                _ApplyItemMods(pItem, slot, false);

                // remove item dependent auras and casts (only weapon and armor slots)
                if (slot < EQUIPMENT_SLOT_END)
                {
                    RemoveItemDependentAurasAndCasts(pItem);

                    // remove held enchantments, update expertise
                    if (slot == EQUIPMENT_SLOT_MAINHAND)
                    {
                        if (pItem->GetItemSuffixFactor())
                        {
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_3);
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_4);
                        }
                        else
                        {
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_0);
                            pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_1);
                        }
                    }
                }
            }

            m_items[slot] = NULL;
            SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), ObjectGuid::Empty);

            UpdateExpertise();

            if (slot < EQUIPMENT_SLOT_END)
                SetVisibleItemSlot(slot, NULL);
        }
        else if (Bag* pBag = GetBagByPos(bag))
            pBag->RemoveItem(slot, update);

        pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, ObjectGuid::Empty);
        pItem->SetSlot(NULL_SLOT);
        if (IsInWorld() && update)
            pItem->SendUpdateToPlayer(this);

        AutoUnequipChildItem(pItem);
    }
}

// Common operation need to remove item from inventory without delete in trade, auction, guild bank, mail....
void Player::MoveItemFromInventory(uint8 bag, uint8 slot, bool update)
{
    if (Item* it = GetItemByPos(bag, slot))
    {
        ItemRemovedQuestCheck(it->GetEntry(), it->GetCount());
        RemoveItem(bag, slot, update);
        it->SetNotRefundable(this, false);
        it->RemoveFromUpdateQueueOf(this);
        if (it->IsInWorld())
        {
            it->RemoveFromWorld();
            it->DestroyForPlayer(this);
        }
    }
}

void Player::MoveItemFromInventory(Item* pItem, bool update)
{
    if (pItem)
    {
        ItemRemovedQuestCheck(pItem->GetEntry(), pItem->GetCount());
        RemoveItem(pItem, update);
        pItem->SetNotRefundable(this, false);
        pItem->RemoveFromUpdateQueueOf(this);
        if (pItem->IsInWorld())
        {
            pItem->RemoveFromWorld();
            pItem->DestroyForPlayer(this);
        }
    }
}

// Common operation need to add item from inventory without delete in trade, guild bank, mail....
void Player::MoveItemToInventory(ItemPosCountVec const& dest, Item* pItem, bool update, bool in_characterInventoryDB)
{
    // update quest counters
    ItemAddedQuestCheck(pItem->GetEntry(), pItem->GetCount());
    UpdateAchievementCriteria(CRITERIA_TYPE_RECEIVE_EPIC_ITEM, pItem->GetEntry(), pItem->GetCount());
    
    // store item
    Item* pLastItem = StoreItem(dest, pItem, update);
    if (!pLastItem)
        return;

    // only set if not merged to existed stack (pItem can be deleted already but we can compare pointers any way)
    if (pLastItem == pItem)
    {
        // update owner for last item (this can be original item with wrong owner
        if (pLastItem->GetOwnerGUID() != GetGUID())
            pLastItem->SetOwnerGUID(GetGUID());

        // if this original item then it need create record in inventory
        // in case trade we already have item in other player inventory
        pLastItem->SetState(in_characterInventoryDB ? ITEM_CHANGED : ITEM_NEW, this);
    }

    if (pLastItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_BOP_TRADEABLE))
        AddTradeableItem(pLastItem);
}

void Player::DestroyItem(uint8 bag, uint8 slot, bool update)
{
    Item* pItem = GetItemByPos(bag, slot);
    if (pItem)
    {
        //! protect delete item while equiping.
        if (pItem->protected_remove_state == 1)
        {
            pItem->protected_remove_state = 2;
            return;
        }
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItem bag = %u, slot = %u, item = %u", bag, slot, pItem->GetEntry());
        // Also remove all contained items if the item is a bag.
        // This if () prevents item saving crashes if the condition for a bag to be empty before being destroyed was bypassed somehow.
        if (pItem->IsNotEmptyBag())
            for (uint8 i = 0; i < MAX_BAG_SIZE; ++i)
                DestroyItem(slot, i, update);

        if (pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_WRAPPED))
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GIFT);

            stmt->setUInt64(0, pItem->GetGUIDLow());

            CharacterDatabase.Execute(stmt);
        }

        RemoveEnchantmentDurations(pItem);
        RemoveItemDurations(pItem);

        pItem->SetNotRefundable(this);
        pItem->ClearSoulboundTradeable(this);
        RemoveTradeableItem(pItem);

        ItemTemplate const* proto = pItem->GetTemplate();
        for (ItemEffectEntry const* effectData : proto->Effects)
            if (effectData->TriggerType == ITEM_SPELLTRIGGER_ON_NO_DELAY_USE && effectData->SpellID)
                RemoveAurasDueToSpell(effectData->SpellID);

        ItemRemovedQuestCheck(pItem->GetEntry(), pItem->GetCount());

        if (bag == INVENTORY_SLOT_BAG_0)
        {
            SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), ObjectGuid::Empty);

            // equipment and equipped bags can have applied bonuses
            if (slot < INVENTORY_SLOT_BAG_END)
            {
                ItemTemplate const* pProto = pItem->GetTemplate();

                // item set bonuses applied only at equip and removed at unequip, and still active for broken items
                if (pProto && pProto->GetItemSet())
                    RemoveItemsSetItem(this, pProto);

                _ApplyItemMods(pItem, slot, false);
            }

            if (slot < EQUIPMENT_SLOT_END)
            {
                // remove item dependent auras and casts (only weapon and armor slots)
                RemoveItemDependentAurasAndCasts(pItem);

                UpdateExpertise();

                // equipment visual show
                SetVisibleItemSlot(slot, NULL);
            }

            m_items[slot] = NULL;
        }
        else if (Bag* pBag = GetBagByPos(bag))
            pBag->RemoveItem(slot, update);

        if (IsInWorld() && update)
        {
            pItem->RemoveFromWorld();
            pItem->DestroyForPlayer(this);
        }

        //pItem->SetOwnerGUID(0);
        pItem->SetGuidValue(ITEM_FIELD_CONTAINED_IN, ObjectGuid::Empty);
        pItem->SetSlot(NULL_SLOT);
        pItem->SetState(ITEM_REMOVED, this);
    }
}

void Player::DestroyItemCount(uint32 item, uint32 count, bool update, bool unequip_check)
{
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItemCount item = %u, count = %u", item, count);
    uint32 remcount = 0;

    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); ++i)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                if (pItem->GetCount() + remcount <= count)
                {
                    // all items in inventory can unequipped
                    remcount += pItem->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                    pItem->SetCount(pItem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pItem->SendUpdateToPlayer(this);
                    pItem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                if (Item* pItem = pBag->GetItemByPos(j))
                {
                    if (pItem->GetEntry() == item && !pItem->IsInTrade())
                    {
                        // all items in bags can be unequipped
                        if (pItem->GetCount() + remcount <= count)
                        {
                            remcount += pItem->GetCount();
                            DestroyItem(i, j, update);

                            if (remcount >= count)
                                return;
                        }
                        else
                        {
                            ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                            pItem->SetCount(pItem->GetCount() - count + remcount);
                            if (IsInWorld() && update)
                                pItem->SendUpdateToPlayer(this);
                            pItem->SetState(ITEM_CHANGED, this);
                            return;
                        }
                    }
                }
            }
        }
    }

    // in equipment and bag list
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pItem && pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                if (pItem->GetCount() + remcount <= count)
                {
                    if (!unequip_check || CanUnequipItem(INVENTORY_SLOT_BAG_0 << 8 | i, false) == EQUIP_ERR_OK)
                    {
                        remcount += pItem->GetCount();
                        DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

                        if (remcount >= count)
                            return;
                    }
                }
                else
                {
                    ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                    pItem->SetCount(pItem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pItem->SendUpdateToPlayer(this);
                    pItem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in bank
    for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
    {
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pItem->GetEntry() == item && !pItem->IsInTrade())
            {
                if (pItem->GetCount() + remcount <= count)
                {
                    remcount += pItem->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                    pItem->SetCount(pItem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pItem->SendUpdateToPlayer(this);
                    pItem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    // in bank bags
    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; i++)
    {
        if (Bag* pBag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
            {
                if (Item* pItem = pBag->GetItemByPos(j))
                {

                
                    if (pItem->GetEntry() == item && !pItem->IsInTrade())
                    {
                        // all items in bags can be unequipped
                        if (pItem->GetCount() + remcount <= count)
                        {
                            remcount += pItem->GetCount();
                            DestroyItem(i, j, update);

                            if (remcount >= count)
                                return;
                        }
                        else
                        {
                            ItemRemovedQuestCheck(pItem->GetEntry(), count - remcount);
                            pItem->SetCount(pItem->GetCount() - count + remcount);
                            if (IsInWorld() && update)
                                pItem->SendUpdateToPlayer(this);
                            pItem->SetState(ITEM_CHANGED, this);
                            return;
                        }
                    }
                }
            }
        }
    }

    for (uint8 i = REAGENT_SLOT_START; i < REAGENT_SLOT_END; ++i)
    {
        if (Item* pitem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pitem->GetEntry() == item && !pitem->IsInTrade())
            {
                if (pitem->GetCount() + remcount <= count)
                {
                    // all keys can be unequipped
                    remcount += pitem->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(pitem->GetEntry(), count - remcount);
                    pitem->SetCount(pitem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pitem->SendUpdateToPlayer(this);
                    pitem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
    {
        if (Item* pitem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (pitem->GetEntry() == item && !pitem->IsInTrade())
            {
                if (pitem->GetCount() + remcount <= count)
                {
                    // all keys can be unequipped
                    remcount += pitem->GetCount();
                    DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

                    if (remcount >= count)
                        return;
                }
                else
                {
                    ItemRemovedQuestCheck(pitem->GetEntry(), count - remcount);
                    pitem->SetCount(pitem->GetCount() - count + remcount);
                    if (IsInWorld() && update)
                        pitem->SendUpdateToPlayer(this);
                    pitem->SetState(ITEM_CHANGED, this);
                    return;
                }
            }
        }
    }
}

void Player::DestroyZoneLimitedItem(bool update, uint32 new_zone)
{
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyZoneLimitedItem in map %u and area %u", GetMapId(), new_zone);

    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
                        DestroyItem(i, j, update);

    // in equipment and bag list
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsLimitedToAnotherMapOrZone(GetMapId(), new_zone))
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
}

void Player::DestroyConjuredItems(bool update)
{
    // used when entering arena
    // destroys all conjured items
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyConjuredItems");

    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsConjuredConsumable())
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->IsConjuredConsumable())
                        DestroyItem(i, j, update);

    // in equipment and bag list
    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; i++)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->IsConjuredConsumable())
                DestroyItem(INVENTORY_SLOT_BAG_0, i, update);
}

Item* Player::GetItemByEntry(uint32 entry, bool inBank) const
{
    // in inventory
    for (int i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == entry)
                return pItem;

    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetEntry() == entry)
                        return pItem;

    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == entry)
                return pItem;

    for (uint8 i = CHILD_EQUIPMENT_SLOT_START; i < CHILD_EQUIPMENT_SLOT_END; ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEntry() == entry)
                return pItem;

    if (inBank)
    {
        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem->GetEntry() == entry)
                    return pItem;

        for (uint8 i = REAGENT_SLOT_START; i < REAGENT_SLOT_END; ++i)
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
                if (pItem->GetEntry() == entry)
                    return pItem;

        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
            if (Bag* pBag = GetBagByPos(i))
                for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                    if (Item* pItem = pBag->GetItemByPos(j))
                        if (pItem->GetEntry() == entry)
                            return pItem;
    }

    return NULL;
}

void Player::DestroyItemCount(Item* pItem, uint32 &count, bool update)
{
    if (!pItem)
        return;

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: DestroyItemCount item (GUID: %u, Entry: %u) count = %u", pItem->GetGUIDLow(), pItem->GetEntry(), count);

    if (pItem->GetCount() <= count)
    {
        count -= pItem->GetCount();

        //! Fix deletion items at loading.
        if (m_itemUpdateQueueBlocked)
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_ITEM);
            stmt->setUInt64(0, pItem->GetGUIDLow());
            CharacterDatabase.Execute(stmt);
        }

        DestroyItem(pItem->GetBagSlot(), pItem->GetSlot(), update);
    }
    else
    {
        ItemRemovedQuestCheck(pItem->GetEntry(), count);
        pItem->SetCount(pItem->GetCount() - count);
        count = 0;
        if (IsInWorld() && update)
            pItem->SendUpdateToPlayer(this);
        pItem->SetState(ITEM_CHANGED, this);
    }
}

void Player::SplitItem(uint16 src, uint16 dst, uint32 count)
{
    uint8 srcbag = src >> 8;
    uint8 srcslot = src & 255;

    uint8 dstbag = dst >> 8;
    uint8 dstslot = dst & 255;

    Item* pSrcItem = GetItemByPos(srcbag, srcslot);
    if (!pSrcItem)
    {
        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, pSrcItem);
        return;
    }

    if (pSrcItem->m_lootGenerated)                           // prevent split looting item (item
    {
        //best error message found for attempting to split while looting
        SendEquipError(EQUIP_ERR_SPLIT_FAILED, pSrcItem);
        return;
    }

    // not let split all items (can be only at cheating)
    if (pSrcItem->GetCount() == count)
    {
        SendEquipError(EQUIP_ERR_SPLIT_FAILED, pSrcItem);
        return;
    }

    // not let split more existed items (can be only at cheating)
    if (pSrcItem->GetCount() < count)
    {
        SendEquipError(EQUIP_ERR_TOO_FEW_TO_SPLIT, pSrcItem);
        return;
    }

    //! If trading
    if (TradeData* tradeData = GetTradeData())
    {
        //! If current item is in trade window (only possible with packet spoofing - silent return)
        if (tradeData->GetTradeSlotForItem(pSrcItem->GetGUID()) != TRADE_SLOT_INVALID)
            return;
    }

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: SplitItem bag = %u, slot = %u, item = %u, count = %u", dstbag, dstslot, pSrcItem->GetEntry(), count);
    Item* pNewItem = pSrcItem->CloneItem(count, this);
    if (!pNewItem)
    {
        SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, pSrcItem);
        return;
    }

    if (IsInventoryPos(dst))
    {
        // change item amount before check (for unique max count check)
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        ItemPosCountVec dest;
        InventoryResult msg = CanStoreItem(dstbag, dstslot, dest, pNewItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem);
            return;
        }

        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);
        pSrcItem->SetState(ITEM_CHANGED, this);
        StoreItem(dest, pNewItem, true);
    }
    else if (IsBankPos(dst))
    {
        // change item amount before check (for unique max count check)
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        ItemPosCountVec dest;
        InventoryResult msg = CanBankItem(dstbag, dstslot, dest, pNewItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem);
            return;
        }

        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);
        pSrcItem->SetState(ITEM_CHANGED, this);
        BankItem(dest, pNewItem, true);
    }
    else if (IsEquipmentPos(dst))
    {
        // change item amount before check (for unique max count check), provide space for splitted items
        pSrcItem->SetCount(pSrcItem->GetCount() - count);

        uint16 dest;
        InventoryResult msg = CanEquipItem(dstslot, dest, pNewItem, false);
        if (msg != EQUIP_ERR_OK)
        {
            delete pNewItem;
            pSrcItem->SetCount(pSrcItem->GetCount() + count);
            SendEquipError(msg, pSrcItem);
            return;
        }

        if (IsInWorld())
            pSrcItem->SendUpdateToPlayer(this);
        pSrcItem->SetState(ITEM_CHANGED, this);
        EquipItem(dest, pNewItem, true);
        AutoUnequipOffhandIfNeed();
    }
}

void Player::SwapItem(uint16 src, uint16 dst)
{
    if (!IsInWorld())
        return;

    uint8 srcbag = src >> 8;
    uint8 srcslot = src & 255;

    uint8 dstbag = dst >> 8;
    uint8 dstslot = dst & 255;

    Item* pSrcItem = GetItemByPos(srcbag, srcslot);
    Item* pDstItem = GetItemByPos(dstbag, dstslot);

    if (!pSrcItem || !pSrcItem->IsInWorld() || (pDstItem && !pDstItem->IsInWorld()))
        return;

    if (pSrcItem->GetCount() > pSrcItem->GetTemplate()->GetMaxStackSize()) // Prevent dupe item, don`t swap this item
    {
        pSrcItem->SetCount(pSrcItem->GetTemplate()->GetMaxStackSize());
        pSrcItem->SendUpdateToPlayer(this);
        return;
    }

    if (pSrcItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_CHILD))
    {
        if (Item* parentItem = GetItemByGuid(pSrcItem->GetGuidValue(ITEM_FIELD_CREATOR)))
        {
            if (IsEquipmentPos(src))
            {
                AutoUnequipChildItem(parentItem);   // we need to unequip child first since it cannot go into whatever is going to happen next
                SwapItem(dst, src);                 // src is now empty
                SwapItem(parentItem->GetPos(), dst);// dst is now empty
                return;
            }
        }
    }
    // else if (pDstItem && pDstItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_CHILD))
    // {
        // if (Item* parentItem = GetItemByGuid(pDstItem->GetGuidValue(ITEM_FIELD_CREATOR)))
        // {
            // if (IsEquipmentPos(dst))
            // {
                // AutoUnequipChildItem(parentItem);   // we need to unequip child first since it cannot go into whatever is going to happen next
                // SwapItem(src, dst);                 // dst is now empty
                // SwapItem(parentItem->GetPos(), src);// src is now empty
                // return;
            // }
        // }
    // }

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: SwapItem bag = %u, slot = %u, item = %u", dstbag, dstslot, pSrcItem->GetEntry());

    if (!isAlive())
    {
        SendEquipError(EQUIP_ERR_PLAYER_DEAD, pSrcItem, pDstItem);
        return;
    }

    // SRC checks

    if (pSrcItem->m_lootGenerated)                           // prevent swap looting item
    {
        //best error message found for attempting to swap while looting
        SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, pSrcItem);
        return;
    }

    if (IsBagPos(src) || IsBagPos(dst))
        TradeCancel(true);

    // check unequip potability for equipped items and bank bags
    if (IsEquipmentPos(src) || IsBagPos(src))
    {
        // bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
        InventoryResult msg = CanUnequipItem(src, !IsBagPos(src) || IsBagPos(dst) || (pDstItem && pDstItem->ToBag() && pDstItem->ToBag()->IsEmpty()));
        if (msg != EQUIP_ERR_OK)
        {
            SendEquipError(msg, pSrcItem, pDstItem);
            return;
        }
    }

    // prevent put equipped/bank bag in self
    if (IsBagPos(src) && srcslot == dstbag)
    {
        SendEquipError(EQUIP_ERR_BAG_IN_BAG, pSrcItem, pDstItem);
        return;
    }

    // prevent equipping bag in the same slot from its inside
    if (IsBagPos(dst) && srcbag == dstslot)
    {
        SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, pDstItem);
        return;
    }

    // don't allow swap items used in spell cast
    if (pSrcItem->IsInUse())
        return;

    // DST checks
    if (pDstItem)
    {
        if (pDstItem->GetCount() > pDstItem->GetTemplate()->GetMaxStackSize()) // Prevent dupe item, don`t swap this item
        {
            pDstItem->SetCount(pDstItem->GetTemplate()->GetMaxStackSize());
            pDstItem->SendUpdateToPlayer(this);
            return;
        }

        if (pDstItem->m_lootGenerated)                       // prevent swap looting item
        {
            //best error message found for attempting to swap while looting
            SendEquipError(EQUIP_ERR_CLIENT_LOCKED_OUT, pDstItem);
            return;
        }

        // check unequip potability for equipped items and bank bags
        if (IsEquipmentPos(dst) || IsBagPos(dst))
        {
            // bags can be swapped with empty bag slots, or with empty bag (items move possibility checked later)
            InventoryResult msg = CanUnequipItem(dst, !IsBagPos(dst) || IsBagPos(src) || (pSrcItem->ToBag() && pSrcItem->ToBag()->IsEmpty()));
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem, pDstItem);
                return;
            }
        }

        // don't allow swap items used in spell cast
        if (pDstItem->IsInUse() || !pDstItem->IsInWorld())
            return;
    }

    // NOW this is or item move (swap with empty), or swap with another item (including bags in bag possitions)
    // or swap empty bag with another empty or not empty bag (with items exchange)

    // Move case
    if (!pDstItem)
    {
        if (IsInventoryPos(dst))
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanStoreItem(dstbag, dstslot, dest, pSrcItem, false);
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem);
                return;
            }

            RemoveItem(srcbag, srcslot, true);
            StoreItem(dest, pSrcItem, true);
            if (IsBankPos(src))
                ItemAddedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
        }
        else if (IsBankPos(dst))
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanBankItem(dstbag, dstslot, dest, pSrcItem, false);
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem);
                return;
            }

            RemoveItem(srcbag, srcslot, true);
            BankItem(dest, pSrcItem, true);
            ItemRemovedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
        }
        else if (IsReagentBankPos(dst))
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanBankReagentItem(dstbag, dstslot, dest, pSrcItem, false);
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem);
                return;
            }

            RemoveItem(srcbag, srcslot, true);
            BankItem(dest, pSrcItem, true);
            ItemRemovedQuestCheck(pSrcItem->GetEntry(), pSrcItem->GetCount());
        }
        else if (IsEquipmentPos(dst))
        {
            uint16 dest;
            InventoryResult msg = CanEquipItem(dstslot, dest, pSrcItem, false);
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, pSrcItem);
                return;
            }
            bool equipChildItem = !pSrcItem->GetChildItem().IsEmpty();

            if (equipChildItem)
                equipChildItem = CanEquipChildItem(pSrcItem) == EQUIP_ERR_OK;

            RemoveItem(srcbag, srcslot, true);
            EquipItem(dest, pSrcItem, true);

            if (equipChildItem)
                EquipChildItem(srcbag, srcslot, pSrcItem);

            AutoUnequipOffhandIfNeed();
        }

        return;
    }

    // attempt merge to / fill target item
    if (!pSrcItem->IsBag() && !pDstItem->IsBag())
    {
        InventoryResult msg;
        ItemPosCountVec sDest;
        uint16 eDest = 0;
        if (IsInventoryPos(dst))
            msg = CanStoreItem(dstbag, dstslot, sDest, pSrcItem, false);
        else if (IsBankPos(dst))
            msg = CanBankItem(dstbag, dstslot, sDest, pSrcItem, false);
        else if (IsEquipmentPos(dst))
            msg = CanEquipItem(dstslot, eDest, pSrcItem, false);
        else
            return;

        if (msg == EQUIP_ERR_OK && IsEquipmentPos(dst) && !pSrcItem->GetChildItem().IsEmpty())
            msg = CanEquipChildItem(pSrcItem);

        // can be merge/fill
        if (msg == EQUIP_ERR_OK)
        {
            if (pSrcItem->GetCount() + pDstItem->GetCount() <= pSrcItem->GetTemplate()->GetMaxStackSize())
            {
                RemoveItem(srcbag, srcslot, true);

                if (IsInventoryPos(dst))
                    StoreItem(sDest, pSrcItem, true);
                else if (IsBankPos(dst))
                    BankItem(sDest, pSrcItem, true);
                else if (IsEquipmentPos(dst))
                {
                    EquipItem(eDest, pSrcItem, true);
                    if (!pSrcItem->GetChildItem().IsEmpty())
                        EquipChildItem(srcbag, srcslot, pSrcItem);

                    AutoUnequipOffhandIfNeed();
                }
            }
            else
            {
                pSrcItem->SetCount(pSrcItem->GetCount() + pDstItem->GetCount() - pSrcItem->GetTemplate()->GetMaxStackSize());
                pDstItem->SetCount(pSrcItem->GetTemplate()->GetMaxStackSize());
                pSrcItem->SetState(ITEM_CHANGED, this);
                pDstItem->SetState(ITEM_CHANGED, this);
                if (IsInWorld())
                {
                    pSrcItem->SendUpdateToPlayer(this);
                    pDstItem->SendUpdateToPlayer(this);
                }
            }
            SendRefundInfo(pDstItem);
            return;
        }
    }

    // impossible merge/fill, do real swap
    InventoryResult msg = EQUIP_ERR_OK;

    // check src->dest move possibility
    ItemPosCountVec sDest;
    uint16 eDest = 0;
    if (IsInventoryPos(dst))
        msg = CanStoreItem(dstbag, dstslot, sDest, pSrcItem, true);
    else if (IsBankPos(dst))
        msg = CanBankItem(dstbag, dstslot, sDest, pSrcItem, true);
    else if (IsReagentBankPos(dst))
        msg = CanBankReagentItem(dstbag, dstslot, sDest, pSrcItem, true);
    else if (IsEquipmentPos(dst))
    {
        msg = CanEquipItem(dstslot, eDest, pSrcItem, true);
        if (msg == EQUIP_ERR_OK)
            msg = CanUnequipItem(eDest, true);
    }

    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, pSrcItem, pDstItem);
        return;
    }

    // check dest->src move possibility
    ItemPosCountVec sDest2;
    uint16 eDest2 = 0;
    if (IsInventoryPos(src))
        msg = CanStoreItem(srcbag, srcslot, sDest2, pDstItem, true);
    else if (IsBankPos(src))
        msg = CanBankItem(srcbag, srcslot, sDest2, pDstItem, true);
    else if (IsReagentBankPos(src))
        msg = CanBankReagentItem(srcbag, srcslot, sDest2, pDstItem, true);
    else if (IsEquipmentPos(src))
    {
        msg = CanEquipItem(srcslot, eDest2, pDstItem, true);
        if (msg == EQUIP_ERR_OK)
            msg = CanUnequipItem(eDest2, true);
    }

    if (msg == EQUIP_ERR_OK && IsEquipmentPos(dst) && !pSrcItem->GetChildItem().IsEmpty())
        msg = CanEquipChildItem(pSrcItem);

    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, pDstItem, pSrcItem);
        return;
    }

    // Check bag swap with item exchange (one from empty in not bag possition (equipped (not possible in fact) or store)
    if (Bag* srcBag = pSrcItem->ToBag())
    {
        if (Bag* dstBag = pDstItem->ToBag())
        {
            Bag* emptyBag = NULL;
            Bag* fullBag = NULL;
            if (srcBag->IsEmpty() && !IsBagPos(src))
            {
                emptyBag = srcBag;
                fullBag  = dstBag;
            }
            else if (dstBag->IsEmpty() && !IsBagPos(dst))
            {
                emptyBag = dstBag;
                fullBag  = srcBag;
            }

            // bag swap (with items exchange) case
            if (emptyBag && fullBag)
            {
                ItemTemplate const* emptyProto = emptyBag->GetTemplate();

                uint32 count = 0;

                for (uint32 i=0; i < fullBag->GetBagSize(); ++i)
                {
                    Item* bagItem = fullBag->GetItemByPos(i);
                    if (!bagItem)
                        continue;

                    ItemTemplate const* bagItemProto = bagItem->GetTemplate();
                    if (!bagItemProto || !ItemCanGoIntoBag(bagItemProto, emptyProto))
                    {
                        // one from items not go to empty target bag
                        SendEquipError(EQUIP_ERR_BAG_IN_BAG, pSrcItem, pDstItem);
                        return;
                    }

                    ++count;
                }

                if (count > emptyBag->GetBagSize())
                {
                    // too small targeted bag
                    SendEquipError(EQUIP_ERR_CANT_SWAP, pSrcItem, pDstItem);
                    return;
                }

                // Items swap
                count = 0;                                      // will pos in new bag
                for (uint32 i = 0; i< fullBag->GetBagSize(); ++i)
                {
                    Item* bagItem = fullBag->GetItemByPos(i);
                    if (!bagItem)
                        continue;

                    fullBag->RemoveItem(i, true);
                    emptyBag->StoreItem(count, bagItem, true);
                    bagItem->SetState(ITEM_CHANGED, this);

                    ++count;
                }
            }
        }
    }

    // now do moves, remove...
    RemoveItem(dstbag, dstslot, false);
    RemoveItem(srcbag, srcslot, false);

    // add to dest
    if (IsInventoryPos(dst))
        StoreItem(sDest, pSrcItem, true);
    else if (IsBankPos(dst))
        BankItem(sDest, pSrcItem, true);
    else if (IsEquipmentPos(dst))
    {
        EquipItem(eDest, pSrcItem, true);
        if (!pSrcItem->GetChildItem().IsEmpty())
            EquipChildItem(srcbag, srcslot, pSrcItem);
    }

    // add to src
    if (IsInventoryPos(src))
        StoreItem(sDest2, pDstItem, true);
    else if (IsBankPos(src))
        BankItem(sDest2, pDstItem, true);
    else if (IsEquipmentPos(src))
        EquipItem(eDest2, pDstItem, true);

    // if player is moving bags and is looting an item inside this bag
    // release the loot
    if (GetLootGUID())
    {
        bool released = false;
        if (IsBagPos(src))
        {
            Bag* bag = pSrcItem->ToBag();
            for (uint32 i = 0; i < bag->GetBagSize(); ++i)
            {
                if (Item* bagItem = bag->GetItemByPos(i))
                {
                    if (bagItem->m_lootGenerated)
                    {
                        m_session->DoLootRelease(GetLootGUID());
                        released = true;                    // so we don't need to look at dstBag
                        break;
                    }
                }
            }
        }

        if (!released && IsBagPos(dst) && pDstItem)
        {
            Bag* bag = pDstItem->ToBag();
            for (uint32 i = 0; i < bag->GetBagSize(); ++i)
            {
                if (Item* bagItem = bag->GetItemByPos(i))
                {
                    if (bagItem->m_lootGenerated)
                    {
                        m_session->DoLootRelease(GetLootGUID());
                        released = true;                    // not realy needed here
                        break;
                    }
                }
            }
        }
    }

    AutoUnequipOffhandIfNeed();
}

void Player::AddItemToBuyBackSlot(Item* pItem)
{
    if (pItem)
    {
        uint32 slot = m_currentBuybackSlot;
        // if current back slot non-empty search oldest or free
        if (m_items[slot])
        {
            uint32 oldest_time = GetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP);
            uint32 oldest_slot = BUYBACK_SLOT_START;

            for (uint32 i = BUYBACK_SLOT_START+1; i < BUYBACK_SLOT_END; ++i)
            {
                // found empty
                if (!m_items[i])
                {
                    oldest_slot = i;
                    break;
                }

                uint32 i_time = GetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP + i - BUYBACK_SLOT_START);

                if (oldest_time > i_time)
                {
                    oldest_time = i_time;
                    oldest_slot = i;
                }
            }

            // find oldest
            slot = oldest_slot;
        }

        RemoveItemFromBuyBackSlot(slot, true);
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: AddItemToBuyBackSlot item = %u, slot = %u", pItem->GetEntry(), slot);

        m_items[slot] = pItem;
        time_t base = time(NULL);
        uint32 etime = uint32(base - m_logintime + (30 * 3600));
        uint32 eslot = slot - BUYBACK_SLOT_START;

        SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), pItem->GetGUID());
        if (ItemTemplate const* proto = pItem->GetTemplate())
            SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + eslot, pItem->GetSellPrice() * pItem->GetCount());
        else
            SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + eslot, 0);
        SetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP + eslot, (uint32)etime);

        // move to next (for non filled list is move most optimized choice)
        if (m_currentBuybackSlot < BUYBACK_SLOT_END - 1)
            ++m_currentBuybackSlot;
    }
}

Item* Player::GetItemFromBuyBackSlot(uint32 slot)
{
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: GetItemFromBuyBackSlot slot = %u", slot);
    if (slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END)
        return m_items[slot];
    return NULL;
}

void Player::RemoveItemFromBuyBackSlot(uint32 slot, bool del)
{
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "STORAGE: RemoveItemFromBuyBackSlot slot = %u", slot);
    if (slot >= BUYBACK_SLOT_START && slot < BUYBACK_SLOT_END)
    {
        Item* pItem = m_items[slot];
        if (pItem)
        {
            pItem->RemoveFromWorld();
            if (del)
                pItem->SetState(ITEM_REMOVED, this);
        }

        m_items[slot] = NULL;

        uint32 eslot = slot - BUYBACK_SLOT_START;
        SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), ObjectGuid::Empty);
        SetUInt32Value(PLAYER_FIELD_BUYBACK_PRICE + eslot, 0);
        SetUInt32Value(PLAYER_FIELD_BUYBACK_TIMESTAMP + eslot, 0);

        // if current backslot is filled set to now free slot
        if (m_items[m_currentBuybackSlot])
            m_currentBuybackSlot = slot;
    }
}

void Player::SendEquipError(InventoryResult msg, Item* pItem /*= nullptr*/, Item* pItem2 /*= nullptr*/, uint32 itemid /*= 0*/)
{
    WorldPackets::Item::InventoryChangeFailure failure;
    failure.BagResult = msg;

    if (msg != EQUIP_ERR_OK)
    {
        if (pItem)
            failure.Item[0] = pItem->GetGUID();

        if (pItem2)
            failure.Item[1] = pItem2->GetGUID();

        failure.ContainerBSlot = 0; 

        switch (msg)
        {
            case EQUIP_ERR_CANT_EQUIP_LEVEL_I:
            case EQUIP_ERR_PURCHASE_LEVEL_TOO_LOW:
                if (ItemTemplate const* proto = pItem ? pItem->GetTemplate() : sObjectMgr->GetItemTemplate(itemid))
                    failure.Level = pItem ? pItem->GetRequiredLevel() : proto->GetBaseRequiredLevel();
                break;
            case EQUIP_ERR_EVENT_AUTOEQUIP_BIND_CONFIRM:    // no idea about this one...
                //failure.SrcContainer
                //failure.SrcSlot
                //failure.DstContainer
                break;
            case EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_COUNT_EXCEEDED_IS:
            case EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_SOCKETED_EXCEEDED_IS:
            case EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED_IS:
                if (ItemTemplate const* proto = pItem ? pItem->GetTemplate() : sObjectMgr->GetItemTemplate(itemid))
                    failure.LimitCategory = proto->GetLimitCategory();
                break;
            default:
                break;
        }
    }

    SendDirectMessage(failure.Write());
}

void Player::SendBuyError(BuyResult msg, Creature* creature /*= nullptr*/, uint32 item /*= 0*/)
{
    WorldPackets::Item::BuyFailed packet;
    if (creature)
        packet.VendorGUID = creature->GetGUID();
    packet.Muid = item;
    packet.Reason = msg;
    SendDirectMessage(packet.Write());
}

void Player::SendSellError(SellResult msg, Creature* creature /*= nullptr*/, ObjectGuid guid /*= ObjectGuid::Emptry*/)
{
    WorldPackets::Item::SellResponse sellResponse;
    if (creature)
        sellResponse.VendorGUID = creature->GetGUID();
    sellResponse.ItemGUID = guid;
    sellResponse.Reason = msg;
    SendDirectMessage(sellResponse.Write());
}

void Player::TradeCancel(bool sendback)
{
    if (m_trade)
    {
        Player* trader = m_trade->GetTrader();

        // send yellow "Trade canceled" message to both traders
        if (sendback)
            GetSession()->SendCancelTrade();

        trader->GetSession()->SendCancelTrade();

        // cleanup
        delete m_trade;
        m_trade = NULL;
        delete trader->m_trade;
        trader->m_trade = NULL;
    }
}

void Player::RecalculatePvPAmountOfAuras()
{
    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
    {
        if (Aura* aura = iter->second->GetBase())
        {
            if (aura->IsRemoved())
                continue;

            if (SpellInfo const* spellInfo = aura->GetSpellInfo())
            {
                for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
                {
                    if (spellInfo->EffectMask < uint32(1 << i))
                        break;

                    if (spellInfo->Effects[i]->PvPMultiplier && spellInfo->Effects[i]->PvPMultiplier != 1.f)
                    {
                        if (AuraEffect* eff = aura->GetEffect(i))
                        {
                            eff->SetCanBeRecalculated(true);
                            eff->RecalculateAmount(this);
                        }
                    }
                }
            }
        }

        ++iter;
    }
}

void Player::RecalculateAmountAllAuras()
{
    for (AuraApplicationMap::iterator iter = m_appliedAuras.begin(); iter != m_appliedAuras.end();)
    {
        if (Aura* aura = iter->second->GetBase())
        {
            if (aura->IsRemoved())
                continue;

            if (SpellInfo const* spellInfo = aura->GetSpellInfo())
            {
                for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
                {
                    if (spellInfo->EffectMask < uint32(1 << i))
                        break;

                    if (AuraEffect* eff = aura->GetEffect(i))
                    {
                        eff->SetCanBeRecalculated(true);
                        eff->RecalculateAmount(this);
                    }
                }
            }
        }

        ++iter;
    }
}

void Player::UpdateSoulboundTradeItems()
{
    if (m_itemSoulboundTradeable.empty())
        return;

    // also checks for garbage data
    for (GuidSet::iterator itr = m_itemSoulboundTradeable.begin(); itr != m_itemSoulboundTradeable.end();)
    {
        Item* item = GetItemByGuid(*itr);
        if (!item || item->GetOwnerGUID() != GetGUID() || item->CheckSoulboundTradeExpire())
            itr = m_itemSoulboundTradeable.erase(itr);
        else
            ++itr;
    }
}

void Player::AddTradeableItem(Item* item)
{
    m_itemSoulboundTradeable.insert(item->GetGUID());
}

//TODO: should never allow an item to be added to m_itemSoulboundTradeable twice
void Player::RemoveTradeableItem(Item* item)
{
    m_itemSoulboundTradeable.erase(item->GetGUID());
}

void Player::UpdateItemDuration(uint32 time, bool realtimeonly)
{
    if (m_itemDuration.empty())
        return;

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "Player::UpdateItemDuration(time %u, realtimeonly %u)", time, realtimeonly);

    for (ItemDurationList::const_iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end();)
    {
        Item* item = *itr;
        ++itr;                                              // current element can be erased in UpdateDuration

        if (!realtimeonly || item->GetTemplate()->GetFlags() & ITEM_FLAG_REAL_DURATION)
            item->UpdateDuration(this, time);
    }
}

void Player::UpdateEnchantTime(uint32 time)
{
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(), next; itr != m_enchantDuration.end(); itr=next)
    {
        ASSERT(itr->item);
        next = itr;
        if (!itr->item->GetEnchantmentId(itr->slot))
        {
            next = m_enchantDuration.erase(itr);
        }
        else if (itr->leftduration <= time)
        {
            ApplyEnchantment(itr->item, itr->slot, false, false);
            itr->item->ClearEnchantment(itr->slot);
            next = m_enchantDuration.erase(itr);
        }
        else if (itr->leftduration > time)
        {
            itr->leftduration -= time;
            ++next;
        }
    }
}

void Player::AddEnchantmentDurations(Item* item)
{
    for (int x = 0; x < MAX_ENCHANTMENT_SLOT; ++x)
    {
        if (!item->GetEnchantmentId(EnchantmentSlot(x)))
            continue;

        uint32 duration = item->GetEnchantmentDuration(EnchantmentSlot(x));
        if (duration > 0)
            AddEnchantmentDuration(item, EnchantmentSlot(x), duration);
    }
}

void Player::RemoveEnchantmentDurations(Item* item)
{
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end();)
    {
        if (itr->item == item)
        {
            // save duration in item
            item->SetEnchantmentDuration(EnchantmentSlot(itr->slot), itr->leftduration, this);
            itr = m_enchantDuration.erase(itr);
        }
        else
            ++itr;
    }
}

void Player::RemoveArenaEnchantments(EnchantmentSlot slot)
{
    // remove enchantments from equipped items first to clean up the m_enchantDuration list
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(), next; itr != m_enchantDuration.end(); itr = next)
    {
        next = itr;
        if (itr->slot == slot)
        {
            if (itr->item && itr->item->GetEnchantmentId(slot))
            {
                // Poisons and DK runes are enchants which are allowed on arenas
                if (sSpellMgr->IsArenaAllowedEnchancment(itr->item->GetEnchantmentId(slot)))
                {
                    ++next;
                    continue;
                }
                // remove from stats
                ApplyEnchantment(itr->item, slot, false, false);
                // remove visual
                itr->item->ClearEnchantment(slot);
            }
            // remove from update list
            next = m_enchantDuration.erase(itr);
        }
        else
            ++next;
    }

    // remove enchants from inventory items
    // NOTE: no need to remove these from stats, since these aren't equipped
    // in inventory
    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); ++i)
        if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            if (pItem->GetEnchantmentId(slot))
                pItem->ClearEnchantment(slot);

    // in inventory bags
    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        if (Bag* pBag = GetBagByPos(i))
            for (uint32 j = 0; j < pBag->GetBagSize(); j++)
                if (Item* pItem = pBag->GetItemByPos(j))
                    if (pItem->GetEnchantmentId(slot))
                        pItem->ClearEnchantment(slot);
}

// duration == 0 will remove item enchant
void Player::AddEnchantmentDuration(Item* item, EnchantmentSlot slot, uint32 duration)
{
    if (!item)
        return;

    if (slot >= MAX_ENCHANTMENT_SLOT)
        return;

    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
    {
        if (itr->item == item && itr->slot == slot)
        {
            itr->item->SetEnchantmentDuration(itr->slot, itr->leftduration, this);
            m_enchantDuration.erase(itr);
            break;
        }
    }
    if (item && duration > 0)
    {
        Item::SendItemEnchantTimeUpdate(this, item->GetGUID(), slot, uint32(duration/1000));
        m_enchantDuration.push_back(EnchantDuration(item, slot, duration));
    }
}

void Player::ApplyEnchantment(Item* item, bool apply)
{
    for (uint32 slot = 0; slot < MAX_ENCHANTMENT_SLOT; ++slot)
        ApplyEnchantment(item, EnchantmentSlot(slot), apply);
}

void Player::ApplyEnchantment(Item* item, EnchantmentSlot slot, bool apply, bool apply_dur, bool ignore_condition)
{
    if (!item || !item->IsEquipped())
        return;

    if (slot >= MAX_ENCHANTMENT_SLOT)
        return;

    uint32 enchant_id = item->GetEnchantmentId(slot);
    if (!enchant_id)
        return;

    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
    if (!pEnchant)
        return;

    if (!ignore_condition && pEnchant->ConditionID && !EnchantmentFitsRequirements(pEnchant->ConditionID, -1))
        return;

    if (pEnchant->MinLevel > getLevel())
        return;

    if (pEnchant->RequiredSkillID > 0 && pEnchant->RequiredSkillRank > GetSkillValue(pEnchant->RequiredSkillID))
        return;

    if ((slot == SOCK_ENCHANTMENT_SLOT || slot == SOCK_ENCHANTMENT_SLOT_2 || slot == SOCK_ENCHANTMENT_SLOT_3))
    {
        if (!item->GetSocketColor(slot - SOCK_ENCHANTMENT_SLOT))
        {
            SpellItemEnchantmentEntry const* pPrismaticEnchant = sSpellItemEnchantmentStore.LookupEntry(item->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));
            if (!pPrismaticEnchant || (pPrismaticEnchant->RequiredSkillID > 0 && pPrismaticEnchant->RequiredSkillRank > GetSkillValue(pPrismaticEnchant->RequiredSkillID)))
                return;
        }

        if (ItemDynamicFieldGems const* gem = item->GetGem(uint16(slot - SOCK_ENCHANTMENT_SLOT)))
            if (ItemTemplate const* gemTemplate = sObjectMgr->GetItemTemplate(gem->ItemId))
                if (gemTemplate->GetRequiredSkill() && GetSkillValue(gemTemplate->GetRequiredSkill()) < gemTemplate->GetRequiredSkillRank())
                    return;
    }

    if (!item->CantBeUse())
    {
        for (int s = 0; s < MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
        {
            uint32 enchant_display_type = pEnchant->Effect[s];
            uint16 enchant_amount = pEnchant->EffectPointsMin[s];
            uint32 enchant_spell_id = pEnchant->EffectArg[s];

            switch (enchant_display_type)
            {
                case ITEM_ENCHANTMENT_TYPE_NONE:
                    break;
                case ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL:
                    // processed in Player::CastItemCombatSpell
                    break;
                case ITEM_ENCHANTMENT_TYPE_DAMAGE:
                    if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND && (
                        item->GetTemplate()->GetInventoryType() == INVTYPE_RANGED || item->GetTemplate()->GetInventoryType() == INVTYPE_THROWN ||
                        item->GetTemplate()->GetInventoryType() == INVTYPE_RANGEDRIGHT))
                        HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
                    else if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
                        HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, float(enchant_amount), apply);
                    else if (item->GetSlot() == EQUIPMENT_SLOT_OFFHAND)
                        HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, float(enchant_amount), apply);
                    break;
                case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
                {
                    if (enchant_spell_id)
                    {
                        if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(enchant_spell_id))
                        {
                            if (apply && (!HasPvpStatsScalingEnabled() || spellInfo->HasAttribute(SPELL_ATTR2_PRESERVE_ENCHANT_IN_ARENA)))
                            {
                                float basepoints = 0;
                                // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
                                if (item->GetItemRandomPropertyId() < 0)
                                {
                                    ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
                                    if (item_rand)
                                    {
                                        // Search enchant_amount
                                        for (int k = 0; k < MAX_ITEM_ENCHANTS; ++k)
                                        {
                                            if (item_rand->Enchantment[k] == enchant_id)
                                            {
                                                basepoints = int32((item_rand->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
                                                break;
                                            }
                                        }
                                    }
                                }
                                // Cast custom spell vs all equal basepoints got from enchant_amount
                                if (basepoints)
                                    CastCustomSpell(this, enchant_spell_id, &basepoints, &basepoints, &basepoints, true, item);
                                else
                                    CastSpell(this, enchant_spell_id, true, item);
                            }
                            else
                                RemoveAurasDueToItemSpell(item, enchant_spell_id);
                        }
                    }
                    break;
                }
                case ITEM_ENCHANTMENT_TYPE_RESISTANCE:

                    if (pEnchant->ScalingClass)
                    {
                        int32 scalingClass = pEnchant->ScalingClass;
                        if ((GetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL) || GetUInt32Value(UNIT_FIELD_MAX_ITEM_LEVEL)) && pEnchant->ScalingClassRestricted)
                            scalingClass = pEnchant->ScalingClassRestricted;

                        uint8 minLevel = pEnchant->Flags & 0x20 ? 1 : 60;
                        uint8 scalingLevel = GetEffectiveLevel();
                        uint8 maxLevel = uint8(pEnchant->MaxLevel ? pEnchant->MaxLevel : sSpellScalingGameTable.GetTableRowCount() - 1);

                        if (minLevel > GetEffectiveLevel())
                            scalingLevel = minLevel;
                        else if (maxLevel < GetEffectiveLevel())
                            scalingLevel = maxLevel;

                        if (GtSpellScalingEntry const* spellScaling = sSpellScalingGameTable.GetRow(scalingLevel))
                            enchant_amount = uint32(pEnchant->EffectScalingPoints[s] * GetSpellScalingColumnForClass(spellScaling, scalingClass));
                    }

                    if (!enchant_amount)
                        if (ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId())))
                            for (int k = 0; k < MAX_ITEM_ENCHANTS; ++k)
                            {
                                if (item_rand->Enchantment[k] == enchant_id)
                                {
                                    enchant_amount = uint32((item_rand->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
                                    break;
                                }
                            }

                    HandleStatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + enchant_spell_id), TOTAL_VALUE, float(enchant_amount), apply);
                    break;
                case ITEM_ENCHANTMENT_TYPE_STAT:
                {
                    if (pEnchant->ScalingClass)
                    {
                        int32 scalingClass = pEnchant->ScalingClass;
                        if ((GetUInt32Value(UNIT_FIELD_MIN_ITEM_LEVEL) || GetUInt32Value(UNIT_FIELD_MAX_ITEM_LEVEL)) && pEnchant->ScalingClassRestricted)
                            scalingClass = pEnchant->ScalingClassRestricted;

                        uint8 minLevel = pEnchant->Flags & 0x20 ? 1 : 60;
                        uint8 scalingLevel = GetEffectiveLevel();
                        uint8 maxLevel = uint8(pEnchant->MaxLevel ? pEnchant->MaxLevel : sSpellScalingGameTable.GetTableRowCount());

                        if (minLevel > GetEffectiveLevel())
                            scalingLevel = minLevel;
                        else if (maxLevel < GetEffectiveLevel())
                            scalingLevel = maxLevel;

                        if (GtSpellScalingEntry const* spellScaling = sSpellScalingGameTable.GetRow(scalingLevel))
                            enchant_amount = uint32(pEnchant->EffectScalingPoints[s] * GetSpellScalingColumnForClass(spellScaling, scalingClass));
                    }

                    if (!enchant_amount)
                        if (ItemRandomSuffixEntry const* item_rand_suffix = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId())))
                            for (int k = 0; k < MAX_ITEM_ENCHANTS; ++k)
                            {
                                if (item_rand_suffix->Enchantment[k] == enchant_id)
                                {
                                    enchant_amount = uint32((item_rand_suffix->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
                                    break;
                                }
                            }

                    TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "Adding %u to stat nb %u", enchant_amount, enchant_spell_id);
                    switch (enchant_spell_id)
                    {
                        case ITEM_MOD_MANA:
                            HandleStatModifier(UNIT_MOD_MANA, BASE_VALUE, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_HEALTH:
                            HandleStatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_AGILITY:
                            HandleStatModifier(UNIT_MOD_STAT_AGILITY, BASE_VALUE, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_STRENGTH:
                            HandleStatModifier(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_INTELLECT:
                            HandleStatModifier(UNIT_MOD_STAT_INTELLECT, BASE_VALUE, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_SPIRIT:
                            break;
                        case ITEM_MOD_STAMINA:
                            HandleStatModifier(UNIT_MOD_STAT_STAMINA, BASE_VALUE, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_DEFENSE_SKILL_RATING:
                            ApplyRatingMod(CR_DEFENSE_SKILL, enchant_amount, apply);
                            break;
                        case  ITEM_MOD_DODGE_RATING:
                            ApplyRatingMod(CR_DODGE, enchant_amount, apply);
                            break;
                        case ITEM_MOD_PARRY_RATING:
                            ApplyRatingMod(CR_PARRY, enchant_amount, apply);
                            break;
                        case ITEM_MOD_BLOCK_RATING:
                            ApplyRatingMod(CR_BLOCK, enchant_amount, apply);
                            break;
                        case ITEM_MOD_HIT_MELEE_RATING:
                            ApplyRatingMod(CR_HIT_MELEE, enchant_amount, apply);
                            break;
                        case ITEM_MOD_HIT_RANGED_RATING:
                            ApplyRatingMod(CR_HIT_RANGED, enchant_amount, apply);
                            break;
                        case ITEM_MOD_HIT_SPELL_RATING:
                            ApplyRatingMod(CR_HIT_SPELL, enchant_amount, apply);
                            break;
                        case ITEM_MOD_CRIT_MELEE_RATING:
                            ApplyRatingMod(CR_CRIT_MELEE, enchant_amount, apply);
                            break;
                        case ITEM_MOD_CRIT_RANGED_RATING:
                            ApplyRatingMod(CR_CRIT_RANGED, enchant_amount, apply);
                            break;
                        case ITEM_MOD_CRIT_SPELL_RATING:
                            ApplyRatingMod(CR_CRIT_SPELL, enchant_amount, apply);
                            break;
                        case ITEM_MOD_HASTE_SPELL_RATING:
                            ApplyRatingMod(CR_HASTE_SPELL, enchant_amount, apply);
                            break;
                        case ITEM_MOD_HIT_RATING:
                            ApplyRatingMod(CR_HIT_MELEE, enchant_amount, apply);
                            ApplyRatingMod(CR_HIT_RANGED, enchant_amount, apply);
                            ApplyRatingMod(CR_HIT_SPELL, enchant_amount, apply);
                            break;
                        case ITEM_MOD_CRIT_RATING:
                            ApplyRatingMod(CR_CRIT_MELEE, enchant_amount, apply);
                            ApplyRatingMod(CR_CRIT_RANGED, enchant_amount, apply);
                            ApplyRatingMod(CR_CRIT_SPELL, enchant_amount, apply);
                            break;
                        case ITEM_MOD_RESILIENCE_RATING:
                            ApplyRatingMod(CR_RESILIENCE_PLAYER_DAMAGE, enchant_amount, apply);
                            break;
                        case ITEM_MOD_HASTE_RATING:
                            ApplyRatingMod(CR_HASTE_MELEE, enchant_amount, apply);
                            ApplyRatingMod(CR_HASTE_RANGED, enchant_amount, apply);
                            ApplyRatingMod(CR_HASTE_SPELL, enchant_amount, apply);
                            break;
                        case ITEM_MOD_EXPERTISE_RATING:
                            ApplyRatingMod(CR_EXPERTISE, enchant_amount, apply);
                            break;
                        case ITEM_MOD_ATTACK_POWER:
                            HandleStatModifier(UNIT_MOD_ATTACK_POWER, TOTAL_VALUE, float(enchant_amount), apply);
                            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_RANGED_ATTACK_POWER:
                            HandleStatModifier(UNIT_MOD_ATTACK_POWER_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_MANA_REGENERATION:
                            ApplyManaRegenBonus(enchant_amount, apply);
                            break;
                        case ITEM_MOD_SPELL_POWER:
                            ApplySpellPowerBonus(enchant_amount, apply);
                            break;
                        case ITEM_MOD_HEALTH_REGEN:
                            ApplyHealthRegenBonus(enchant_amount, apply);
                            break;
                        case ITEM_MOD_SPELL_PENETRATION:
                            ApplyModInt32Value(PLAYER_FIELD_MOD_TARGET_RESISTANCE, enchant_amount, apply);
                            m_spellPenetrationItemMod += apply ? int32(enchant_amount) : -int32(enchant_amount);
                            break;
                        case ITEM_MOD_BLOCK_VALUE:
                            HandleBaseModValue(SHIELD_BLOCK_VALUE, FLAT_MOD, float(enchant_amount), apply);
                            break;
                        case ITEM_MOD_MASTERY_RATING:
                            ApplyRatingMod(CR_MASTERY, int32(enchant_amount), apply);
                            break;
                        case ITEM_MOD_VERSATILITY:
                            ApplyRatingMod(CR_VERSATILITY_DAMAGE_DONE, int32(enchant_amount), apply);
                            ApplyRatingMod(CR_VERSATILITY_DAMAGE_TAKEN, int32(enchant_amount), apply);
                            break;
                        case ITEM_MOD_CR_MULTISTRIKE:
                            ApplyRatingMod(CR_MULTISTRIKE, int32(enchant_amount), apply);
                            break;
                        case ITEM_MOD_CR_READINESS:
                            ApplyRatingMod(CR_READINESS, int32(enchant_amount), apply);
                            break;
                        case ITEM_MOD_CR_SPEED:
                            ApplyRatingMod(CR_SPEED, int32(enchant_amount), apply);
                            break;
                        case ITEM_MOD_CR_LIFESTEAL:
                            ApplyRatingMod(CR_LIFESTEAL, int32(enchant_amount), apply);
                            break;
                        case ITEM_MOD_CR_AVOIDANCE:
                            ApplyRatingMod(CR_AVOIDANCE, int32(enchant_amount), apply);
                            break;
                        case ITEM_MOD_CR_AMPLIFY: // items with this should not lose durability on player death - dynamic stat?
                        case ITEM_MOD_CR_STURDINESS:
                        case ITEM_MOD_CR_CLEAVE: // apply spellAura on player and modify value with this rating ( from UF )
                            break;
                        // deprecated
                        case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
                        case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
                        case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
                        case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
                        case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
                        case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
                        case ITEM_MOD_HASTE_MELEE_RATING:
                        case ITEM_MOD_HASTE_RANGED_RATING:
                        case ITEM_MOD_PVP_POWER:
                        case ITEM_MOD_HIT_TAKEN_RATING:
                        case ITEM_MOD_CRIT_TAKEN_RATING:
                            break;
                        default:
                            break;
                    }
                    break;
                }
                case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
                {
                    if (getClass() == CLASS_SHAMAN)
                    {
                        float addValue = 0.0f;
                        if (item->GetSlot() == EQUIPMENT_SLOT_MAINHAND)
                        {
                            addValue = float(enchant_amount * item->GetTemplate()->GetDelay() / 1000.0f);
                            HandleStatModifier(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_VALUE, addValue, apply);
                        }
                        else if (item->GetSlot() == EQUIPMENT_SLOT_OFFHAND)
                        {
                            addValue = float(enchant_amount * item->GetTemplate()->GetDelay() / 1000.0f);
                            HandleStatModifier(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_VALUE, addValue, apply);
                        }
                    }
                    break;
                }
                case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
                    // processed in Player::CastItemUseSpell
                    break;
                case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
                    // nothing do..
                    break;
                default:
                    TC_LOG_ERROR(LOG_FILTER_PLAYER, "Unknown item enchantment (id = %d) display type: %d", enchant_id, enchant_display_type);
                    break;
            }                                               /*switch (enchant_display_type)*/
        }                                                   /*for*/
    }

    // visualize enchantment at player and equipped items
    if (slot == PERM_ENCHANTMENT_SLOT)
        SetUInt16Value(PLAYER_FIELD_VISIBLE_ITEMS + VISIBLE_ITEM_ENCHANTMENT_OFFSET + (item->GetSlot() * 2), 1, item->GetVisibleItemVisual(this));

    if (apply_dur)
    {
        if (apply)
        {
            // set duration
            uint32 duration = item->GetEnchantmentDuration(slot);
            if (duration > 0)
                AddEnchantmentDuration(item, slot, duration);
        }
        else
        {
            // duration == 0 will remove EnchantDuration
            AddEnchantmentDuration(item, slot, 0);
        }
    }
}

void Player::UpdateSkillEnchantments(uint16 skill_id, uint16 curr_value, uint16 new_value)
{
    for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (m_items[i])
        {
            for (uint8 slot = 0; slot < MAX_ENCHANTMENT_SLOT; ++slot)
            {
                uint32 ench_id = m_items[i]->GetEnchantmentId(EnchantmentSlot(slot));
                if (!ench_id)
                    continue;

                SpellItemEnchantmentEntry const* Enchant = sSpellItemEnchantmentStore.LookupEntry(ench_id);
                if (!Enchant)
                    return;

                if (Enchant->RequiredSkillID == skill_id)
                {
                    // Checks if the enchantment needs to be applied or removed
                    if (curr_value < Enchant->RequiredSkillRank && new_value >= Enchant->RequiredSkillRank)
                        ApplyEnchantment(m_items[i], EnchantmentSlot(slot), true);
                    else if (new_value < Enchant->RequiredSkillRank && curr_value >= Enchant->RequiredSkillRank)
                        ApplyEnchantment(m_items[i], EnchantmentSlot(slot), false);
                }

                // If we're dealing with a gem inside a prismatic socket we need to check the prismatic socket requirements
                // rather than the gem requirements itself. If the socket has no color it is a prismatic socket.
                if ((slot == SOCK_ENCHANTMENT_SLOT || slot == SOCK_ENCHANTMENT_SLOT_2 || slot == SOCK_ENCHANTMENT_SLOT_3)
                    && !m_items[i]->GetTemplate()->GetSocketType(slot-SOCK_ENCHANTMENT_SLOT))
                {
                    SpellItemEnchantmentEntry const* pPrismaticEnchant = sSpellItemEnchantmentStore.LookupEntry(m_items[i]->GetEnchantmentId(PRISMATIC_ENCHANTMENT_SLOT));

                    if (pPrismaticEnchant && pPrismaticEnchant->RequiredSkillID == skill_id)
                    {
                        if (curr_value < pPrismaticEnchant->RequiredSkillRank && new_value >= pPrismaticEnchant->RequiredSkillRank)
                            ApplyEnchantment(m_items[i], EnchantmentSlot(slot), true);
                        else if (new_value < pPrismaticEnchant->RequiredSkillRank && curr_value >= pPrismaticEnchant->RequiredSkillRank)
                            ApplyEnchantment(m_items[i], EnchantmentSlot(slot), false);
                    }
                }
            }
        }
    }
}

void Player::SendEnchantmentDurations()
{
    for (auto const& x : m_enchantDuration)
        x.item->SendItemEnchantTimeUpdate(this, x.item->GetGUID(), x.slot, x.leftduration / 1000);
}

void Player::SendItemDurations()
{
    for (ItemDurationList::const_iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end(); ++itr)
        (*itr)->SendTimeUpdate(this);
}

void Player::SendNewItem(Item* item, uint32 count, bool received, bool created, bool broadcast /*= false*/, bool bonusRoll /*= false*/)
{
    if (!item)                                               // prevent crash
        return;

    WorldPackets::Item::ItemPushResult packet;
    packet.PlayerGUID = GetGUID();
    packet.ItemGUID = item->GetGUID();

    packet.Slot = item->GetBagSlot();
    packet.SlotInBag = (item->GetCount() == count) ? item->GetSlot() : -1;
    packet.Item.Initialize(item);

    packet.QuestLogItemID = 0;
    packet.DungeonEncounterID = item->dungeonEncounterID;
    packet.Quantity = count;
    packet.DisplayText = !item->dungeonEncounterID ? WorldPackets::Item::ItemPushResult::DisplayType::NORMAL : WorldPackets::Item::ItemPushResult::DisplayType::ENCOUNTER_LOOT;
    packet.QuantityInInventory = GetItemCount(item->GetEntry());
    packet.BattlePetBreedID = item->GetModifier(ITEM_MODIFIER_BATTLE_PET_BREED_DATA) & 0xFFFFFF;
    packet.BattlePetBreedQuality = (item->GetModifier(ITEM_MODIFIER_BATTLE_PET_BREED_DATA) >> 24) & 0xFF;
    packet.BattlePetSpeciesID = item->GetModifier(ITEM_MODIFIER_BATTLE_PET_SPECIES_ID);
    packet.BattlePetLevel = item->GetModifier(ITEM_MODIFIER_BATTLE_PET_LEVEL);
    packet.Pushed = received;
    packet.IsEncounterLoot = item->dungeonEncounterID; // TODO: this only for personal loot - trigger event ENCOUNTER_LOOT_RECEIVED, send toast list of looted all party/raid members
    packet.Created = created;
    packet.IsBonusRoll = bonusRoll;

    if (broadcast && GetGroup())
        GetGroup()->BroadcastPacket(packet.Write(), true);
    else
        SendDirectMessage(packet.Write());
    
    if (item->GetEntry() == 139178) // scenario for rogue
        CastSpell(this, 218892);
    if (item->GetEntry() == 136802)
        UpdateAchievementCriteria(CRITERIA_TYPE_SCRIPT_EVENT_2, 54824);
}

/*********************************************************/
/***                    GOSSIP SYSTEM                  ***/
/*********************************************************/

void Player::PrepareGossipMenu(WorldObject* source, uint32 menuId /*= 0*/, bool showQuests /*= false*/)
{
    PlayerMenu* menu = PlayerTalkClass;
    menu->ClearMenus();

    menu->GetGossipMenu().SetMenuId(menuId);

    auto menuItemBounds = sGossipDataStore->GetGossipMenuItemsMapBounds(menuId);

    // if default menuId and no menu options exist for this, use options from default options
    if (menuItemBounds.first == menuItemBounds.second && menuId == GetDefaultGossipMenuForSource(source))
        menuItemBounds = sGossipDataStore->GetGossipMenuItemsMapBounds(0);

    uint32 npcflags = 0;
    uint32 npcflags2 = 0;
    if (source->IsCreature())
    {
        npcflags = source->GetUInt32Value(UNIT_FIELD_NPC_FLAGS);
        npcflags2 = source->GetUInt32Value(UNIT_FIELD_NPC_FLAGS2);

        if (npcflags & UNIT_NPC_FLAG_QUESTGIVER && showQuests)
            PrepareQuestMenu(source->GetGUID());
    }

    if (source->IsGameObject())
        if (source->ToGameObject()->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
            PrepareQuestMenu(source->GetGUID());

    for (auto itr = menuItemBounds.first; itr != menuItemBounds.second; ++itr)
    {
        bool canTalk = true;
        if (!sConditionMgr->IsObjectMeetToConditions(this, source, itr->second.Conditions))
            continue;

        if (Creature* creature = source->ToCreature())
        {
            if (!(itr->second.OptionNpcflag & npcflags))
                continue;

            if (itr->second.OptionNpcflag2 && !(itr->second.OptionNpcflag2 & npcflags2))
                continue;
            switch (itr->second.OptionType)
            {
                case GOSSIP_OPTION_ARMORER:
                    canTalk = false;                       // added in special mode
                    break;
                case GOSSIP_OPTION_SPIRITHEALER:
                    if (!isDead())
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_VENDOR:
                {
                    VendorItemData const* vendorItems = creature->GetVendorItems();
                    if (!vendorItems || vendorItems->Empty())
                    {
                        TC_LOG_ERROR(LOG_FILTER_SQL, "Creature %u (Entry: %u) have UNIT_NPC_FLAG_VENDOR but have empty trading item list.", creature->GetGUIDLow(), creature->GetEntry());
                        canTalk = false;
                    }
                    break;
                }
                case GOSSIP_OPTION_TRAINER:
                    if (!creature->isCanTrainingOf(this, false))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_UNLEARNTALENTS:
                    if (!creature->isCanTrainingAndResetTalentsOf(this))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_TAXIVENDOR:
                    if (GetSession()->SendLearnNewTaxiNode(creature))
                        return;
                    break;
                case GOSSIP_OPTION_BATTLEFIELD:
                    if (!creature->isCanInteractWithBattleMaster(this, false))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_STABLEPET:
                    if (getClass() != CLASS_HUNTER)
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_QUESTGIVER:
                    canTalk = false;
                    break;
                case GOSSIP_OPTION_GOSSIP:
                case GOSSIP_OPTION_SPIRITGUIDE:
                case GOSSIP_OPTION_INNKEEPER:
                case GOSSIP_OPTION_BANKER:
                case GOSSIP_OPTION_PETITIONER:
                case GOSSIP_OPTION_TABARDDESIGNER:
                case GOSSIP_OPTION_AUCTIONEER:
                case GOSSIP_OPTION_SCENARIO:
                case GOSSIP_OPTION_TRANSMOGRIFIER:
                case GOSSIP_OPTION_MAILBOX:
                    break;                                  // no checks
                case GOSSIP_OPTION_OUTDOORPVP:
                    if (!sOutdoorPvPMgr->CanTalkTo(this, creature, itr->second))
                        canTalk = false;
                    break;
                case GOSSIP_OPTION_GARRISON_SHIPMENT:
                    canTalk = false;
                    if (Garrison* garr = GetGarrisonPtr())
                        canTalk = garr->canAddShipmentOrder(creature);
                    break;
                case GOSSIP_OPTION_GARRISON_TRADESKILL:
                    canTalk = creature->HasFlag(UNIT_FIELD_NPC_FLAGS2, UNIT_NPC_FLAG2_TRADESKILL_NPC);
                    break;
                //! ToDo
                case GOSSIP_OPTION_SHIPMENT_CRAFTER:
                case GOSSIP_OPTION_CHOICE:
                case GOSSIP_OPTION_ALLIED_RACE_DETAILS:
                     canTalk = true;
                    break;
                case GOSSIP_OPTION_ARTIFACT_RESPEC:
                    if (GetArtifactWeapon())
                        canTalk = true;
                    break;
                //! ToDo
                case GOSSIP_OPTION_CLASS_HALL_UPGRADE:
                    canTalk = false;
                    if (_garrison)
                        canTalk = _garrison->canStartUpgrade();
                    break;
                default:
                    TC_LOG_ERROR(LOG_FILTER_SQL, "Creature entry %u have unknown gossip option %u for menu %u", creature->GetEntry(), itr->second.OptionType, itr->second.MenuID);
                    canTalk = false;
                    break;
            }
        }
        else if (GameObject* go = source->ToGameObject())
        {
            switch (itr->second.OptionType)
            {
                case GOSSIP_OPTION_GOSSIP:
                case GOSSIP_OPTION_SCENARIO:
                    if (go->GetGoType() != GAMEOBJECT_TYPE_QUESTGIVER && go->GetGoType() != GAMEOBJECT_TYPE_GOOBER)
                        canTalk = false;
                    break;
                default:
                    canTalk = false;
                    break;
            }
        }

        if (canTalk)
        {
            std::string strOptionText = itr->second.OptionText;
            std::string strBoxText = itr->second.BoxText;

            LocaleConstant localeConstant = GetSession()->GetSessionDbLocaleIndex();
            if (BroadcastTextEntry const* optionBroadcastText = sBroadcastTextStore.LookupEntry(itr->second.OptionBroadcastTextID))
            {
                if (sConditionMgr->IsPlayerMeetingCondition(this, optionBroadcastText->ConditionID))
                    strOptionText = DB2Manager::GetBroadcastTextValue(optionBroadcastText, localeConstant, getGender());
            }
            else if (GossipMenuItemsLocale const* gossipMenuLocale = sGossipDataStore->GetGossipMenuItemsLocale(MAKE_PAIR32(menuId, itr->second.OptionIndex)))
                ObjectMgr::GetLocaleString(gossipMenuLocale->OptionText, localeConstant, strOptionText);

            if (BroadcastTextEntry const* boxBroadcastText = sBroadcastTextStore.LookupEntry(itr->second.BoxBroadcastTextID))
            {
                if (sConditionMgr->IsPlayerMeetingCondition(this, boxBroadcastText->ConditionID))
                    strBoxText = DB2Manager::GetBroadcastTextValue(boxBroadcastText, localeConstant, getGender());
            }
            else if (GossipMenuItemsLocale const* gossipMenuLocale = sGossipDataStore->GetGossipMenuItemsLocale(MAKE_PAIR32(menuId, itr->second.OptionIndex)))
                ObjectMgr::GetLocaleString(gossipMenuLocale->BoxText, localeConstant, strBoxText);

            menu->GetGossipMenu().AddMenuItem(itr->second.OptionIndex, itr->second.OptionNPC, strOptionText, 0, itr->second.OptionType, strBoxText, itr->second.BoxMoney, itr->second.BoxCurrency, itr->second.BoxCoded);
            menu->GetGossipMenu().AddGossipMenuItemData(itr->second.OptionIndex, itr->second.ActionMenuID, itr->second.ActionPoiID);
        }
    }
}

void Player::SendPreparedGossip(WorldObject* source)
{
    if (!source)
        return;

    if (source->IsCreature())
    {
        // in case no gossip flag and quest menu not empty, open quest menu (client expect gossip menu with this flag)
        if (!source->ToCreature()->HasFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP) && !PlayerTalkClass->GetQuestMenu().Empty())
        {
            SendPreparedQuest(source->GetGUID());
            return;
        }
    }
    else if (source->IsGameObject())
    {
        // probably need to find a better way here
        if (!PlayerTalkClass->GetGossipMenu().GetMenuId() && !PlayerTalkClass->GetQuestMenu().Empty())
        {
            SendPreparedQuest(source->GetGUID());
            return;
        }
    }

    // in case non empty gossip menu (that not included quests list size) show it
    // (quest entries from quest menu will be included in list)

    uint32 textId = GetGossipTextId(source);

    if (uint32 menuId = PlayerTalkClass->GetGossipMenu().GetMenuId())
        textId = GetGossipTextId(menuId, source);

    uint32 friendshipFactionID = 0;
    if (uint32 menuId = PlayerTalkClass->GetGossipMenu().GetMenuId())
        friendshipFactionID = GetGossipFriendshipFactionID(menuId, source);
    
    PlayerTalkClass->SendGossipMenu(textId, source->GetGUID(), friendshipFactionID);
}

void Player::OnGossipSelect(WorldObject* source, uint32 gossipListId, uint32 menuId)
{
    GossipMenu& gossipMenu = PlayerTalkClass->GetGossipMenu();

    // if not same, then something funky is going on
    if (menuId != gossipMenu.GetMenuId())
        return;

    GossipMenuItem const* item = gossipMenu.GetItem(gossipListId);
    if (!item)
        return;
    uint32 gossipHandlerType = item->OptionType;
    ObjectGuid guid = source->GetGUID();

    if (source->IsGameObject())
    {
        if (gossipHandlerType > GOSSIP_OPTION_QUESTGIVER && gossipHandlerType != GOSSIP_OPTION_SCENARIO)
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player guid %u request invalid gossip option for GameObject entry %u", GetGUIDLow(), source->GetEntry());
            return;
        }
    }

    GossipMenuItemData const* menuItemData = gossipMenu.GetItemData(gossipListId);
    if (!menuItemData)
        return;

    int32 cost = int32(item->BoxMoney);
    int32 currencyID = int32(item->BoxCurrency);
    if (currencyID)
    {
        if (!HasCurrency(currencyID, cost))
        {
            SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY);
            PlayerTalkClass->SendCloseGossip();
            return;
        }
    }
    else if (!HasEnoughMoney(int64(cost)))
    {
        SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY);
        PlayerTalkClass->SendCloseGossip();
        return;
    }

    switch (gossipHandlerType)
    {
        case GOSSIP_OPTION_GOSSIP:
        {
            // hack ArmyTraining
            if (menuItemData->GossipActionMenuId == 20187)
            {
                if (GetQuestStatus(44636) == QUEST_STATUS_INCOMPLETE) // first time
                {
                    KilledMonsterCredit(114524);
                    armyTrainingInfo.buyedNowUnits = 8;
                    TeleportTo(1626, 2087.56f, 5399.13f, 47.36f, 5.99f);
                    break;
                }
            }
            else if (menuId == 20187)
            {
                if (GetQuestStatus(43943) != QUEST_STATUS_INCOMPLETE)
                    return;

                KilledMonsterCredit(111948);
                armyTrainingInfo.buyedNowUnits = menuItemData->GossipActionMenuId;
                TeleportTo(1626, 2087.56f, 5399.13f, 47.36f, 5.99f);
                break;
            }

            if (menuItemData->GossipActionPoi)
                PlayerTalkClass->SendPointOfInterest(menuItemData->GossipActionPoi);

            if (menuItemData->GossipActionMenuId)
            {
                PrepareGossipMenu(source, menuItemData->GossipActionMenuId);
                SendPreparedGossip(source);
            }else
                PlayerTalkClass->SendCloseGossip();
            break;
        }
        case GOSSIP_OPTION_OUTDOORPVP:
            sOutdoorPvPMgr->HandleGossipOption(this, source->GetGUID(), gossipListId);
            break;
        case GOSSIP_OPTION_SPIRITHEALER:
            if (isDead())
                source->ToCreature()->CastSpell(source->ToCreature(), 17251, true, NULL, NULL, GetGUID());
            break;
        case GOSSIP_OPTION_QUESTGIVER:
            PrepareQuestMenu(guid);
            SendPreparedQuest(guid);
            break;
        case GOSSIP_OPTION_VENDOR:
        case GOSSIP_OPTION_ARMORER:
            GetSession()->SendListInventory(guid);
            break;
        case GOSSIP_OPTION_STABLEPET:
            GetSession()->SendStablePet(guid);
            break;
        case GOSSIP_OPTION_TRAINER:
            GetSession()->SendTrainerList(guid);
            break;
        case GOSSIP_OPTION_UNLEARNTALENTS:
            PlayerTalkClass->SendCloseGossip();
            SendTalentWipeConfirm(guid, RESPEC_TYPE_TALENTS);
            break;
        case GOSSIP_OPTION_TAXIVENDOR:
            GetSession()->SendTaxiMenu(source->ToCreature());
            break;
        case GOSSIP_OPTION_INNKEEPER:
            PlayerTalkClass->SendCloseGossip();
            SetBindPoint(guid);
            break;
        case GOSSIP_OPTION_BANKER:
            GetSession()->SendShowBank(guid);
            break;
        case GOSSIP_OPTION_PETITIONER:
            PlayerTalkClass->SendCloseGossip();
            GetSession()->SendPetitionShowList(guid);
            break;
        case GOSSIP_OPTION_TABARDDESIGNER:
            PlayerTalkClass->SendCloseGossip();
            GetSession()->SendTabardVendorActivate(guid);
            break;
        case GOSSIP_OPTION_AUCTIONEER:
            GetSession()->SendAuctionHello(guid, source->ToCreature());
            break;
        case GOSSIP_OPTION_SPIRITGUIDE:
            PrepareGossipMenu(source);
            SendPreparedGossip(source);
            break;
        case GOSSIP_OPTION_BATTLEFIELD:
        {
            uint16 bgTypeId = sBattlegroundMgr->GetBattleMasterBG(source->GetEntry());

            if (bgTypeId == MS::Battlegrounds::BattlegroundTypeId::None)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "a user (guid %u) requested battlegroundlist from a npc who is no battlemaster", GetGUIDLow());
                return;
            }

            sBattlegroundMgr->SendBattlegroundList(this, guid, bgTypeId);
            break;
        }
        case GOSSIP_OPTION_GARRISON_SHIPMENT:
            if (Garrison* garr = GetGarrisonPtr())
                garr->OnGossipSelect(source);
            break;
        case GOSSIP_OPTION_GARRISON_TRADESKILL:
            if (Garrison* garr = GetGarrisonPtr())
                garr->OnGossipTradeSkill(source);
            break;
        case GOSSIP_OPTION_SCENARIO:
        {
            std::set<uint32> ScenarioId;
            ScenarioId.insert(cost);
            sLFGMgr->JoinLfg(this, GetSpecializationRoleMaskForGroup(), ScenarioId);
            break;
        }
        case GOSSIP_OPTION_SHIPMENT_CRAFTER:
            //SMSG_ADVENTURE_JOURNAL_CLOSE
            //if (!getAdventureQuestID())
            {
                WorldPackets::NPC::ShowAdventureMap packet;
                packet.Guid = guid;
                SendDirectMessage(packet.Write());
            }
            break;
        case GOSSIP_OPTION_CLASS_HALL_UPGRADE:
        {
            WorldPackets::Garrison::GarrisonOpenUpgradeNpcResponse packet;
            packet.NpcGUID = guid;
            SendDirectMessage(packet.Write());
            break;
        }
        case GOSSIP_OPTION_CHOICE:
            SendDisplayPlayerChoice(GetGUID(), cost);
            return;
        case GOSSIP_OPTION_ARTIFACT_RESPEC:
        {
            if (Item* artifact = GetArtifactWeapon())
            {
                WorldPackets::Artifact::RespecResult packet;
                packet.ArtifactGUID = artifact->GetGUID();
                packet.NpcGUID = guid;
                SendDirectMessage(packet.Write());
            }
            break;
        }
        case GOSSIP_OPTION_TRANSMOGRIFIER:
            GetSession()->SendOpenTransmogrifier(guid);
            break;
        case GOSSIP_OPTION_MAILBOX:
            GetSession()->SendShowMailBox(guid);
            break;
        case GOSSIP_OPTION_ALLIED_RACE_DETAILS:
            GetSession()->SendOpenAlliedRaceDetails(guid, cost);
            return;
    }

    if (currencyID)
        ModifyCurrency(currencyID, -cost);
    else
        ModifyMoney(-cost);
}

uint32 Player::GetGossipTextId(WorldObject* source)
{
    if (!source)
        return DEFAULT_GOSSIP_MESSAGE;

    return GetGossipTextId(GetDefaultGossipMenuForSource(source), source);
}

uint32 Player::GetGossipTextId(uint32 menuId, WorldObject* source)
{
    uint32 textId = DEFAULT_GOSSIP_MESSAGE;
    if (!menuId)
        return textId;

    auto menuBounds = sGossipDataStore->GetGossipMenusMapBounds(menuId);
    for (auto itr = menuBounds.first; itr != menuBounds.second; ++itr)
        if (sConditionMgr->IsObjectMeetToConditions(this, source, itr->second.Conditions))
            textId = itr->second.TextID;

    return textId;
}

uint32 Player::GetDefaultGossipMenuForSource(WorldObject* source)
{
    switch (source->GetTypeId())
    {
        case TYPEID_UNIT:
            return source->ToCreature()->GetCreatureTemplate()->GossipMenuId;
        case TYPEID_GAMEOBJECT:
            return source->ToGameObject()->GetGOInfo()->GetGossipMenuId();
        default:
            break;
    }

    return 0;
}

uint32 Player::GetGossipFriendshipFactionID(uint32 menuId, WorldObject* source)
{
    uint32 friendshipFactionID = 0;
    if (!menuId)
        return friendshipFactionID;

    auto menuBounds = sGossipDataStore->GetGossipMenusMapBounds(menuId);
    for (auto itr = menuBounds.first; itr != menuBounds.second; ++itr)
        if (sConditionMgr->IsObjectMeetToConditions(this, source, itr->second.Conditions))
            friendshipFactionID = itr->second.FriendshipFactionID;

    return friendshipFactionID;
}

/*********************************************************/
/***                    QUEST SYSTEM                   ***/
/*********************************************************/

void Player::PrepareAreaQuest(uint32 area)
{
    QuestRelationBounds objectQR = sQuestDataStore->GetAreaQuestRelationBounds(area);

    for (QuestRelations::const_iterator i = objectQR.first; i != objectQR.second; ++i)
    {
        uint32 quest_id = i->second;
        Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
        if (!quest)
            continue;

        if (!CanTakeQuest(quest, false))
            continue;

        AddQuest(quest, this);

        if (CanCompleteQuest(quest_id))
            CompleteQuest(quest_id);

        if ((quest->IsAutoComplete() && quest->IsRepeatable() && !quest->IsDailyOrWeekly())/* || quest->HasFlag(QUEST_FLAGS_AUTOCOMPLETE)*/)
            PlayerTalkClass->SendQuestGiverRequestItems(quest, GetGUID(), CanCompleteRepeatableQuest(quest), true);
        else
            PlayerTalkClass->SendQuestGiverQuestDetails(quest, GetGUID(), true);
    }
}

void Player::PrepareQuestMenu(ObjectGuid guid)
{
    QuestRelationBounds objectQR;
    QuestRelationBounds objectQIR;

    // pets also can have quests
    if (Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid))
    {
        objectQR  = sQuestDataStore->GetCreatureQuestRelationBounds(creature->GetEntry());
        objectQIR = sQuestDataStore->GetCreatureQuestInvolvedRelationBounds(creature->GetEntry());
    }
    else
    {
        //we should obtain map pointer from GetMap() in 99% of cases. Special case
        //only for quests which cast teleport spells on player
        Map* _map = IsInWorld() ? GetMap() : sMapMgr->FindMap(GetMapId(), GetInstanceId());
        ASSERT(_map);
        GameObject* pGameObject = _map->GetGameObject(guid);
        if (pGameObject)
        {
            objectQR  = sQuestDataStore->GetGOQuestRelationBounds(pGameObject->GetEntry());
            objectQIR = sQuestDataStore->GetGOQuestInvolvedRelationBounds(pGameObject->GetEntry());
        }
        else
            return;
    }

    QuestMenu &qm = PlayerTalkClass->GetQuestMenu();
    qm.ClearMenu();

    for (QuestRelations::const_iterator i = objectQIR.first; i != objectQIR.second; ++i)
    {
        uint32 quest_id = i->second;
        QuestStatus status = GetQuestStatus(quest_id);
        if (status == QUEST_STATUS_COMPLETE)
            qm.AddMenuItem(quest_id, 4);
        else if (status == QUEST_STATUS_INCOMPLETE)
            qm.AddMenuItem(quest_id, 4);
        //else if (status == QUEST_STATUS_AVAILABLE)
        //    qm.AddMenuItem(quest_id, 2);
    }

    for (QuestRelations::const_iterator i = objectQR.first; i != objectQR.second; ++i)
    {
        uint32 quest_id = i->second;
        Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
        if (!quest)
            continue;

        if (!CanTakeQuest(quest, false))
            continue;

        if (quest->IsAutoComplete())
            qm.AddMenuItem(quest_id, 4);
        else if (GetQuestStatus(quest_id) == QUEST_STATUS_NONE)
            qm.AddMenuItem(quest_id, 2);
    }
}

void Player::SendPreparedQuest(ObjectGuid guid)
{
    QuestMenu& questMenu = PlayerTalkClass->GetQuestMenu();
    if (questMenu.Empty())
        return;

    QuestMenuItem const& qmi0 = questMenu.GetItem(0);

    uint32 icon = qmi0.QuestIcon;

    // single element case
    if (questMenu.GetMenuItemCount() == 1)
    {
        // Auto open -- maybe also should verify there is no greeting
        uint32 questId = qmi0.QuestId;
        if (Quest const* quest = sQuestDataStore->GetQuestTemplate(questId))
        {
            if (icon == 4 && !GetQuestRewardStatus(questId))
                PlayerTalkClass->SendQuestGiverRequestItems(quest, guid, CanRewardQuest(quest, false), true);
            else if (icon == 4)
                PlayerTalkClass->SendQuestGiverRequestItems(quest, guid, CanRewardQuest(quest, false), true);
            // Send completable on repeatable and autoCompletable quest if player don't have quest
            // TODO: verify if check for !quest->IsDaily() is really correct (possibly not)
            else
            {
                Object* object = ObjectAccessor::GetObjectByTypeMask(*this, guid, TYPEMASK_UNIT | TYPEMASK_GAMEOBJECT | TYPEMASK_ITEM);
                if (!object || (!object->hasQuest(questId) && !object->hasInvolvedQuest(questId)))
                {
                    PlayerTalkClass->SendCloseGossip();
                    return;
                }

                if (quest->IsAutoAccept() && CanAddQuest(quest, true) && CanTakeQuest(quest, true))
                {
                    AddQuest(quest, object);
                    if (CanCompleteQuest(questId))
                        CompleteQuest(questId);
                }

                if ((quest->IsAutoComplete() && quest->IsRepeatable() && !quest->IsDailyOrWeekly())/* || quest->HasFlag(QUEST_FLAGS_AUTOCOMPLETE)*/)
                    PlayerTalkClass->SendQuestGiverRequestItems(quest, guid, CanCompleteRepeatableQuest(quest), true);
                else
                    PlayerTalkClass->SendQuestGiverQuestDetails(quest, guid, true);
            }
        }
    }
    // multiple entries
    else
    {
        uint32 BroadcastTextID = 0;

        // need pet case for some quests
        Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
        if (creature)
        {
            uint32 textid = GetGossipTextId(creature);
            NpcText const* gossiptext = sObjectMgr->GetNpcText(textid);
            if (gossiptext)
                BroadcastTextID = gossiptext->Data[0].BroadcastTextID;
        }
        PlayerTalkClass->SendQuestGiverQuestList(BroadcastTextID, guid);
    }
}

Quest const* Player::GetNextQuest(ObjectGuid guid, Quest const* quest)
{
    QuestRelationBounds objectQR;

    Creature* creature = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
    if (creature)
        objectQR  = sQuestDataStore->GetCreatureQuestRelationBounds(creature->GetEntry());
    else
    {
        //we should obtain map pointer from GetMap() in 99% of cases. Special case
        //only for quests which cast teleport spells on player
        Map* _map = IsInWorld() ? GetMap() : sMapMgr->FindMap(GetMapId(), GetInstanceId());
        ASSERT(_map);
        GameObject* pGameObject = _map->GetGameObject(guid);
        if (pGameObject)
            objectQR  = sQuestDataStore->GetGOQuestRelationBounds(pGameObject->GetEntry());
        else
            return NULL;
    }

    uint32 nextQuestID = quest->NextQuestIdChain;
    for (QuestRelations::const_iterator itr = objectQR.first; itr != objectQR.second; ++itr)
    {
        if (itr->second == nextQuestID)
            return sQuestDataStore->GetQuestTemplate(nextQuestID);
    }

    return NULL;
}

bool Player::CanSeeStartQuest(Quest const* quest)
{
    bool msg = false;   //for debug
    if (SatisfyQuestClass(quest, msg) && SatisfyQuestRace(quest, msg) && SatisfyQuestSkill(quest, msg) &&
        SatisfyQuestExclusiveGroup(quest, msg) && SatisfyQuestReputation(quest, msg) &&
        SatisfyQuestPreviousQuest(quest, msg) && SatisfyQuestNextChain(quest, msg) &&
        SatisfyQuestPrevChain(quest, msg) && SatisfyQuestDay(quest, msg) && SatisfyQuestWeek(quest) &&
        SatisfyQuestSeasonal(quest) && !DisableMgr::IsDisabledFor(DISABLE_TYPE_QUEST, quest->GetQuestId(), this))
        return getLevel() + sWorld->getIntConfig(CONFIG_QUEST_HIGH_LEVEL_HIDE_DIFF) >= quest->MinLevel;

    return false;
}

bool Player::CanTakeQuest(Quest const* quest, bool msg)
{
    return !DisableMgr::IsDisabledFor(DISABLE_TYPE_QUEST, quest->GetQuestId(), this) 
        && SatisfyQuestStatus(quest, msg) && SatisfyQuestExclusiveGroup(quest, msg)
        && SatisfyQuestClass(quest, msg) && SatisfyQuestRace(quest, msg) && SatisfyQuestLevel(quest, msg)
        && SatisfyQuestSkill(quest, msg) && SatisfyQuestReputation(quest, msg)
        && SatisfyQuestPreviousQuest(quest, msg) && SatisfyQuestTimed(quest, msg)
        && SatisfyQuestNextChain(quest, msg) && SatisfyQuestPrevChain(quest, msg)
        && SatisfyQuestDay(quest, msg) && SatisfyQuestWeek(quest)
        && SatisfyQuestSeasonal(quest)
        && SatisfyQuestConditions(quest, msg);
}

bool Player::CanAddQuest(Quest const* quest, bool msg)
{
    if (!SatisfyQuestLog(msg))
        return false;

    if (quest->SourceItemId)
    {
        ItemPosCountVec dest;
        InventoryResult msg2 = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, quest->SourceItemId, quest->SourceItemIdCount);

        // player already have max number (in most case 1) source item, no additional item needed and quest can be added.
        if (msg2 == EQUIP_ERR_ITEM_MAX_COUNT)
            return true;
        if (msg2 != EQUIP_ERR_OK)
        {
            SendEquipError(msg2, nullptr, nullptr, quest->SourceItemId);
            return false;
        }
    }

    return true;
}

void Player::AutoCompleteObjectives(Quest const* quest, bool onlyBugged)
{
    for (uint32 i = 0; i < quest->Objectives.size(); ++i)
    {
        QuestObjective const& obj = quest->Objectives[i];
        if (onlyBugged && !obj.Bugged)
            continue;

        switch (obj.Type)
        {
            case QUEST_OBJECTIVE_ITEM:
            {
                uint32 curItemCount = GetItemCount(obj.ObjectID, true);
                ItemPosCountVec dest;
                uint8 msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, obj.ObjectID, obj.Amount - curItemCount);
                if (msg == EQUIP_ERR_OK)
                {
                    Item* item = StoreNewItem(dest, obj.ObjectID, true);
                    SendNewItem(item, obj.Amount - curItemCount, true, false);
                }
                break;
            }
            case QUEST_OBJECTIVE_MONSTER:
            {
                if (CreatureTemplate const* creatureInfo = sObjectMgr->GetCreatureTemplate(obj.ObjectID))
                    for (uint16 z = 0; z < obj.Amount; ++z)
                        KilledMonster(creatureInfo, ObjectGuid::Empty);
                break;
            }
            case QUEST_OBJECTIVE_GAMEOBJECT:
            {
                for (uint16 z = 0; z < obj.Amount; ++z)
                    KillCreditGO(obj.ObjectID, ObjectGuid::Empty);
                break;
            }
            case QUEST_OBJECTIVE_MIN_REPUTATION:
            {
                // assume that rep is always feasible
                if (onlyBugged)
                    break;

                uint32 curRep = GetReputationMgr().GetReputation(obj.ObjectID);
                if (curRep < uint32(obj.Amount))
                    if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(obj.ObjectID))
                        GetReputationMgr().SetReputation(factionEntry, obj.Amount);
                break;
            }
            case QUEST_OBJECTIVE_MAX_REPUTATION:
            {
                // assume that rep is always feasible
                if (onlyBugged)
                    break;

                uint32 curRep = GetReputationMgr().GetReputation(obj.ObjectID);
                if (curRep > uint32(obj.Amount))
                    if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(obj.ObjectID))
                        GetReputationMgr().SetReputation(factionEntry, obj.Amount);
                break;
            }
            case QUEST_OBJECTIVE_MONEY:
            {
                // assume that money is always feasible
                if (onlyBugged)
                    break;

                ModifyMoney(obj.Amount);
                break;
            }
        }
    }
}

bool Player::HasQuestObjectiveComplete(Quest const* qInfo, QuestObjective const& obj)
{
    switch (obj.Type)
    {
        case QUEST_OBJECTIVE_TASK_IN_ZONE:
        {
            float scale = 0.0f;
            for (QuestObjective const& task : qInfo->GetObjectives())
            {
                if (task.Flags & (QUEST_OBJECTIVE_FLAG_HIDE_ITEM_GAINS | QUEST_OBJECTIVE_FLAG_PART_OF_PROGRESS_BAR))
                    scale += float(GetQuestObjectiveData(qInfo, task.StorageIndex) * task.TaskStep);
            }
            return scale >= 100.0f;
        }
        case QUEST_OBJECTIVE_PET_TRAINER_DEFEAT:
        case QUEST_OBJECTIVE_MONSTER:
        case QUEST_OBJECTIVE_ITEM:
        case QUEST_OBJECTIVE_GAMEOBJECT:
        case QUEST_OBJECTIVE_PLAYERKILLS:
        case QUEST_OBJECTIVE_TALKTO:
        case QUEST_OBJECTIVE_COMPLETE_CRITERIA_TREE:
        case QUEST_OBJECTIVE_HAVE_CURRENCY:
        case QUEST_OBJECTIVE_OBTAIN_CURRENCY:
            return GetQuestObjectiveData(qInfo, obj.StorageIndex) >= obj.Amount;
        case QUEST_OBJECTIVE_MIN_REPUTATION:
            return GetReputationMgr().GetReputation(obj.ObjectID) >= obj.Amount;
        case QUEST_OBJECTIVE_MAX_REPUTATION:
            return GetReputationMgr().GetReputation(obj.ObjectID) <= obj.Amount;
        case QUEST_OBJECTIVE_MONEY:
            return HasEnoughMoney(uint64(obj.Amount));
        case QUEST_OBJECTIVE_AREATRIGGER:
            return GetQuestObjectiveData(qInfo, obj.StorageIndex);
        case QUEST_OBJECTIVE_LEARNSPELL:
            return HasSpell(obj.ObjectID);
        case QUEST_OBJECTIVE_CURRENCY:
            return HasCurrency(obj.ObjectID, obj.Amount);
        default:
            TC_LOG_DEBUG(LOG_FILTER_PLAYER, "Player::CanCompleteQuest unknown objective type %u", obj.Type);
            return false;
    }
}

bool Player::CanCompleteQuest(uint32 quest_id)
{
    if (quest_id)
    {
        Quest const* qInfo = sQuestDataStore->GetQuestTemplate(quest_id);
        if (!qInfo)
            return false;

        if (qInfo->IsWeekly() && IsQuestWeekRewarded(quest_id))
            return false;

        if (qInfo->IsSeasonal() && IsQuestSeasonalRewarded(quest_id))
            return false;

        if (!qInfo->IsRepeatable() && m_RewardedQuests.find(quest_id) != m_RewardedQuests.end())
            return false;                                   // not allow re-complete quest

        // auto complete quest
        if (qInfo->IsAutoComplete()/* || qInfo->GetFlags() & QUEST_FLAGS_AUTOCOMPLETE) && CanTakeQuest(qInfo, false)*/)
            return true;

        QuestStatusData* q_status = getQuestStatus(quest_id);
        if (!q_status)
            return false;

        if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_EXPLORATION_OR_EVENT) && q_status->Status != QUEST_STATUS_COMPLETE)
            return false;

        if (q_status->Status == QUEST_STATUS_INCOMPLETE)
        {
            for (QuestObjective const& obj : qInfo->GetObjectives())
            {
                if (obj.Flags & (QUEST_OBJECTIVE_FLAG_HIDE_ITEM_GAINS | QUEST_OBJECTIVE_FLAG_PART_OF_PROGRESS_BAR))
                    continue;

                if (obj.Flags & QUEST_OBJECTIVE_FLAG_OPTIONAL) 
                    continue;

                if (!HasQuestObjectiveComplete(qInfo, obj))
                    return false;
            }

            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED) && q_status->Timer == 0)
                return false;

            return true;
        }
    }

    return false;
}

bool Player::CanCompleteRepeatableQuest(Quest const* quest)
{
    // Solve problem that player don't have the quest and try complete it.
    // if repeatable she must be able to complete event if player don't have it.
    // Seem that all repeatable quest are DELIVER Flag so, no need to add more.
    if (!CanTakeQuest(quest, false))
        return false;

    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_DELIVER))
        for (QuestObjective const& obj : quest->GetObjectives())
            if (obj.Type == QUEST_OBJECTIVE_ITEM && !HasItemCount(obj.ObjectID, obj.Amount) && !(obj.Flags & QUEST_OBJECTIVE_FLAG_OPTIONAL))
                return false;

    if (!CanRewardQuest(quest, false))
        return false;

    return true;
}

bool Player::CanRewardQuest(Quest const* quest, bool msg)
{
    // not auto complete quest and not completed quest (only cheating case, then ignore without message)
    if (!quest->IsDFQuest() && !quest->IsAutoComplete() /*&& !(quest->GetFlags() & QUEST_FLAGS_AUTOCOMPLETE)*/ && GetQuestStatus(quest->GetQuestId()) != QUEST_STATUS_COMPLETE)
        return false;

    // daily quest can't be rewarded (25 daily quest already completed)
    if (IsQuestDailyRewarded(quest->GetQuestId()) || IsQuestWeekRewarded(quest->GetQuestId()) || IsQuestSeasonalRewarded(quest->GetQuestId()))
        return false;

    // rewarded and not repeatable quest (only cheating case, then ignore without message)
    if (GetQuestRewardStatus(quest->GetQuestId()))
        return false;

    // prevent receive reward with quest items in bank
    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_DELIVER))
    {
        for (QuestObjective const& obj : quest->GetObjectives())
        {
            if (obj.Type != QUEST_OBJECTIVE_ITEM)
                continue;

            if (obj.Flags & QUEST_OBJECTIVE_FLAG_OPTIONAL)
                continue;

            if (GetItemCount(obj.ObjectID) < uint32(obj.Amount))
            {
                if (msg)
                    SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL, obj.ObjectID);
                return false;
            }
        }
    }

    for (QuestObjective const& obj : quest->GetObjectives())
    {
        switch (obj.Type)
        {
        case QUEST_OBJECTIVE_CURRENCY:
            if (!HasCurrency(obj.ObjectID, obj.Amount))
                return false;
            break;
        case QUEST_OBJECTIVE_MONEY:
            if (!HasEnoughMoney(uint64(obj.Amount)))
                return false;
            break;
        }
    }

    return true;
}

bool Player::CanRewardQuest(Quest const* quest, uint32 reward, bool msg, uint32 packItemId)
{
    // prevent receive reward with quest items in bank or for not completed quest
    if (!CanRewardQuest(quest, msg))
        return false;

    ItemPosCountVec dest;
    if (quest->m_rewChoiceItemsCount)
    {
        for (uint32 i = 0; i < quest->m_rewChoiceItemsCount; ++i)
        {
            if (quest->RewardChoiceItemId[i] && quest->RewardChoiceItemId[i] == reward)
            {
                InventoryResult res = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, quest->RewardChoiceItemId[i], quest->RewardChoiceItemCount[i]);
                if (res != EQUIP_ERR_OK)
                {
                    SendEquipError(res, NULL, NULL, quest->RewardChoiceItemId[i]);
                    return false;
                }
            }
        }
    }

    if (quest->m_rewItemsCount)
    {
        for (uint32 i = 0; i < quest->m_rewItemsCount; ++i)
        {
            if (quest->RewardItemId[i])
            {
                InventoryResult res = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, quest->RewardItemId[i], quest->RewardItemCount[i]);
                if (res != EQUIP_ERR_OK)
                {
                    SendEquipError(res, NULL, NULL, quest->RewardItemId[i]);
                    return false;
                }
            }
        }
    }

    if (quest->PackageID)
    {
        if (std::vector<QuestPackageItemEntry const*> const* questPackageItems = sDB2Manager.GetQuestPackageItems(quest->PackageID))
        {
            for (QuestPackageItemEntry const* questPackageItem : *questPackageItems)
            {
                if (questPackageItem->ItemID != reward)
                    continue;

                if (ItemTemplate const* rewardProto = sObjectMgr->GetItemTemplate(questPackageItem->ItemID))
                {
                    if (rewardProto->IsUsableBySpecialization(GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID), getLevel()))
                    {
                        InventoryResult res = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, questPackageItem->ItemID, questPackageItem->ItemQuantity);
                        if (res != EQUIP_ERR_OK)
                        {
                            SendEquipError(res, NULL, NULL, questPackageItem->ItemID);
                            return false;
                        }
                    }
                }
            }
        }
    }

    return true;
}

void Player::AddQuest(Quest const* quest, Object* questGiver)
{
    uint16 log_slot = FindQuestSlot(0);

    if (log_slot >= MAX_QUEST_LOG_SIZE) // Player does not have any free slot in the quest log
        return;

    uint32 quest_id = quest->GetQuestId();

    // if not exist then created with set uState == NEW and rewarded=false
    QuestStatusData& status_q = m_QuestStatus[quest_id];
    (*m_QuestStatusVector)[quest_id] = &status_q;

    // check for repeatable quests status reset
    status_q.Status = QUEST_STATUS_INCOMPLETE;

    GiveQuestSourceItem(quest);
    AdjustQuestReqItemCount(quest);

    for (QuestObjective const& obj : quest->Objectives)
    {
        if (obj.Type == QUEST_OBJECTIVE_MIN_REPUTATION || obj.Type == QUEST_OBJECTIVE_MAX_REPUTATION)
        {
            if (FactionEntry const* factionEntry = sFactionStore.LookupEntry(obj.ObjectID))
                GetReputationMgr().SetVisible(factionEntry);
        }
        else if (obj.Type == QUEST_OBJECTIVE_COMPLETE_CRITERIA_TREE)
        {
            if (CriteriaTree const* tree = sAchievementMgr->GetCriteriaTree(obj.ObjectID))
            {
                for (CriteriaTree const* node : tree->Children)
                    if (node->Criteria && node->Criteria->Entry && (node->Criteria->Entry->Flags & CRITERIA_FLAG_RESET_ON_START))
                        m_achievementMgr->RemoveCriteriaProgress(node);

                if (m_achievementMgr->IsCompletedCriteriaTree(tree))
                    AddDelayedEvent(2000, [this, obj]() -> void { AchieveCriteriaCredit(obj.ObjectID); });
            }
        }
    }

    uint32 qtime = 0;
    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
    {
        uint32 limittime = quest->LimitTime;

        // shared timed quest
        if (questGiver && questGiver->IsPlayer())
            if (QuestStatusData* statusData = questGiver->ToPlayer()->getQuestStatus(quest->GetQuestId()))
                limittime = statusData->Timer / IN_MILLISECONDS;

        AddTimedQuest(quest_id);
        status_q.Timer = limittime * IN_MILLISECONDS;
        qtime = static_cast<uint32>(time(NULL)) + limittime;
    }
    else
        status_q.Timer = 0;

    SetQuestSlot(log_slot, quest_id, qtime);

    m_QuestStatusSave[quest_id] = QUEST_DEFAULT_SAVE_TYPE;

    m_achievementMgr->StartTimedAchievement(CRITERIA_TIMED_TYPE_ITEM, quest_id);

    //starting initial quest script
    if (questGiver && quest->StartScript)
        GetMap()->ScriptsStart(sQuestStartScripts, quest->StartScript, questGiver, this);

    if (questGiver && questGiver->IsCreature())
        questGiver->ToCreature()->AI()->OnStartQuest(this, quest);

    SetQuestUpdate(quest_id);

    // automatically complete objectives marked as bugged
    AutoCompleteObjectives(quest, true);

    AddDelayedEvent(100, [this, quest_id]() -> void
    {
        PhaseUpdateData phaseUdateData;
        phaseUdateData.AddQuestUpdate(quest_id);
        GetPhaseMgr().NotifyConditionChanged(phaseUdateData);
        UpdateForQuestWorldObjects();
    });
}

void Player::CompleteQuest(uint32 quest_id)
{
    if (quest_id)
    {
        SetQuestStatus(quest_id, QUEST_STATUS_COMPLETE);

        uint16 log_slot = FindQuestSlot(quest_id);
        if (log_slot < MAX_QUEST_LOG_SIZE)
            SetQuestSlotState(log_slot, QUEST_STATE_COMPLETE);

        if (Quest const* qInfo = sQuestDataStore->GetQuestTemplate(quest_id))
        {
            //QUEST_SPECIAL_FLAGS_AUTO_REWARD - is just objectrive with scale. Q: 39279 auto-rewarded, but Q: 38819 not.
            // SO. Diff of  flags is QUEST_FLAGS_AUTOCOMPLETE AND QUEST_FLAGS_AUTO_ACCEPT or  (0x00090000). 
            // SO. QUEST_FLAGS_AUTOCOMPLETE is AutoRewerd. Yes? Or Not! But if u will be correct something on this logic check after quest: 39279 & 38819
            if (qInfo->HasFlag(QUEST_FLAGS_TRACKING) || /*qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_AUTO_REWARD) && */qInfo->HasFlag(QUEST_FLAGS_AUTOCOMPLETE))
                RewardQuest(qInfo, 0, this, true);
            else
                SendQuestComplete(qInfo);
        }
    }
}

void Player::IncompleteQuest(uint32 quest_id)
{
    if (quest_id)
    {
        SetQuestStatus(quest_id, QUEST_STATUS_INCOMPLETE);

        uint16 log_slot = FindQuestSlot(quest_id);
        if (log_slot < MAX_QUEST_LOG_SIZE)
            RemoveQuestSlotState(log_slot, QUEST_STATE_COMPLETE);
    }
}

int32 Player::GetQuestMoneyReward(Quest const* quest) const
{
    if (quest->RewardMoney < 0)
        return quest->RewardMoney;

    return quest->MoneyValue(getLevel()) * (GetMap()->IsDungeon() && sWorld->getBoolConfig(CONFIG_DROP_DUNGEON_ONLY_X1)  ? 1.0f : sWorld->getRate(RATE_DROP_MONEY));
}

uint32 Player::GetQuestXPReward(Quest const* quest)
{
    bool rewarded = (m_RewardedQuests.find(quest->GetQuestId()) != m_RewardedQuests.end());

    // Not give XP in case already completed once repeatable quest
    if (rewarded && !quest->IsDFQuest())
        return 0;

    float QuestXpRate = 1.0f;
    if (float rate = GetSession()->GetPersonalXPRate())
        QuestXpRate = rate;
    else if(GetPersonnalXpRate())
        QuestXpRate = GetPersonnalXpRate();
    else
        QuestXpRate = sWorld->getRate(RATE_XP_QUEST);

    uint32 XP = quest->XPValue(this) * QuestXpRate;
    XP *= GetTotalAuraMultiplier(SPELL_AURA_MOD_XP_QUEST_PCT);
    return XP;
}

void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver, bool announce, uint32 packItemId)
{
    //this THING should be here to protect code from quest, which cast on player far teleport as a reward
    //should work fine, cause far teleport will be executed in Player::Update()
    SetCanDelayTeleport(true);

    uint32 quest_id = quest->GetQuestId();
    Item* rewardItem = nullptr;

    for (QuestObjective const& obj : quest->GetObjectives())
    {
        switch (obj.Type)
        {
            case QUEST_OBJECTIVE_ITEM:
                if (!(quest->FlagsEx & QUEST_FLAGS_EX_KEEP_ADDITIONAL_ITEMS))
                    DestroyItemCount(obj.ObjectID, obj.Amount, true);
                break;
            case QUEST_OBJECTIVE_CURRENCY:
                if (int32 reqCountCurrency = obj.Amount)
                {
                    reqCountCurrency *= sDB2Manager.GetCurrencyPrecision(obj.ObjectID);
                    ModifyCurrency(obj.ObjectID, -reqCountCurrency);
                }
                break;
            case QUEST_OBJECTIVE_COMPLETE_CRITERIA_TREE:
            {
                if (CriteriaTree const* tree = sAchievementMgr->GetCriteriaTree(obj.ObjectID))
                    for (CriteriaTree const* node : tree->Children)
                        m_achievementMgr->RemoveCriteriaProgress(node);
            }
            default:
                break;
        }
    }

    if ( !quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_NOT_REMOVE_SOURCE))
        TakeQuestSourceItem(quest_id, true); // remove quest src item from player

    RemoveTimedQuest(quest_id);

    if (quest->m_rewChoiceItemsCount)
    {
        if (uint32 itemId = quest->RewardChoiceItemId[reward])
        {
            ItemPosCountVec dest;
            if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, quest->RewardChoiceItemCount[reward]) == EQUIP_ERR_OK)
            {
                Item* item = StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId, GetLootSpecID()), GuidSet(), sObjectMgr->GetItemBonusTree(itemId, GetMap()->GetDifficultyLootItemContext(), getLevel()), GetMap()->GetDifficultyLootItemContext());
                // triggers some lua events
                SendDisplayToast(itemId, ToastType::ITEM, 0, quest->RewardChoiceItemCount[reward], DisplayToastMethod::DISPLAY_TOAST_SPECIAL_UNK, quest_id, item);
                SendNewItem(item, quest->RewardChoiceItemCount[reward], true, false);
            }
        }
    }

    if (quest->m_rewItemsCount)
    {
        for (uint32 i = 0; i < quest->m_rewItemsCount; ++i)
        {
            if (uint32 itemId = quest->RewardItemId[i])
            {
                ItemPosCountVec dest;
                if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, quest->RewardItemCount[i]) == EQUIP_ERR_OK)
                {
                    Item* item = StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId, GetLootSpecID()), GuidSet(), sObjectMgr->GetItemBonusTree(itemId, GetMap()->GetDifficultyLootItemContext(), getLevel()), GetMap()->GetDifficultyLootItemContext());
                    // triggers some lua events
                    SendDisplayToast(itemId, ToastType::ITEM, false, quest->RewardItemCount[i], DisplayToastMethod::DISPLAY_TOAST_SPECIAL_UNK, quest_id, item);
                    SendNewItem(item, quest->RewardItemCount[i], true, false);
                }
            }
        }
    }

    if (quest->PackageID)
    {
        if (std::vector<QuestPackageItemEntry const*> const* questPackageItems = sDB2Manager.GetQuestPackageItems(quest->PackageID))
        {
            for (QuestPackageItemEntry const* questPackageItem : *questPackageItems)
            {
                if (questPackageItem->ItemID != packItemId)
                    continue;

                if (sObjectMgr->GetItemTemplate(questPackageItem->ItemID))
                {
                    // if (rewardProto->IsUsableBySpecialization(GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID), getLevel())) // Check bug on item without spec
                    {
                        ItemPosCountVec dest;
                        if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, questPackageItem->ItemID, questPackageItem->ItemQuantity) == EQUIP_ERR_OK)
                        {
                            Item* item = StoreNewItem(dest, questPackageItem->ItemID, true, Item::GenerateItemRandomPropertyId(questPackageItem->ItemID, GetLootSpecID()), GuidSet(), sObjectMgr->GetItemBonusTree(questPackageItem->ItemID, GetMap()->GetDifficultyLootItemContext(), getLevel()), GetMap()->GetDifficultyLootItemContext());
                            // triggers some lua events
                            SendDisplayToast(questPackageItem->ItemID, ToastType::ITEM, false, questPackageItem->ItemQuantity, DisplayToastMethod::DISPLAY_TOAST_SPECIAL_UNK, quest_id, item);
                            SendNewItem(item, questPackageItem->ItemQuantity, true, false);
                        }
                    }
                }
            }
        }
    }

    if (quest->m_rewCurrencyCount)
    {
        for (uint32 i = 0; i < quest->m_rewCurrencyCount; ++i)
        {
            if (uint32 currencyId = quest->RewardCurrencyId[i])
            {
                if (uint32 countCurrency = quest->RewardCurrencyCount[i])
                {
                    countCurrency *= sDB2Manager.GetCurrencyPrecision(currencyId);
                    ModifyCurrency(currencyId, countCurrency, true);
                    // log Veiled Argunite and Wakening Essence currency
                    if (currencyId == 1508 || currencyId == 1533 || currencyId == 1160)
                        sLog->outWarden("Player %s (GUID: %u) adds a currency value %u (%u) from quest %u", GetName(), GetGUIDLow(), countCurrency, currencyId, quest->Id);
                    SendDisplayToast(currencyId, ToastType::CURRENCY, false, countCurrency, DisplayToastMethod::DISPLAY_TOAST_SPECIAL_UNK);
                }
            }
        }
    }

    if (uint32 const skill = quest->RewardSkillId)
        UpdateSkillPro(skill, 1000, quest->RewardSkillPoints);

    RewardReputation(quest);
    RewardGuildReputation(quest);

    uint16 log_slot = FindQuestSlot(quest_id);
    if (log_slot < MAX_QUEST_LOG_SIZE)
        SetQuestSlot(log_slot, 0);

    // Not give XP in case already completed once repeatable quest
    uint32 XP = GetQuestXPReward(quest);

    int32 moneyRew = 0;

    if (quest->GetRewMoneyMaxLevel() < 0)
        quest->GetRewMoneyMaxLevel();
    else if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        GiveXP(XP, nullptr);
    else
        moneyRew = int32(quest->GetRewMoneyMaxLevel() * (GetMap()->IsDungeon() && sWorld->getBoolConfig(CONFIG_DROP_DUNGEON_ONLY_X1) ? 1.0f: sWorld->getRate(RATE_DROP_MONEY)));

    // Give player extra money if GetRewMoney > 0 and get ReqMoney if negative
    if (GetQuestMoneyReward(quest))
        moneyRew += GetQuestMoneyReward(quest);

    if (quest->IsWorld())
    {
        // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "RewardQuest IsWorld quest_id %u", quest_id);

        if (WorldQuest const* wq = sQuestDataStore->GetWorldQuest(quest))
        {
            moneyRew = wq->Gold;
            if (uint32 currencyId = wq->CurrencyID)
            {
                if (uint32 countCurrency = wq->CurrencyCount)
                {
                    countCurrency *= sDB2Manager.GetCurrencyPrecision(currencyId);
                    ModifyCurrency(currencyId, countCurrency, true);
                    // log Veiled Argunite and Wakening Essence currency
                    if (currencyId == 1508 || currencyId == 1533)
                        sLog->outWarden("Player %s (GUID: %u) adds a currency value %u (%u) from quest %u", GetName(), GetGUIDLow(), countCurrency, currencyId, quest->Id);
                    SendDisplayToast(currencyId, ToastType::CURRENCY, false, countCurrency, DisplayToastMethod::DISPLAY_TOAST_SPECIAL_UNK);
                }
            }
            if (uint32 currencyId = wq->worldQuest->Currency)
            {
                if (uint32 countCurrency = wq->worldQuest->CurrencyCount)
                {
                    countCurrency *= sDB2Manager.GetCurrencyPrecision(currencyId);
                    ModifyCurrency(currencyId, countCurrency, true);
                    // log Veiled Argunite and Wakening Essence currency
                    if (currencyId == 1508 || currencyId == 1533)
                        sLog->outWarden("Player %s (GUID: %u) adds a currency value %u (%u) from quest %u", GetName(), GetGUIDLow(), countCurrency, currencyId, quest->Id);
                    SendDisplayToast(currencyId, ToastType::CURRENCY, false, countCurrency, DisplayToastMethod::DISPLAY_TOAST_SPECIAL_UNK);
                }
            }
            uint32 ItemID = GetTeamId() == TEAM_HORDE ? wq->ItemList[CLASS_NONE].ItemIDH : wq->ItemList[CLASS_NONE].ItemIDA;
            uint32 ItemCount = wq->ItemList[CLASS_NONE].ItemCount;

            if (wq->Recipe && wq->Recipe->ItemID && (!wq->Recipe->NeedSpell || HasSpell(wq->Recipe->NeedSpell)) && (!wq->Recipe->NotNeedSpell || !HasSpell(wq->Recipe->NotNeedSpell)))
            {
                if (sObjectMgr->GetItemTemplate(wq->Recipe->ItemID))
                {
                    ItemPosCountVec dest;
                    if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, wq->Recipe->ItemID, wq->Recipe->ItemCount) == EQUIP_ERR_OK)
                    {
                        auto bonusTree = GetWorldQuestBonusTreeMod(wq);
                        uint32 needLevel = std::get<1>(bonusTree);
                        if (wq->worldQuest->MinItemLevel)
                            needLevel = wq->worldQuest->MinItemLevel;

                        rewardItem = StoreNewItem(dest, wq->Recipe->ItemID, true, Item::GenerateItemRandomPropertyId(wq->Recipe->ItemID, GetLootSpecID()), GuidSet(), sObjectMgr->GetItemBonusTree(wq->Recipe->ItemID, std::get<0>(bonusTree), getLevel(), 0, 0, needLevel), std::get<0>(bonusTree));
                        // triggers some lua events
                        SendDisplayToast(wq->Recipe->ItemID, ToastType::ITEM, false, wq->Recipe->ItemCount, DisplayToastMethod::DISPLAY_TOAST_SPECIAL_UNK, quest_id, rewardItem);
                        SendNewItem(rewardItem, wq->Recipe->ItemCount, true, false);
                    }
                }
            }

            // For Oplote class tallent. For 
            if (wq->typeReward == WORLD_QUEST_TYPE_REWARD_ARTIFACT_POWER && roll_chance_i(25))
            {
                Garrison* garr = GetGarrisonPtr();
                if (garr && garr->hasLegionFall())
                    ItemCount *= 2;
            }

            if (!ItemID)
            {
                ItemID = GetTeamId() == TEAM_HORDE ? wq->ItemList[getClass()].ItemIDH : wq->ItemList[getClass()].ItemIDA;
                ItemCount = wq->ItemList[getClass()].ItemCount;
            }
            if (ItemID)
            {
                ItemPosCountVec dest;
                if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, ItemID, ItemCount) == EQUIP_ERR_OK)
                {
                    if (ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(ItemID))
                    {
                        auto bonusTree = GetWorldQuestBonusTreeMod(wq);
                        uint32 needLevel = std::get<1>(bonusTree);
                        if (wq->worldQuest->MinItemLevel)
                            needLevel = wq->worldQuest->MinItemLevel;

                        rewardItem = StoreNewItem(dest, ItemID, true, Item::GenerateItemRandomPropertyId(ItemID, GetLootSpecID()), GuidSet(), sObjectMgr->GetItemBonusTree(ItemID, std::get<0>(bonusTree), getLevel(), 0, 0, needLevel), std::get<0>(bonusTree));
                        // triggers some lua events
                        SendDisplayToast(ItemID, ToastType::ITEM, false, ItemCount, DisplayToastMethod::DISPLAY_TOAST_SPECIAL_UNK, quest_id, rewardItem);
                        SendNewItem(rewardItem, ItemCount, true, false);
                    }
                }
            }

            // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "RewardQuest IsWorld moneyRew %i ItemID %u ItemCount %u", moneyRew, ItemID, ItemCount);
            UpdateAchievementCriteria(CRITERIA_TYPE_COMPLETE_WORLD_QUEST, 1, quest->QuestInfoID);
            KilledMonsterCredit(542184); // for daily event quest
            WorldQuestInfo& wqi = m_worldquests[quest_id];
            wqi.QuestID = quest_id;
            wqi.resetTime = wq->StartTime + wq->Timer;
            wqi.needSave = true;

            UpdateAreaQuestTasks(GetAreaId(), GetAreaId());
        }
    }

    if (quest->IsRated())
        PvpRatedQuestReward(quest_id);

    if (quest->IsEmissary())
    {
        if (WorldQuest const* wq = sQuestDataStore->GetWorldQuest(quest))
        {
            WorldQuestInfo& wqi = m_worldquests[quest_id];
            wqi.QuestID = quest_id;
            wqi.resetTime = wq->StartTime + wq->Timer;
            wqi.needSave = true;
            UpdateAchievementCriteria(CRITERIA_TYPE_COMPLETE_WORLD_QUEST, 1, quest->QuestInfoID);
            KilledMonsterCredit(542184); // for daily event quest
        }
    }

    if (moneyRew)
    {
        ModifyMoney(moneyRew);

        if (moneyRew > 0)
            UpdateAchievementCriteria(CRITERIA_TYPE_MONEY_FROM_QUEST_REWARD, uint32(moneyRew));

        SendDisplayToast(0, ToastType::MONEY, false, moneyRew, DisplayToastMethod::DISPLAY_TOAST_SPECIAL_UNK);
    }

    // honor reward
    if (quest->RewardHonor)
    {
        RewardHonor(nullptr, 0, quest->RewardHonor);
        SendDisplayToast(0, ToastType::HONOR, false, quest->RewardHonor, DisplayToastMethod::DISPLAY_TOAST_SPECIAL_UNK);
    }

    if (Item* artifact = GetArtifactWeapon())
        if (quest->RewardArtifactCategoryID || quest->RewardArtifactXP)
            artifact->GiveArtifactXp(quest->RewardArtifactXP * quest->RewardArtifactXPMultiplier, nullptr, quest->RewardArtifactCategoryID);

    if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(quest->RewardTitleId))
        SetTitle(titleEntry);

    if (uint32 rewardMailTemplateId = quest->RewardMailTemplateId)
    {
        //- TODO: Poor design of mail system
        SQLTransaction trans = CharacterDatabase.BeginTransaction();
        MailDraft draft(rewardMailTemplateId);
        if (!quest->RewardMailTitle.empty())
            draft.AddSubject(quest->RewardMailTitle);
        if (MailTemplateEntry const* mailTemplateEntry = sMailTemplateStore.LookupEntry(rewardMailTemplateId))
            draft.AddBody(mailTemplateEntry->Body->Str[GetSession()->GetSessionDbLocaleIndex()]);
        draft.SendMailTo(trans, this, questGiver, MAIL_CHECK_MASK_HAS_BODY, quest->RewardMailDelay);
        CharacterDatabase.CommitTransaction(trans);
    }

    if (quest->IsDaily() || quest->IsDFQuest())
    {
        SetDailyQuestStatus(quest_id);
        if (quest->IsDaily())
        {
            UpdateAchievementCriteria(CRITERIA_TYPE_COMPLETE_DAILY_QUEST, quest_id);
            UpdateAchievementCriteria(CRITERIA_TYPE_COMPLETE_DAILY_QUEST_DAILY, quest_id);
        }
    }
    else if (quest->IsWeekly())
        SetWeeklyQuestStatus(quest_id);
    else if (quest->IsSeasonal())
        SetSeasonalQuestStatus(quest_id);
    else if (!quest->IsWorld() && !quest->IsEmissary())
    {
        m_RewardedQuests.insert(quest_id);
        m_accuntQuests.insert(quest_id);
        m_RewardedQuestsSave[quest_id] = QUEST_DEFAULT_SAVE_TYPE;
    }
    
    // Must come after the insert in m_RewardedQuests because of spell_area check
    RemoveActiveQuest(quest_id);

    SendQuestReward(quest, XP, questGiver, moneyRew, rewardItem, !announce);

    AddDelayedEvent(100, [this, quest_id]() -> void
    {
        PhaseUpdateData phaseUdateData;
        phaseUdateData.AddQuestUpdate(quest_id);
        GetPhaseMgr().NotifyConditionChanged(phaseUdateData);
    });

    // update area quests
    uint32 newzone, newarea;
    GetZoneAndAreaId(newzone, newarea);
    PrepareAreaQuest(newzone);
    PrepareAreaQuest(newarea);

    // StoreNewItem, mail reward, etc. save data directly to the database
    // to prevent exploitable data desynchronisation we save the quest status to the database too
    // (to prevent rewarding this quest another time while rewards were already given out)
    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    _SaveQuestStatus(trans);
    _SaveWorldQuestStatus(trans);
    CharacterDatabase.CommitTransaction(trans);

    // cast spells after mark quest complete (some spells have quest completed state requirements in spell_area data)
    if (quest->RewardSpell > 0)
    {
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(quest->RewardSpell);
        if (spellInfo && questGiver)
        {
            if (questGiver->IsUnit() &&
                !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) &&
                !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM) &&
                !spellInfo->HasEffect(SPELL_EFFECT_APPLY_AURA) &&
                !spellInfo->HasEffect(SPELL_EFFECT_TRIGGER_SPELL) &&
                spellInfo->Effects[EFFECT_0]->TargetA.GetTarget() != TARGET_UNIT_CASTER) //SPELL_EFFECT_TRIGGER_SPELL should cast plr for learning followers.
            {
                if (Unit* unit = questGiver->ToUnit())
                    unit->CastSpell(this, quest->RewardSpell, true);
            }
            else
                CastSpell(this, quest->RewardSpell, true);
        }
    }
    else
    {
        for (uint32 i = 0; i < QUEST_REWARD_DISPLAY_SPELL_COUNT; ++i)
        {
            if (quest->RewardDisplaySpell[i] > 0)
            {
                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(quest->RewardDisplaySpell[i]);
                if (spellInfo && questGiver)
                {
                    if (questGiver->IsUnit() && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
                    {
                        if (Unit* unit = questGiver->ToUnit())
                            unit->CastSpell(this, quest->RewardDisplaySpell[i], true);
                    }
                    else
                        CastSpell(this, quest->RewardDisplaySpell[i], true);
                }
            }
        }
    }

    if (quest->QuestSortID > 0)
        UpdateAchievementCriteria(CRITERIA_TYPE_COMPLETE_QUESTS_IN_ZONE, quest_id, quest->QuestSortID, quest->QuestInfoID);
    UpdateAchievementCriteria(CRITERIA_TYPE_COMPLETE_QUEST_COUNT);
    UpdateAchievementCriteria(CRITERIA_TYPE_COMPLETE_QUEST, quest_id, quest->QuestInfoID);
    UpdateAchievementCriteria(CRITERIA_TYPE_COMPLETE_QUESTS_COUNT, 1, 0, 0, NULL, this);

    SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(quest_id), true);

    //lets remove flag for delayed teleports
    SetCanDelayTeleport(false);
}

void Player::FailQuest(uint32 questId)
{
    if (Quest const* quest = sQuestDataStore->GetQuestTemplate(questId))
    {
        SetQuestStatus(questId, QUEST_STATUS_FAILED);

        uint16 log_slot = FindQuestSlot(questId);

        if (log_slot < MAX_QUEST_LOG_SIZE)
        {
            SetQuestSlotTimer(log_slot, 1);
            SetQuestSlotState(log_slot, QUEST_STATE_FAIL);
        }

        if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
        {
            if (QuestStatusData* q_status = getQuestStatus(questId))
            {
                RemoveTimedQuest(questId);
                q_status->Timer = 0;

                SendQuestTimerFailed(questId);
            }
        }
        else
            SendQuestFailed(questId);

        // Destroy quest items on quest failure.
        for (QuestObjective const& obj : quest->GetObjectives())
            if (obj.Type == QUEST_OBJECTIVE_ITEM)
                DestroyItemCount(obj.ObjectID, obj.Amount, true, true);
        // Destroy items received during the quest.
        for (uint8 i = 0; i < QUEST_ITEM_COUNT; ++i)
            if (quest->ItemDrop[i] && quest->ItemDropQuantity[i])
                DestroyItemCount(quest->ItemDrop[i], quest->ItemDropQuantity[i], true, true);
    }
}

bool Player::SatisfyQuestSkill(Quest const* qInfo, bool msg) const
{
    uint32 skill = qInfo->RequiredSkillId;
    if (!skill)
        return true;

    if (const_cast<Player*>(this)->GetSkillValue(skill) < qInfo->RequiredSkillPoints)
    {
        if (msg)
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "skill");

        return false;
    }

    return true;
}

bool Player::SatisfyQuestLevel(Quest const* qInfo, bool msg)
{
    if (getLevel() < qInfo->MinLevel)
    {
        if (msg)
            SendCanTakeQuestResponse(INVALIDREASON_QUEST_FAILED_LOW_LEVEL, qInfo);
        return false;
    }
    if (qInfo->MaxLevel > 0 && getLevel() > qInfo->MaxLevel)
    {
        if (msg)
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "level"); // There doesn't seem to be a specific response for too high player level
        return false;
    }
    return true;
}

bool Player::SatisfyQuestLog(bool msg)
{
    // exist free slot
    if (FindQuestSlot(0) < MAX_QUEST_LOG_SIZE)
        return true;

    if (msg)
        SendDirectMessage(WorldPackets::Quest::QuestLogFull().Write());

    return false;
}

bool Player::SatisfyQuestPreviousQuest(Quest const* qInfo, bool msg)
{
    // No previous quest (might be first quest in a series)
    if (qInfo->prevQuests.empty())
        return true;

    for (PrevQuests::const_iterator iter = qInfo->prevQuests.begin(); iter != qInfo->prevQuests.end(); ++iter)
    {
        uint32 prevId = abs(*iter);
        Quest const* qPrevInfo = sQuestDataStore->GetQuestTemplate(prevId);
        if (!qPrevInfo)
            continue;

        // If any of the positive previous quests completed, return true
        if (*iter > 0 && m_RewardedQuests.find(prevId) != m_RewardedQuests.end())
        {
            // skip one-from-all exclusive group
            if (qPrevInfo->ExclusiveGroup >= 0)
                return true;

            // each-from-all exclusive group (< 0)
            // can be start if only all quests in prev quest exclusive group completed and rewarded
            ExclusiveQuestGroups::iterator iter2 = sQuestDataStore->mExclusiveQuestGroups.lower_bound(qPrevInfo->ExclusiveGroup);
            ExclusiveQuestGroups::iterator end  = sQuestDataStore->mExclusiveQuestGroups.upper_bound(qPrevInfo->ExclusiveGroup);

            ASSERT(iter2 != end);                         // always must be found if qPrevInfo->ExclusiveGroup != 0
            for (; iter2 != end; ++iter2)
            {
                uint32 exclude_Id = iter2->second;

                // skip checked quest id, only state of other quests in group is interesting
                if (exclude_Id == prevId)
                    continue;

                // skip enother team.
                if (Quest const* qexclude = sQuestDataStore->GetQuestTemplate(exclude_Id))
                    if (!SatisfyQuestRace(qexclude, msg))
                        continue;

                // alternative quest from group also must be completed and rewarded(reported)
                if (m_RewardedQuests.find(exclude_Id) == m_RewardedQuests.end())
                {
                    if (msg)
                        SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "rewarded");
                    return false;
                }
            }
            return true;
        }

        // If any of the negative previous quests active, return true
        if (*iter < 0 && GetQuestStatus(prevId) != QUEST_STATUS_NONE)
        {
            // skip one-from-all exclusive group
            if (qPrevInfo->ExclusiveGroup >= 0)
                return true;

            // each-from-all exclusive group (< 0)
            // can be start if only all quests in prev quest exclusive group active
            ExclusiveQuestGroups::iterator iter2 = sQuestDataStore->mExclusiveQuestGroups.lower_bound(qPrevInfo->ExclusiveGroup);
            ExclusiveQuestGroups::iterator end  = sQuestDataStore->mExclusiveQuestGroups.upper_bound(qPrevInfo->ExclusiveGroup);

            ASSERT(iter2 != end);                         // always must be found if qPrevInfo->ExclusiveGroup != 0

            for (; iter2 != end; ++iter2)
            {
                uint32 exclude_Id = iter2->second;

                // skip checked quest id, only state of other quests in group is interesting
                if (exclude_Id == prevId)
                    continue;

                // alternative quest from group also must be active
                if (GetQuestStatus(exclude_Id) != QUEST_STATUS_NONE)
                {
                    if (msg)
                        SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "not active alt quest");
                    return false;
                }
            }
            return true;
        }
    }

    // Has only positive prev. quests in non-rewarded state
    // and negative prev. quests in non-active state
    if (msg)
        SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "prev");

    return false;
}

bool Player::SatisfyQuestClass(Quest const* qInfo, bool msg) const
{
    int32 reqClass = qInfo->AllowableClasses;
    if (!reqClass)
        return true;

    if (reqClass > 0)
    {
        // Positive = Only specified
        if ((reqClass & getClassMask()) == 0)
        {
            if (msg)
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "class");

            return false;
        }
    }
    else
    {
        // Negative = All except specified
        reqClass = -reqClass;

        if (reqClass & getClassMask())
        {
            if (msg)
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "class");

            return false;
        }
    }

    return true;
}

bool Player::SatisfyQuestRace(Quest const* qInfo, bool msg)
{
    uint64 reqraces = qInfo->AllowableRaces;
    if (reqraces == uint64(-1))
        return true;

    if ((reqraces & getRaceMask()) == 0)
    {
        if (msg)
            SendCanTakeQuestResponse(INVALIDREASON_QUEST_FAILED_WRONG_RACE, qInfo);
        return false;
    }

    return true;
}

bool Player::SatisfyQuestReputation(Quest const* qInfo, bool msg)
{
    uint32 fIdMin = qInfo->RequiredMinRepFaction;
    if (fIdMin && GetReputationMgr().GetReputation(fIdMin) < qInfo->RequiredMinRepValue)
    {
        if (msg)
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "rep");
        return false;
    }

    uint32 fIdMax = qInfo->RequiredMaxRepFaction;
    if (fIdMax && GetReputationMgr().GetReputation(fIdMax) >= qInfo->RequiredMaxRepValue)
    {
        if (msg)
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "rep");
        return false;
    }

    /** @todo 6.x investigate if it's still needed
    // ReputationObjective2 does not seem to be an objective requirement but a requirement
    // to be able to accept the quest
    uint32 fIdObj = qInfo->GetRepObjectiveFaction2();
    if (fIdObj && GetReputationMgr().GetReputation(fIdObj) >= qInfo->GetRepObjectiveValue2())
    {
        if (msg)
        {
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo);
            TC_LOG_INFO(LOG_FILTER_GENERAL, "SatisfyQuestReputation: Sent INVALIDREASON_DONT_HAVE_REQ (questId: %u) because player does not have required reputation (ReputationObjective2).", qInfo->GetQuestId());
        }
        return false;
    }**/

    return true;
}

bool Player::SatisfyQuestStatus(Quest const* qInfo, bool msg)
{
    if (GetQuestStatus(qInfo->GetQuestId()) != QUEST_STATUS_NONE)
    {
        if (msg)
            SendCanTakeQuestResponse(INVALIDREASON_QUEST_ALREADY_ON, qInfo);
        return false;
    }
    return true;
}

bool Player::SatisfyQuestConditions(Quest const* qInfo, bool msg)
{
    ConditionList conditions = sConditionMgr->GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_QUEST_ACCEPT, qInfo->GetQuestId());
    if (!sConditionMgr->IsObjectMeetToConditions(this, conditions))
    {
        if (msg)
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "cond");
        TC_LOG_DEBUG(LOG_FILTER_CONDITIONSYS, "Player::SatisfyQuestConditions: conditions not met for quest %u", qInfo->GetQuestId());
        return false;
    }
    return true;
}

bool Player::SatisfyQuestTimed(Quest const* qInfo, bool msg)
{
    if (!m_timedquests.empty() && qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED))
    {
        if (msg)
            SendCanTakeQuestResponse(INVALIDREASON_QUEST_ONLY_ONE_TIMED, qInfo);
        return false;
    }
    return true;
}

bool Player::SatisfyQuestExclusiveGroup(Quest const* qInfo, bool msg)
{
    // non positive exclusive group, if > 0 then can be start if any other quest in exclusive group already started/completed
    if (qInfo->ExclusiveGroup <= 0)
        return true;

    ExclusiveQuestGroups::iterator iter = sQuestDataStore->mExclusiveQuestGroups.lower_bound(qInfo->ExclusiveGroup);
    ExclusiveQuestGroups::iterator end  = sQuestDataStore->mExclusiveQuestGroups.upper_bound(qInfo->ExclusiveGroup);

    //ASSERT(iter != end);                                      // always must be found if qInfo->ExclusiveGroup != 0

    for (; iter != end; ++iter)
    {
        uint32 exclude_Id = iter->second;

        // skip checked quest id, only state of other quests in group is interesting
        if (exclude_Id == qInfo->GetQuestId())
            continue;

        // not allow have daily quest if daily quest from exclusive group already recently completed
        Quest const* Nquest = sQuestDataStore->GetQuestTemplate(exclude_Id);
        if (!SatisfyQuestDay(Nquest, false) || !SatisfyQuestWeek(Nquest) || !SatisfyQuestSeasonal(Nquest))
        {
            if (msg)
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "season");

            return false;
        }

        // skip enother team.
        if (!SatisfyQuestRace(Nquest, msg))
            continue;

        // alternative quest already started or completed - but don't check rewarded states if both are repeatable
        if (GetQuestStatus(exclude_Id) != QUEST_STATUS_NONE || (!(qInfo->IsRepeatable() && Nquest->IsRepeatable()) && (m_RewardedQuests.find(exclude_Id) != m_RewardedQuests.end())))
        {
            if (msg)
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "alternative quest already started or completed");
            return false;
        }
    }
    return true;
}

bool Player::SatisfyQuestNextChain(Quest const* qInfo, bool msg)
{
    if (!qInfo->NextQuestIdChain)
        return true;

    // next quest in chain already started or completed
    if (GetQuestStatus(qInfo->NextQuestIdChain) != QUEST_STATUS_NONE) // GetQuestStatus returns QUEST_STATUS_COMPLETED for rewarded quests
    {
        if (msg)
            SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "chain");
        return false;
    }

    // check for all quests further up the chain
    // only necessary if there are quest chains with more than one quest that can be skipped
    //return SatisfyQuestNextChain(qInfo->GetNextQuestInChain(), msg);
    return true;
}

bool Player::SatisfyQuestPrevChain(Quest const* qInfo, bool msg)
{
    // No previous quest in chain
    if (qInfo->prevChainQuests.empty())
        return true;

    for (PrevChainQuests::const_iterator iter = qInfo->prevChainQuests.begin(); iter != qInfo->prevChainQuests.end(); ++iter)
    {
        QuestStatusData* q_status = getQuestStatus(*iter);
        // If any of the previous quests in chain active, return false
        if (q_status && q_status->Status != QUEST_STATUS_NONE)
        {
            if (msg)
                SendCanTakeQuestResponse(INVALIDREASON_DONT_HAVE_REQ, qInfo, "prev chain");
            return false;
        }

        // check for all quests further down the chain
        // only necessary if there are quest chains with more than one quest that can be skipped
        //if (!SatisfyQuestPrevChain(prevId, msg))
        //    return false;
    }

    // No previous quest in chain active
    return true;
}

bool Player::SatisfyQuestDay(Quest const* qInfo, bool msg)
{
    if (!qInfo->IsDaily() && !qInfo->IsDFQuest())
        return true;

    if (qInfo->IsDFQuest())
    {
        // there are separate df quests for all random dungeon types...
        if (m_DFQuests.find(qInfo->GetQuestId()) != m_DFQuests.end())
            return false;

        return true;
    }

    bool res = m_dailyquests.find(qInfo->GetQuestId()) == m_dailyquests.end();
    if (!res && msg)
        SendCanTakeQuestResponse(INVALIDREASON_DAILY_QUEST_COMPLETED_TODAY, qInfo);
    return res;
}

bool Player::SatisfyQuestWeek(Quest const* qInfo)
{
    if (!qInfo->IsWeekly() || m_weeklyquests.empty())
        return true;

    // if not found in cooldown list
    return m_weeklyquests.find(qInfo->GetQuestId()) == m_weeklyquests.end();
}

bool Player::SatisfyQuestSeasonal(Quest const* qInfo)
{
    if (!qInfo->IsSeasonal() || m_seasonalquests.empty())
        return true;

    uint16 eventId = sGameEventMgr->GetEventIdForQuest(qInfo);
    if (m_seasonalquests.find(eventId) == m_seasonalquests.end() || m_seasonalquests[eventId].empty())
        return true;

    // if not found in cooldown list
    return m_seasonalquests[eventId].find(qInfo->GetQuestId()) == m_seasonalquests[eventId].end();
}

bool Player::GiveQuestSourceItem(Quest const* quest)
{
    if (quest->SourceItemId)
    {
        ItemPosCountVec dest;
        InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, quest->SourceItemId, quest->SourceItemIdCount ? quest->SourceItemIdCount : 1);
        if (msg == EQUIP_ERR_OK)
        {
            Item* item = StoreNewItem(dest, quest->SourceItemId, true);
            SendNewItem(item, quest->SourceItemIdCount ? quest->SourceItemIdCount : 1, true, false);
            return true;
        }
        // player already have max amount required item, just report success
        if (msg == EQUIP_ERR_ITEM_MAX_COUNT)
            return true;
        SendEquipError(msg, nullptr, nullptr, quest->SourceItemId);
        return false;
    }

    return true;
}

bool Player::TakeQuestSourceItem(uint32 questId, bool msg)
{
    Quest const* quest = sQuestDataStore->GetQuestTemplate(questId);
    if (quest)
    {
        if (quest->SourceItemId)
        {
            // exist two cases when destroy source quest item not possible:
            // a) non un-equippable item (equipped non-empty bag, for example)
            // b) when quest is started from an item and item also is needed in
            // the end as RequiredItemId
            InventoryResult res = CanUnequipItems(quest->SourceItemId, quest->SourceItemIdCount ? quest->SourceItemIdCount : 1);
            if (res != EQUIP_ERR_OK)
            {
                if (msg)
                    SendEquipError(res, NULL, NULL, quest->SourceItemId);
                return false;
            }

            bool destroyItem = true;
            ItemTemplate const* item = sObjectMgr->GetItemTemplate(quest->SourceItemId);
            for (QuestObjective const& obj : quest->GetObjectives())
                if (obj.Type == QUEST_OBJECTIVE_ITEM)
                    if (item->GetStartQuestID() == questId && quest->SourceItemId == obj.ObjectID)
                        destroyItem = false;

            if (destroyItem)
                DestroyItemCount(quest->SourceItemId, quest->SourceItemIdCount ? quest->SourceItemIdCount : 1, true, true);
        }

        for (uint8 i = 0; i < QUEST_ITEM_COUNT; ++i)
            if (quest->ItemDrop[i] && !quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_NOT_REMOVE_SOURCE))
                DestroyItemCount(quest->ItemDrop[i], quest->ItemDropQuantity[i] ? quest->ItemDropQuantity[i] : 9999, true);
    }

    return true;
}

bool Player::GetQuestRewardStatus(uint32 quest_id) const
{
    Quest const* qInfo = sQuestDataStore->GetQuestTemplate(quest_id);
    if (qInfo)
    {
        if (qInfo->IsWeekly())
            return IsQuestWeekRewarded(quest_id);

        if (qInfo->IsSeasonal())
            return IsQuestSeasonalRewarded(quest_id);

        // for repeatable quests: rewarded field is set after first reward only to prevent getting XP more than once
        if (!qInfo->IsRepeatable())
            return m_RewardedQuests.find(quest_id) != m_RewardedQuests.end();

        return false;
    }
    return false;
}

QuestStatus Player::GetQuestStatus(uint32 quest_id) const
{
    if (quest_id)
    {
        if (Quest const* qInfo = sQuestDataStore->GetQuestTemplate(quest_id))
        {
            QuestStatusData const* q_status = const_cast<Player*>(this)->getQuestStatus(quest_id);
            if (q_status)
                return q_status->Status;

            if (qInfo->IsDaily() && IsQuestDailyRewarded(quest_id))
                return QUEST_STATUS_REWARDED;

            if (qInfo->IsWeekly() && IsQuestWeekRewarded(quest_id))
                return QUEST_STATUS_REWARDED;

            if (qInfo->IsSeasonal() && IsQuestSeasonalRewarded(quest_id))
                return QUEST_STATUS_REWARDED;

            if (!qInfo->IsRepeatable() && m_RewardedQuests.find(quest_id) != m_RewardedQuests.end())
                return QUEST_STATUS_REWARDED;

            if (qInfo->IsWorld())
                return WorldQuestCompleted(quest_id) ? QUEST_STATUS_REWARDED : QUEST_STATUS_NONE;
        }
    }
    return QUEST_STATUS_NONE;
}

QuestStatus Player::GetDailyQuestStatus(uint32 quest_id) const
{
    if (quest_id)
    {
        if (m_dailyquests.find(quest_id) != m_dailyquests.end())
            return QUEST_STATUS_REWARDED;
    }
    return QUEST_STATUS_NONE;
}

bool Player::CanShareQuest(uint32 quest_id) const
{
    Quest const* qInfo = sQuestDataStore->GetQuestTemplate(quest_id);
    if (qInfo && qInfo->HasFlag(QUEST_FLAGS_SHARABLE))
    {
        QuestStatusData const* q_status = const_cast<Player*>(this)->getQuestStatus(quest_id);
        if (q_status)
            return q_status->Status == QUEST_STATUS_INCOMPLETE;
    }
    return false;
}

void Player::QuestObjectiveSatisfy(uint32 objectId, uint32 amount, QuestObjectiveType type /*= QUEST_OBJECTIVE_MONSTER*/, ObjectGuid guid /*= ObjectGuid::Empty*/)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questID = GetQuestSlotQuestId(i);
        if (!questID)
            continue;

        if (auto const& q_status = getQuestStatus(questID))
            if (q_status->Status != QUEST_STATUS_INCOMPLETE)
                continue;

        Quest const* quest = sQuestDataStore->GetQuestTemplate(questID);
        if (!quest)
            continue;

        //if (!quest->GetQuestObjectiveCountType(type))
        //    continue;

        for (QuestObjective const& obj : quest->GetObjectives())
        {
            if (obj.Type == type && (uint32)obj.ObjectID == objectId)
            {
                SetQuestObjectiveData(quest, &obj, std::min<uint32>(GetQuestObjectiveData(quest, obj.StorageIndex) + amount, obj.Amount));

                SendQuestUpdateAddCredit(quest, guid, obj, amount);

                if (CanCompleteQuest(questID))
                    CompleteQuest(questID);
                break;
            }
        }
    }
}

void Player::SetQuestStatus(uint32 quest_id, QuestStatus status)
{
    if (sQuestDataStore->GetQuestTemplate(quest_id))
    {
        QuestStatusData& q_status = (*m_QuestStatusVector)[quest_id] ? *(*m_QuestStatusVector)[quest_id] : m_QuestStatus[quest_id];
        q_status.Status = status;
        m_QuestStatusSave[quest_id] = QUEST_DEFAULT_SAVE_TYPE;
        (*m_QuestStatusVector)[quest_id] = &q_status;
    }

    SetQuestUpdate(quest_id);

    AddDelayedEvent(100, [this, quest_id]() -> void
    {
        PhaseUpdateData phaseUdateData;
        phaseUdateData.AddQuestUpdate(quest_id);
        GetPhaseMgr().NotifyConditionChanged(phaseUdateData);
        UpdateForQuestWorldObjects();
    });
}

void Player::RemoveActiveQuest(uint32 quest_id)
{
    if (!sQuestDataStore->GetQuestTemplate(quest_id))
        return;

    QuestStatusData* status = getQuestStatus(quest_id);
    if (!status)
        return;

    (*m_QuestStatusVector)[quest_id] = NULL;
    m_QuestStatus.erase(quest_id);
    m_QuestStatusSave[quest_id] = QUEST_DELETE_SAVE_TYPE;

    SetQuestUpdate(quest_id);

    AddDelayedEvent(100, [this, quest_id]() -> void
    {
        PhaseUpdateData phaseUdateData;
        phaseUdateData.AddQuestUpdate(quest_id);
        GetPhaseMgr().NotifyConditionChanged(phaseUdateData);
    });
}

void Player::RemoveRewardedQuest(uint32 quest_id)
{
    RewardedQuestSet::iterator rewItr = m_RewardedQuests.find(quest_id);
    if (rewItr != m_RewardedQuests.end())
    {
        m_RewardedQuests.erase(rewItr);

        AddDelayedEvent(100, [this, quest_id]() -> void
        {
            PhaseUpdateData phaseUdateData;
            phaseUdateData.AddQuestUpdate(quest_id);
            GetPhaseMgr().NotifyConditionChanged(phaseUdateData);
        });
    }

    // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "RemoveRewardedQuest quest_id %u", quest_id);
    m_weeklyquests.erase(quest_id);
    m_dailyquests.erase(quest_id);
    m_worldquests.erase(quest_id);
    SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(quest_id), false);

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_C);
    stmt->setUInt64(0, GetGUIDLow());
    stmt->setUInt32(1, quest_id);
    trans->Append(stmt);

    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_DAILY_C);
    stmt->setUInt64(0, GetGUIDLow());
    stmt->setUInt32(1, quest_id);
    trans->Append(stmt);

    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_WEEKLY_C);
    stmt->setUInt64(0, GetGUIDLow());
    stmt->setUInt32(1, quest_id);
    trans->Append(stmt);

    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_SEASONAL_C);
    stmt->setUInt64(0, GetGUIDLow());
    stmt->setUInt32(1, quest_id);
    trans->Append(stmt);
    CharacterDatabase.CommitTransaction(trans);
}

// not used in Trinity, but used in scripting code
uint16 Player::GetReqKillOrCastCurrentCount(uint32 quest_id, int32 entry)
{
    Quest const* qInfo = sQuestDataStore->GetQuestTemplate(quest_id);
    if (!qInfo)
        return 0;

    for (QuestObjective const& obj : qInfo->GetObjectives())
        if (obj.ObjectID == entry)
            return GetQuestObjectiveData(qInfo, obj.StorageIndex);

    return 0;
}

void Player::AdjustQuestReqItemCount(Quest const* quest)
{
    if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_DELIVER))
    {
        for (QuestObjective const& obj : quest->GetObjectives())
        {
            if (obj.Type != QUEST_OBJECTIVE_ITEM)
                continue;

            if (obj.Flags & QUEST_OBJECTIVE_FLAG_OPTIONAL)
                continue;

            SetQuestObjectiveData(quest, &obj, std::min(GetItemCount(obj.ObjectID, true), uint32(obj.Amount)));
        }
    }
}

uint16 Player::FindQuestSlot(uint32 quest_id) const
{
    for (uint16 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
        if (GetQuestSlotQuestId(i) == quest_id)
            return i;

    return MAX_QUEST_LOG_SIZE;
}

uint32 Player::GetQuestSlotQuestId(uint16 slot) const
{
    return GetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_ID_OFFSET);
}

uint32 Player::GetQuestSlotState(uint16 slot)   const
{
    return GetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_STATE_OFFSET);
}

uint16 Player::GetQuestSlotCounter(uint16 slot, uint8 counter) const
{
    if (counter < MAX_QUEST_COUNTS)
        return GetUInt16Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_COUNTS_OFFSET + counter / 2, counter % 2);
    return 0;
}

uint32 Player::GetQuestSlotTime(uint16 slot) const
{
    return GetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_TIME_OFFSET);
}

void Player::SetQuestSlot(uint16 slot, uint32 quest_id, uint32 timer /*= 0*/)
{
    SetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_ID_OFFSET, quest_id);
    SetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_STATE_OFFSET, 0);
    for (uint32 i = 0; i < MAX_QUEST_COUNTS / 2; ++i)
        SetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_COUNTS_OFFSET + i, 0);
    SetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_TIME_OFFSET, timer);
}

void Player::SetQuestSlotCounter(uint16 slot, uint8 counter, uint16 count)
{
    if (counter >= MAX_QUEST_COUNTS)
        return;

    SetUInt16Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_COUNTS_OFFSET + counter / 2, counter % 2, count);
}

void Player::SetSpecialCriteriaComplete(uint16 slot, uint8 StorageIndex)
{
    //! yes. QUEST_STATE_OFFSET used. second part of uint16.
    SetByteFlag(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_STATE_OFFSET, 1, 1 << StorageIndex);
}

void Player::SetQuestSlotState(uint16 slot, uint32 state)
{
    SetFlag(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_STATE_OFFSET, state);
}

void Player::RemoveQuestSlotState(uint16 slot, uint32 state)
{
    RemoveFlag(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_STATE_OFFSET, state);
}

void Player::SetQuestSlotTimer(uint16 slot, uint32 timer)
{
    SetUInt32Value(PLAYER_FIELD_QUEST_LOG + slot * MAX_QUEST_OFFSET + QUEST_TIME_OFFSET, timer);
}

void Player::SetQuestCompletedBit(uint32 questBit, bool completed)
{
    if (!questBit)
        return;

    uint32 fieldOffset = (questBit - 1) >> 5;
    if (fieldOffset >= QUESTS_COMPLETED_BITS_SIZE)
        return;

    ApplyModFlag(PLAYER_FIELD_QUEST_COMPLETED + ((questBit - 1) >> 5), 1 << ((questBit - 1) & 31), completed);
}

bool Player::IsQuestBitFlaged(uint32 questBit) const
{
    if (!questBit)
        return false;

    return HasFlag(PLAYER_FIELD_QUEST_COMPLETED + (questBit - 1) / 31, 1 << ((questBit - 1) % 31));
}

void Player::AreaExploredOrEventHappens(uint32 questId)
{
    if (Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questId))
    {
        uint16 log_slot = FindQuestSlot(questId);
        if (log_slot < MAX_QUEST_LOG_SIZE)
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Deprecated function AreaExploredOrEventHappens called for quest %u", questId);

            /** @todo
            This function was previously used for area triggers but now those are a part of quest objective system
            Currently this function is used to complete quests with no objectives (needs verifying) so probably rename it?
            **/
            QuestStatusData* q_status = getQuestStatus(questId);
            if (!q_status)
                return;

            if (q_status->Status != QUEST_STATUS_COMPLETE)
            {
                q_status->Status = QUEST_STATUS_COMPLETE;
                m_QuestStatusSave[questId] = QUEST_DEFAULT_SAVE_TYPE;
                SetQuestSlotState(log_slot, QUEST_STATE_COMPLETE);
                SendQuestComplete(qInfo);
             }
            for (QuestObjective const& obj : qInfo->GetObjectives())
            {
                SetSpecialCriteriaComplete(log_slot, obj.StorageIndex);
                WorldPackets::Quest::QuestUpdateAddCreditSimple packet;
                packet.QuestID = qInfo->GetQuestId();
                packet.ObjectID = obj.ObjectID;
                packet.ObjectiveType = obj.Type;
                SendDirectMessage(packet.Write());
            }
        }
        if (CanCompleteQuest(questId))
            CompleteQuest(questId);

        if ((qInfo->IsAutoComplete() && qInfo->IsRepeatable() && !qInfo->IsDailyOrWeekly())/* || quest->HasFlag(QUEST_FLAGS_AUTOCOMPLETE)*/)
            PlayerTalkClass->SendQuestGiverRequestItems(qInfo, GetGUID(), CanCompleteRepeatableQuest(qInfo), true);
        //else
        //    PlayerTalkClass->SendQuestGiverQuestDetails(qInfo, GetGUID(), true);
    }
}

//not used in Trinityd, function for external script library
void Player::GroupEventHappens(uint32 questId, WorldObject const* pEventObject)
{
    if (Group* group = GetGroup())
    {
        for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
        {
            Player* player = itr->getSource();

            // for any leave or dead (with not released body) group member at appropriate distance
            if (player && player->IsAtGroupRewardDistance(pEventObject) && !player->GetCorpse())
                player->AreaExploredOrEventHappens(questId);
        }
    }
    else
        AreaExploredOrEventHappens(questId);
}

void Player::ItemAddedQuestCheck(uint32 entry, uint32 count)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid);
        if (!qInfo || !qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_DELIVER))
            continue;

        QuestStatusData* q_status = getQuestStatus(questid);
        if (!q_status)
            continue;

        if (q_status->Status != QUEST_STATUS_INCOMPLETE)
            continue;

        for (QuestObjective const& obj : qInfo->GetObjectives())
        {
            if (obj.Type != QUEST_OBJECTIVE_ITEM)
                continue;

            if (obj.ObjectID == entry)
            {
                uint32 reqitemcount = obj.Amount;
                uint16 curitemcount = GetQuestObjectiveData(qInfo, obj.StorageIndex);
                if (curitemcount < reqitemcount)
                {
                    SetQuestObjectiveData(qInfo, &obj, std::min<uint32>(curitemcount + count, reqitemcount));
                    if (CanCompleteQuest(questid))
                        CompleteQuest(questid);
                    break;
                }
            }
        }
    }
    
    AddDelayedEvent(100, [=]() -> void
    {
        if (this)
            UpdateForQuestWorldObjects();
    });
}

void Player::ItemRemovedQuestCheck(uint32 entry, uint32 count)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;
        Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid);
        if (!qInfo || !qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_DELIVER))
            continue;

        for (QuestObjective const& obj : qInfo->GetObjectives())
        {
            if (obj.Type != QUEST_OBJECTIVE_ITEM)
                continue;

            if (obj.Flags & QUEST_OBJECTIVE_FLAG_OPTIONAL)
                continue;

            uint32 reqItem = obj.ObjectID;
            if (reqItem == entry)
            {
                uint32 reqItemCount = obj.Amount;
                uint16 curItemCount = GetQuestObjectiveData(qInfo, obj.StorageIndex);

                if (curItemCount >= reqItemCount) // we may have more than what the status shows
                    curItemCount = GetItemCount(entry, false);

                uint16 newItemCount = (count > curItemCount) ? 0 : curItemCount - count;

                if (newItemCount < reqItemCount)
                {
                    SetQuestObjectiveData(qInfo, &obj, newItemCount);
                    IncompleteQuest(questid);
                    return;
                }
            }
        }
    }
   
    AddDelayedEvent(100, [=]() -> void
    {
        if (this)
            UpdateForQuestWorldObjects();
    });
}

void Player::KilledMonster(CreatureTemplate const* cInfo, ObjectGuid guid)
{
    if (cInfo->Entry)
        KilledMonsterCredit(cInfo->Entry, guid);

    for (uint8 i = 0; i < MAX_KILL_CREDIT; ++i)
        if (cInfo->KillCredit[i])
            KilledMonsterCredit(cInfo->KillCredit[i]);
}

void Player::KilledMonsterCredit(uint32 entry, ObjectGuid guid /*= ObjectGuid::Empty*/)
{
    uint16 addKillCount = 1;
    uint32 real_entry = entry;
    Creature* killed = NULL;
    if (!guid.IsEmpty())
    {
        if (killed = GetMap()->GetCreature(guid))
        {
            if (killed->GetEntry())
                real_entry = killed->GetEntry();

            UpdateAchievementCriteria(CRITERIA_TYPE_KILL_CREATURE_TYPE, killed->GetCreatureType(), addKillCount, 0, killed);
            if (Guild* guild = sGuildMgr->GetGuildById(GetGuildId()))
                guild->UpdateAchievementCriteria(CRITERIA_TYPE_KILL_CREATURE_TYPE_GUILD, killed->GetCreatureType(), addKillCount, 0, killed, this);
        }
        AddKillCreature(real_entry, addKillCount, false);
    }

    m_achievementMgr->StartTimedAchievement(CRITERIA_TIMED_TYPE_CREATURE, real_entry);   // MUST BE CALLED FIRST
    UpdateAchievementCriteria(CRITERIA_TYPE_KILL_CREATURE, real_entry, addKillCount, 0, killed);

    if (killed)
        AddTrackingQuestIfNeeded(killed->GetGUID());

    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid);
        if (!qInfo)
            continue;
        // just if !ingroup || !noraidgroup || raidgroup
        QuestStatusData* q_status = getQuestStatus(questid);
        if (!q_status)
            continue;

        if (q_status->Status == QUEST_STATUS_INCOMPLETE && (!GetGroup() || !GetGroup()->isRaidGroup() || qInfo->IsAllowedInRaid(GetMap()->GetDifficultyID())))
        {
            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_KILL | QUEST_SPECIAL_FLAGS_CAST))
            {
                for (QuestObjective const& obj : qInfo->GetObjectives())
                {
                    if (obj.Type != QUEST_OBJECTIVE_MONSTER && obj.Type != QUEST_OBJECTIVE_TALKTO)
                        continue;

                    uint32 reqkill = obj.ObjectID;

                    if (reqkill == real_entry)
                    {
                        uint32 reqKillCount = obj.Amount;
                        uint16 curKillCount = GetQuestObjectiveData(qInfo, obj.StorageIndex);
                        if (curKillCount < reqKillCount)
                        {
                            SetQuestObjectiveData(qInfo, &obj, curKillCount + addKillCount);
                            SendQuestUpdateAddCredit(qInfo, guid, obj, curKillCount + addKillCount);
                            if (CanCompleteQuest(questid))
                                CompleteQuest(questid);
                            else
                            {
                                //Update phase or area spells by objective.
                                SetQuestStatus(questid, QUEST_STATUS_INCOMPLETE);
                            }
                            break;
                        }
                    }
                }
            }
        }
    }
}

void Player::KilledPlayerCredit()
{
    uint16 addKillCount = 1;

    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid);
        if (!qInfo)
            continue;

        // This flag is only used for performance optimisation to prevent iterating over all quests
        if (!qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_PLAYER_KILL))
            continue;

        // just if !ingroup || !noraidgroup || raidgroup
        QuestStatusData* q_status = getQuestStatus(questid);
        if (!q_status)
            continue;

        if (q_status->Status == QUEST_STATUS_INCOMPLETE && (!GetGroup() || !GetGroup()->isRaidGroup() || qInfo->IsAllowedInRaid(GetMap()->GetDifficultyID())))
        {
            for (QuestObjective const& obj : qInfo->GetObjectives())
            {
                if (obj.Type != QUEST_OBJECTIVE_PLAYERKILLS)
                    continue;

                uint32 curKillCount = GetQuestObjectiveData(qInfo, obj.StorageIndex);
                if (curKillCount < uint32(obj.Amount))
                {
                    SetQuestObjectiveData(qInfo, &obj, curKillCount + addKillCount);
                    SendQuestUpdateAddPlayer(qInfo, curKillCount + addKillCount, obj.Amount);

                    if (CanCompleteQuest(questid))
                        CompleteQuest(questid);
                    break;
                }
            }
        }
    }
}

void Player::KillCreditGO(uint32 entry, ObjectGuid const& guid)
{
    uint16 addCastCount = 1;
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid);
        if (!qInfo)
            continue;

        QuestStatusData* q_status = getQuestStatus(questid);
        if (!q_status)
            continue;

        if (q_status->Status == QUEST_STATUS_INCOMPLETE)
        {
            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_CAST) /*&& !qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_KILL)*/)
            {
                for (QuestObjective const& obj : qInfo->GetObjectives())
                {
                    if (obj.Type != QUEST_OBJECTIVE_GAMEOBJECT)
                        continue;

                    uint32 reqTarget = obj.ObjectID;

                    // other not this creature/GO related objectives
                    if (reqTarget != entry)
                        continue;

                    uint32 reqCastCount = obj.Amount;
                    uint32 curCastCount = GetQuestObjectiveData(qInfo, obj.StorageIndex);
                    if (curCastCount < reqCastCount)
                    {
                        SetQuestObjectiveData(qInfo, &obj, curCastCount + addCastCount);
                        SendQuestUpdateAddCredit(qInfo, guid, obj, curCastCount + addCastCount);
                        if (CanCompleteQuest(questid))
                            CompleteQuest(questid);
                        break;
                    }

                }
            }
        }
    }
}

bool Player::TalkedToCreature(uint32 entry, ObjectGuid guid)
{
    if (!guid)
        return false;

    uint16 addTalkCount = 1;
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid);
        if (!qInfo)
            continue;

        QuestStatusData* q_status = getQuestStatus(questid);
        if (!q_status)
            continue;

        if (q_status->Status == QUEST_STATUS_INCOMPLETE)
        {
            if (qInfo->HasSpecialFlag(QUEST_SPECIAL_FLAGS_KILL | QUEST_SPECIAL_FLAGS_CAST | QUEST_SPECIAL_FLAGS_SPEAKTO))
            {
                for (QuestObjective const& obj : qInfo->GetObjectives())
                {
                    if (obj.Type != QUEST_OBJECTIVE_MONSTER && obj.Type != QUEST_OBJECTIVE_TALKTO)
                        continue;

                    if (obj.ObjectID == entry)
                    {
                        uint32 reqTalkCount = obj.Amount;
                        uint32 curTalkCount = GetQuestObjectiveData(qInfo, obj.StorageIndex);
                        if (curTalkCount < reqTalkCount)
                        {
                            SetQuestObjectiveData(qInfo, &obj, curTalkCount + addTalkCount);
                            SendQuestUpdateAddCredit(qInfo, guid, obj, curTalkCount + addTalkCount);
                            if (CanCompleteQuest(questid))
                                CompleteQuest(questid);
                            return true;
                        }
                    }
                }
            }
        }
    }

    return false;
}

void Player::MoneyChanged(uint32 count)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid);
        if (qInfo && GetQuestMoneyReward(qInfo))
        {
            QuestStatusData* q_status = getQuestStatus(questid);
            if (!q_status)
                continue;

            if (q_status->Status == QUEST_STATUS_INCOMPLETE)
            {
                if (count >= GetQuestMoneyReward(qInfo))
                {
                    if (CanCompleteQuest(questid))
                        CompleteQuest(questid);
                }
            }
            else if (q_status->Status == QUEST_STATUS_COMPLETE)
            {
                if (count < GetQuestMoneyReward(qInfo))
                    IncompleteQuest(questid);
            }
        }
    }
}

void Player::ReputationChanged(FactionEntry const* factionEntry)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        if (uint32 questid = GetQuestSlotQuestId(i))
        {
            if (Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid))
            {
                QuestStatusData* q_status = getQuestStatus(questid);
                if (!q_status)
                    continue;

                for (QuestObjective const& obj : qInfo->GetObjectives())
                {
                    if (uint32(obj.ObjectID) != factionEntry->ID)
                        continue;

                    if (obj.Type == QUEST_OBJECTIVE_MIN_REPUTATION)
                    {
                        if (q_status->Status == QUEST_STATUS_INCOMPLETE)
                        {
                            if (GetReputationMgr().GetReputation(factionEntry) >= obj.Amount)
                                if (CanCompleteQuest(questid))
                                    CompleteQuest(questid);
                        }
                        else if (q_status->Status == QUEST_STATUS_COMPLETE)
                        {
                            if (GetReputationMgr().GetReputation(factionEntry) < obj.Amount)
                                IncompleteQuest(questid);
                        }
                    }
                    else if (obj.Type == QUEST_OBJECTIVE_MAX_REPUTATION)
                    {
                        if (q_status->Status == QUEST_STATUS_INCOMPLETE)
                        {
                            if (GetReputationMgr().GetReputation(factionEntry) <= obj.Amount)
                                if (CanCompleteQuest(questid))
                                    CompleteQuest(questid);
                        }
                        else if (q_status->Status == QUEST_STATUS_COMPLETE)
                        {
                            if (GetReputationMgr().GetReputation(factionEntry) > obj.Amount)
                                IncompleteQuest(questid);
                        }
                    }
                }
            }
        }
    }
}

void Player::CurrencyChanged(uint32 currencyID, int32 change)
{
    if (currencyID == 1325)
    {
        uint32 AllianceScore = sWorld->getWorldState(WS_SCORE_CALL_OF_THE_SCARAB_ALLINCE) + change;
        sWorld->setWorldState(WS_SCORE_CALL_OF_THE_SCARAB_ALLINCE, AllianceScore);
    }

    if (currencyID == 1324)
    {
        uint32 HordeScore = sWorld->getWorldState(WS_SCORE_CALL_OF_THE_SCARAB_HORDE) + change;
        sWorld->setWorldState(WS_SCORE_CALL_OF_THE_SCARAB_HORDE, HordeScore);
    }

    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (!questid)
            continue;

        Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid);
        if (!qInfo)
            continue;

        for (QuestObjective const& obj : qInfo->GetObjectives())
        {
            if (uint32(obj.ObjectID) != currencyID)
                continue;

            if (obj.Type != QUEST_OBJECTIVE_HAVE_CURRENCY)
                continue;

            QuestStatusData* q_status = getQuestStatus(questid);
            if (!q_status)
                continue;

            if (obj.Type == QUEST_OBJECTIVE_CURRENCY || obj.Type == QUEST_OBJECTIVE_HAVE_CURRENCY)
            {
                int64 value = GetCurrency(currencyID);
                if (obj.Type == QUEST_OBJECTIVE_HAVE_CURRENCY)
                    SetQuestObjectiveData(qInfo, &obj, int32(std::min<int64>(value, obj.Amount)));

                if (q_status->Status == QUEST_STATUS_INCOMPLETE)
                {
                    if (value >= obj.Amount)
                    {
                        if (CanCompleteQuest(questid))
                            CompleteQuest(questid);
                    }
                }
                else if (q_status->Status == QUEST_STATUS_COMPLETE)
                {
                    if (value < obj.Amount)
                        IncompleteQuest(questid);
                }
            }
            else if (obj.Type == QUEST_OBJECTIVE_OBTAIN_CURRENCY && change > 0) // currency losses are not accounted for in this objective type
            {
                SetQuestObjectiveData(qInfo,&obj, int32(std::max(std::min<int64>(GetQuestObjectiveData(qInfo, obj.StorageIndex) + change, obj.Amount), SI64LIT(0))));
                if (CanCompleteQuest(questid))
                    CompleteQuest(questid);
            }
        }
    }

    if (currencyID == CURRENCY_TYPE_HONOR_POINTS && change > 0 && m_honorInfo.HonorLevel != HonorInfo::MaxHonorLevel)
    {
        m_honorInfo.CurrentHonorAtLevel += change / sDB2Manager.GetCurrencyPrecision(currencyID);

        if (GtHonorLevelEntry const* data = sHonorLevelGameTable.GetRow(m_honorInfo.NextHonorLevel))
        {
            if (m_honorInfo.CurrentHonorAtLevel && m_honorInfo.CurrentHonorAtLevel >= data->Prestige[m_honorInfo.PrestigeLevel])
            {
                while (m_honorInfo.CurrentHonorAtLevel && m_honorInfo.CurrentHonorAtLevel >= data->Prestige[m_honorInfo.PrestigeLevel])
                {
                    if (m_honorInfo.HonorLevel == m_honorInfo.MaxHonorLevel)
                        break;

                    m_honorInfo.CurrentHonorAtLevel -= data->Prestige[m_honorInfo.PrestigeLevel];
                    if (m_honorInfo.IncreaseHonorLevel())
                    {
                        if (m_honorInfo.HonorLevel != m_honorInfo.MaxHonorLevel)
                            DeliveryRewardPack(sDB2Manager.GetHonorLevelRewardPack(m_honorInfo.HonorLevel, 0)); // First reward with 0 prestige for every level prestige
                        else
                            DeliveryRewardPack(sDB2Manager.GetHonorLevelRewardPack(m_honorInfo.HonorLevel, m_honorInfo.PrestigeLevel));
                    }

                    if (GtHonorLevelEntry const* data2 = sHonorLevelGameTable.GetRow(m_honorInfo.NextHonorLevel))
                        m_honorInfo.NextHonorAtLevel = data2->Prestige[m_honorInfo.PrestigeLevel];

                    UpdateAchievementCriteria(CRITERIA_TYPE_HONOR_LEVEL_UP, m_honorInfo.HonorLevel);
                    if (m_honorInfo.HonorLevel == m_honorInfo.MaxHonorLevel)
                        break;
                }
            }
            else
                m_honorInfo.NextHonorAtLevel = data->Prestige[m_honorInfo.PrestigeLevel];
        }

        SetUInt32Value(PLAYER_FIELD_HONOR, m_honorInfo.CurrentHonorAtLevel);
        SetUInt32Value(PLAYER_FIELD_HONOR_LEVEL, m_honorInfo.HonorLevel);
        SetUInt32Value(PLAYER_FIELD_HONOR_NEXT_LEVEL, m_honorInfo.NextHonorAtLevel);
    }
}

bool Player::HasQuestForItem(uint32 itemid) const
{
    Map const* map = GetMap();
    if (!map)
        return false;

    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        QuestStatusData const* status = const_cast<Player*>(this)->getQuestStatus(questid);
        if (!status)
            continue;

        if (status->Status == QUEST_STATUS_INCOMPLETE)
        {
            Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid);
            if (!qInfo)
                continue;

            // hide quest if player is in raid-group and quest is no raid quest
            if (GetGroup() && GetGroup()->isRaidGroup() && !qInfo->IsAllowedInRaid(map->GetDifficultyID()))
                if (!InBattleground()) //there are two ways.. we can make every bg-quest a raidquest, or add this code here.. i don't know if this can be exploited by other quests, but i think all other quests depend on a specific area.. but keep this in mind, if something strange happens later
                    continue;

            // There should be no mixed ReqItem/ReqSource drop
            // This part for ReqItem drop
            for (QuestObjective const& obj : qInfo->GetObjectives())
            {
                if (obj.Type == QUEST_OBJECTIVE_ITEM && itemid == uint32(obj.ObjectID) && GetQuestObjectiveData(qInfo, obj.StorageIndex) < obj.Amount)
                    return true;
            }
            // This part - for ReqSource
            for (uint8 j = 0; j < QUEST_ITEM_COUNT; ++j)
            {
                // examined item is a source item
                if (qInfo->ItemDrop[j] == itemid)
                {
                    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(itemid);

                    // 'unique' item
                    if (pProto->GetMaxCount() && (int32)GetItemCount(itemid, true) < pProto->GetMaxCount())
                        return true;

                    // allows custom amount drop when not 0
                    if (qInfo->ItemDropQuantity[j])
                    {
                        if (GetItemCount(itemid, true) < qInfo->ItemDropQuantity[j])
                            return true;
                    } else if (GetItemCount(itemid, true) < pProto->GetMaxStackSize())
                        return true;
                }
            }
        }
    }
    return false;
}

bool Player::HasQuestForCreature(CreatureTemplate const* cInfo) const
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid);
        if (!qInfo)
            continue;

        QuestStatusData const* status = const_cast<Player*>(this)->getQuestStatus(questid);
        if (!status)
            continue;

        // There should be no mixed ReqItem/ReqSource drop
        // This part for ReqItem drop
        for (QuestObjective const& obj : qInfo->GetObjectives())
        {
            switch (obj.Type)
            {
                case QUEST_OBJECTIVE_MONSTER:
                    if (cInfo->Entry == uint32(obj.ObjectID))
                        return true;
                    for (uint8 x = 0; x < MAX_KILL_CREDIT; ++x)
                        if (cInfo->KillCredit[x] && cInfo->KillCredit[x] == uint32(obj.ObjectID))
                            return true;
                    break;
                case QUEST_OBJECTIVE_ITEM:
                    for (uint8 v = 0; v < MAX_CREATURE_QUEST_ITEMS; ++v)
                        if (cInfo->QuestItem[v] && cInfo->QuestItem[v] == uint32(obj.ObjectID))
                            return true;
                    break;
                default:
                    break;
            }
        }
    }
    return false;
}

int32 Player::GetQuestObjectiveData(uint32 QuestID, uint32 ObjectID) const
{
    Quest const* quest = sQuestDataStore->GetQuestTemplate(QuestID);
    if (!quest)
        return 0;

    for (QuestObjective const& obj : quest->GetObjectives())
    {
        if (obj.ObjectID == ObjectID)
            return GetQuestObjectiveData(quest, obj.StorageIndex);
    }
    return 0;
}

int32 Player::GetQuestObjectiveData(Quest const* quest, int8 storageIndex) const
{
    QuestStatusData const* status = const_cast<Player*>(this)->getQuestStatus(quest->GetQuestId());
    if (!status)
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER, "GetQuestObjectiveData: player %s (%s) doesn't have quest status data for quest %u", GetName(), GetGUID().ToString().c_str(), quest->GetQuestId());
        return 0;
    }

    auto sItr = status->ObjectiveData.find(storageIndex);
    if (sItr == status->ObjectiveData.end())
        return 0;

    return sItr->second;
}

void Player::SetQuestObjectiveData(Quest const* quest, QuestObjective const* obj, int32 data, bool isLoad)
{
    QuestStatusData* status = getQuestStatus(quest->GetQuestId());
    if (!status)
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER, "SetQuestObjectiveData: player %s (%s) doesn't have quest status data for quest %u", GetName(), GetGUID().ToString().c_str(), quest->GetQuestId());
        return;
    }

    if (isLoad && !data)
        if (obj->Type == QUEST_OBJECTIVE_COMPLETE_CRITERIA_TREE)
            if (CriteriaTree const* tree = sAchievementMgr->GetCriteriaTree(obj->ObjectID))
                data = m_achievementMgr->IsCompletedCriteriaTree(tree);

    // No change
    if (status->ObjectiveData[obj->StorageIndex] == data)
        return;

    // Set data
    status->ObjectiveData[obj->StorageIndex] = data;

    // Add to save
    if (!isLoad)
        m_QuestStatusSave[quest->GetQuestId()] = QUEST_DEFAULT_SAVE_TYPE;

    if (status->Status == QUEST_STATUS_INCOMPLETE || status->Status == QUEST_STATUS_COMPLETE)
    {
        // Update quest fields
        // Negative index  - hiden
        uint16 log_slot = FindQuestSlot(quest->GetQuestId());
        if (log_slot < MAX_QUEST_LOG_SIZE)
        {
            SetQuestSlotCounter(log_slot, obj->StorageIndex, status->ObjectiveData[obj->StorageIndex]);
            if (obj->IsStoringFlag())
            {
                if (data)
                    SetQuestSlotState(log_slot, QUEST_STATUS_COMPLETE);
                else
                    RemoveQuestSlotState(log_slot, QUEST_STATUS_COMPLETE);
            }
        }

        //if (log_slot < MAX_QUEST_LOG_SIZE && obj->StorageIndex >= 0 /*&& (obj->Flags & QUEST_OBJECTIVE_FLAG_SEQUENCED) == 0*/ && obj->Type != QUEST_OBJECTIVE_COMPLETE_CRITERIA_TREE)
        //    SetQuestSlotCounter(log_slot, obj->StorageIndex, status->ObjectiveData[obj->StorageIndex]);

        if (log_slot < MAX_QUEST_LOG_SIZE && obj->IsStoringFlag())
        {
            SetSpecialCriteriaComplete(log_slot, obj->StorageIndex);
            if (!isLoad)
            {
                WorldPackets::Quest::QuestUpdateAddCreditSimple packet;
                packet.QuestID = quest->GetQuestId();
                packet.ObjectID = obj->ObjectID;
                packet.ObjectiveType = obj->Type;
                SendDirectMessage(packet.Write());
            }
        }
    }
}

bool Player::HasCompletedQuest(uint32 questId) const
{
    return GetQuestStatus(questId) == QUEST_STATUS_REWARDED;
}

void Player::UpdateQuestObjectiveData(Quest const* quest)
{
    QuestStatusData* status = getQuestStatus(quest->GetQuestId());
    if (!status)
        return;

    for (QuestObjective const& obj : quest->GetObjectives())
    {
        TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "UpdateQuestObjectiveData ObjectiveData %u StorageIndex %u", status->ObjectiveData[obj.StorageIndex], obj.StorageIndex);

        // No change
        if (status->ObjectiveData[obj.StorageIndex] == 0)
            continue;

        // Update quest fields
        // Negative index  - hiden
        uint16 log_slot = FindQuestSlot(quest->GetQuestId());
        if (log_slot < MAX_QUEST_LOG_SIZE && obj.StorageIndex >= 0 /*&& (obj.Flags & QUEST_OBJECTIVE_FLAG_SEQUENCED) == 0*/ && obj.Type != QUEST_OBJECTIVE_COMPLETE_CRITERIA_TREE)
            SetQuestSlotCounter(log_slot, obj.StorageIndex, status->ObjectiveData[obj.StorageIndex]);

        if (log_slot < MAX_QUEST_LOG_SIZE && obj.Type == QUEST_OBJECTIVE_COMPLETE_CRITERIA_TREE)
            SetSpecialCriteriaComplete(log_slot, obj.StorageIndex);
    }
}

void Player::SendQuestComplete(Quest const* quest)
{
    if (quest)
    {
        WorldPackets::Quest::QuestUpdateComplete data;
        data.QuestID = quest->GetQuestId();
        SendDirectMessage(data.Write());
    }
}

void Player::SendQuestReward(Quest const* quest, uint32 XP, Object* questGiver, int32 moneyReward, Item* item, bool hideChatMessage)
{
    uint32 questId = quest->GetQuestId();
    sGameEventMgr->HandleQuestComplete(questId);

    uint32 xp = 0;

    if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        xp = XP;
    else // At max level, increase gold reward
        xp = 0;

    if (quest->Type == QUEST_TYPE_TASK)
    {
        WorldPackets::Misc::SetTaskComplete task;
        task.TaskID = questId;
        SendDirectMessage(task.Write());
    }

    WorldPackets::Quest::QuestGiverQuestComplete packet;
    packet.QuestID = questId;
    packet.MoneyReward = moneyReward;
    packet.XPReward = xp;
    packet.SkillLineIDReward = quest->RewardSkillId;
    packet.NumSkillUpsReward = quest->RewardSkillPoints;
    packet.HideChatMessage = hideChatMessage;

    if (questGiver && questGiver->IsCreature())
    {
        if (auto giver = questGiver->ToCreature())
        {
            if (giver->isGossip())
                packet.LaunchGossip = true;
            else if (giver->isQuestGiver())
                packet.LaunchQuest = true;
            else if (quest->NextQuestIdChain && !quest->HasFlag(QUEST_FLAGS_AUTOCOMPLETE))
                packet.UseQuestReward = true;

            giver->AI()->OnQuestReward(this, quest);
        }
    }

    if (item)
        packet.ItemReward.Initialize(item);

    SendDirectMessage(packet.Write());
    
    sScriptMgr->OnPlayerQuestReward(this, quest);

    if (quest->CompleteScript)
        GetMap()->ScriptsStart(sQuestEndScripts, quest->CompleteScript, questGiver, this);

    if (Garrison* garr = GetGarrisonPtr())
        garr->OnQuestReward(questId);
}

void Player::SendQuestFailed(uint32 questId, InventoryResult reason)
{
    if (questId)
    {
        WorldPackets::Quest::QuestGiverQuestFailed failed;
        failed.QuestID = questId;
        failed.Reason = reason;
        SendDirectMessage(failed.Write());
    }
}

void Player::SendQuestTimerFailed(uint32 questID)
{
    if (questID)
        SendDirectMessage(WorldPackets::Quest::QuestUpdateFailedTimer(questID).Write());
}

void Player::SendCanTakeQuestResponse(uint32 msg, Quest const* qInfo, std::string str) const
{
    WorldPackets::Quest::QuestGiverInvalidQuest invalidQuest;
    invalidQuest.Reason = msg;
    invalidQuest.SendErrorMessage = str.size();
    invalidQuest.ReasonText = str;
    SendDirectMessage(invalidQuest.Write());
}

void Player::SendQuestConfirmAccept(Quest const* quest, Player* receiver)
{
    if (receiver)
    {
        std::string questTitle = quest->LogTitle;
        if (QuestTemplateLocale const* pLocale = sQuestDataStore->GetQuestLocale(quest->GetQuestId()))
            ObjectMgr::GetLocaleString(pLocale->LogTitle, receiver->GetSession()->GetSessionDbLocaleIndex(), questTitle);

        WorldPackets::Quest::QuestConfirmAcceptResponse packet;
        packet.QuestID = quest->GetQuestId();
        packet.InitiatedBy = GetGUID();
        packet.QuestTitle = questTitle;
        receiver->SendDirectMessage(packet.Write());
    }
}

void Player::SendPushToPartyResponse(Player* player, uint8 reason)
{
    if (player)
    {
        WorldPackets::Quest::QuestPushResultResponse data;
        data.SenderGUID = player->GetGUID();
        data.Result = reason;
        SendDirectMessage(data.Write());
    }
}

void Player::SendQuestUpdateAddCredit(Quest const* quest, ObjectGuid guid, QuestObjective const& obj, uint16 count)
{
    if (quest->Type == QUEST_TYPE_TASK)
        return;

    WorldPackets::Quest::QuestUpdateAddCredit packet;
    packet.VictimGUID = guid;
    packet.QuestID = quest->GetQuestId();
    packet.ObjectID = obj.ObjectID;
    packet.Count = count;
    packet.Required = obj.Amount;
    packet.ObjectiveType = obj.Type;
    SendDirectMessage(packet.Write());
}

void Player::SendQuestUpdateAddPlayer(Quest const* quest, uint16 old_count, uint16 add_count)
{
    ASSERT(old_count + add_count < 65536 && "player count store in 16 bits");

    WorldPackets::Quest::QuestUpdateAddPvPCredit credit;
    credit.QuestID = quest->GetQuestId();
    credit.Count = old_count + add_count;
    SendDirectMessage(credit.Write());
}

/*********************************************************/
/***                   LOAD SYSTEM                     ***/
/*********************************************************/

void Player::Initialize(ObjectGuid::LowType guid)
{
    Object::_Create(ObjectGuid::Create<HighGuid::Player>(guid));
}

void Player::_LoadDeclinedNames(PreparedQueryResult result)
{
    if (!result)
        return;

    delete m_declinedname;
    m_declinedname = new DeclinedName;
    for (uint8 i = 0; i < MAX_DECLINED_NAME_CASES; ++i)
        m_declinedname->name[i] = (*result)[i].GetString();
}

void Player::_LoadEquipmentSets(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();
        if (!fields)
            return;

        EquipmentSetInfo eqSet;
        eqSet.Data.Type = EquipmentSetInfo::EQUIPMENT;
        eqSet.State = EQUIPMENT_SET_UNCHANGED;
        eqSet.Data.Appearances.fill(0);
        eqSet.Data.Enchants.fill(0);

        eqSet.Data.Guid = fields[0].GetUInt64();
        eqSet.Data.SetID = fields[1].GetUInt8();
        eqSet.Data.SetName = fields[2].GetString();
        eqSet.Data.SetIcon = fields[3].GetString();
        eqSet.Data.IgnoreMask = fields[4].GetUInt32();
        eqSet.Data.AssignedSpecIndex = fields[5].GetInt32();

        for (uint8 i = 0; i < EQUIPMENT_SLOT_END; ++i)
            if (ObjectGuid::LowType guid = fields[6 + i].GetUInt64())
                eqSet.Data.Pieces[i] = ObjectGuid::Create<HighGuid::Item>(guid);

        if (eqSet.Data.SetID >= MAX_EQUIPMENT_SET_INDEX)
            continue;

        _equipmentSets[eqSet.Data.Guid] = eqSet;
    }
    while (result->NextRow());
}

void Player::_LoadTransmogOutfits(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();
        if (!fields)
            return;

        EquipmentSetInfo eqSet;
        eqSet.Data.Type = EquipmentSetInfo::TRANSMOG;
        eqSet.State = EQUIPMENT_SET_UNCHANGED;
        eqSet.Data.Pieces.fill(ObjectGuid::Empty);

        eqSet.Data.Guid = fields[0].GetUInt64();
        eqSet.Data.SetID = fields[1].GetUInt8();
        eqSet.Data.SetName = fields[2].GetString();
        eqSet.Data.SetIcon = fields[3].GetString();
        eqSet.Data.IgnoreMask = fields[4].GetUInt32();

        for (uint32 i = 0; i < EQUIPMENT_SLOT_END; ++i)
            eqSet.Data.Appearances[i] = fields[5 + i].GetInt32();

        for (std::size_t i = 0; i < eqSet.Data.Enchants.size(); ++i)
            eqSet.Data.Enchants[i] = fields[24 + i].GetInt32();

        if (eqSet.Data.SetID >= MAX_EQUIPMENT_SET_INDEX)
            continue;

        _equipmentSets[eqSet.Data.Guid] = eqSet;
    } while (result->NextRow());
}

void Player::_LoadPetData(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();
        m_petInfo[fields[0].GetUInt32()].UpdateData(fields);

        TC_LOG_ERROR(LOG_FILTER_PETS, "_LoadPetData: pet_number %u", fields[0].GetUInt32());

    } while (result->NextRow());
}

void Player::_LoadBGData(PreparedQueryResult result)
{
    if (!result)
        return;

    Field* fields = result->Fetch();
    // Expecting only one row
    //        0           1     2      3      4      5      6          7          8        9           10
    // SELECT instanceId, team, joinX, joinY, joinZ, joinO, joinMapId, taxiStart, taxiEnd, mountSpell, lastActiveSpec FROM character_battleground_data WHERE guid = ?

    m_bgData.BgInstanceID = fields[0].GetUInt32();
    m_bgData.BgTeam       = fields[1].GetUInt16();
    m_bgData.JoinPosition      = WorldLocation(fields[6].GetUInt16(),    // Map
                                          fields[2].GetFloat(),     // X
                                          fields[3].GetFloat(),     // Y
                                          fields[4].GetFloat(),     // Z
                                          fields[5].GetFloat());    // Orientation
    m_bgData.TaxiPath[0]  = fields[7].GetUInt32();
    m_bgData.TaxiPath[1]  = fields[8].GetUInt32();
    m_bgData.MountSpellID   = fields[9].GetUInt32();
    m_bgData.LastActiveSpecID = fields[10].GetUInt8();
}

bool Player::LoadPositionFromDB(uint32& mapid, float& x, float& y, float& z, float& o, bool& in_flight, ObjectGuid guid)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHAR_POSITION);
    stmt->setUInt64(0, guid.GetCounter());
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (!result)
        return false;

    Field* fields = result->Fetch();

    x = fields[0].GetFloat();
    y = fields[1].GetFloat();
    z = fields[2].GetFloat();
    o = fields[3].GetFloat();
    mapid = fields[4].GetUInt16();
    in_flight = !fields[5].GetString().empty();

    return true;
}

uint32 GetSelectionFromContext(uint32 context, uint32 playerClass)
{
    switch (context)
    {
        case 1:
            if (playerClass == CLASS_DEATH_KNIGHT)
                return 1;
            if (playerClass == CLASS_DEMON_HUNTER)
                return 3;
            return 0;
        case 2:
            if (playerClass == CLASS_DEATH_KNIGHT)
                return 5;
            if (playerClass == CLASS_DEMON_HUNTER)
                return 6;
            return 4;
        case 3:
            return 7;
        case 4:
            if (playerClass == CLASS_DEATH_KNIGHT)
                return 9;
            if (playerClass == CLASS_DEMON_HUNTER)
                return 10;
            return 8;
        default:
            if (playerClass == CLASS_DEATH_KNIGHT)
                return 1;
            if (playerClass == CLASS_DEMON_HUNTER)
                return 2;
            return 0;
    }
}

bool ComponentFlagsMatch(CharSectionsEntry const* entry, uint32 selection)
{
    switch (selection)
    {
        case 0:
            if (!(entry->Flags & 1))
                return false;
            return !(entry->Flags & 0x2C);
        case 1:
            if (!(entry->Flags & 1))
                return false;
            if (!(entry->Flags & 0x94))
                return false;
            return !(entry->Flags & 8);
        case 2:
            if (!(entry->Flags & 1))
                return false;
            if (!(entry->Flags & 0x70))
                return false;
            return !(entry->Flags & 8);
        case 3:
            if (!(entry->Flags & 1))
                return false;
            if (!(entry->Flags & 0x20))
                return false;
            return !(entry->Flags & 8);
        case 4:
        case 8:
            if (!(entry->Flags & 3))
                return false;
            return !(entry->Flags & 0x2C);
        case 5:
        case 9:
            if (!(entry->Flags & 3))
                return false;
            if (!(entry->Flags & 0x94))
                return false;
            return !(entry->Flags & 8);
        case 6:
        case 10:
            if (!(entry->Flags & 3))
                return false;
            if (!(entry->Flags & 0x70))
                return false;
            return !(entry->Flags & 8);
        case 7:
            return true;
        default:
            break;
    }

    return false;
}

bool IsSectionFlagValid(CharSectionsEntry const* entry, uint8 class_, bool create)
{
    if (create)
        return ComponentFlagsMatch(entry, GetSelectionFromContext(0, class_));

    return ComponentFlagsMatch(entry, GetSelectionFromContext(2, class_));
}

bool IsSectionValid(uint8 race, uint8 class_, uint8 gender, CharBaseSectionVariation variation, uint8 variationIndex, uint8 colorIndex, bool create)
{
    if (auto section = sDB2Manager.GetCharSectionEntry(race, gender, variation, variationIndex, colorIndex))
        return IsSectionFlagValid(section, class_, create);

    return false;
}

bool Player::ValidateAppearance(uint8 race, uint8 class_, uint8 gender, uint8 hairID, uint8 hairColor, uint8 faceID, uint8 facialHairID, uint8 skinColor, std::array<uint8, PLAYER_CUSTOM_DISPLAY_SIZE> const& customDisplay, bool create /*= false*/)
{
    if (!IsSectionValid(race, class_, gender, CharBaseSectionVariation::Skin, 0, skinColor, create))
        return false;

    if (!IsSectionValid(race, class_, gender, CharBaseSectionVariation::Face, faceID, skinColor, create))
        return false;

    if (!IsSectionValid(race, class_, gender, CharBaseSectionVariation::Hair, hairID, hairColor, create))
        return false;

    if (!IsSectionValid(race, class_, gender, CharBaseSectionVariation::FacialHair, facialHairID, hairColor, create))
        if (sDB2Manager.HasCharSections(race, gender, CharBaseSectionVariation::FacialHair) || !sDB2Manager.HasCharacterFacialHairStyle(race, gender, facialHairID))
            return false;

    if (!IsSectionValid(race, class_, gender, CharBaseSectionVariation::CustomDisplay1, customDisplay[0], 0, create))
        return false;

    if (!IsSectionValid(race, class_, gender, CharBaseSectionVariation::CustomDisplay2, customDisplay[1], 0, create))
        return false;

    if (!IsSectionValid(race, class_, gender, CharBaseSectionVariation::CustomDisplay3, customDisplay[2], 0, create))
        return false;

    return true;
}

void Player::SetHomebind(WorldLocation const& loc, uint32 area_id)
{
    m_homebindMapId  = loc.GetMapId();
    m_homebindAreaId = area_id;
    m_homebindX      = loc.GetPositionX();
    m_homebindY      = loc.GetPositionY();
    m_homebindZ      = loc.GetPositionZ();

    // update sql homebind
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_PLAYER_HOMEBIND);
    stmt->setUInt16(0, m_homebindMapId);
    stmt->setUInt16(1, m_homebindAreaId);
    stmt->setFloat (2, m_homebindX);
    stmt->setFloat (3, m_homebindY);
    stmt->setFloat (4, m_homebindZ);
    stmt->setUInt64(5, GetGUIDLow());
    CharacterDatabase.Execute(stmt);
}

void Player::SendBindPointUpdate()
{
    WorldPackets::Misc::BindPointUpdate packet;
    packet.BindPosition = Position(m_homebindX, m_homebindY, m_homebindZ);
    packet.BindMapID = m_homebindMapId;
    packet.BindAreaID = m_homebindAreaId;
    SendDirectMessage(packet.Write());
}

uint32 Player::GetUInt32ValueFromArray(Tokenizer const& data, uint16 index)
{
    if (index >= data.size())
        return 0;

    return static_cast<uint32>(atoi(data[index]));
}

float Player::GetFloatValueFromArray(Tokenizer const& data, uint16 index)
{
    float result;
    uint32 temp = Player::GetUInt32ValueFromArray(data, index);
    memcpy(&result, &temp, sizeof(result));

    return result;
}

bool Player::LoadFromDB(ObjectGuid guid, SQLQueryHolder *holder)
{
    enum fieldIDX
    {
        f_guid, f_account, f_name, f_race, f_class, f_level, f_xp, f_money, f_skin, f_face, f_hairstyle, f_haircolor, f_facialhair, f_blindfold, f_gender, f_tattoo, f_horn, f_inventorySlots, f_bankslots, f_drunk, f_playerFlags,
        f_playerFlagsEx, f_position_x, f_position_y, f_position_z, f_map, f_orientation, f_taximask, f_cinematic, f_totaltime, f_leveltime, f_rest_bonus, f_logout_time, f_is_logout_resting,
        f_trans_x, f_trans_y, f_trans_z, f_trans_o, f_transguid, f_extra_flags, f_at_login, f_zone, f_online, f_death_expire_time, f_taxi_path, f_dungeonDifficulty,
        f_totalKills, f_todayKills, f_yesterdayKills, f_chosenTitle, f_watchedFaction,
        f_health, f_mana, f_instance_id, f_activespec, f_specialization, f_lootspecialization, f_exploredZones, f_equipmentCache, f_knownTitles, f_actionBars,
        f_currentpetnumber, f_petslot, f_grantableLevels, f_lfgBonusFaction, f_raidDifficulty, f_legacyRaidDifficulty, f_created_time,
        f_killPoints
    };

    PreparedQueryResult result = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADFROM);

    if (!result)
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (GUID: %u) not found in table `characters`, can't load. ", guid.GetCounter());
        return false;
    }

    Field* fields = result->Fetch();

    uint32 dbAccountId = fields[f_account].GetUInt32();

    // check if the character's account in the db and the logged in account match.
    // player should be able to load/delete character only with correct account!
    if (dbAccountId != GetSession()->GetAccountId())
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (GUID: %u) loading from wrong account (is: %u, should be: %u)", guid.GetCounter(), GetSession()->GetAccountId(), dbAccountId);
        return false;
    }

    if (holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADBANNED))
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (GUID: %u) is banned, can't load.", guid.GetCounter());
        return false;
    }

    Object::_Create(guid);

    m_name = fields[f_name].GetString();

    // check name limitations
    if (sCharacterDataStore->CheckPlayerName(m_name, GetSession()->GetSessionDbcLocale()) != CHAR_NAME_SUCCESS || (AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()) && sCharacterDataStore->IsReservedName(m_name)))
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_ADD_AT_LOGIN_FLAG);

        stmt->setUInt16(0, uint16(AT_LOGIN_RENAME));
        stmt->setUInt64(1, guid.GetCounter());

        CharacterDatabase.Execute(stmt);

        return false;
    }

    // overwrite possible wrong/corrupted guid
    SetGuidValue(OBJECT_FIELD_GUID, guid);
    SetGuidValue(PLAYER_FIELD_WOW_ACCOUNT, GetSession()->GetAccountGUID());

    uint8 Gender = fields[f_gender].GetUInt8();
    if (!IsValidGender(Gender))
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (GUID: %u) has wrong gender (%hu), can't be loaded.", guid.GetCounter(), Gender);
        return false;
    }

    // overwrite some data fields
    uint8 classID = fields[f_class].GetUInt8();
    SetRace(fields[f_race].GetUInt8());
    SetClass(classID);
    SetGender(Gender);

    SetUInt32Value(UNIT_FIELD_LEVEL, fields[f_level].GetUInt8());
    if (getLevel() > MAX_LEVEL)
        SetUInt32Value(UNIT_FIELD_LEVEL, MAX_LEVEL);
    SetUInt32Value(UNIT_FIELD_EFFECTIVE_LEVEL, 0);
    SetXP(fields[f_xp].GetUInt32());

    _LoadIntoDataField(fields[f_exploredZones].GetString(), PLAYER_FIELD_EXPLORED_ZONES, PLAYER_EXPLORED_ZONES_SIZE);
    _LoadIntoDataField(fields[f_knownTitles].GetString(), PLAYER_FIELD_KNOWN_TITLES, KNOWN_TITLES_SIZE * 2);

    SetFloatValue(UNIT_FIELD_BOUNDING_RADIUS, DEFAULT_WORLD_OBJECT_SIZE);
    SetFloatValue(UNIT_FIELD_COMBAT_REACH, 1.5f);
    SetFloatValue(UNIT_FIELD_HOVER_HEIGHT, 1.0f);

    for (uint16 i = 0; i < uint16(sItemModifiedAppearanceStore.GetNumRows()/32); ++i)
        AddDynamicValue(PLAYER_DYNAMIC_FIELD_TRANSMOG, 0);

    // load achievements before anything else to prevent multiple gains for the same achievement/criteria on every loading (as loading does call UpdateAchievementCriteria)
    m_achievementMgr->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADACHIEVEMENTS),
                                holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADCRITERIAPROGRESS),
                                holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADACCOUNTACHIEVEMENTS),
                                holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADACCOUNTCRITERIAPROGRESS));

    uint64 money = fields[f_money].GetUInt64();
    if (money > MAX_MONEY_AMOUNT)
        money = MAX_MONEY_AMOUNT;
    SetMoney(money);

    SetByteValue(PLAYER_FIELD_BYTES_1, PLAYER_BYTES_1_SKIN_ID, fields[f_skin].GetUInt8());
    SetByteValue(PLAYER_FIELD_BYTES_1, PLAYER_BYTES_1_FACE_ID, fields[f_face].GetUInt8());
    SetByteValue(PLAYER_FIELD_BYTES_1, PLAYER_BYTES_1_HAIR_STYLE_ID, fields[f_hairstyle].GetUInt8());
    SetByteValue(PLAYER_FIELD_BYTES_1, PLAYER_BYTES_1_HAIR_COLOR_ID, fields[f_haircolor].GetUInt8());

    SetByteValue(PLAYER_FIELD_BYTES_2, PLAYER_BYTES_2_TATOO, fields[f_tattoo].GetUInt8());
    SetByteValue(PLAYER_FIELD_BYTES_2, PLAYER_BYTES_2_HORN, fields[f_horn].GetUInt8());
    SetByteValue(PLAYER_FIELD_BYTES_2, PLAYER_BYTES_2_OFFSET_BLIND_FOLD, fields[f_blindfold].GetUInt8());
    SetByteValue(PLAYER_FIELD_BYTES_2, PLAYER_BYTES_2_OFFSET_FACIAL_STYLE, fields[f_facialhair].GetUInt8());

    SetByteValue(PLAYER_FIELD_BYTES_3, PLAYER_BYTES_3_OFFSET_BANK_BAG_SLOTS, fields[f_bankslots].GetUInt8());
    SetByteValue(PLAYER_FIELD_BYTES_3, PLAYER_BYTES_3_OFFSET_GENDER, Gender);
    SetByteValue(PLAYER_FIELD_BYTES_3, PLAYER_BYTES_3_OFFSET_INEBRIATION, fields[f_drunk].GetUInt8());

    SetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS, fields[f_playerFlags].GetUInt32());
    SetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS_EX, fields[f_playerFlagsEx].GetUInt32());
    SetInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX, fields[f_watchedFaction].GetInt32());

    SetFlag(PLAYER_FIELD_LOCAL_FLAGS, PLAYER_LOCAL_FLAG_ACCOUNT_SECURED);
    SetInventorySlotCount(fields[f_inventorySlots].GetUInt8() > 0 ? fields[f_inventorySlots].GetUInt8() : INVENTORY_DEFAULT_SIZE);
    // set which actionbars the client has active - DO NOT REMOVE EVER AGAIN (can be changed though, if it does change fieldwise)

    SetByteValue(PLAYER_FIELD_BYTES_4, PLAYER_BYTES_4_ACTION_BAR_TOGGLES, fields[f_actionBars].GetUInt8());

    m_currentPetNumber = fields[f_currentpetnumber].GetInt32();
    LoadPetSlot(fields[f_petslot].GetCString());

    InitDisplayIds();

    // cleanup inventory related item value fields (its will be filled correctly in _LoadInventory)
    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        SetGuidValue(PLAYER_FIELD_INV_SLOTS + (slot * 4), ObjectGuid::Empty);
        SetVisibleItemSlot(slot, NULL);

        delete m_items[slot];
        m_items[slot] = NULL;
    }

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Load Basic value of player %s is: ", m_name.c_str());
    outDebugValues();

    //Need to call it to initialize m_team (m_team can be calculated from race)
    //Other way is to saves m_team into characters table.
    setFactionForRace(getRace());

    // load home bind and check in same time class/race pair, it used later for restore broken positions
    if (!_LoadHomeBind(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADHOMEBIND)))
        return false;

    InitPrimaryProfessions();                               // to max set before any spell loaded

    // init saved position, and fix it later if problematic
    ObjectGuid::LowType transLowGUID = uint32(fields[f_transguid].GetUInt64());

    Relocate(fields[f_position_x].GetFloat(), fields[f_position_y].GetFloat(), fields[f_position_z].GetFloat(), fields[f_orientation].GetFloat());

    uint32 mapId = fields[f_map].GetUInt16();
    uint32 instanceId = fields[f_instance_id].GetUInt32();

    SetDungeonDifficultyID(CheckLoadedDungeonDifficultyID(Difficulty(fields[f_dungeonDifficulty].GetUInt8())));
    SetRaidDifficultyID(CheckLoadedRaidDifficultyID(Difficulty(fields[f_raidDifficulty].GetUInt8())));
    SetLegacyRaidDifficultyID(CheckLoadedLegacyRaidDifficultyID(Difficulty(fields[f_legacyRaidDifficulty].GetUInt8())));

    _garrison->LoadFromDB(
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GARRISON),
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GARRISON_BLUEPRINTS),
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GARRISON_BUILDINGS),
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GARRISON_FOLLOWERS),
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GARRISON_FOLLOWER_ABILITIES),
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GARRISON_MISSIONS),
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GARRISON_SHIPMENTS),
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GARRISON_TALENTS));


    std::string taxi_nodes = fields[f_taxi_path].GetString();

#define RelocateToHomebind(){ mapId = m_homebindMapId; instanceId = 0; Relocate(m_homebindX, m_homebindY, m_homebindZ); }

    _LoadGroup(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADGROUP));
    _LoadLootCooldown(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_LOOTCOOLDOWN));
    _LoadLfgCooldown(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_LFGCOOLDOWN));
    _LoadKillCreature(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_KILL_CREATURE));

    _LoadCurrency(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADCURRENCY));

    InitBrackets();

    SetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, fields[f_totalKills].GetUInt32());
    SetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0, fields[f_todayKills].GetUInt16());
    SetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1, fields[f_yesterdayKills].GetUInt16());

    _LoadBoundInstances(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADBOUNDINSTANCES));
    _LoadBGData(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADBGDATA));

    _LoadPetData(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_PETS));

    GetSession()->SetPlayer(this);
    MapEntry const* mapEntry = sMapStore.LookupEntry(mapId);

    m_atLoginFlags = fields[f_at_login].GetUInt16();
    bool mustResurrectFromUnlock = false;

    if(m_atLoginFlags & AT_LOGIN_UNLOCK)
    {
        bool BGdesert = false;
        bool DungeonDesert = false;
        bool MalDeRez = false;

        RemoveAtLoginFlag(AT_LOGIN_UNLOCK, true);
        if (HasAura(SPELL_BG_DESERTER)) // deserteur
            BGdesert = true;
        if (HasAura(71041)) // deserteur de donjon
            DungeonDesert = true;
        if (HasAura(15007))
            MalDeRez = true;

        RemoveAllAuras();
        RemoveFromGroup();

        if (BGdesert)
            AddAura(SPELL_BG_DESERTER, this);
        if (DungeonDesert)
            AddAura(71041, this);
        if (MalDeRez)
            AddAura(15007, this);

        mustResurrectFromUnlock = true;
        RelocateToHomebind();
    }
    else if (!mapEntry || !IsPositionValid())
    {
        RemoveAtLoginFlag(AT_LOGIN_UNLOCK, true);
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (guidlow %d) have invalid coordinates (MapId: %u X: %f Y: %f Z: %f O: %f). Teleport to default race/class locations.", guid.GetCounter(), mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
        RelocateToHomebind();
    }
    // Player was saved in Arena or Bg
    else if (mapEntry && mapEntry->IsBattlegroundOrArena())
    {
        Battleground* currentBg = NULL;
        if (m_bgData.BgInstanceID)                                                //saved in Battleground
            currentBg = sBattlegroundMgr->GetBattleground(m_bgData.BgInstanceID, MS::Battlegrounds::BattlegroundTypeId::None);

        bool player_at_bg = currentBg && currentBg->IsPlayerInBattleground(GetGUID());

        if (player_at_bg && currentBg->GetStatus() != STATUS_WAIT_LEAVE)
        {
            uint8 bgQueueTypeId = MS::Battlegrounds::GetBgQueueTypeIdByBgTypeID(currentBg->GetTypeID(), currentBg->GetJoinType());
            AddBattlegroundQueueId(bgQueueTypeId);

            m_bgData.BgTypeID = currentBg->GetTypeID();

            //join player to battleground group
            currentBg->EventPlayerLoggedIn(this);
            currentBg->AddOrSetPlayerToCorrectBgGroup(this, m_bgData.BgTeam);

            SetInviteForBattlegroundQueueType(bgQueueTypeId, currentBg->GetInstanceID());
        }
        // Bg was not found - go to Entry Point
        else
        {
            // leave bg
            if (player_at_bg)
                currentBg->RemovePlayerAtLeave(GetGUID(), false, true);

            // Do not look for instance if bg not found
            const WorldLocation& _loc = GetBattlegroundEntryPoint();
            mapId = _loc.GetMapId(); instanceId = 0;

            // Db field type is type int16, so it can never be MAPID_INVALID
            //if (mapId == MAPID_INVALID) -- code kept for reference
            if (int16(mapId) == int16(-1)) // Battleground Entry Point not found (???)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (guidlow %d) was in BG in database, but BG was not found, and entry point was invalid! Teleport to default race/class locations.", guid.GetCounter());
                RelocateToHomebind();
            }
            else
                Relocate(&_loc);

            // We are not in BG anymore
            m_bgData.BgInstanceID = 0;
        }
    }
    // currently we do not support transport in bg and in world, because guid is dinamyc and after restart server guis have new value
    else if (transLowGUID)
    {
        /*ObjectGuid transGUID = ObjectGuid::Create<HighGuid::Transport>(transLowGUID);

        Transport* transport = nullptr;
        if (GameObject* go = HashMapHolder<GameObject>::Find(transGUID))
            transport = reinterpret_cast<Transport*>(go);

        if (transport)
        {
            float x = fields[f_trans_x].GetFloat(), y = fields[f_trans_y].GetFloat(), z = fields[f_trans_z].GetFloat(), o = fields[f_trans_o].GetFloat();
            m_movementInfo.transport.Pos.Relocate(x, x, z, o);
            transport->CalculatePassengerPosition(x, y, z, &o);

            if (!Trinity::IsValidMapCoord(x, y, z, o) ||
                // transport size limited
                m_movementInfo.transport.Pos.m_positionX > 250 || m_movementInfo.transport.Pos.m_positionY > 250 || m_movementInfo.transport.Pos.m_positionZ > 250)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (guidlow %d) have invalid transport coordinates (X: %f Y: %f Z: %f O: %f). Teleport to bind location.", guid.GetCounter(), GetPositionX()+m_movementInfo.transport.Pos.m_positionX, GetPositionY()+m_movementInfo.transport.Pos.m_positionY, GetPositionZ()+m_movementInfo.transport.Pos.m_positionZ, GetOrientation()+m_movementInfo.transport.Pos.GetOrientation());

                m_movementInfo.transport.Reset();

                RelocateToHomebind();
            }
            else
            {
                Relocate(x, y, z, o);
                mapId = transport->GetMapId();

                transport->AddPassenger(this);
            }
        }
        else*/
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (guidlow %d) have problems with transport guid (%u). Teleport to bind location.", guid.GetCounter(), transLowGUID);
            RelocateToHomebind();
        }
    }
    // currently we do not support taxi in instance
    else if (!taxi_nodes.empty())
    {
        instanceId = 0;

        // Not finish taxi flight path
        if (m_bgData.HasTaxiPath())
        {
            for (uint8 i = TEAM_ALLIANCE; i < MAX_TEAMS; ++i)
                m_taxi.AddTaxiDestination(m_bgData.TaxiPath[i]);
        }
        else if (!m_taxi.LoadTaxiDestinationsFromString(taxi_nodes, GetTeam()))
        {
            // problems with taxi path loading
            TaxiNodesEntry const* nodeEntry = NULL;
            if (uint32 node_id = m_taxi.GetTaxiSource())
                nodeEntry = sTaxiNodesStore.LookupEntry(node_id);

            if (!nodeEntry)                                      // don't know taxi start node, to homebind
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Character %u have wrong data in taxi destination list, teleport to homebind.", GetGUIDLow());
                RelocateToHomebind();
            }
            else                                                // have start node, to it
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Character %u have too short taxi destination list, teleport to original node.", GetGUIDLow());
                if (MapManager::IsValidMapCoord(nodeEntry->ContinentID, nodeEntry->Pos.X, nodeEntry->Pos.Y, nodeEntry->Pos.Z))
                {
                    mapId = nodeEntry->ContinentID;
                    Relocate(nodeEntry->Pos.X, nodeEntry->Pos.Y, nodeEntry->Pos.Z, 0.0f);
                }
                else
                    RelocateToHomebind();
            }
            m_taxi.ClearTaxiDestinations();
        }

        if (uint32 node_id = m_taxi.GetTaxiSource())
        {
            // save source node as recall coord to prevent recall and fall from sky
            TaxiNodesEntry const* nodeEntry = sTaxiNodesStore.LookupEntry(node_id);
            if (nodeEntry && nodeEntry->ContinentID == GetMapId())
            {
                ASSERT(nodeEntry);                                  // checked in m_taxi.LoadTaxiDestinationsFromString
                if (MapManager::IsValidMapCoord(nodeEntry->ContinentID, nodeEntry->Pos.X, nodeEntry->Pos.Y, nodeEntry->Pos.Z))
                {
                    mapId = nodeEntry->ContinentID;
                    Relocate(nodeEntry->Pos.X, nodeEntry->Pos.Y, nodeEntry->Pos.Z, 0.0f);
                }
                else
                    RelocateToHomebind();
            }

            // flight will started later
        }
    }

    // Map could be changed before
    mapEntry = sMapStore.LookupEntry(mapId);
    // client without expansion support
    if (mapEntry)
    {
        if (GetSession()->Expansion() < mapEntry->ExpansionID)
        {
            TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Player %s using client without required expansion tried login at non accessible map %u", GetName(), mapId);
            RelocateToHomebind();
        }

        // fix crash (because of if (Map* map = _FindMap(instanceId)) in MapInstanced::CreateInstance)
        if (instanceId)
            if (InstanceSave* save = GetInstanceSave(mapId))
                if (save->GetInstanceId() != instanceId)
                    instanceId = 0;
    }

    // NOW player must have valid map
    // load the player's map here if it's not already loaded
    Map* map = sMapMgr->CreateMap(mapId, this);

    if (!map)
    {
        instanceId = 0;
        AreaTriggerStruct const* at = sAreaTriggerDataStore->GetGoBackTrigger(mapId);
        if (at)
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (guidlow %d) is teleported to gobacktrigger (Map: %u X: %f Y: %f Z: %f O: %f).", guid.GetCounter(), mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
            Relocate(at->target_X, at->target_Y, at->target_Z, GetOrientation());
            mapId = at->target_mapId;
        }
        else if (const WorldSafeLocsEntry* grave = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), mapId, GetTeam()))
        {
            mapId = grave->MapID;
            Relocate(grave->Loc.X, grave->Loc.Y, grave->Loc.Z, grave->Loc.O);
        }
        else
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (guidlow %d) is teleported to home (Map: %u X: %f Y: %f Z: %f O: %f).", guid.GetCounter(), mapId, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
            RelocateToHomebind();
        }

        map = sMapMgr->CreateMap(mapId, this);
        if (!map)
        {
            PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
            mapId = info->mapId;
            Relocate(info->positionX, info->positionY, info->positionZ, 0.0f);
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (guidlow %d) have invalid coordinates (X: %f Y: %f Z: %f O: %f). Teleport to default race/class locations.", guid.GetCounter(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
            map = sMapMgr->CreateMap(mapId, this);
            if (!map)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (guidlow %d) has invalid default map coordinates (X: %f Y: %f Z: %f O: %f). or instance couldn't be created", guid.GetCounter(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
                return false;
            }
        }
    }

    // if the player is in an instance and it has been reset in the meantime teleport him to the entrance
    if (instanceId && !sInstanceSaveMgr->GetInstanceSave(instanceId) && !map->IsBattlegroundOrArena() && !map->CanCreatedZone() && !map->IsGarrison())
    {
        AreaTriggerStruct const* at = sAreaTriggerDataStore->GetMapEntranceTrigger(mapId);
        if (at)
            Relocate(at->target_X, at->target_Y, at->target_Z, at->target_Orientation);
        else if (auto inst = map->ToInstanceMap())
        {
            if (WorldLocation const* grave = inst->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ()))
                Relocate(grave->GetPositionX(), grave->GetPositionY(), grave->GetPositionZ(), grave->GetOrientation());
        }
        else
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player %s(GUID: %u) logged in to a reset instance (map: %u) and there is no area-trigger leading to this map. Thus he can't be ported back to the entrance. This _might_ be an exploit attempt.", GetName(), GetGUIDLow(), mapId);
            RelocateToHomebind();
        }
    }

    SetMap(map);

    // randomize first save time in range [CONFIG_INTERVAL_SAVE] around [CONFIG_INTERVAL_SAVE]
    // this must help in case next save after mass player load after server startup
    m_nextSave = urand(m_nextSave/2, m_nextSave*3/2);

    SaveRecallPosition();

    time_t now = time(NULL);
    time_t logoutTime = time_t(fields[f_logout_time].GetUInt32());

    // since last logout (in seconds)
    uint32 time_diff = uint32(now - logoutTime); //uint64 is excessive for a time_diff in seconds.. uint32 allows for 136~ year difference.

    // set value, including drunk invisibility detection
    // calculate sobering. after 15 minutes logged out, the player will be sober again
    uint8 newDrunkValue = 0;
    if (time_diff < uint32(GetDrunkValue()) * 9)
        newDrunkValue = GetDrunkValue() - time_diff / 9;

    SetDrunkValue(newDrunkValue);

    m_cinematic = fields[f_cinematic].GetUInt8();
    m_Played_time[PLAYED_TIME_TOTAL] = fields[f_totaltime].GetUInt32();
    m_Played_time[PLAYED_TIME_LEVEL] = fields[f_leveltime].GetUInt32();
    m_createdtime = fields[f_created_time].GetUInt32();
    m_killPoints = fields[f_killPoints].GetFloat();

    m_taxi.LoadTaxiMask(fields[f_taximask].GetCString());            // must be before InitTaxiNodesForLevel

    uint32 extraflags = fields[f_extra_flags].GetUInt16();

    // Honor system
    // Update Honor kills data
    m_lastHonorUpdateTime = logoutTime;

    m_deathExpireTime = time_t(fields[f_death_expire_time].GetUInt32());
    if (m_deathExpireTime > now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP)
        m_deathExpireTime = now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP-1;

    _lastSummonedBattlePet = 0/*fields[70].GetUInt32()*/;

    // clear charm/summon related fields
    SetOwnerGUID(ObjectGuid::Empty);
    SetGuidValue(UNIT_FIELD_CHARMED_BY, ObjectGuid::Empty);
    SetGuidValue(UNIT_FIELD_CHARM, ObjectGuid::Empty);
    SetGuidValue(UNIT_FIELD_SUMMON, ObjectGuid::Empty);
    SetGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT, ObjectGuid::Empty);
    SetCreatorGUID(ObjectGuid::Empty);

    RemoveFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FORCE_MOVEMENT);

    // reset some aura modifiers before aura apply
    SetUInt32Value(PLAYER_FIELD_TRACK_CREATURE_MASK, 0);
    SetUInt32Value(PLAYER_FIELD_TRACK_RESOURCE_MASK, 0);

    // make sure the unit is considered out of combat for proper loading
    ClearInCombat();

    // make sure the unit is considered not in duel for proper loading
    SetGuidValue(PLAYER_FIELD_DUEL_ARBITER, ObjectGuid::Empty);
    SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 0);

    // reset stats before loading any modifiers
    InitStatsForLevel();
    InitTaxiNodesForLevel();
    InitRunes();

    // rest bonus can only be calculated after InitStatsForLevel()
    m_rest_bonus = fields[f_rest_bonus].GetFloat();

    if (time_diff > 0)
    {
        auto bubble0 = 0.031f; //speed collect rest bonus in offline, in logout, far from tavern, city (section/in hour)
        auto bubble1 = 0.125f; //speed collect rest bonus in offline, in logout, in tavern, city (section/in hour)
        float bubble = fields[f_is_logout_resting].GetUInt8() > 0 ? bubble1 * sWorld->getRate(RATE_REST_OFFLINE_IN_TAVERN_OR_CITY) : bubble0 * sWorld->getRate(RATE_REST_OFFLINE_IN_WILDERNESS);
        SetRestBonus(GetRestBonus() + time_diff * ((float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP) / 72000)*bubble);
    }
    else
        SetRestBonus(1.0f);

    SetPrimarySpecialization(fields[f_specialization].GetUInt32());
    SetLootSpecID(fields[f_lootspecialization].GetUInt32());
    SetActiveTalentGroup(fields[f_activespec].GetUInt8());
    ChrSpecializationEntry const* primarySpec = sChrSpecializationStore.LookupEntry(GetPrimarySpecialization());
    if (!primarySpec || primarySpec->ClassID != getClass() || GetActiveTalentGroup() >= MAX_SPECIALIZATIONS)
        ResetTalentSpecialization();

    if (ChrSpecializationEntry const* spec = sDB2Manager.GetChrSpecializationByIndex(getClass(), GetActiveTalentGroup()))
        SetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID, spec->ID);

    // load skills after InitStatsForLevel because it triggering aura apply also
    _LoadSkills(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSKILLS));
    UpdateSkillsForLevel(); //update skills after load, to make sure they are correctly update at player load
    _LoadArchaeology(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADARCHAELOGY));
    _LoadArchaeologyFinds(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ARCHAEOLOGY_FINDS));

    // apply original stats mods before spell loading or item equipment that call before equip _RemoveStatsMods()

    //mails are loaded only when needed ;-) - when player in game click on mailbox.
    //_LoadMail();

    _LoadTalents(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADTALENTS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_PVP_TALENTS));
    _LoadSpells(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSPELLS));

    _LoadGlyphs(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_GLYPHS));
    _LoadAuras(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADAURAS), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADAURAS_EFFECTS), time_diff);
    _LoadGlyphAuras();
    // add ghost flag (must be after aura load: PLAYER_FLAGS_GHOST set in aura)
    if (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
        m_deathState = DEAD;

    // after spell load, learn rewarded spell if need also - test on achievements
    _LoadSpellRewards();
    // after rewarded spell load various quest statuses
    _LoadQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADQUESTSTATUS));
    _LoadQuestStatusObjectives(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_QUEST_STATUS_OBJECTIVES));
    _LoadQuestStatusRewarded(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADQUESTSTATUSREW));
    _LoadDailyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADDAILYQUESTSTATUS));
    _LoadWeeklyQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADWEEKLYQUESTSTATUS));
    _LoadSeasonalQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSEASONALQUESTSTATUS));
    _LoadAdventureQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_ADVENTURE_QUEST));
    _LoadAccountQuest(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_ACCOUNT_QUEST));
    _LoadRandomBGStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADRANDOMBG));
    _LoadWorldQuestStatus(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADWORLDQUESTSTATUS));
    _LoadPetBattles(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_BATTLE_PETS));
    UpdateAvailableQuestLines();

    // after spell and quest load
    InitTalentForLevel();
    LearnDefaultSkills();
    LearnDefaultSpells();

    // must be before inventory (some items required reputation check)
    m_reputationMgr.LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADREPUTATION));

    _collectionMgr->LoadFromDB(
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_TOYS),
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_HEIRLOOMS),
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_TRANSMOGS),
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ACCOUNT_MOUNTS),
        holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ITEM_FAVORITE_APPEARANCES));

    _LoadChallengeKey(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_CHALLENGE_KEY));
    _LoadAccountProgress(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_ACCOUNT_PROGRESS));

    _LoadInventory(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADINVENTORY), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_ARTIFACTS), time_diff);
    _LoadNotInventory(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADNOTINVENTORY), time_diff);

    if (IsVoidStorageUnlocked())
        _LoadVoidStorage(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADVOIDSTORAGE), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_VOIDSTORAGE_ITEM));

    AddNonVisibleItemToCollect(); // Delete this after open game realm

    // update items with duration and realtime
    UpdateItemDuration(time_diff, true);

    _LoadActions(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADACTIONS));

    // unread mails and next delivery time, actual mails not loaded
    _LoadMailInit(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADMAILCOUNT), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADMAILDATE));

    m_social = sSocialMgr->LoadFromDB(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSOCIALLIST), GetGUID());

    // check PLAYER_FIELD_PLAYER_TITLE compatibility with PLAYER_FIELD_KNOWN_TITLES
    // note: PLAYER_FIELD_KNOWN_TITLES updated at quest status loaded
    uint32 curTitle = fields[f_chosenTitle].GetUInt32();
    if (curTitle && !HasTitle(curTitle))
        curTitle = 0;

    SetUInt32Value(PLAYER_FIELD_PLAYER_TITLE, curTitle);

    SetUInt32Value(PLAYER_FIELD_VIRTUAL_PLAYER_REALM, GetVirtualRealmAddress());

    // has to be called after last Relocate() in Player::LoadFromDB
    SetFallInformation(0, GetPositionZ());

    _LoadSpellCooldowns(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADSPELLCOOLDOWNS));
    _LoadHonor(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_HONOR), holder->GetPreparedResult(PLAYER_LOGIN_QUERY_HONOR_INFO));
    UpdateHonorFields(true);

    // Spell code allow apply any auras to dead character in load time in aura/spell/item loading
    // Do now before stats re-calculation cleanup for ghost state unexpected auras
    if (!isAlive())
        RemoveAllAurasOnDeath();
    else
        RemoveAllAurasRequiringDeadTarget();

    //apply all stat bonuses from items and auras
    SetCanModifyStats(true);
    UpdateAllStats();

    // restore remembered power/health values (but not more max values)
    uint32 savedHealth = fields[f_health].GetUInt32();
    SetHealth(savedHealth > GetMaxHealth() ? GetMaxHealth() : savedHealth);

    if (GetPowerIndex(POWER_MANA) != MAX_POWERS)
        SetPower(POWER_MANA, std::min(fields[f_mana].GetUInt32(), GetUInt32Value(UNIT_FIELD_MAX_POWER + 0)));

    TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "The value of player %s after load item and aura is: ", m_name.c_str());
    outDebugValues();

    if (extraflags & PLAYER_EXTRA_INVISIBLE_STATUS)
    {
        if (InvisibleStatusRatingRequirements())
        {
            m_ExtraFlags |= PLAYER_EXTRA_INVISIBLE_STATUS;
        }
        else
        {
            SendInvisibleStatusMsg(0);
        }
    }

    // GM state
    if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
    {
        switch (sWorld->getIntConfig(CONFIG_GM_LOGIN_STATE))
        {
            default:
            case 0:                      break;             // disable
            case 1: SetGameMaster(true); break;             // enable
            case 2:                                         // save state
                if (extraflags & PLAYER_EXTRA_GM_ON)
                    SetGameMaster(true);
                break;
        }

        switch (sWorld->getIntConfig(CONFIG_GM_VISIBLE_STATE))
        {
            default:
            case 0: SetGMVisible(false); break;             // invisible
            case 1:                      break;             // visible
            case 2:                                         // save state
                if (extraflags & PLAYER_EXTRA_GM_INVISIBLE)
                    SetGMVisible(false);
                break;
        }

        switch (sWorld->getIntConfig(CONFIG_GM_CHAT))
        {
            default:
            case 0:                  break;                 // disable
            case 1: SetGMChat(true); break;                 // enable
            case 2:                                         // save state
                if (extraflags & PLAYER_EXTRA_GM_CHAT)
                    SetGMChat(true);
                break;
        }

        switch (sWorld->getIntConfig(CONFIG_GM_WHISPERING_TO))
        {
            default:
            case 0:                          break;         // disable
            case 1: SetAcceptWhispers(true); break;         // enable
            case 2:                                         // save state
                if (extraflags & PLAYER_EXTRA_ACCEPT_WHISPERS)
                    SetAcceptWhispers(true);
                break;
        }
    }

    // RaF stuff.
    m_grantableLevels = fields[f_grantableLevels].GetUInt8();

    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
        SetFlag(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_REFER_A_FRIEND);

    if (m_grantableLevels > 0)
        SetByteValue(PLAYER_FIELD_BYTES_4, PLAYER_BYTES_4_RAF_GRANTABLE_LEVEL, 0x01);

    _LoadDeclinedNames(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADDECLINEDNAMES));

    m_achievementMgr->CheckAllAchievementCriteria(this);

    _LoadEquipmentSets(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOADEQUIPMENTSETS));
    _LoadTransmogOutfits(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_TRANSMOG_OUTFITS));

    _LoadCUFProfiles(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CUF_PROFILES));

    SetLfgBonusFaction(fields[f_lfgBonusFaction].GetUInt32());

    if(PreparedQueryResult PersonnalRateResult = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_PERSONAL_RATE))
        m_PersonnalXpRate = (PersonnalRateResult->Fetch())[0].GetFloat();

    ModifyCanUseDonate(true);

    if (mustResurrectFromUnlock)
        ResurrectPlayer(1.0f, true);

    //if (GmTicket* ticket = sTicketMgr->GetTicketByPlayer(GetGUID()))
        //if (!ticket->IsClosed() && ticket->IsCompleted())
            //ticket->SendResponse(GetSession());

    _ApplyOrRemoveItemEquipDependentAuras(ObjectGuid::Empty, false);

    if(PreparedQueryResult resultvis = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_VISUAL))
    {
        if (!m_vis)
            m_vis = new Visuals;

        Field *fieldsvis = resultvis->Fetch();

        m_vis->m_visHead        = fieldsvis[0].GetUInt32();
        m_vis->m_visShoulders   = fieldsvis[1].GetUInt32();
        m_vis->m_visChest       = fieldsvis[2].GetUInt32();
        m_vis->m_visWaist       = fieldsvis[3].GetUInt32();
        m_vis->m_visLegs        = fieldsvis[4].GetUInt32();
        m_vis->m_visFeet        = fieldsvis[5].GetUInt32();
        m_vis->m_visWrists      = fieldsvis[6].GetUInt32();
        m_vis->m_visHands       = fieldsvis[7].GetUInt32();
        m_vis->m_visBack        = fieldsvis[8].GetUInt32();
        m_vis->m_visMainhand    = fieldsvis[9].GetUInt32();
        m_vis->m_visOffhand     = fieldsvis[10].GetUInt32();
        m_vis->m_visRanged      = fieldsvis[11].GetUInt32();
        m_vis->m_visTabard      = fieldsvis[12].GetUInt32();
        m_vis->m_visShirt       = fieldsvis[13].GetUInt32();

        HandleAltVisSwitch();
    }
    
    if (PreparedQueryResult DMStats = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_DEATHMATCH_STATS))
    {
        Field *fieldDM = DMStats->Fetch();
        ModifyDeathMatchStats(fieldDM[0].GetUInt32(), fieldDM[1].GetUInt32(), fieldDM[2].GetUInt64(), fieldDM[3].GetUInt32(), 0, fieldDM[4].GetUInt32());
    }
    
    if (PreparedQueryResult dmStore = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_DEATHMATCH_STORE))
    {
        Field *fieldDM = dmStore->Fetch();
        dmScore.totalKills = fieldDM[0].GetUInt32();
        dmScore.selectedMorph = fieldDM[1].GetUInt32();
        Tokenizer buyed_morph(fieldDM[2].GetString(), ' ');
        for (char const* token : buyed_morph)
			dmScore.buyedMorphs.insert(atol(token));
        
    }
    
    if (PreparedQueryResult ChatResult = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_CHAT_LOGOS))
    {
        do
        {
            Field *field = ChatResult->Fetch();
            std::string logo = field[0].GetString();
            bool active = field[1].GetBool();
            buyed_chat_logos.insert(std::pair<std::string, bool>(logo, active));
            if (active)
                setSelectedChatLogo(logo);
            
            // setSelectedChatLogo("|TInterface/ICONS/Inv_misc_map08:20|t");
            
        } while (ChatResult->NextRow());
    }

    if (PreparedQueryResult armyQuery = holder->GetPreparedResult(PLAYER_LOGIN_QUERY_ARMY_TRAINING))
    {
        Field *armyField = armyQuery->Fetch();
        uint8 i = 0;
        for (;i < 3; ++i)
            armyTrainingInfo.justOpenedUnits[i] = armyField[i].GetUInt32();

        armyTrainingInfo.moreHP = armyField[i++].GetUInt8();
        armyTrainingInfo.moreDMG = armyField[i++].GetUInt8();
        armyTrainingInfo.moreFixate = armyField[i++].GetBool();
        armyTrainingInfo.moreBrave = armyField[i++].GetBool();

        Tokenizer chests(armyField[i++].GetString(), ' ');
        for (char const* token : chests)
            armyTrainingInfo.justFindedChest.insert(atol(token));
        
    }

    // Check professions
    //if(sWorld->getBoolConfig(CONFIG_CHECK_PROF_AT_LOGIN) && GetSession()->GetSecurity() < SEC_GAMEMASTER)
    {
        uint32 prof_count = 0;
        std::vector<uint32> prof_skills;
        prof_skills.push_back(164);     // Blacksmithing
        prof_skills.push_back(165);     // Leatherworking
        prof_skills.push_back(171);     // Alchemy
        prof_skills.push_back(182);     // Herbalism
        prof_skills.push_back(186);     // Mining
        prof_skills.push_back(197);     // Tailoring
        prof_skills.push_back(202);     // Engineering
        prof_skills.push_back(333);     // Enchanting
        prof_skills.push_back(393);     // Skinning
        prof_skills.push_back(755);     // Jewelcrafting
        prof_skills.push_back(773);     // Inscription

        for(std::vector<uint32>::iterator itr = prof_skills.begin(); itr != prof_skills.end(); ++itr)
        {
            uint32 skill_id = *itr;

            if(HasSkill(skill_id))
            {
                ++prof_count;

                if(prof_count > 2)
                    SetSkill(skill_id);
            }    
        }
    }

    return true;
}

bool Player::isAllowedToLoot(const Creature* creature)
{
    if (!creature->isDead() || !creature->IsDamageEnoughForLootingAndReward())
        return false;

    if (!creature->HasFlag(OBJECT_FIELD_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE))
        return false;

    if (HasPendingBind())
        return false;

    if(Loot* lootPesonal = GetPersonalLoot(creature->GetGUID()))
    {
        if(lootPesonal->isLooted())
            return false;
        return true;
    }

    // TC_LOG_DEBUG(LOG_FILTER_LOOT, "Player::isAllowedToLoot 2");

    Group* thisGroup = GetGroup();
    if (!thisGroup)
        return creature->HasInLootList(GetGUID());
    if (thisGroup != creature->GetLootRecipientGroup())
        return false;

    const Loot* loot = &creature->loot;

    // TC_LOG_DEBUG(LOG_FILTER_LOOT, "Player::isAllowedToLoot 3 isLooted %u GetLootMethod %u roundRobinPlayer %s", loot->isLooted(), thisGroup->GetLootMethod(), loot->roundRobinPlayer.ToString().c_str());

    if (loot->isLooted())
        return false;

    switch (thisGroup->GetLootMethod())
    {
        case PERSONAL_LOOT:
        case FREE_FOR_ALL:
            return true;
        case MASTER_LOOT:
            // may only loot if the player is the loot roundrobin player
            // or if there are free/quest/conditional item for the player
            if (loot->roundRobinPlayer.IsEmpty() || loot->roundRobinPlayer == GetGUID())
                return true;
            return loot->hasItemFor(this);
        case GROUP_LOOT:
            // may only loot if the player is the loot roundrobin player
            // or item over threshold (so roll(s) can be launched)
            // or if there are free/quest/conditional item for the player
            if (!loot->roundRobinPlayer || loot->roundRobinPlayer == GetGUID())
                return true;

            if (loot->hasOverThresholdItem())
                return true;

            return loot->hasItemFor(this);
        default:
            break;
    }

    // TC_LOG_DEBUG(LOG_FILTER_LOOT, "Player::isAllowedToLoot 4");

    return false;
}

void Player::_LoadActions(PreparedQueryResult result)
{
    m_actionButtons.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint8 button = fields[0].GetUInt8();
            uint32 action = fields[1].GetUInt32();
            uint8 type = fields[2].GetUInt8();

            if (!addActionButton(button, action, type, ACTIONBUTTON_UNCHANGED))
            {
                // Will be deleted from DB at next save
                m_actionButtons.emplace(button, ActionButton(action, type, ACTIONBUTTON_DELETED));
            }
        } while (result->NextRow());
    }
}

void Player::_LoadAuras(PreparedQueryResult result, PreparedQueryResult resultEffect, uint32 timediff)
{
    TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Loading auras for player %u", GetGUIDLow());

    std::list<auraEffectData> auraEffectList;
    if(resultEffect)
    {
        do
        {
            Field* fields = resultEffect->Fetch();
            uint8 slot = fields[0].GetUInt8();
            uint8 effect = fields[1].GetUInt8();
            uint32 baseamount = fields[2].GetUInt32();
            uint32 amount = fields[3].GetUInt32();

            auraEffectList.push_back(auraEffectData(slot, effect, amount, baseamount));
        }
        while (resultEffect->NextRow());
    }

    /*                                                           0       1        2         3                 4         5      6       7         8              9            10
    QueryResult* result = CharacterDatabase.PQuery("SELECT caster_guid, spell, effect_mask, recalculate_mask, stackcount, amount0, amount1, amount2, base_amount0, base_amount1, base_amount2,
                                                        11          12          13
                                                    maxduration, remaintime, remaincharges FROM character_aura WHERE guid = '%u'", GetGUIDLow());
    */

    if (result)
    {
        ObjectGuid caster_guid;
        do
        {
            Field* fields = result->Fetch();
            int32 damage[32];
            float baseDamage[32];
            caster_guid.SetRawValue(fields[0].GetBinary());
            uint8 slot = fields[1].GetUInt8();
            uint32 spellid = fields[2].GetUInt32();
            uint32 effmask = fields[3].GetUInt16();
            uint32 recalculatemask = fields[4].GetUInt8();
            uint8 stackcount = fields[5].GetUInt8();
            int32 maxduration = fields[6].GetInt32();
            int32 remaintime = fields[7].GetInt32();
            uint8 remaincharges = fields[8].GetUInt8();

            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellid);
            if (!spellInfo)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Unknown aura (spellid %u), ignore.", spellid);
                continue;
            }

            // negative effects should continue counting down after logout
            if (remaintime != -1 && !spellInfo->IsPositive())
            {
                if (remaintime/IN_MILLISECONDS <= int32(timediff))
                    continue;

                remaintime -= timediff*IN_MILLISECONDS;
            }

            // prevent wrong values of remaincharges
            if (spellInfo->GetAuraOptions(m_spawnMode)->ProcCharges)
            {
                // we have no control over the order of applying auras and modifiers allow auras
                // to have more charges than value in SpellInfo
                if (remaincharges <= 0/* || remaincharges > spellproto->procCharges*/)
                    remaincharges = spellInfo->GetAuraOptions(m_spawnMode)->ProcCharges;
            }
            else
                remaincharges = 0;

            for(std::list<auraEffectData>::iterator itr = auraEffectList.begin(); itr != auraEffectList.end(); ++itr)
            {
                if(itr->_slot == slot)
                {
                    damage[itr->_effect] = itr->_amount;
                    baseDamage[itr->_effect] = itr->_baseamount;
                }
            }

            Aura* aura = Aura::TryCreate(spellInfo, effmask, this, NULL, &baseDamage[0], NULL, caster_guid);
            if (aura != NULL)
            {
                if (!aura->CanBeSaved())
                {
                    aura->Remove();
                    continue;
                }

                if (InArena())
                    if (aura->GetId() == 158263)
                    {
                        aura->Remove();
                        continue;
                    }

                aura->SetLoadedState(maxduration, remaintime, remaincharges, stackcount, recalculatemask, &damage[0]);
                aura->ApplyForTargets();
                TC_LOG_DEBUG(LOG_FILTER_PLAYER, "Added aura spellid %u, effectmask %u", spellInfo->Id, effmask);
            }
        }
        while (result->NextRow());
    }
}

void Player::_LoadGlyphAuras()
{
    for (uint32 glyphId : GetGlyphs(GetActiveTalentGroup()))
        CastSpell(this, sGlyphPropertiesStore.AssertEntry(glyphId)->SpellID, true);
}

void Player::LoadCorpse()
{
    if (isAlive())
        sObjectAccessor->ConvertCorpseForPlayer(GetGUID());
    else
    {
        if (Corpse* corpse = GetCorpse())
            ApplyModFlag(PLAYER_FIELD_LOCAL_FLAGS, PLAYER_LOCAL_FLAG_RELEASE_TIMER, corpse && !sMapStore.LookupEntry(corpse->GetMapId())->Instanceable());
        else
            //Prevent Dead Player login without corpse
            ResurrectPlayer(0.5f);
    }
}

void Player::_LoadInventory(PreparedQueryResult result, PreparedQueryResult artifactsResult, uint32 timeDiff)
{
    //        0     1          2            3                4      5         6        7      8             9                   10                11          12          13
    //        guid, itemEntry, creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyType, randomPropertyId, durability, playedTime, text,
    //        14         15                  16                  17              18                  19
    //        upgradeId, battlePetSpeciesId, battlePetBreedData, battlePetLevel, battlePetDisplayId, bonusListIDs,
    //        20                              21                           22                           23                           24
    //        itemModifiedAppearanceAllSpecs, itemModifiedAppearanceSpec1, itemModifiedAppearanceSpec2, itemModifiedAppearanceSpec3, itemModifiedAppearanceSpec4,
    //        25                            26                         27                         28                         29
    //        spellItemEnchantmentAllSpecs, spellItemEnchantmentSpec1, spellItemEnchantmentSpec2, spellItemEnchantmentSpec3, spellItemEnchantmentSpec4,
    //        30          31           32           33                34          35           36           37                38          39           40           41                
    //        gemItemId1, gemBonuses1, gemContext1, gemScalingLevel1, gemItemId2, gemBonuses2, gemContext2, gemScalingLevel2, gemItemId3, gemBonuses3, gemContext3, gemScalingLevel3,
    //        42                 43                      44  45                    46   47 
    //        fixedScalingLevel, artifactKnowledgeLevel, xp, artifactAppearanceId, bag, slot
    //        FROM character_inventory ci JOIN item_instance ii ON ci.item = ii.guid WHERE ci.guid = ? ORDER BY bag, slot

    //NOTE: the "order by `bag`" is important because it makes sure
    //the bagMap is filled before items in the bags are loaded
    //NOTE2: the "order by `slot`" is needed because mainhand weapons are (wrongly?)
    //expected to be equipped before offhand items (TODO: fixme)

        //                 0     1                       2                   3                 4
    // SELECT a.itemGuid, a.xp, a.artifactAppearanceId, ap.artifactPowerId, ap.purchasedRank FROM item_instance_artifact_powers ap LEFT JOIN item_instance_artifact a ON ap.itemGuid = a.itemGuid INNER JOIN character_inventory ci ON ci.item = ap.guid WHERE ci.guid = ?
    //std::unordered_map<uint32, std::vector<ItemDynamicFieldArtifactPowers>> artifactData;

    AllArtifacts.clear();  // only fill
    if (artifactsResult)
    {
        do
        {
            Field* fields = artifactsResult->Fetch();
            auto& artifactDataEntry = GlobalArtifactData[(fields[0].GetUInt32())];
            ItemDynamicFieldArtifactPowers artifactPowerData;
            artifactPowerData.ArtifactPowerId = fields[3].GetUInt32();
            artifactPowerData.PurchasedRank = fields[4].GetUInt8();
            if (ArtifactPowerEntry const* artifactPower = sArtifactPowerStore.LookupEntry(artifactPowerData.ArtifactPowerId))
            {
                artifactPowerData.CurrentRankWithBonus = ((artifactPower->Flags & ARTIFACT_POWER_FLAG_NO_LINK_REQUIRED) && !artifactPower->Tier) ? 1 : 0;

                artifactDataEntry.push_back(artifactPowerData);
            }

            AllArtifacts.insert(std::make_pair(ObjectGuid::Create<HighGuid::Item> (fields[5].GetUInt64()), fields[0].GetUInt32()));
            
        } while (artifactsResult->NextRow());
    }

    if (result)
    {
        uint32 zoneId = GetZoneId();

        std::map<ObjectGuid, Bag*> bagMap;                                  // fast guid lookup for bags
        std::map<ObjectGuid, Item*> invalidBagMap;                          // fast guid lookup for bags
        std::list<Item*> problematicItems;
        std::vector<Item*> childItems;
        std::vector<Item*> artifactItems;
        SQLTransaction trans = CharacterDatabase.BeginTransaction();

        // Prevent items from being added to the queue while loading
        m_itemUpdateQueueBlocked = true;
        do
        {
            Field* fields = result->Fetch();

            //item on auction
            if (sAuctionMgr->GetAItem(fields[0].GetUInt64()/*itemGuid*/))
                continue;

            if (Item* item = _LoadItem(trans, zoneId, timeDiff, fields))
            {
                if (item->GetTemplate()->GetArtifactID())
                {
                    auto artifactDataItr = GlobalArtifactData.find(item->GetEntry());
                    if (artifactDataItr != GlobalArtifactData.end())
                        item->LoadArtifactData(this, artifactDataItr->second);
                    else
                    {
                        item->InitArtifactPowers(item->GetTemplate()->GetArtifactID());

                        for (ArtifactAppearanceEntry const* artifactAppearance : sArtifactAppearanceStore)
                        {
                            if (ArtifactAppearanceSetEntry const* artifactAppearanceSet = sArtifactAppearanceSetStore.LookupEntry(artifactAppearance->ArtifactAppearanceSetID))
                            {
                                if (item->GetTemplate()->GetArtifactID() != artifactAppearanceSet->ArtifactID)
                                    continue;

                                if (!sConditionMgr->IsPlayerMeetingCondition(this, artifactAppearance->UnlockPlayerConditionID))
                                    continue;

                                item->SetModifier(ITEM_MODIFIER_ARTIFACT_APPEARANCE_ID, artifactAppearance->ID);
                                item->SetAppearanceModId(artifactAppearance->ItemAppearanceModifierID);
                                break;
                            }
                        }
                    }
                    ObjectGuid itemGUID = item->GetGUID();
                    AddDelayedEvent(3000, [this, itemGUID]() -> void
                    {
                        if (Item* item = GetItemByGuid(itemGUID))
                            UnLockThirdSocketIfNeed(item);
                    });
                }
 
                ObjectGuid bGUID = fields[50].GetUInt64() ? ObjectGuid::Create<HighGuid::Item>(fields[50].GetUInt64()) : ObjectGuid::Empty;
                uint8 slot = fields[51].GetUInt8();

                item->SetDonateItem(fields[52].GetBool());

                _collectionMgr->CheckHeirloomUpgrades(item);

                uint8 err = EQUIP_ERR_OK;
                // Item is not in bag
                if (!bGUID)
                {
                    ObjectGuid::LowType iGUIDfromInv = fields[0].GetUInt64();

                    item->SetContainer(NULL);
                    item->SetSlot(slot);

                    // check for already equiped item
                    if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
                        err = EQUIP_ERR_ITEM_MAX_COUNT;
                    // as at lost link item has 0 slot 0 bag this mean EQUIPMENT_SLOT_HEAD so could be stack with this slot
                    if (!iGUIDfromInv)  
                        err = EQUIP_ERR_ITEM_MAX_COUNT;

                    if (err == EQUIP_ERR_OK)
                    {
                        if (IsInventoryPos(INVENTORY_SLOT_BAG_0, slot))
                        {
                            ItemPosCountVec dest;
                            err = CanStoreItem(INVENTORY_SLOT_BAG_0, slot, dest, item, false);
                            if (err == EQUIP_ERR_OK)
                                item = StoreItem(dest, item, true);
                        }
                        else if (IsEquipmentPos(INVENTORY_SLOT_BAG_0, slot))
                        {
                            uint16 dest;
                            err = CanEquipItem(slot, dest, item, false, false);
                            if (err == EQUIP_ERR_OK)
                                QuickEquipItem(dest, item);
                        }
                        else if (IsBankPos(INVENTORY_SLOT_BAG_0, slot))
                        {
                            ItemPosCountVec dest;
                            err = CanBankItem(INVENTORY_SLOT_BAG_0, slot, dest, item, false, false);
                            if (err == EQUIP_ERR_OK)
                                item = BankItem(dest, item, true);
                        }
                    }

                    if (!item)
                        continue;

                    // Remember bags that may contain items in them
                    if (err == EQUIP_ERR_OK)
                    {
                        if (IsBagPos(item->GetPos()))
                            if (Bag* pBag = item->ToBag())
                                bagMap[item->GetGUID()] = pBag;
                    }
                    else
                        if (IsBagPos(item->GetPos()))
                            if (item->IsBag())
                                invalidBagMap[item->GetGUID()] = item;
                }
                else
                {
                    item->SetSlot(NULL_SLOT);
                    // Item is in the bag, find the bag
                    std::map<ObjectGuid, Bag*>::iterator itr = bagMap.find(bGUID);
                    if (itr != bagMap.end())
                    {
                        ItemPosCountVec dest;
                        err = CanStoreItem(itr->second->GetSlot(), slot, dest, item);
                        if (err == EQUIP_ERR_OK)
                            item = StoreItem(dest, item, true);
                    }
                    else if (invalidBagMap.find(bGUID) != invalidBagMap.end())
                    {
                        std::map<ObjectGuid, Item*>::iterator itr2 = invalidBagMap.find(bGUID);
                        if (std::find(problematicItems.begin(), problematicItems.end(), itr2->second) != problematicItems.end())
                            err = EQUIP_ERR_INTERNAL_BAG_ERROR;
                    }
                    else
                    {
                        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) which doesnt have a valid bag (Bag GUID: %u, slot: %u). Possible cheat?", GetGUIDLow(), GetName(), item->GetGUIDLow(), item->GetEntry(), bGUID.GetCounter(), slot);
                        item->DeleteFromInventoryDB(trans);
                        RemoveItemDurations(item);
                        RemoveTradeableItem(item);
                        delete item;
                        continue;
                    }
                }

                if (!item)
                    continue;

                if (item->GetTemplate()->IsLegendaryLoot())
                    AllLegendarys.insert(item->GetEntry());

                // Item's state may have changed after storing
                if (err == EQUIP_ERR_OK)
                {
                    item->SetState(ITEM_UNCHANGED, this);
                    if (item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_CHILD))
                        childItems.push_back(item);
                    if (item->GetTemplate()->GetArtifactID())
                        artifactItems.push_back(item);

                    item->UpgradeLegendary();
                }
                else
                {
                    TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) which can't be loaded into inventory (Bag GUID: %u, slot: %u) by reason %u. Item will be sent by mail.", GetGUIDLow(), GetName(), item->GetGUIDLow(), item->GetEntry(), bGUID.GetCounter(), slot, err);
                    item->DeleteFromInventoryDB(trans);
                    RemoveItemDurations(item);
                    RemoveTradeableItem(item);
                    problematicItems.push_back(item);
                }

                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ITEM_INSTANCE_RELICS);
                stmt->setUInt64(0, item->GetGUIDLow());
                if (PreparedQueryResult relics = CharacterDatabase.Query(stmt))
                {
                    auto result = relics->Fetch();
                    for (uint8 i = 0; i < 3; ++i)
                    {
                        std::string info = result[i].GetString();
                        if (info.empty())
                            continue;

                        Tokenizer tokens(info, ' ',0, false);
                        if (tokens.size() < 6)
                            continue;

                        uint8 offset = i * 6;
                        for (auto value : tokens)
                        {
                            uint32 val = atol(value);
                            if (val == 0)
                                break;

                            item->SetDynamicValue(ITEM_DYNAMIC_FIELD_RELIC_TALENT_DATA, offset++, val);
                        }
                        uint32 val = atol(tokens[2]);
                        if (val == 0)
                            continue;

                        for (uint8 z = 0; z <= 5; ++z)
                            if ((1 << z) & val)
                            {
                                uint32 reqLevel = 0;
                                if (z > 0)
                                    reqLevel = 60 + i * 3;
                                if (z > 2)
                                    reqLevel += 9;

                                if (reqLevel <= item->GetTotalPurchasedArtifactPowers())
                                    item->AddOrRemoveSocketTalent(z, true, i + 2);
                                else
                                    val &= ~(1 << z);
                            }

                        item->SetDynamicValue(ITEM_DYNAMIC_FIELD_RELIC_TALENT_DATA, i * 6 + 2, val);
                    }
                }

            }
        } while (result->NextRow());

        m_itemUpdateQueueBlocked = false;

        // Old system artifact
        for (Item* artifactItem : artifactItems)
        {
            if (ItemChildEquipmentEntry const* childItemEntry = sDB2Manager.GetItemChildEquipment(artifactItem->GetEntry()))
            {
                if (Item* childItem = GetItemByEntry(childItemEntry->ChildItemID))
                {
                    if (!childItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_CHILD))
                    {
                        childItem->SetGuidValue(ITEM_FIELD_CREATOR, artifactItem->GetGUID());
                        childItem->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_CHILD);
                        childItem->SetState(ITEM_CHANGED, this);
                    }
                    if (artifactItem->IsEquipped() && !childItem->IsEquipped())
                    {
                        ItemPosCountVec dest;
                        InventoryResult msg = CanStoreItem(NULL_BAG, NULL_SLOT, dest, artifactItem, false);
                        if (msg == EQUIP_ERR_OK)
                        {
                            RemoveItem(artifactItem->GetBagSlot(), artifactItem->GetSlot(), true);
                            StoreItem(dest, artifactItem, true);
                        }
                    }
                    artifactItem->SetChildItem(childItem->GetGUID());
                }
                else if (ItemTemplate const* childTemplate = sObjectMgr->GetItemTemplate(childItemEntry->ChildItemID))
                {
                    ItemPosCountVec childDest;
                    uint32 count = 1;
                    CanStoreItem_InInventorySlots(CHILD_EQUIPMENT_SLOT_START, CHILD_EQUIPMENT_SLOT_END, childDest, childTemplate, count, false, nullptr, NULL_BAG, NULL_SLOT);
                    if (Item* childItem = StoreNewItem(childDest, childTemplate->GetId(), false))
                    {
                        childItem->SetGuidValue(ITEM_FIELD_CREATOR, artifactItem->GetGUID());
                        childItem->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_CHILD);
                        artifactItem->SetChildItem(childItem->GetGUID());
                    }
                    if (artifactItem->IsEquipped())
                    {
                        ItemPosCountVec dest;
                        InventoryResult msg = CanStoreItem(NULL_BAG, NULL_SLOT, dest, artifactItem, false);
                        if (msg == EQUIP_ERR_OK)
                        {
                            RemoveItem(artifactItem->GetBagSlot(), artifactItem->GetSlot(), true);
                            StoreItem(dest, artifactItem, true);
                        }
                    }
                }
            }
        }

        for (Item* childItem : childItems)
        {
            if (Item* parent = GetItemByGuid(childItem->GetGuidValue(ITEM_FIELD_CREATOR)))
            {
                InventoryResult res = CanUseItem(parent, false);
                if (res == EQUIP_ERR_OK)
                {
                    parent->SetChildItem(childItem->GetGUID());
                    childItem->CopyArtifactDataFromParent(parent);
                    if (childItem->IsEquipped())
                        SetVisibleItemSlot(childItem->GetSlot(), childItem);
                }
                else
                {
                    if (childItem->IsEquipped())
                    {
                        ItemPosCountVec destChildren;
                        InventoryResult msg = CanStoreItem(NULL_BAG, NULL_SLOT, destChildren, childItem, false);
                        if (msg == EQUIP_ERR_OK)
                        {
                            RemoveItem(childItem->GetBagSlot(), childItem->GetSlot(), true);
                            StoreItem(destChildren, childItem, true);
                        }
                        else
                        {
                            RemoveItem(childItem->GetBagSlot(), childItem->GetSlot(), true);
                            childItem->RemoveFromWorld();
                            childItem->SetState(ITEM_REMOVED, this);
                        }
                    }
                }
            }
            else if (childItem->IsEquipped())
            {
                ItemPosCountVec destChildren;
                InventoryResult msg = CanStoreItem(NULL_BAG, NULL_SLOT, destChildren, childItem, false);
                if (msg == EQUIP_ERR_OK)
                {
                    RemoveItem(childItem->GetBagSlot(), childItem->GetSlot(), true);
                    StoreItem(destChildren, childItem, true);
                }
                else
                {
                    RemoveItem(childItem->GetBagSlot(), childItem->GetSlot(), true);
                    childItem->RemoveFromWorld();
                    childItem->SetState(ITEM_REMOVED, this);
                }
            }
        }

        // Send problematic items by mail
        while (!problematicItems.empty())
        {
            std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);

            MailDraft draft(subject, "There were problems with equipping item(s).");
            for (uint8 i = 0; !problematicItems.empty() && i < MAX_MAIL_ITEMS; ++i)
            {
                if (Item* pItem = problematicItems.front())
                    if (!pItem->GetTemplate()->GetArtifactID())  // don't send art by mail
                        draft.AddItem(pItem);
                problematicItems.pop_front();
            }
            draft.SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);
        }

        CharacterDatabase.CommitTransaction(trans);
    }
    //if (isAlive())
    _ApplyAllItemMods();

}

void Player::_LoadNotInventory(PreparedQueryResult result, uint32 timeDiff)
{
    if (result)
    {
        uint32 zoneId = GetZoneId();

        std::list<Item*> problematicItems;
        SQLTransaction trans = CharacterDatabase.BeginTransaction();

        // Prevent items from being added to the queue while loading
        m_itemUpdateQueueBlocked = true;
        do
        {
            Field* fields = result->Fetch();
            uint32 itemEntry = fields[1].GetUInt32();
            if (sDB2Manager.IsChildItem(itemEntry))
                continue;

            ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemEntry);
            if (!proto || proto->GetArtifactID() || proto->GetMaxStackSize() != 1 || proto->GetClass() == ITEM_CLASS_QUEST || proto->GetQuality() <= ITEM_QUALITY_NORMAL)
                continue;

            if (Item* item = _LoadItem(trans, zoneId, timeDiff, fields))
            {
                item->SetDonateItem(fields[50].GetBool());
                problematicItems.push_back(item);
            }
        } while (result->NextRow());

        m_itemUpdateQueueBlocked = false;

        // Send problematic items by mail
        while (!problematicItems.empty())
        {
            std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);

            MailDraft draft(subject, "There were problems with equipping item(s).");
            for (uint8 i = 0; !problematicItems.empty() && i < MAX_MAIL_ITEMS; ++i)
            {
                if (Item* pItem = problematicItems.front())
                    draft.AddItem(pItem);
                problematicItems.pop_front();
            }
            draft.SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);
        }

        CharacterDatabase.CommitTransaction(trans);
    }
}

void Player::_LoadVoidStorage(PreparedQueryResult result, PreparedQueryResult resultItem)
{
    if (result)
    {
        do
        {
            // SELECT itemid, itemEntry, slot, creatorGuid FROM character_void_storage WHERE playerGuid = ?
            Field* fields = result->Fetch();

            ObjectGuid itemId = ObjectGuid::Create<HighGuid::Item>(fields[0].GetUInt64());
            uint32 itemEntry = fields[1].GetUInt32();
            uint32 slot = fields[2].GetUInt32();
            ObjectGuid creatorGuid = ObjectGuid::Create<HighGuid::Player>(fields[3].GetUInt64());
            ItemRandomEnchantmentId randomProperty(ItemRandomEnchantmentType(fields[4].GetUInt8()), fields[5].GetUInt32());
            uint32 suffixFactor = fields[6].GetUInt32();

            if (itemId.IsEmpty())
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid id (item id: %u, entry: %u).", GetGUIDLow(), GetName(), itemId.GetCounter(), itemEntry);
                continue;
            }

            if (!sObjectMgr->GetItemTemplate(itemEntry))
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid entry (item id: %u, entry: %u).", GetGUIDLow(), GetName(), itemId.GetCounter(), itemEntry);
                continue;
            }

            if (slot >= VOID_STORAGE_MAX_SLOT)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid slot (item id: %u, entry: %u, slot: %u).", GetGUIDLow(), GetName(), itemId.GetCounter(), itemEntry, slot);
                continue;
            }

            if (!sObjectMgr->GetPlayerByLowGUID(creatorGuid.GetCounter()))
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid creator guid, set to 0 (item id: %u, entry: %u, creatorGuid: %u).", GetGUIDLow(), GetName(), itemId.GetCounter(), itemEntry, creatorGuid.GetCounter());
                creatorGuid.Clear();
            }

            AllLegendarys.insert(itemEntry);

            _voidStorageItems[slot] = new VoidStorageItem(itemId.GetCounter(), itemEntry, creatorGuid, randomProperty, suffixFactor, false);
        }
        while (result->NextRow());
    }
    if (resultItem)
    {
        do
        {
            Field* fields = resultItem->Fetch();

            ObjectGuid::LowType itemGuid = fields[0].GetUInt64();
            uint32 itemEntry = fields[1].GetUInt32();
            ObjectGuid itemId = ObjectGuid::Create<HighGuid::Item>(fields[51].GetUInt64());
            uint32 slot = fields[50].GetUInt32();

            ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemEntry);
            if (!proto)
                continue;

            Item* item = NewItemOrBag(proto);

            if (!item->LoadFromDB(itemGuid, GetGUID(), fields, itemEntry, getLevel()))
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - itemId (%u) doesn't exist !!!! - item guid: %u, deleted from VoidStorage", itemId.GetCounter(), itemGuid);

                item->FSetState(ITEM_REMOVED);

                SQLTransaction temp = SQLTransaction(NULL);
                item->SaveToDB(temp);                               // it also deletes item object !
                continue;
            }

            if (itemId.IsEmpty())
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid id (item id: %u, entry: %u).", GetGUIDLow(), GetName(), itemId.GetCounter(), itemEntry);
                continue;
            }

            if (slot >= VOID_STORAGE_MAX_SLOT)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadVoidStorage - Player (GUID: %u, name: %s) has an item with an invalid slot (item id: %u, entry: %u, slot: %u).", GetGUIDLow(), GetName(), itemId.GetCounter(), itemEntry, slot);
                continue;
            }

            _voidStorageItems[slot] = new VoidStorageItem(itemId.GetCounter(), item, false);
        }
        while (resultItem->NextRow());
    }
}

Item* Player::_LoadItem(SQLTransaction& trans, uint32 zoneId, uint32 timeDiff, Field* fields)
{
    Item* item = nullptr;

    ObjectGuid::LowType itemGuid  = fields[0].GetUInt64();
    uint32 itemEntry = fields[1].GetUInt32();
    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemEntry))
    {
        bool remove = false;
        item = NewItemOrBag(proto);
        if (item->LoadFromDB(itemGuid, GetGUID(), fields, itemEntry, getLevel()))
        {
            PreparedStatement* stmt = NULL;

            // Do not allow to have item limited to another map/zone in alive state
            if (isAlive() && item->IsLimitedToAnotherMapOrZone(GetMapId(), zoneId))
            {
                TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s', map: %u) has item (GUID: %u, entry: %u) limited to another map (%u). Deleting item.",
                    GetGUIDLow(), GetName(), GetMapId(), item->GetGUIDLow(), item->GetEntry(), zoneId);
                remove = true;
            }
            // "Conjured items disappear if you are logged out for more than 15 minutes"
            else if (timeDiff > 15 * MINUTE && proto->GetFlags() & ITEM_FLAG_CONJURED)
            {
                TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s', diff: %u) has conjured item (GUID: %u, entry: %u) with expired lifetime (15 minutes). Deleting item.",
                    GetGUIDLow(), GetName(), timeDiff, item->GetGUIDLow(), item->GetEntry());
                remove = true;
            }
            else if (item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE))
            {
                if (item->GetPlayedTime() > (2 * HOUR))
                {
                    TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with expired refund time (%u). Deleting refund data and removing refundable flag.",
                        GetGUIDLow(), GetName(), item->GetGUIDLow(), item->GetEntry(), item->GetPlayedTime());

                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_REFUND_INSTANCE);
                    stmt->setUInt64(0, item->GetGUIDLow());
                    trans->Append(stmt);

                    item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE);
                }
                else
                {
                    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ITEM_REFUNDS);
                    stmt->setUInt64(0, item->GetGUIDLow());
                    stmt->setUInt64(1, GetGUIDLow());
                    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
                    {
                        item->SetRefundRecipient(GetGUID());
                        item->SetPaidMoney((*result)[0].GetUInt64());
                        item->SetPaidExtendedCost((*result)[1].GetUInt16());
                        AddRefundReference(item->GetGUID());
                    }
                    else
                    {
                        TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with refundable flags, but without data in item_refund_instance. Removing flag.",
                            GetGUIDLow(), GetName(), item->GetGUIDLow(), item->GetEntry());
                        item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE);
                    }
                }
            }
            else if (item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_BOP_TRADEABLE))
            {
                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ITEM_BOP_TRADE);
                stmt->setUInt64(0, item->GetGUIDLow());
                if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
                {
                    std::string strGUID = (*result)[0].GetString();
                    Tokenizer GUIDlist(strGUID, ' ');
                    GuidSet looters;
                    for (Tokenizer::const_iterator itr = GUIDlist.begin(); itr != GUIDlist.end(); ++itr)
                    {
                        std::string guidStr(*itr);
                        ObjectGuid guid;
                        guid.SetRawValue(uint64(strtoull(guidStr.substr(0, 16).c_str(), NULL, 16)), uint64(strtoull(guidStr.substr(16).c_str(), NULL, 16)));
                        looters.insert(guid);
                    }
                    item->SetSoulboundTradeable(looters);
                    AddTradeableItem(item);
                }
                else
                {
                    TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Player::_LoadInventory: player (GUID: %u, name: '%s') has item (GUID: %u, entry: %u) with ITEM_FLAG_BOP_TRADEABLE flag, but without data in item_soulbound_trade_data. Removing flag.",
                        GetGUIDLow(), GetName(), item->GetGUIDLow(), item->GetEntry());
                    item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_BOP_TRADEABLE);
                }
            }
            else if (proto->GetRequiredHoliday())
            {
                remove = true;
                GameEventMgr::GameEventDataMap const& events = sGameEventMgr->GetEventMap();
                GameEventMgr::ActiveEvents const& activeEventsList = sGameEventMgr->GetActiveEventList();
                for (GameEventMgr::ActiveEvents::const_iterator itr = activeEventsList.begin(); itr != activeEventsList.end(); ++itr)
                {
                    if (uint32(events[*itr].holiday_id) == proto->GetRequiredHoliday())
                    {
                        remove = false;
                        break;
                    }
                }
            }

            if (!InitChallengeKey(item))
                remove = true;
        }
        else
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has broken item (GUID: %u, entry: %u) in inventory. Deleting item.",
                GetGUIDLow(), GetName(), itemGuid, itemEntry);
            remove = true;
        }
        // Remove item from inventory if necessary
        if (remove)
        {
            Item::DeleteFromInventoryDB(trans, itemGuid);
            item->FSetState(ITEM_REMOVED);
            item->SaveToDB(trans);                           // it also deletes item object!
            item = NULL;
        }
    }
    else
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadInventory: player (GUID: %u, name: '%s') has unknown item (entry: %u) in inventory. Deleting item.",
            GetGUIDLow(), GetName(), itemEntry);
        /* Delete de cette foutue fonction, jamais tu ne delete des items !
        Item::DeleteFromInventoryDB(trans, itemGuid);
        Item::DeleteFromDB(trans, itemGuid);
        */
    }
    return item;
}

// load mailed item which should receive current player
void Player::_LoadMailedItems(Mail* mail)
{
    //          0           1               2       3           4       5       6           7                   8           9        10         11              12          13                  14          15          16      17          
    //SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, transmogrification, upgradeId, enchantIllusion, bonusListIDs, item_guid, itemEntry, owner_guid
    // data needs to be at first place for Item::LoadFromDB
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAILITEMS);
    stmt->setUInt32(0, mail->messageID);
    PreparedQueryResult result = CharacterDatabase.Query(stmt);
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();

        ObjectGuid::LowType itemGuid = fields[0].GetUInt64();
        uint32 itemTemplate = fields[1].GetUInt32();

        mail->AddItem(itemGuid, itemTemplate);

        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemTemplate);

        if (!proto)
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player %u has unknown item_template (ProtoType) in mailed items(GUID: %u template: %u) in mail (%u), deleted.", GetGUIDLow(), itemGuid, itemTemplate, mail->messageID);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_INVALID_MAIL_ITEM);
            stmt->setUInt64(0, itemGuid);
            CharacterDatabase.Execute(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
            stmt->setUInt64(0, itemGuid);
            CharacterDatabase.Execute(stmt);
            continue;
        }

        std::vector<ItemDynamicFieldArtifactPowers> artifactData;

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_ITEM_INSTANCE_ARTIFACT_POWERS);
        stmt->setUInt64(0, itemGuid);
        PreparedQueryResult artifactsResult = CharacterDatabase.Query(stmt);
    
        if (artifactsResult)
        {
            do
            {
                Field* art_fields = artifactsResult->Fetch();
                ItemDynamicFieldArtifactPowers artifactPowerData;
                artifactPowerData.ArtifactPowerId = art_fields[0].GetUInt32();
                artifactPowerData.PurchasedRank = art_fields[1].GetUInt8();
                if (ArtifactPowerEntry const* artifactPower = sArtifactPowerStore.LookupEntry(artifactPowerData.ArtifactPowerId))
                {
                    artifactPowerData.CurrentRankWithBonus = ((artifactPower->Flags & ARTIFACT_POWER_FLAG_NO_LINK_REQUIRED) && !artifactPower->Tier) ? 1 : 0;

                    artifactData.push_back(artifactPowerData);
                }

            } while (artifactsResult->NextRow());
        }

        Item* item = NewItemOrBag(proto);

        if (!item->LoadFromDB(itemGuid, ObjectGuid::Create<HighGuid::Player>(fields[50].GetUInt64()), fields, itemTemplate, getLevel()))
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadMailedItems - Item in mail (%u) doesn't exist !!!! - item guid: %u, deleted from mail", mail->messageID, itemGuid);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM);
            stmt->setUInt64(0, itemGuid);
            CharacterDatabase.Execute(stmt);

            item->FSetState(ITEM_REMOVED);

            SQLTransaction temp = SQLTransaction(NULL);
            item->SaveToDB(temp);                               // it also deletes item object !
            continue;
        }

        if (item->GetTemplate()->GetArtifactID())
        {
            if (!artifactData.empty())
                item->LoadArtifactData(this, artifactData);
            else
            {
                item->InitArtifactPowers(item->GetTemplate()->GetArtifactID());

                for (ArtifactAppearanceEntry const* artifactAppearance : sArtifactAppearanceStore)
                {
                    if (ArtifactAppearanceSetEntry const* artifactAppearanceSet = sArtifactAppearanceSetStore.LookupEntry(artifactAppearance->ArtifactAppearanceSetID))
                    {
                        if (item->GetTemplate()->GetArtifactID() != artifactAppearanceSet->ArtifactID)
                            continue;

                        if (!sConditionMgr->IsPlayerMeetingCondition(this, artifactAppearance->UnlockPlayerConditionID))
                            continue;

                        item->SetModifier(ITEM_MODIFIER_ARTIFACT_APPEARANCE_ID, artifactAppearance->ID);
                        item->SetAppearanceModId(artifactAppearance->ItemAppearanceModifierID);
                        break;
                    }
                }
            }
        }

        if (item->GetTemplate()->IsLegendaryLoot())
            AllLegendarys.insert(item->GetEntry());

        AddMItem(item);
    }
    while (result->NextRow());
}

void Player::_LoadMailInit(PreparedQueryResult resultUnread, PreparedQueryResult resultDelivery)
{
    //set a count of unread mails
    //QueryResult* resultMails = CharacterDatabase.PQuery("SELECT COUNT(id) FROM mail WHERE receiver = '%u' AND (checked & 1)=0 AND deliver_time <= '" UI64FMTD "'", GUID_LOPART(playerGuid), (uint64)cTime);
    if (resultUnread)
        unReadMails = uint8((*resultUnread)[0].GetUInt64());

    // store nearest delivery time (it > 0 and if it < current then at next player update SendNewMaill will be called)
    //resultMails = CharacterDatabase.PQuery("SELECT MIN(deliver_time) FROM mail WHERE receiver = '%u' AND (checked & 1)=0", GUID_LOPART(playerGuid));
    if (resultDelivery)
        m_nextMailDelivereTime = time_t((*resultDelivery)[0].GetUInt32());
}

void Player::_LoadMail()
{
    m_mail.clear();

    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_MAIL);
    stmt->setUInt64(0, GetGUIDLow());
    PreparedQueryResult result = CharacterDatabase.Query(stmt);

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            Mail* m = new Mail;

            m->messageID      = fields[0].GetUInt32();
            m->messageType    = fields[1].GetUInt8();
            m->sender         = fields[2].GetUInt64();
            m->receiver       = fields[3].GetUInt64();
            m->subject        = fields[4].GetString();
            m->body           = fields[5].GetString();
            bool has_items    = fields[6].GetBool();
            m->expire_time    = time_t(fields[7].GetUInt32());
            m->deliver_time   = time_t(fields[8].GetUInt32());
            m->money          = fields[9].GetUInt64();
            m->COD            = fields[10].GetUInt64();
            m->checked        = fields[11].GetUInt8();
            m->stationery     = fields[12].GetUInt8();
            m->mailTemplateId = fields[13].GetInt16();

            if (m->mailTemplateId && !sMailTemplateStore.LookupEntry(m->mailTemplateId))
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadMail - Mail (%u) have not existed MailTemplateId (%u), remove at load", m->messageID, m->mailTemplateId);
                m->mailTemplateId = 0;
            }

            m->state = MAIL_STATE_UNCHANGED;

            if (has_items)
                _LoadMailedItems(m);

            m_mail.push_back(m);
        }
        while (result->NextRow());
    }
    m_mailsLoaded = true;
}

void Player::LoadPet()
{
    //fixme: the pet should still be loaded if the player is not in world
    // just not added to the map
    if (m_currentPetNumber && IsInWorld())
    {
        Pet* pet = new Pet(this);
        if (!pet->LoadPetFromDB(this, 0, m_currentPetNumber))
            delete pet;
    }
}

void Player::_LoadQuestStatus(PreparedQueryResult result)
{
    uint16 slot = 0;

    ////                                                       0      1       2     3
    //QueryResult* result = CharacterDatabase.PQuery("SELECT quest, status, timer, guid WHERE guid = '%u'", GetSession()->GetAccountId());

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 quest_id = fields[0].GetUInt32();
            ObjectGuid::LowType guid = fields[3].GetUInt64();
                                                            // used to be new, no delete?
            Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
            if (quest)
            {
                if ((*m_QuestStatusVector)[quest_id])
                    continue;

                if (quest->QuestInfoID != QUEST_INFO_ACCOUNT && guid != GetGUIDLow()) //check account quest
                    continue;

                // find or create
                QuestStatusData& q_status = m_QuestStatus[quest_id];
                (*m_QuestStatusVector)[quest_id] = &q_status;

                uint8 qstatus = fields[1].GetUInt8();
                if (qstatus < MAX_QUEST_STATUS)
                    q_status.Status = QuestStatus(qstatus);
                else
                {
                    q_status.Status = QUEST_STATUS_INCOMPLETE;
                    TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player %s (GUID: %u) has invalid quest %d status (%u), replaced by QUEST_STATUS_INCOMPLETE(3).",
                        GetName(), GetGUIDLow(), quest_id, qstatus);
                }

                time_t quest_time = time_t(fields[2].GetUInt32());

                if (quest->HasSpecialFlag(QUEST_SPECIAL_FLAGS_TIMED) && !GetQuestRewardStatus(quest_id))
                {
                    AddTimedQuest(quest_id);

                    if (quest_time <= sWorld->GetGameTime())
                        q_status.Timer = 1;
                    else
                        q_status.Timer = uint32((quest_time - sWorld->GetGameTime()) * IN_MILLISECONDS);
                }
                //! WARN! time should send always. As it require for correct showing on tracking list. 
                /*else
                    quest_time = 0;*/

                // add to quest log
                //! q_status.Status == QUEST_STATUS_INCOMPLETE --> WTF? we should set SetQuestSlotState & add on slot it.
                if (slot < MAX_QUEST_LOG_SIZE /*&& q_status.Status == QUEST_STATUS_INCOMPLETE*/ && quest->Type != QUEST_TYPE_TASK)
                {
                    SetQuestSlot(slot, quest_id, uint32(quest_time)); // cast can't be helped

                    if (q_status.Status == QUEST_STATUS_COMPLETE)
                        SetQuestSlotState(slot, QUEST_STATE_COMPLETE);
                    else if (q_status.Status == QUEST_STATUS_FAILED)
                        SetQuestSlotState(slot, QUEST_STATE_FAIL);

                    ++slot;
                }

                TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Quest status is {%u} for quest {%u} for player (GUID: %u)", q_status.Status, quest_id, GetGUIDLow());
            }
        }
        while (result->NextRow());
    }

    // clear quest log tail
    for (uint16 i = slot; i < MAX_QUEST_LOG_SIZE; ++i)
        SetQuestSlot(i, 0);
}

void Player::_LoadQuestStatusObjectives(PreparedQueryResult result)
{
    ////                                                       0        1       2
    //QueryResult* result = CharacterDatabase.PQuery("SELECT quest, objective, data WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 questID = fields[0].GetUInt32();

            Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questID);
            if (!qInfo)
                continue;

            if (getQuestStatus(questID))
            {
                int8 objectiveIndex = fields[1].GetInt8();
                int32 data = fields[2].GetInt32();

                for (QuestObjective const& obj : qInfo->GetObjectives())
                {
                    if (objectiveIndex == obj.StorageIndex)
                    {
                        SetQuestObjectiveData(qInfo, &obj, data, true);
                        break;
                    }
                }
            }
            else
                TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Player %s (%s) does not have quest %d but has objective data for it.", GetName(), GetGUID().ToString().c_str(), questID);
        }
        while (result->NextRow());
    }
}

void Player::_LoadQuestStatusRewarded(PreparedQueryResult result)
{
    // SELECT quest, guid FROM character_queststatus_rewarded WHERE account = ?

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 quest_id = fields[0].GetUInt32();
            ObjectGuid::LowType guid = fields[1].GetUInt64();

            if (m_RewardedQuests.find(quest_id) != m_RewardedQuests.end())
                continue;
                                                            // used to be new, no delete?
            Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
            if (quest)
            {
                if (quest->QuestInfoID != QUEST_INFO_ACCOUNT && guid != GetGUIDLow()) //check account quest
                    continue;

                // learn rewarded spell if unknown
                learnQuestRewardedSpells(quest);

                if (quest->RewardTitleId)
                    if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(quest->RewardTitleId))
                        SetTitle(titleEntry);

                // Skip loading special quests - they are also added to rewarded quests but only once and remain there forever
                // instead add them separately from load daily/weekly/monthly/seasonal
                if (!quest->IsDailyOrWeekly() /*&& !quest->IsMonthly()*/ && !quest->IsSeasonal())
                    SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(quest_id), true);

                //clean db as status not deleted.
                if (QuestStatusData* q_status = getQuestStatus(quest_id))
                {
                    q_status->Status = QUEST_STATUS_REWARDED;
                    m_QuestStatusSave[quest_id] = QUEST_DELETE_SAVE_TYPE;
                }
            }

            m_RewardedQuests.insert(quest_id);
        }
        while (result->NextRow());
    }
}

void Player::_LoadAccountQuest(PreparedQueryResult result)
{
    // SELECT quest FROM character_queststatus_rewarded WHERE account = ?

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            m_accuntQuests.insert(fields[0].GetUInt32());
        }
        while (result->NextRow());
    }
}

void Player::_LoadDailyQuestStatus(PreparedQueryResult result)
{
    m_DFQuests.clear();

    //QueryResult* result = CharacterDatabase.PQuery("SELECT quest, time, guid FROM character_queststatus_daily WHERE account = '%u'", GetSession()->GetAccountId());

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            ObjectGuid::LowType guid = fields[2].GetUInt64();

            Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            if (quest->QuestInfoID != QUEST_INFO_ACCOUNT && guid != GetGUIDLow()) //check account quest
                continue;

            if (quest->IsDFQuest())
            {
                m_DFQuests.insert(quest->GetQuestId());
                m_lastDailyQuestTime = time_t(fields[1].GetUInt32());
                continue;
            }

            // save _any_ from daily quest times (it must be after last reset anyway)
            m_lastDailyQuestTime = time_t(fields[1].GetUInt32());

            if (m_dailyquests.find(quest_id) == m_dailyquests.end())
            {
                AddDynamicValue(PLAYER_DYNAMIC_FIELD_DAILY_QUESTS_COMPLETED, quest_id);
                SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(quest_id), true);
                m_dailyquests.insert(quest_id);
            }

            TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Daily quest (%u) cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_DailyQuestChanged = false;
}

void Player::_LoadWeeklyQuestStatus(PreparedQueryResult result)
{
    m_weeklyquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            ObjectGuid::LowType guid = fields[1].GetUInt64();

            Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            if (quest->QuestInfoID != QUEST_INFO_ACCOUNT && guid != GetGUIDLow()) //check account quest
                continue;

            if (m_weeklyquests.find(quest_id) != m_weeklyquests.end())
                continue;

            m_weeklyquests.insert(quest_id);
            SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(quest_id), true);
            TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Weekly quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_WeeklyQuestChanged = false;
}

void Player::_LoadSeasonalQuestStatus(PreparedQueryResult result)
{
    m_seasonalquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            uint32 event_id = fields[1].GetUInt32();
            ObjectGuid::LowType guid = fields[2].GetUInt64();

            Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            if (quest->QuestInfoID != QUEST_INFO_ACCOUNT && guid != GetGUIDLow()) //check account quest
                continue;

            if (m_seasonalquests.find(quest_id) != m_seasonalquests.end())
                continue;

            m_seasonalquests[event_id].insert(quest_id);
            SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(quest_id), true);
            TC_LOG_DEBUG(LOG_FILTER_PLAYER_LOADING, "Seasonal quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }

    m_SeasonalQuestChanged = false;
}

void Player::_LoadAdventureQuestStatus(PreparedQueryResult result)
{
    m_adventure_questID = 0;

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();

            Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
            if (!quest)
                continue;
            m_adventure_questID = quest_id;

        }
        while (result->NextRow());
    }
}

/*void Player::_LoadMonthlyQuestStatus(PreparedQueryResult result)
{
    m_monthlyquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            m_monthlyquests.insert(quest_id);
            SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(quest_id), true);

            TC_LOG_DEBUG("entities.player.loading", "Monthly quest {%u} cooldown for player (%s)", quest_id, GetGUID().ToString().c_str());
        }
        while (result->NextRow());
    }

    m_MonthlyQuestChanged = false;
}*/
void Player::_LoadSpells(PreparedQueryResult result)
{
    //QueryResult* result = CharacterDatabase.PQuery("SELECT spell, active, disabled FROM character_spell WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 spellID = fields[0].GetUInt32();
            if (auto const& speciesInfo = sDB2Manager.GetSpeciesBySpell(spellID))
                _oldPetBattleSpellToMerge.insert(std::make_pair(spellID, speciesInfo->ID));

            addSpell((*result)[0].GetUInt32(), (*result)[1].GetBool(), false, false, (*result)[2].GetBool(), true, 0, true);
        } while (result->NextRow());
    }
}

void Player::_LoadSpellRewards()
{
    // check on achievement reward spell
    CompletedAchievementMap const* achievs = m_achievementMgr->GetCompletedAchievementsList();

    if (!achievs || achievs->empty())
        return;

    for (CompletedAchievementMap::const_iterator iter = achievs->begin(); iter != achievs->end(); ++iter)
    {
        AchievementEntry const* achievement = sAchievementStore.LookupEntry(iter->first);

        if (!achievement)
            continue;

        if (AchievementReward const* reward = sAchievementMgr->GetAchievementReward(achievement))
        {
            if (reward->learnSpell && !HasSpell(reward->learnSpell))
                learnSpell(reward->learnSpell, true);
        }
    }
}

void Player::_LoadCUFProfiles(PreparedQueryResult result)
{
    if (!result)
        return;

    do
    {
        // SELECT profileId, profileName, frameHeight, frameWidth, sortBy, healthText, options, unk146, unk147, unk148, unk150, unk152, unk154 FROM character_cuf_profiles WHERE guid = ?
        Field* fields = result->Fetch();

        uint8 id            = fields[0].GetUInt8();
        std::string name    = fields[1].GetString();
        uint16 frameHeight  = fields[2].GetUInt16();
        uint16 frameWidth   = fields[3].GetUInt16();
        uint8 sortBy        = fields[4].GetUInt8();
        uint8 healthText    = fields[5].GetUInt8();
        uint32 boolOptions  = fields[6].GetUInt32();
        uint8 topPoint      = fields[7].GetUInt8();
        uint8 bottomPoint   = fields[8].GetUInt8();
        uint8 leftPoint     = fields[9].GetUInt8();
        uint16 topOffset    = fields[10].GetUInt16();
        uint16 bottomOffset = fields[11].GetUInt16();
        uint16 leftOffset   = fields[12].GetUInt16();

        if (id > MAX_CUF_PROFILES)
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::_LoadCUFProfiles - Player (GUID: %u, name: %s) has an CUF profile with invalid id (id: %u), max is %i.", GetGUIDLow(), GetName(), id, MAX_CUF_PROFILES);
            continue;
        }

        _CUFProfiles[id] = Trinity::make_unique<CUFProfile>(name, frameHeight, frameWidth, sortBy, healthText, boolOptions, topPoint, bottomPoint, leftPoint, topOffset, bottomOffset, leftOffset);
    }
    while (result->NextRow());
}

void Player::_LoadGroup(PreparedQueryResult result)
{
    //QueryResult* result = CharacterDatabase.PQuery("SELECT guid FROM group_member WHERE memberGuid=%u", GetGUIDLow());
    if (result)
    {
        if (Group* group = sGroupMgr->GetGroupByDbStoreId((*result)[0].GetUInt32()))
        {
            if (group->IsLeader(GetGUID()))
                SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GROUP_LEADER);

            uint8 subgroup = group->GetMemberGroup(GetGUID());
            SetGroup(group, subgroup);
            SetPartyType(group->GetGroupCategory(), GROUP_TYPE_NORMAL);
            ResetGroupUpdateSequenceIfNeeded(group);
            if (getLevel() >= LEVELREQUIREMENT_HEROIC)
            {
                // the group leader may change the instance difficulty while the player is offline
                SetDungeonDifficultyID(group->GetDungeonDifficultyID());
                SetRaidDifficultyID(group->GetRaidDifficultyID());
                SetLegacyRaidDifficultyID(group->GetLegacyRaidDifficultyID());
            }
        }
    }

    if (!GetGroup() || !GetGroup()->IsLeader(GetGUID()))
        RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_GROUP_LEADER);
}

void Player::_LoadLootCooldown(PreparedQueryResult result)
{
    if (!result)
        return;
    do
    {
        Field* fields = result->Fetch();
        playerLootCooldown lootCooldown;
        lootCooldown.entry = fields[0].GetInt32();
        lootCooldown.type = fields[1].GetInt8();
        lootCooldown.difficultyID = fields[2].GetUInt8();
        lootCooldown.respawnTime = fields[3].GetInt32();
        lootCooldown.state = false;
        m_playerLootCooldown[lootCooldown.type][lootCooldown.entry][lootCooldown.difficultyID] = lootCooldown;
    }
    while (result->NextRow());
}

void Player::_SaveLootCooldown(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;

    for(int i = 0; i < MAX_LOOT_COOLDOWN_TYPE; i++)
    {
        for (PlayerLootCooldownMap::iterator itr = m_playerLootCooldown[i].begin(); itr != m_playerLootCooldown[i].end(); ++itr)
            for (std::map<uint8, playerLootCooldown>::iterator iter = itr->second.begin(); iter != itr->second.end(); ++iter)
            {
                if (!iter->second.state)
                    continue;

                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PLAYER_LOOTCOOLDOWN);
                stmt->setUInt64(0, GetGUIDLow());
                stmt->setUInt32(1, iter->second.entry);
                stmt->setUInt32(2, iter->second.type);
                stmt->setUInt32(3, iter->second.difficultyID);
                stmt->setUInt32(4, iter->second.respawnTime);
                iter->second.state = false;
                trans->Append(stmt);
            }
    }
}

void Player::ResetLootCooldown()
{
    for(int i = 0; i < MAX_LOOT_COOLDOWN_TYPE; ++i)
    {
        for (PlayerLootCooldownMap::iterator itr = m_playerLootCooldown[i].begin(); itr != m_playerLootCooldown[i].end(); ++itr)
        {
            for (std::map<uint8, playerLootCooldown>::iterator iter = itr->second.begin(); iter != itr->second.end();)
            {
                if (iter->second.respawnTime)
                    itr->second.erase(iter++);
                else
                    ++iter;
            }
        }
    }
    m_playerLfgCooldown.clear();
}

void Player::AddPlayerLootCooldown(uint32 entry, uint32 guid, uint8 type/* = 0*/, bool respawn/* = true*/, uint8 diff/* = 0*/)
{
    if (!diff)
        diff = GetMap()->GetDifficultyID();

    uint32 respawnTime = respawn ? sWorld->getNextInstanceWeeklyReset() : 0;
    if (type == TYPE_GUID && diff == DIFFICULTY_NONE)
    {
        respawnTime = time(NULL) + 600;
        entry = guid;
    }

    switch (diff)
    {
        case DIFFICULTY_N_SCENARIO:
        case DIFFICULTY_HC_SCENARIO:
        case DIFFICULTY_NORMAL:
        case DIFFICULTY_MYTHIC_KEYSTONE:
            if (type == TYPE_GO || type == TYPE_GUID)
            {
                respawnTime = sWorld->getNextInstanceDailyReset();
                type = TYPE_GUID;
                entry = guid;
            }
            else
                respawnTime = time(NULL) + 2 * HOUR;
            break;
        case DIFFICULTY_HEROIC:
        case DIFFICULTY_MYTHIC_DUNGEON:
            respawnTime = sWorld->getNextInstanceDailyReset();
            break;
        default:
            break;
    }

    if (entry == 542185 || entry == 542191)
        respawnTime = time(NULL) + 7200;

    if (type == TYPE_ZONE)
        respawnTime = time(NULL) + 21600;

    playerLootCooldown& lootCooldown = m_playerLootCooldown[type][entry][diff];
    lootCooldown.entry = entry;
    lootCooldown.type = type;
    lootCooldown.difficultyID = diff;
    lootCooldown.respawnTime = respawnTime;
    lootCooldown.state = true;
}

bool Player::IsPlayerLootCooldown(uint32 entry, uint8 type/* = 0*/, uint8 diff/* = 0*/)
{
    PlayerLootCooldownMap::const_iterator itr = m_playerLootCooldown[type].find(entry);
    if (itr == m_playerLootCooldown[type].end())
        return false;

    std::map<uint8, playerLootCooldown>::const_iterator iter = itr->second.find(diff);
    if (iter != itr->second.end())
        if (!iter->second.respawnTime || iter->second.respawnTime > time(NULL))
            return true;

    return false;
}

void Player::_LoadLfgCooldown(PreparedQueryResult result)
{
    if (!result)
        return;
    do
    {
        Field* fields = result->Fetch();
        uint32 dungeonId = fields[0].GetInt32();
        playerLfgCooldown& lfgCooldown = m_playerLfgCooldown[dungeonId];
        lfgCooldown.dungeonId = dungeonId;
        lfgCooldown.respawnTime = fields[1].GetInt32();
        lfgCooldown.state = false;
    }
    while (result->NextRow());
}

void Player::_SaveLfgCooldown(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    for (PlayerLfgCooldownMap::iterator iter = m_playerLfgCooldown.begin(); iter != m_playerLfgCooldown.end(); ++iter)
    {
        if (!iter->second.state)
            continue;

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PLAYER_LFGCOOLDOWN);
        stmt->setUInt64(0, GetGUIDLow());
        stmt->setUInt32(1, iter->second.dungeonId);
        stmt->setUInt32(2, iter->second.respawnTime);
        iter->second.state = false;
        trans->Append(stmt);
    }
}

void Player::AddLfgCooldown(uint32 dungeonId)
{
    uint32 respawnTime = sWorld->getNextInstanceWeeklyReset();

    switch (GetMap()->GetDifficultyID())
    {
        case DIFFICULTY_N_SCENARIO:
        case DIFFICULTY_HC_SCENARIO:
        case DIFFICULTY_NORMAL:
        case DIFFICULTY_HEROIC:
        case DIFFICULTY_MYTHIC_KEYSTONE:
        case DIFFICULTY_MYTHIC_DUNGEON:
            respawnTime = sWorld->getNextInstanceDailyReset();
            break;
        default:
            break;
    }

    playerLfgCooldown& lfgCooldown = m_playerLfgCooldown[dungeonId];
    lfgCooldown.dungeonId = dungeonId;
    lfgCooldown.respawnTime = respawnTime;
    lfgCooldown.state = true;
}

bool Player::IsLfgCooldown(uint32 dungeonId)
{
    return m_playerLfgCooldown.find(dungeonId) != m_playerLfgCooldown.end();
}

void Player::_LoadBoundInstances(PreparedQueryResult result)
{
    for (uint8 i = 0; i < MAX_BOUND; ++i)
        m_boundInstances[i].clear();

    Group* group = GetGroup();

    //QueryResult* result = CharacterDatabase.PQuery("SELECT instance, map, difficulty, permanent, completedEncounters, data, resetTime, Extended FROM character_instance WHERE guid = '%u'", GUID_LOPART(m_guid));
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();

            uint32 instanceId = fields[0].GetUInt32();
            uint32 mapId = fields[1].GetUInt16();
            uint8 difficulty = fields[2].GetUInt8();
            bool perm = fields[3].GetBool();
            uint32 completedEncounter = fields[4].GetUInt32();
            std::string data  = fields[5].GetString();
            time_t resetTime = time_t(fields[6].GetUInt32());
            bool Extended = fields[7].GetBool();

            bool deleteInstance = false;

            MapEntry const* mapEntry = sMapStore.LookupEntry(mapId);
            if (!mapEntry || !mapEntry->IsDungeon())
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) has bind to not existed or not dungeon map %d", GetName(), GetGUIDLow(), mapId);
                deleteInstance = true;
            }
            else if (difficulty >= MAX_DIFFICULTY)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) has bind to not existed difficulty %d instance for map %u", GetName(), GetGUIDLow(), difficulty, mapId);
                deleteInstance = true;
            }
            else if ((resetTime + MONTH) <= time(NULL) && !Extended)
                deleteInstance = true;
            else
            {
                MapDifficultyEntry const* mapDiff = sDB2Manager.GetMapDifficultyData(mapId, Difficulty(difficulty));
                if (!mapDiff)
                {
                    TC_LOG_ERROR(LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) has bind to not existed difficulty %d instance for map %u", GetName(), GetGUIDLow(), difficulty, mapId);
                    deleteInstance = true;
                }
                else if (!perm && group)
                {
                    TC_LOG_ERROR(LOG_FILTER_PLAYER, "_LoadBoundInstances: player %s(%d) is in group %d but has a non-permanent character bind to map %d, %d, %d", GetName(), GetGUIDLow(), group->GetGUIDLow(), mapId, instanceId, difficulty);
                    deleteInstance = true;
                }
            }

            if (deleteInstance)
            {
                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID);

                stmt->setUInt64(0, GetGUIDLow());
                stmt->setUInt32(1, instanceId);

                CharacterDatabase.Execute(stmt);
                continue;
            }

            // since non permanent binds are always solo bind, they can always be reset
            if (InstanceSave* save = sInstanceSaveMgr->AddInstanceSave(mapId, instanceId, Difficulty(difficulty), completedEncounter, data, resetTime, !perm, true))
            {
                BindToInstance(save, perm, true);
                save->SetPerm(perm);
                save->SetExtended(Extended);
            }
        }
        while (result->NextRow());
    }
}

InstancePlayerBind* Player::GetBoundInstance(uint32 mapid, Difficulty difficulty)
{
    auto mapDiff = sDB2Manager.GetDownscaledMapDifficultyData(mapid, difficulty);
    if (!mapDiff)
        return nullptr;

    return Trinity::Containers::MapGetValuePtr(m_boundInstances[sObjectMgr->GetboundTypeFromDifficulty(difficulty)], mapid);
}

InstanceSave* Player::GetInstanceSave(uint32 mapid)
{
    MapEntry const* mapEntry = sMapStore.LookupEntry(mapid);
    InstancePlayerBind* pBind = GetBoundInstance(mapid, GetDifficultyID(mapEntry));
    InstanceSave* pSave = pBind ? pBind->save : NULL;
    if (!pBind || !pBind->perm)
        if (Group* group = GetGroup())
            if (InstanceGroupBind* groupBind = group->GetBoundInstance(this))
                pSave = groupBind->save;

    return pSave;
}

void Player::UnbindInstance(uint32 mapid, Difficulty difficulty, bool unload)
{
    uint8 boundType = sObjectMgr->GetboundTypeFromDifficulty(difficulty);
    BoundInstancesMap::iterator itr = m_boundInstances[boundType].find(mapid);
    UnbindInstance(itr, difficulty, unload);
}

void Player::UnbindInstance(BoundInstancesMap::iterator &itr, Difficulty difficulty, bool unload)
{
    uint8 boundType = sObjectMgr->GetboundTypeFromDifficulty(difficulty);
    if (itr != m_boundInstances[boundType].end())
    {
        if (!unload)
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INSTANCE_BY_INSTANCE_GUID);

            stmt->setUInt64(0, GetGUIDLow());
            stmt->setUInt32(1, itr->second.save->GetInstanceId());

            CharacterDatabase.Execute(stmt);
        }

        if (itr->second.perm)
            SendCalendarRaidLockout(itr->second.save, false);

        itr->second.save->RemovePlayer(this);               // save can become invalid
        m_boundInstances[boundType].erase(itr++);
    }
}

InstancePlayerBind* Player::BindToInstance(InstanceSave* save, bool permanent, bool load)
{
    if (save)
    {
        uint8 boundType = sObjectMgr->GetboundTypeFromDifficulty(save->GetDifficultyID());
        InstancePlayerBind& bind = m_boundInstances[boundType][save->GetMapId()];

        if(save->CanBeSave())
        {
            bool needSave = false;
            if (bind.save)
            {
                // update the save when the group kills a boss
                if (permanent != bind.perm || save != bind.save)
                    if (!load)
                        needSave = true;
            }
            else if (!load)
                    needSave = true;

            save->SetPerm(permanent);
            if (needSave)
                UpdateInstance(save);
        }
        else
            permanent = false;

        if (bind.save != save)
        {
            if (bind.save)
                bind.save->RemovePlayer(this);
            save->AddPlayer(this);
        }

        if (permanent)
            save->SetCanReset(false);

        bind.save = save;
        bind.perm = permanent;
        if (!load)
            TC_LOG_DEBUG(LOG_FILTER_MAPS, "Player::BindToInstance: %s(%d) is now bound to map %d, instance %d, difficulty %d", GetName(), GetGUIDLow(), save->GetMapId(), save->GetInstanceId(), save->GetDifficultyID());
        sScriptMgr->OnPlayerBindToInstance(this, save->GetDifficultyID(), save->GetMapId(), permanent);
        return &bind;
    }
    return NULL;
}

void Player::BindToInstance()
{
    InstanceSave* mapSave = sInstanceSaveMgr->GetInstanceSave(_pendingBindId);
    if (!mapSave) //it seems sometimes mapSave is NULL, but I did not check why
        return;

    if (mapSave->SaveIsOld() && mapSave->GetExtended())
    {
        mapSave->SetExtended(false);
        if (MapDifficultyEntry const* mapDiff = sDB2Manager.GetMapDifficultyData(mapSave->GetMapId(), mapSave->GetDifficultyID()))
            mapSave->SetResetTime(sWorld->getInstanceResetTime(mapDiff->GetRaidDuration()));
        UpdateInstance(mapSave);
    }
    SendDirectMessage(WorldPackets::Instance::InstanceSaveCreated(false).Write());
    BindToInstance(mapSave, true);
    SendCalendarRaidLockout(mapSave, true);
}

void Player::SendRaidInfo()
{
    time_t now = time(NULL);
    WorldPackets::Instance::InstanceInfo instanceInfo;

    for (uint8 i = 0; i < MAX_BOUND; ++i)
    {
        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
        {
            if (itr->second.perm)
            {
                InstanceSave* save = itr->second.save;

                int32 resetTime = save->GetResetTime() - now;
                if (save->GetExtended())
                    if (MapDifficultyEntry const* mapDiff = sDB2Manager.GetMapDifficultyData(save->GetMapId(), save->GetDifficultyID()))
                        resetTime = sWorld->getInstanceResetTime(mapDiff->GetRaidDuration()) - now;

                WorldPackets::Instance::InstanceLockInfos lockInfos;
                lockInfos.InstanceID = save->GetInstanceId();
                lockInfos.MapID = save->GetMapId();
                lockInfos.DifficultyID = save->GetDifficultyID();
                lockInfos.TimeRemaining = resetTime > 0 ? resetTime : 0;
                lockInfos.CompletedMask = save->GetCompletedEncounterMask();
                lockInfos.Locked = lockInfos.TimeRemaining > 0;
                lockInfos.Extended = save->GetExtended();
                instanceInfo.LockList.push_back(lockInfos);
            }
        }
    }

    SendDirectMessage(instanceInfo.Write());
}

/*
- called on every successful teleportation to a map
*/
void Player::SendSavedInstances()
{
    bool hasBeenSaved = false;
    for (uint8 i = 0; i < MAX_BOUND; ++i)
    {
        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
        {
            if (itr->second.perm)                               // only permanent binds are sent
            {
                hasBeenSaved = true;
                break;
            }
        }
    }

    WorldPackets::Instance::UpdateInstanceOwnership instanceOwnerShip;
    instanceOwnerShip.IOwnInstance = hasBeenSaved;
    SendDirectMessage(instanceOwnerShip.Write());

    if (!hasBeenSaved)
        return;

    for (uint8 i = 0; i < MAX_BOUND; ++i)
    {
        for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
            if (itr->second.perm)
                SendDirectMessage(WorldPackets::Instance::UpdateLastInstance(itr->second.save->GetMapId()).Write());
    }
}

/// convert the player's binds to the group
void Player::ConvertInstancesToGroup(Player* player, Group* group, bool switchLeader)
{
    // copy all binds to the group, when changing leader it's assumed the character
    // will not have any solo binds

    for (uint8 i = 0; i < MAX_BOUND; ++i)
    {
        for (BoundInstancesMap::iterator itr = player->m_boundInstances[i].begin(); itr != player->m_boundInstances[i].end();)
        {
            group->BindToInstance(itr->second.save, itr->second.perm, false);
            // permanent binds are not removed
            if (switchLeader && !itr->second.perm)
            {
                // increments itr in call
                player->UnbindInstance(itr, itr->second.save->GetDifficultyID(), false);
            }
            else
                ++itr;
        }
    }
}

Player::BoundInstancesMap& Player::GetBoundInstances(Difficulty difficulty)
{
    uint8 boundType = sObjectMgr->GetboundTypeFromDifficulty(difficulty);
    return m_boundInstances[boundType];
}

bool Player::Satisfy(AccessRequirement const* ar, uint32 target_map, bool report)
{
    if (!isGameMaster() && ar)
    {
        uint8 LevelMin = 0;
        uint8 LevelMax = 0;

        MapEntry const* mapEntry = sMapStore.LookupEntry(target_map);
        if (!mapEntry)
            return false;

        if (!sWorld->getBoolConfig(CONFIG_INSTANCE_IGNORE_LEVEL))
        {
            if (ar->levelMin && getLevel() < ar->levelMin)
                LevelMin = ar->levelMin;
            if (ar->levelMax && getLevel() > ar->levelMax)
                LevelMax = ar->levelMax;
        }

        uint32 missingItem = 0;
        if (ar->item)
        {
            if (!HasItemCount(ar->item) &&
                (!ar->item2 || !HasItemCount(ar->item2)))
                missingItem = ar->item;
        }
        else if (ar->item2 && !HasItemCount(ar->item2))
            missingItem = ar->item2;

        if (DisableMgr::IsDisabledFor(DISABLE_TYPE_MAP, target_map, this))
        {
            GetSession()->SendNotification("%s", GetSession()->GetTrinityString(LANG_INSTANCE_CLOSED));
            return false;
        }

        uint32 missingQuest = 0;
        uint32 checkAchievement = 0;
        if(GetTeam() == ALLIANCE)
        {
            if (ar->quest_A && !HasAccountQuest(ar->quest_A))
                missingQuest = ar->quest_A;
            if(ar->achievement_A != 0)
                checkAchievement = ar->achievement_A;
        }
        else if (ar->quest_H && !HasAccountQuest(ar->quest_H))
            missingQuest = ar->quest_H;

        if(checkAchievement == 0)
            checkAchievement = ar->achievement;

        Player* leader = this;
        ObjectGuid leaderGuid = GetGroup() ? GetGroup()->GetLeaderGUID() : GetGUID();
        if (leaderGuid != GetGUID())
            leader = ObjectAccessor::FindPlayer(leaderGuid);

        uint32 missingAchievement = 0;
        if (checkAchievement)
            if (!leader || !leader->HasAchieved(checkAchievement))
                missingAchievement = checkAchievement;

        Difficulty target_difficulty = GetDifficultyID(mapEntry);

        MapDifficultyEntry const* mapDiff = sDB2Manager.GetDownscaledMapDifficultyData(target_map, target_difficulty);
        if (!mapDiff)
            return false;

        if (LevelMin || LevelMax || missingItem || missingQuest || missingAchievement)
        {
            if (report)
            {
                if (missingQuest && !ar->questFailedText.empty())
                    ChatHandler(GetSession()).PSendSysMessage("%s", ar->questFailedText.c_str());
                else if (missingAchievement)
                    SendTransferAborted(target_map, TRANSFER_ABORT_DIFFICULTY, target_difficulty);
                else if (missingItem)
                    GetSession()->SendNotification(GetSession()->GetTrinityString(LANG_LEVEL_MINREQUIRED_AND_ITEM), LevelMin, sObjectMgr->GetItemTemplate(missingItem)->GetName()->Str[GetSession()->GetSessionDbLocaleIndex()]);
                else if (LevelMin)
                    GetSession()->SendNotification(GetSession()->GetTrinityString(LANG_LEVEL_MINREQUIRED), LevelMin);
            }
            return false;
        }
    }
    return true;
}

bool Player::CheckInstanceLoginValid()
{
    Map const* map = GetMap();
    if (!map)
        return false;

    if (!map->IsDungeon() || isGameMaster())
        return true;

    // and do one more check before InstanceMap::CanEnte
    // instance full don't checks in CanPlayerEnter due ignore login case.
    if (map->GetPlayersCountExceptGMs() > static_cast<InstanceMap const*>(map)->GetMaxPlayers() && map->GetId() != 1191)
    {
        SendTransferAborted(map->GetId(), TRANSFER_ABORT_MAX_PLAYERS);
        return false;
    }

    // do checks for satisfy accessreqs, instance full, encounter in progress (raid), perm bind group != perm bind player
    return sMapMgr->CanPlayerEnter(GetMap()->GetId(), this, true);
}

PetInfoData* Player::GetPetInfo(uint32 petentry, uint32 petnumber)
{
    if (petnumber)
        return Trinity::Containers::MapGetValuePtr(m_petInfo, petnumber);

    if (petentry)
        for (auto itr = m_petInfo.begin(); itr != m_petInfo.end(); ++itr)
            if (itr->second.entry == petentry)
                return &itr->second;

    return nullptr;
}

void Player::AddPetInfo(Pet* pet)
{
    m_petInfo[pet->GetCharmInfo()->GetPetNumber()].UpdateData(pet);
    setPetSlot(pet->GetSlot(), pet->GetCharmInfo()->GetPetNumber());
}

bool Player::_LoadHomeBind(PreparedQueryResult result)
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    if (!info)
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player (Name %s) has incorrect race/class (%u/%u) pair. Can't be loaded.", GetName(), uint32(getRace()), uint32(getClass()));
        return false;
    }

    bool ok = false;
    // SELECT mapId, zoneId, posX, posY, posZ FROM character_homebind WHERE guid = ?
    if (result)
    {
        Field* fields = result->Fetch();

        m_homebindMapId = fields[0].GetUInt16();
        m_homebindAreaId = fields[1].GetUInt16();
        m_homebindX = fields[2].GetFloat();
        m_homebindY = fields[3].GetFloat();
        m_homebindZ = fields[4].GetFloat();

        MapEntry const* bindMapEntry = sMapStore.LookupEntry(m_homebindMapId);

        // accept saved data only for valid position (and non instanceable), and accessable
        if (MapManager::IsValidMapCoord(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ) &&
            !bindMapEntry->Instanceable() && GetSession()->Expansion() >= bindMapEntry->ExpansionID)
            ok = true;
        else
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_HOMEBIND);
            stmt->setUInt64(0, GetGUIDLow());
            CharacterDatabase.Execute(stmt);
        }
    }

    if (!ok)
    {
        m_homebindMapId = info->mapId;
        m_homebindAreaId = info->areaId;
        m_homebindX = info->positionX;
        m_homebindY = info->positionY;
        m_homebindZ = info->positionZ;

        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PLAYER_HOMEBIND);
        stmt->setUInt64(0, GetGUIDLow());
        stmt->setUInt16(1, m_homebindMapId);
        stmt->setUInt16(2, m_homebindAreaId);
        stmt->setFloat (3, m_homebindX);
        stmt->setFloat (4, m_homebindY);
        stmt->setFloat (5, m_homebindZ);
        CharacterDatabase.Execute(stmt);
    }

    TC_LOG_DEBUG(LOG_FILTER_PLAYER, "Setting player home position - mapid: %u, areaid: %u, X: %f, Y: %f, Z: %f",
        m_homebindMapId, m_homebindAreaId, m_homebindX, m_homebindY, m_homebindZ);

    return true;
}

/*********************************************************/
/***                   SAVE SYSTEM                     ***/
/*********************************************************/

void Player::SaveToDB(bool create /*=false*/)
{
    // delay auto save at any saves (manual, in code, or autosave)
    m_nextSave = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);

    //lets allow only players in world to be saved
    if (IsBeingTeleportedFar())
    {
        ScheduleDelayedOperation(DELAYED_SAVE_PLAYER);
        return;
    }

    if (m_operationsAfterDelayMask & OAD_ARENA_DESERTER)
        HandleArenaDeserter();

    // first save/honor gain after midnight will also update the player's honor fields
    UpdateHonorFields();

    TC_LOG_DEBUG(LOG_FILTER_UNITS, "The value of player %s at save: ", m_name.c_str());
    outDebugValues();

    if (m_vis)
    {
        std::ostringstream ps;
        ps << "REPLACE INTO character_visuals (guid, head, shoulders, chest, waist, legs, feet, wrists, hands, back, main, off, ranged, tabard, shirt) VALUES ("
            << GetGUIDLow() << ", "
            << m_vis->m_visHead << ", "
            << m_vis->m_visShoulders << ", "
            << m_vis->m_visChest << ", "
            << m_vis->m_visWaist << ", "
            << m_vis->m_visLegs << ", "
            << m_vis->m_visFeet << ", "
            << m_vis->m_visWrists << ", "
            << m_vis->m_visHands << ", "
            << m_vis->m_visBack << ", "
            << m_vis->m_visMainhand << ", "
            << m_vis->m_visOffhand << ", "
            << m_vis->m_visRanged << ", "
            << m_vis->m_visTabard << ", "
            << m_vis->m_visShirt << ")";
        CharacterDatabase.Execute(ps.str().c_str());
    }

    PreparedStatement* stmt = NULL;
    uint8 index = 0;

    if (create)
    {
        //! Insert query
        //! TO DO: Filter out more redundant fields that can take their default value at player create
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER);
        stmt->setUInt64(index++, GetGUIDLow());
        stmt->setUInt32(index++, GetSession()->GetAccountId());
        stmt->setString(index++, GetName());
        stmt->setUInt8(index++, getRace());
        stmt->setUInt8(index++, getClass());
        stmt->setUInt8(index++, getLevel());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_XP));
        stmt->setUInt64(index++, GetMoney());
        stmt->setUInt8(index++, GetSkinValue());
        stmt->setUInt8(index++, GetFaceValue());
        stmt->setUInt8(index++, GetHairStyleValue());
        stmt->setUInt8(index++, GetHairColorValue());
        stmt->setUInt8(index++, GetFacialStyleValue());
        stmt->setUInt8(index++, GetBlindFoldValue());
        stmt->setUInt8(index++, GetGenderValue());
        stmt->setUInt8(index++, GetTatooValue());
        stmt->setUInt8(index++, GetHornValue());
        stmt->setUInt8(index++, GetInventorySlotCount());
        stmt->setUInt8(index++, GetBankBagSlotsValue());
        stmt->setUInt8(index++, GetDrunkValue());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS_EX));
        stmt->setUInt16(index++, (uint16)GetMapId());
        stmt->setUInt32(index++, (uint32)GetInstanceId());
        stmt->setUInt8(index++, GetDungeonDifficultyID() != DIFFICULTY_MYTHIC_KEYSTONE ? uint8(GetDungeonDifficultyID()) : DIFFICULTY_MYTHIC_DUNGEON);
        stmt->setUInt8(index++, uint8(GetRaidDifficultyID()));
        stmt->setUInt8(index++, uint8(GetLegacyRaidDifficultyID()));
        stmt->setFloat(index++, finiteAlways(GetPositionX()));
        stmt->setFloat(index++, finiteAlways(GetPositionY()));
        stmt->setFloat(index++, finiteAlways(GetPositionZ()));
        stmt->setFloat(index++, finiteAlways(GetOrientation()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetX()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetY()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetZ()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetO()));
        ObjectGuid::LowType transLowGUID = UI64LIT(0);
        if (GetTransport())
            transLowGUID = GetTransport()->GetGUID().GetCounter();
        stmt->setUInt64(index++, transLowGUID);

        std::ostringstream ss;
        ss << m_taxi;
        stmt->setString(index++, ss.str());
        stmt->setUInt8(index++, m_cinematic);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_TOTAL]);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_LEVEL]);
        stmt->setFloat(index++, finiteAlways(m_rest_bonus));
        stmt->setUInt32(index++, uint32(time(NULL)));
        stmt->setUInt8(index++,  (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0));
        stmt->setUInt16(index++, (uint16)m_ExtraFlags);
        stmt->setUInt16(index++, (uint16)m_atLoginFlags);
        stmt->setUInt16(index++, m_zoneId ? m_zoneId : m_oldZoneId);
        stmt->setUInt32(index++, uint32(m_deathExpireTime));

        ss.str("");
        ss << m_taxi.SaveTaxiDestinationsToString();

        stmt->setString(index++, ss.str());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE));
        stmt->setInt32(index++, GetInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX));
        stmt->setUInt32(index++, GetHealth());
        stmt->setUInt32(index++, GetPower(POWER_MANA));
        stmt->setUInt32(index++, GetSession()->GetLatency());

        stmt->setUInt8(index++, GetActiveTalentGroup());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID));
        stmt->setUInt32(index++, GetFieldLootSpecID());

        ss.str("");
        for (uint16 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + i) << ' ';
        stmt->setString(index++, ss.str());

        ss.str("");
        // cache equipment...
        for (uint32 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
        {
            if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            {
                ss << item->GetTemplate()->GetInventoryType() << ' ' << item->GetDisplayId(this) << ' ';
                if (SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(item->GetVisibleEnchantmentId(this)))
                    ss << enchant->ItemVisual;
                else
                    ss << '0';

                ss << ' ';
            }
            else
                ss << "0 0 0 ";
        }
        stmt->setString(index++, ss.str());

        ss.str("");
        for (uint32 i = 0; i < KNOWN_TITLES_SIZE*2; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_KNOWN_TITLES + i) << ' ';
        stmt->setString(index++, ss.str());

        stmt->setUInt8(index++, GetActionBarTogglesValue());
        stmt->setInt32(index++, m_currentPetNumber);

        ss.str("");
        for (uint32 i = 0; i < PET_SLOT_LAST; ++i)
            ss << m_PetSlots[i] << ' ';

        stmt->setString(index++, ss.str());

        stmt->setUInt32(index++, m_grantableLevels);
        stmt->setUInt32(index++, m_createdtime);
        stmt->setFloat(index++, m_killPoints);
    }
    else
    {
        // Update query
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER);
        stmt->setString(index++, GetName());
        stmt->setUInt8(index++, getRace());
        stmt->setUInt8(index++, getClass());
        stmt->setUInt8(index++, getLevel());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_XP));
        stmt->setUInt64(index++, GetMoney());
        stmt->setUInt8(index++, GetSkinValue());
        stmt->setUInt8(index++, GetFaceValue());
        stmt->setUInt8(index++, GetHairStyleValue());
        stmt->setUInt8(index++, GetHairColorValue());
        stmt->setUInt8(index++, GetFacialStyleValue());
        stmt->setUInt8(index++, GetBlindFoldValue());
        stmt->setUInt8(index++, GetGenderValue());
        stmt->setUInt8(index++, GetTatooValue());
        stmt->setUInt8(index++, GetHornValue());
        stmt->setUInt8(index++, GetInventorySlotCount());
        stmt->setUInt8(index++, GetBankBagSlotsValue());
        stmt->setUInt8(index++, GetDrunkValue());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_FLAGS_EX));

        if (!IsBeingTeleported())
        {
            stmt->setUInt16(index++, (uint16)GetMapId());
            stmt->setUInt32(index++, (uint32)GetInstanceId());
            stmt->setUInt8(index++, GetDungeonDifficultyID() != DIFFICULTY_MYTHIC_KEYSTONE ? uint8(GetDungeonDifficultyID()) : DIFFICULTY_MYTHIC_DUNGEON);
            stmt->setUInt8(index++, uint8(GetRaidDifficultyID()));
            stmt->setUInt8(index++, uint8(GetLegacyRaidDifficultyID()));
            stmt->setFloat(index++, finiteAlways(GetPositionX()));
            stmt->setFloat(index++, finiteAlways(GetPositionY()));
            stmt->setFloat(index++, finiteAlways(GetPositionZ()));
            stmt->setFloat(index++, finiteAlways(GetOrientation()));
        }
        else
        {
            stmt->setUInt16(index++, (uint16)GetTeleportDest().GetMapId());
            stmt->setUInt32(index++, (uint32)0);
            stmt->setUInt8(index++, GetDungeonDifficultyID() != DIFFICULTY_MYTHIC_KEYSTONE ? uint8(GetDungeonDifficultyID()) : DIFFICULTY_MYTHIC_DUNGEON);
            stmt->setUInt8(index++, uint8(GetRaidDifficultyID()));
            stmt->setUInt8(index++, uint8(GetLegacyRaidDifficultyID()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionX()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionY()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionZ()));
            stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetOrientation()));
        }

        stmt->setFloat(index++, finiteAlways(GetTransOffsetX()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetY()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetZ()));
        stmt->setFloat(index++, finiteAlways(GetTransOffsetO()));
        ObjectGuid::LowType transLowGUID = UI64LIT(0);
        if (GetTransport())
            transLowGUID = GetTransport()->GetGUID().GetCounter();
        stmt->setUInt64(index++, transLowGUID);

        std::ostringstream ss;
        ss << m_taxi;
        stmt->setString(index++, ss.str());
        stmt->setUInt8(index++, m_cinematic);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_TOTAL]);
        stmt->setUInt32(index++, m_Played_time[PLAYED_TIME_LEVEL]);
        stmt->setFloat(index++, finiteAlways(m_rest_bonus));
        stmt->setUInt32(index++, uint32(time(NULL)));
        stmt->setUInt8(index++,  (HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0));

        stmt->setUInt16(index++, (uint16)m_ExtraFlags);
        stmt->setUInt16(index++, (uint16)m_atLoginFlags);
        stmt->setUInt16(index++, m_zoneId ? m_zoneId : m_oldZoneId);
        stmt->setUInt32(index++, uint32(m_deathExpireTime));

        ss.str("");
        ss << m_taxi.SaveTaxiDestinationsToString();

        stmt->setString(index++, ss.str());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 0));
        stmt->setUInt16(index++, GetUInt16Value(PLAYER_FIELD_YESTERDAY_HONORABLE_KILLS, 1));
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_PLAYER_TITLE));
        stmt->setInt32(index++, GetInt32Value(PLAYER_FIELD_WATCHED_FACTION_INDEX));
        stmt->setUInt32(index++, GetHealth());
        stmt->setUInt32(index++, GetPower(POWER_MANA));
        stmt->setUInt32(index++, GetSession()->GetLatency());

        stmt->setUInt8(index++, GetActiveTalentGroup());
        stmt->setUInt32(index++, GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID));
        stmt->setUInt32(index++, GetFieldLootSpecID());

        ss.str("");
        for (uint16 i = 0; i < PLAYER_EXPLORED_ZONES_SIZE; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_EXPLORED_ZONES + i) << ' ';
        stmt->setString(index++, ss.str());

        ss.str("");
        // cache equipment...
        for (uint32 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
        {
            Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
            if (item && item->GetTemplate())
            {
                ss << item->GetTemplate()->GetInventoryType() << ' ' << item->GetDisplayId(this) << ' ';
                if (SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(item->GetVisibleEnchantmentId(this)))
                    ss << enchant->ItemVisual;
                else
                    ss << '0';

                ss << ' ';
            }
            else
                ss << "0 0 0 ";
        }

        stmt->setString(index++, ss.str());

        ss.str("");
        for (uint32 i = 0; i < KNOWN_TITLES_SIZE*2; ++i)
            ss << GetUInt32Value(PLAYER_FIELD_KNOWN_TITLES + i) << ' ';

        stmt->setString(index++, ss.str());
        stmt->setUInt8(index++, GetActionBarTogglesValue());
        stmt->setInt32(index++, m_currentPetNumber);

        ss.str("");
        for (uint32 i = 0; i < PET_SLOT_LAST; ++i)
            ss << m_PetSlots[i] << ' ';

        stmt->setString(index++, ss.str());

        stmt->setUInt32(index++, m_grantableLevels);

        stmt->setUInt8(index++, IsInWorld() ? 1 : 0);

        stmt->setUInt32(index++, GetLfgBonusFaction());
        stmt->setFloat(index++, m_killPoints);

        // Index
        stmt->setUInt64(index++, GetGUIDLow());
    }

    SQLTransaction trans = CharacterDatabase.BeginTransaction();

    trans->Append(stmt);

    if (m_mailsUpdated)                                     //save mails only when needed
        _SaveMail(trans);

    _SaveBGData(trans);
    _SaveInventory(trans);
    _SaveVoidStorage(trans);
    _SaveQuestStatus(trans);
    _SaveDailyQuestStatus(trans);
    _SaveWeeklyQuestStatus(trans);
    _SaveSeasonalQuestStatus(trans);
    _SaveAdventureQuest(trans);
    _SaveWorldQuestStatus(trans);
    _SaveTalents(trans);
    _SaveSpells(trans);
    _SaveSpellCooldowns(trans);
    _SaveActions(trans);
    _SaveAuras(trans);
    _SaveSkills(trans);
    m_achievementMgr->SaveToDB(trans);
    m_reputationMgr.SaveToDB(trans);
    _SaveEquipmentSets(trans);
    GetSession()->SaveTutorialsData(trans);                 // changed only while character in game
    _SaveGlyphs(trans);
    _SaveCurrency(trans);
    _SaveCUFProfiles(trans);
    _SaveArchaeology(trans);
    _SaveHonor();
    _SaveLootCooldown(trans);
    _SaveLfgCooldown(trans);
    _SaveKillCreature(trans);

    if (_garrison)
        _garrison->SaveToDB(trans);
       
    if (_collectionMgr)
        _collectionMgr->SaveToDB(trans);

    SaveBattlePets(trans);

    _SaveChallengeKey(trans);
    _SaveDeathMatchStats(trans);
    _SaveChatLogos(trans);
    _SaveArmyTrainingInfo(trans);
    _SaveAccountProgress(trans);

    CharacterDatabase.CommitTransaction(trans);

    // TODO: Move this out
    trans = LoginDatabase.BeginTransaction();
    stmt = LoginDatabase.GetPreparedStatement(LOGIN_DEL_BNET_LAST_PLAYER_CHARACTERS);
    stmt->setUInt32(0, GetSession()->GetAccountId());
    stmt->setUInt8(1, realm.Id.Region);
    stmt->setUInt8(2, realm.Id.Site);
    trans->Append(stmt);

    stmt = LoginDatabase.GetPreparedStatement(LOGIN_INS_BNET_LAST_PLAYER_CHARACTERS);
    stmt->setUInt32(0, GetSession()->GetAccountId());
    stmt->setUInt8(1, realm.Id.Region);
    stmt->setUInt8(2, realm.Id.Site);
    stmt->setUInt32(3, realm.Id.Realm);
    stmt->setString(4, GetName());
    stmt->setUInt64(5, GetGUID().GetCounter());
    stmt->setUInt32(6, time(nullptr));
    trans->Append(stmt);

    LoginDatabase.CommitTransaction(trans);

    // save pet (hunter pet level and experience and all type pets health/mana).
    if (Pet* pet = GetPet())
        pet->SavePetToDB();
}

bool Player::HandleChangeSlotModel(uint32 newItem, uint16 pos)
{
    if (newItem == 0 && pos != EQUIPMENT_SLOT_RANGED)
    {
        SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + pos * 2, 0);
        return true;
    }
    if (newItem == 1)
    {
        Item const* realItem = GetItemByPos(255, pos);
        if (realItem)
            SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + pos * 2, realItem->GetEntry());
        else
            SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + pos * 2, 0);
        return true;
    }
    //ItemEntry const* itemProto = sItemStore.LookupEntry(newItem);
    ItemSparseEntry const* itemProto = sItemSparseStore.LookupEntry(newItem);

    if (!itemProto)
        return false;

    if (itemProto->OverallQualityID != ITEM_QUALITY_LEGENDARY)
    {
        bool condition = false;
        switch (pos)
        {
            case EQUIPMENT_SLOT_HEAD:
                // head
                if (itemProto->InventoryType == INVTYPE_HEAD)
                    condition = true;
                break;
            case EQUIPMENT_SLOT_SHOULDERS:        // shoulders
                if (itemProto->InventoryType == INVTYPE_SHOULDERS)
                    condition = true;
                break;
            case EQUIPMENT_SLOT_BODY:           // shirt
                if (itemProto->InventoryType == INVTYPE_BODY)
                    condition = true;
                break;
            case EQUIPMENT_SLOT_CHEST:        // chest
                if (itemProto->InventoryType == INVTYPE_CHEST || itemProto->InventoryType == INVTYPE_ROBE)
                    condition = true;
                break;
            case EQUIPMENT_SLOT_WAIST:        // belt
                if (itemProto->InventoryType == INVTYPE_WAIST)
                    condition = true;
                break;
            case EQUIPMENT_SLOT_LEGS:        // legs
                if (itemProto->InventoryType == INVTYPE_LEGS)
                    condition = true;
                break;
            case EQUIPMENT_SLOT_FEET:        // feet
                if (itemProto->InventoryType == INVTYPE_FEET)
                    condition = true;
                break;
            case EQUIPMENT_SLOT_WRISTS:        // wrists
                if (itemProto->InventoryType == INVTYPE_WRISTS)
                    condition = true;
                break;
            case EQUIPMENT_SLOT_HANDS:    // hands
                if (itemProto->InventoryType == INVTYPE_HANDS)
                    condition = true;
                break;
            case EQUIPMENT_SLOT_BACK:    // back
                if (itemProto->InventoryType == INVTYPE_CLOAK)
                    condition = true;
                break;
            case EQUIPMENT_SLOT_MAINHAND:    // weapon - main
                if ((itemProto->InventoryType == INVTYPE_WEAPON || itemProto->InventoryType == INVTYPE_WEAPONMAINHAND || itemProto->InventoryType == INVTYPE_2HWEAPON || itemProto->InventoryType == INVTYPE_RANGED || itemProto->InventoryType == INVTYPE_RANGEDRIGHT))
                    condition = true;
                break;
            case EQUIPMENT_SLOT_OFFHAND:    // weapon - offhand
                if (itemProto->InventoryType == INVTYPE_HOLDABLE || itemProto->InventoryType == INVTYPE_WEAPON || itemProto->InventoryType == INVTYPE_WEAPONOFFHAND || itemProto->InventoryType == INVTYPE_SHIELD || itemProto->InventoryType == INVTYPE_2HWEAPON || itemProto->InventoryType == INVTYPE_RANGED || itemProto->InventoryType == INVTYPE_RANGEDRIGHT)
                    condition = true;
                break;
            case EQUIPMENT_SLOT_RANGED:    // weapon - ranged
                if (itemProto->InventoryType == INVTYPE_RANGED || itemProto->InventoryType == INVTYPE_RANGEDRIGHT)
                    condition = true;
                break;
            case EQUIPMENT_SLOT_TABARD:    // tabard
                if (itemProto->InventoryType == INVTYPE_TABARD)
                    condition = true;
                break;
            default:
                break;
        }
        if (condition)
        {
            SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + pos * 2, newItem);
            return true;
        }
        return false;
    }
    return false;
}

void Player::HandleAltVisSwitch()
{
    if (!m_vis)    // display off
    {
        for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
        {
            Item const* realItem =  GetItemByPos(255, i);
            if (realItem)
                SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + (i * 2), realItem->GetEntry());
            else
                SetUInt32Value(PLAYER_FIELD_VISIBLE_ITEMS + (i * 2), 0);
        }
    }
    else
    {
        uint32 *currItem = &m_vis->m_visHead;
        for (int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
        {
            if (*currItem != 1)
                HandleChangeSlotModel(*currItem, i);
            currItem++;
            if (i == 0 || i == 2) ++i;
            if (i == 9) i += 4;
        }
    }
}

void Player::SetResurrectRequestData(Unit* caster, uint64 health, uint32 mana, uint32 appliedAura, SpellInfo const* resSpell)
{
    ASSERT(!IsRessurectRequested());
    _resurrectionData = new ResurrectionData();
    _resurrectionData->GUID = caster->GetGUID();
    _resurrectionData->Location.WorldRelocate(*caster);
    _resurrectionData->Health = health;
    _resurrectionData->Mana = mana;
    _resurrectionData->Aura = appliedAura;
    _resurrectionData->ResSpell = resSpell;
}

void Player::ClearResurrectRequestData()
{
    delete _resurrectionData;
    _resurrectionData = nullptr;
}

bool Player::IsRessurectRequestedBy(ObjectGuid guid) const
{
    if (!IsRessurectRequested())
        return false;
    return _resurrectionData->GUID == guid;
}

bool Player::IsRessurectRequested() const
{
    return _resurrectionData != nullptr;
}

void Player::ResurectUsingRequestData()
{
    if (GetMap()->IsDungeon() && _resurrectionData->ResSpell && _resurrectionData->ResSpell->IsBattleResurrection())
    {
        if (InstanceScript* instanceScript = GetInstanceScript())
        {
            if (instanceScript->IsEncounterInProgress())
            {
                if (instanceScript->CanUseCombatResurrection())
                    instanceScript->ConsumeCombatResurrectionCharge();
                else
                {
                    RemoveAura(160029);
                    ClearResurrectRequestData();

                    WorldPackets::Misc::DisplayGameError display;
                    display.Error = UIErrors::ERR_SPELL_FAILED_S;
                    display.Arg = boost::in_place();
                    display.Arg = 236;
                    SendDirectMessage(display.Write());

                    SendDirectMessage(WorldPackets::Misc::NullSMsg(SMSG_FORCED_DEATH_UPDATE).Write());
                    return;
                }
            }
        }
    }

    /// Teleport before resurrecting by player, otherwise the player might get attacked from creatures near his corpse
    float x, y, z, o;
    _resurrectionData->Location.GetPosition(x, y, z, o);
    TeleportTo(_resurrectionData->Location.GetMapId(), x, y, z, o);

    if (IsBeingTeleported())
    {
        ScheduleDelayedOperation(DELAYED_RESURRECT_PLAYER);
        return;
    }

    ResurrectPlayer(0.0f, false);

    if (GetMaxHealth() > _resurrectionData->Health)
        SetHealth(_resurrectionData->Health);
    else
        SetFullHealth();

    if (uint32(GetMaxPower(POWER_MANA)) > _resurrectionData->Mana)
        SetPower(POWER_MANA, _resurrectionData->Mana);
    else
        SetPower(POWER_MANA, GetMaxPower(POWER_MANA));

    ResetPowers();

    if (uint32 aura = _resurrectionData->Aura)
        CastSpell(this, aura, true, nullptr, nullptr, _resurrectionData->GUID);

    SpawnCorpseBones();
}

// fast save function for item/money cheating preventing - save only inventory and money state
void Player::SaveInventoryAndGoldToDB(SQLTransaction& trans)
{
    _SaveInventory(trans);
    _SaveCurrency(trans);
    SaveGoldToDB(trans);
}

void Player::SaveGoldToDB(SQLTransaction& trans)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UDP_CHAR_MONEY);
    stmt->setUInt64(0, GetMoney());
    stmt->setUInt64(1, GetGUIDLow());
    trans->Append(stmt);
}

void Player::_SaveActions(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;

    for (ActionButtonList::iterator itr = m_actionButtons.begin(); itr != m_actionButtons.end();)
    {
        switch (itr->second.uState)
        {
            case ACTIONBUTTON_NEW:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_ACTION);
                stmt->setUInt64(0, GetGUIDLow());
                stmt->setUInt8(1, GetActiveTalentGroup());
                stmt->setUInt8(2, itr->first);
                stmt->setUInt32(3, itr->second.GetAction());
                stmt->setUInt8(4, uint8(itr->second.GetType()));
                trans->Append(stmt);

                itr->second.uState = ACTIONBUTTON_UNCHANGED;
                ++itr;
                break;
            case ACTIONBUTTON_CHANGED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHAR_ACTION);
                stmt->setUInt32(0, itr->second.GetAction());
                stmt->setUInt8(1, uint8(itr->second.GetType()));
                stmt->setUInt64(2,  GetGUIDLow());
                stmt->setUInt8(3, itr->first);
                stmt->setUInt8(4, GetActiveTalentGroup());
                trans->Append(stmt);

                itr->second.uState = ACTIONBUTTON_UNCHANGED;
                ++itr;
                break;
            case ACTIONBUTTON_DELETED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_ACTION_BY_BUTTON_SPEC);
                stmt->setUInt64(0, GetGUIDLow());
                stmt->setUInt8(1, itr->first);
                stmt->setUInt8(2, GetActiveTalentGroup());
                trans->Append(stmt);

                m_actionButtons.erase(itr++);
                break;
            default:
                ++itr;
                break;
        }
    }
}

void Player::_SaveAuras(SQLTransaction& trans)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA);
    stmt->setUInt64(0, GetGUIDLow());
    trans->Append(stmt);
    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_AURA_EFFECT);
    stmt->setUInt64(0, GetGUIDLow());
    trans->Append(stmt);

    for (AuraMap::const_iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end(); ++itr)
    {
        if (!itr->second || !itr->second->CanBeSaved())
            continue;

        Aura* aura = itr->second;
        AuraApplication* foundAura = GetAuraApplication(aura->GetId(), aura->GetCasterGUID(), aura->GetCastItemGUID());
        if(!foundAura)
            continue;

        uint8 index = 0;
        uint32 effMask = 0;
        uint32 recalculateMask = 0;
        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
        {
            if (AuraEffect const* effect = aura->GetEffect(i))
            {
                index = 0;
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_AURA_EFFECT);
                stmt->setUInt64(index++, GetGUIDLow());
                stmt->setUInt8(index++, foundAura->GetSlot());
                stmt->setUInt8(index++, i);
                stmt->setInt32(index++, effect->GetBaseAmount());
                stmt->setInt32(index++, effect->GetAmount());

                trans->Append(stmt);

                effMask |= 1 << i;
                if (effect->CanBeRecalculated())
                    recalculateMask |= 1 << i;
            }
        }

        index = 0;
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_AURA);
        stmt->setUInt64(index++, GetGUIDLow());
        stmt->setUInt8(index++, foundAura->GetSlot());
        stmt->setBinary(index++, itr->second->GetCasterGUID().GetRawValue());
        stmt->setBinary(index++, itr->second->GetCastItemGUID().GetRawValue());
        stmt->setUInt32(index++, itr->second->GetId());
        stmt->setUInt16(index++, effMask);
        stmt->setUInt8(index++, recalculateMask);
        stmt->setUInt8(index++, itr->second->GetStackAmount());
        stmt->setInt32(index++, itr->second->GetMaxDuration());
        stmt->setInt32(index++, itr->second->GetDuration());
        stmt->setUInt8(index, itr->second->GetCharges());
        trans->Append(stmt);
    }
}

void Player::_SaveInventory(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    // force items in buyback slots to new state
    // and remove those that aren't already
    for (uint8 i = BUYBACK_SLOT_START; i < BUYBACK_SLOT_END; ++i)
    {
        Item* item = m_items[i];
        if (!item || item->GetState() == ITEM_NEW)
            continue;

        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_ITEM);
        stmt->setUInt64(0, item->GetGUIDLow());
        trans->Append(stmt);

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
        stmt->setUInt64(0, item->GetGUIDLow());
        trans->Append(stmt);
        m_items[i]->FSetState(ITEM_NEW);
    }

    // Updated played time for refundable items. We don't do this in Player::Update because there's simply no need for it,
    // the client auto counts down in real time after having received the initial played time on the first
    // SMSG_SET_ITEM_PURCHASE_DATA packet.
    // Item::UpdatePlayedTime is only called when needed, which is in DB saves, and item refund info requests.
    GuidSet::iterator i_next;
    for (GuidSet::iterator itr = m_refundableItems.begin(); itr!= m_refundableItems.end(); itr = i_next)
    {
        // use copy iterator because itr may be invalid after operations in this loop
        i_next = itr;
        ++i_next;

        Item* iPtr = GetItemByGuid(*itr);
        if (iPtr)
        {
            iPtr->UpdatePlayedTime(this);
            continue;
        }
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Can't find item guid %u but is in refundable storage for player %u ! Removing.", (*itr).GetGUIDLow(), GetGUIDLow());
        m_refundableItems.erase(itr);
    }

    // update enchantment durations
    for (EnchantDurationList::iterator itr = m_enchantDuration.begin(); itr != m_enchantDuration.end(); ++itr)
        itr->item->SetEnchantmentDuration(itr->slot, itr->leftduration, this);

    // if no changes
    if (m_itemUpdateQueue.empty())
        return;

    ObjectGuid::LowType lowGuid = GetGUIDLow();
    for (std::set<Item*>::const_iterator itr = m_itemUpdateQueue.begin(); itr != m_itemUpdateQueue.end(); ++itr)
    {
        Item* item = *itr;
        if (!item)
            continue;

        volatile uint32 itemEntry = item->GetEntry();
        volatile uint32 itemGuidLow = item->GetGUIDLow();

        Bag* container = item->GetContainer();
        ObjectGuid::LowType bag_guid = container ? container->GetGUIDLow() : UI64LIT(0);

        if (item->GetState() != ITEM_REMOVED)
        {
            Item* test = GetItemByPos(item->GetBagSlot(), item->GetSlot());
            if (test == NULL)
            {
                ObjectGuid::LowType bagTestGUID = UI64LIT(0);
                if (Item* test2 = GetItemByPos(INVENTORY_SLOT_BAG_0, item->GetBagSlot()))
                    bagTestGUID = test2->GetGUIDLow();
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player(GUID: %u Name: %s)::_SaveInventory - the bag(%u) and slot(%u) values for the item with guid %u (state %d) are incorrect, the player doesn't have an item at that position!", lowGuid, GetName(), item->GetBagSlot(), item->GetSlot(), item->GetGUIDLow(), (int32)item->GetState());
                // according to the test that was just performed nothing should be in this slot, delete
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_BAG_SLOT);
                stmt->setUInt64(0, bagTestGUID);
                stmt->setUInt8(1, item->GetSlot());
                stmt->setUInt64(2, lowGuid);
                trans->Append(stmt);

                // also THIS item should be somewhere else, cheat attempt
                item->FSetState(ITEM_REMOVED); // we are IN updateQueue right now, can't use SetState which modifies the queue
                DeleteRefundReference(item->GetGUID());
                // don't skip, let the switch delete it
                //continue;
            }
            else if (test != item)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player(GUID: %u Name: %s)::_SaveInventory - the bag(%u) and slot(%u) values for the item with guid %u are incorrect, the item with guid %u is there instead!", lowGuid, GetName(), item->GetBagSlot(), item->GetSlot(), item->GetGUIDLow(), test->GetGUIDLow());
                // save all changes to the item...
                if (item->GetState() != ITEM_NEW) // only for existing items, no dupes
                    item->SaveToDB(trans);
                // ...but do not save position in inventory
                continue;
            }
        }

        PreparedStatement* stmt = NULL;
        switch (item->GetState())
        {
            case ITEM_NEW:
            case ITEM_CHANGED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_INVENTORY_ITEM);
                stmt->setUInt64(0, lowGuid);
                stmt->setUInt64(1, bag_guid);
                stmt->setUInt8 (2, item->GetSlot());
                stmt->setUInt64(3, item->GetGUIDLow());
                trans->Append(stmt);
                break;
            case ITEM_REMOVED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_INVENTORY_BY_ITEM);
                stmt->setUInt64(0, item->GetGUIDLow());
                trans->Append(stmt);
            case ITEM_UNCHANGED:
                break;
        }

        if (item)
            item->SaveToDB(trans);                                   // item have unchanged inventory record and can be save standalone
    }
    m_itemUpdateQueue.clear();
}

void Player::_SaveVoidStorage(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    ObjectGuid::LowType lowGuid = GetGUIDLow();

    for (uint32 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
    {
        if (_voidStorageItems[i]) // unused item
        {
            if(_voidStorageItems[i]->deleted)
            {
                // DELETE FROM void_storage WHERE ItemId = ?
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_VOID_STORAGE_ITEM);
                stmt->setUInt64(0, _voidStorageItems[i]->ItemId);
                trans->Append(stmt);

                delete _voidStorageItems[i];
                _voidStorageItems[i] = NULL;
                continue;
            }
            if(!_voidStorageItems[i]->change)
                continue;

            // REPLACE INTO character_inventory (itemId, playerGuid, itemEntry, slot, creatorGuid) VALUES (?, ?, ?, ?, ?)
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHAR_VOID_STORAGE_ITEM);
            stmt->setUInt64(0, _voidStorageItems[i]->ItemId);
            stmt->setUInt64(1, lowGuid);
            stmt->setUInt32(2, _voidStorageItems[i]->item ? _voidStorageItems[i]->item->GetEntry() : _voidStorageItems[i]->ItemEntry);
            stmt->setUInt32(3, i);
            stmt->setUInt64(4, _voidStorageItems[i]->CreatorGuid.GetCounter());
            stmt->setUInt8(5, uint8(_voidStorageItems[i]->ItemRandomPropertyId.Type));
            stmt->setUInt32(6, _voidStorageItems[i]->ItemRandomPropertyId.Id);
            stmt->setUInt32(7, _voidStorageItems[i]->ItemSuffixFactor);
            stmt->setUInt64(8, _voidStorageItems[i]->item ? _voidStorageItems[i]->item->GetGUIDLow() : 0);
            trans->Append(stmt);
        }
    }
}

void Player::_SaveMail(SQLTransaction& trans)
{
    if (!m_mailsLoaded)
        return;

    PreparedStatement* stmt = NULL;

    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
    {
        Mail* m = (*itr);
        if (m->state == MAIL_STATE_CHANGED)
        {
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_MAIL);
            stmt->setUInt8(0, uint8(m->HasItems() ? 1 : 0));
            stmt->setUInt32(1, uint32(m->expire_time));
            stmt->setUInt32(2, uint32(m->deliver_time));
            stmt->setUInt32(3, m->money);
            stmt->setUInt32(4, m->COD);
            stmt->setUInt8(5, uint8(m->checked));
            stmt->setUInt32(6, m->messageID);

            trans->Append(stmt);

            if (!m->removedItems.empty())
            {
                for (std::vector<ObjectGuid::LowType>::iterator itr2 = m->removedItems.begin(); itr2 != m->removedItems.end(); ++itr2)
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM);
                    stmt->setUInt64(0, *itr2);
                    trans->Append(stmt);
                }
                m->removedItems.clear();
            }
            m->state = MAIL_STATE_UNCHANGED;
        }
        else if (m->state == MAIL_STATE_DELETED)
        {
            if (m->HasItems())
            {
                PreparedStatement* stmt = NULL;
                for (MailItemInfoVec::iterator itr2 = m->items.begin(); itr2 != m->items.end(); ++itr2)
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ITEM_INSTANCE);
                    stmt->setUInt64(0, itr2->item_guid);
                    trans->Append(stmt);
                }
            }
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_BY_ID);
            stmt->setUInt32(0, m->messageID);
            trans->Append(stmt);

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_MAIL_ITEM_BY_ID);
            stmt->setUInt32(0, m->messageID);
            trans->Append(stmt);
        }
    }

    //deallocate deleted mails...
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end();)
    {
        if ((*itr)->state == MAIL_STATE_DELETED)
        {
            Mail* m = *itr;
            m_mail.erase(itr);
            delete m;
            itr = m_mail.begin();
        }
        else
            ++itr;
    }

    m_mailsUpdated = false;
}

void Player::_SaveQuestStatus(SQLTransaction& trans)
{
    QuestStatusSaveMap::iterator saveItr;
    PreparedStatement* stmt = NULL;

    bool keepAbandoned = !(sWorld->GetCleaningFlags() & CharacterDatabaseCleaner::CLEANING_FLAG_QUESTSTATUS);

    for (saveItr = m_QuestStatusSave.begin(); saveItr != m_QuestStatusSave.end(); ++saveItr)
    {
        if (saveItr->second == QUEST_DEFAULT_SAVE_TYPE)
        {
            QuestStatusData * status = getQuestStatus(saveItr->first);
            Quest const* quest = sQuestDataStore->GetQuestTemplate(saveItr->first);
            ObjectGuid::LowType guid = GetGUIDLow();
            if (quest && quest->QuestInfoID == QUEST_INFO_ACCOUNT)
                guid = 0;

            if (status && (keepAbandoned || status->Status != QUEST_STATUS_NONE))
            {
                uint8 index = 0;
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHAR_QUESTSTATUS);

                stmt->setUInt64(index++, guid);
                stmt->setUInt32(index++, saveItr->first);
                stmt->setUInt8(index++, uint8(status->Status));
                stmt->setUInt32(index++, uint32(status->Timer / IN_MILLISECONDS + sWorld->GetGameTime()));
                stmt->setUInt32(index, GetSession()->GetAccountId());
                trans->Append(stmt);

                // Save objectives
                if (quest)
                    for (QuestObjective const& obj : quest->GetObjectives())
                    {
                        stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHAR_QUESTSTATUS_OBJECTIVES);
                        stmt->setUInt64(0, guid);
                        stmt->setUInt32(1, saveItr->first);
                        stmt->setInt8(2, obj.StorageIndex);
                        stmt->setInt32(3, GetQuestObjectiveData(quest, obj.StorageIndex));
                        stmt->setUInt32(4, GetSession()->GetAccountId());
                        trans->Append(stmt);
                    }
            }
        }
        else
        {
            Quest const* quest = sQuestDataStore->GetQuestTemplate(saveItr->first);
            if (quest && quest->QuestInfoID == QUEST_INFO_ACCOUNT)
            {
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ACC_QUESTSTATUS_BY_QUEST);
                stmt->setUInt32(0, GetSession()->GetAccountId());
                stmt->setUInt32(1, saveItr->first);
                trans->Append(stmt);

                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ACC_QUESTSTATUS_OBJECTIVES_BY_QUEST);
                stmt->setUInt32(0, GetSession()->GetAccountId());
                stmt->setUInt32(1, saveItr->first);
                trans->Append(stmt);
            }
            else
            {
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_BY_QUEST);
                stmt->setUInt64(0, GetGUIDLow());
                stmt->setUInt32(1, saveItr->first);
                trans->Append(stmt);

                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_OBJECTIVES_BY_QUEST);
                stmt->setUInt64(0, GetGUIDLow());
                stmt->setUInt32(1, saveItr->first);
                trans->Append(stmt);
            }
        }
    }

    m_QuestStatusSave.clear();

    for (saveItr = m_RewardedQuestsSave.begin(); saveItr != m_RewardedQuestsSave.end(); ++saveItr)
    {
        Quest const* quest = sQuestDataStore->GetQuestTemplate(saveItr->first);

        if (saveItr->second == QUEST_DEFAULT_SAVE_TYPE)
        {
            if (quest && quest->QuestInfoID == QUEST_INFO_ACCOUNT)
            {
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_QUESTSTATUS);
                stmt->setUInt64(0, 0);
                stmt->setUInt32(1, saveItr->first);
                stmt->setUInt32(2, GetSession()->GetAccountId());
                trans->Append(stmt);

            }
            else
            {
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_QUESTSTATUS);
                stmt->setUInt64(0, GetGUIDLow());
                stmt->setUInt32(1, saveItr->first);
                stmt->setUInt32(2, GetSession()->GetAccountId());
                trans->Append(stmt);
            }

        }
        else if (saveItr->second == QUEST_FORCE_DELETE_SAVE_TYPE || !keepAbandoned)
        {
            if (quest && quest->QuestInfoID == QUEST_INFO_ACCOUNT)
            {
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ACC_QUESTSTATUS_REWARDED_BY_QUEST);
                stmt->setUInt32(0, GetSession()->GetAccountId());
                stmt->setUInt32(1, saveItr->first);
                trans->Append(stmt);
            }
            else
            {
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_QUESTSTATUS_REWARDED_BY_QUEST);
                stmt->setUInt64(0, GetGUIDLow());
                stmt->setUInt32(1, saveItr->first);
                trans->Append(stmt);
            }
        }
    }

    m_RewardedQuestsSave.clear();
}

void Player::_SaveDailyQuestStatus(SQLTransaction& trans)
{
    if (!m_DailyQuestChanged)
        return;

    m_DailyQuestChanged = false;

    // save last daily quest time for all quests: we need only mostly reset time for reset check anyway

    // we don't need transactions here.
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_DAILY_CHAR);
    stmt->setUInt64(0, GetGUIDLow());
    trans->Append(stmt);
    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_QUEST_STATUS_DAILY_ACC);
    stmt->setUInt32(0, GetSession()->GetAccountId());
    trans->Append(stmt);

    for (QuestSet::iterator itr = m_dailyquests.begin(); itr != m_dailyquests.end(); ++itr)
    {
        ObjectGuid::LowType guid = GetGUIDLow();
        Quest const* quest = sQuestDataStore->GetQuestTemplate((*itr));
        if (quest && quest->QuestInfoID == QUEST_INFO_ACCOUNT)
            guid = 0;

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_DAILYQUESTSTATUS);
        stmt->setUInt64(0, guid);
        stmt->setUInt32(1, *itr);
        stmt->setUInt64(2, uint64(m_lastDailyQuestTime));
        stmt->setUInt32(3, GetSession()->GetAccountId());
        trans->Append(stmt);
    }

    if (!m_DFQuests.empty())
    {
        for (DFQuestsDoneList::iterator itr = m_DFQuests.begin(); itr != m_DFQuests.end(); ++itr)
        {
            ObjectGuid::LowType guid = GetGUIDLow();
            Quest const* quest = sQuestDataStore->GetQuestTemplate((*itr));
            if (quest && quest->QuestInfoID == QUEST_INFO_ACCOUNT)
                guid = 0;

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_DAILYQUESTSTATUS);
            stmt->setUInt64(0, guid);
            stmt->setUInt32(1, (*itr));
            stmt->setUInt64(2, uint64(m_lastDailyQuestTime));
            stmt->setUInt32(3, GetSession()->GetAccountId());
            trans->Append(stmt);
        }
    }
}

void Player::_SaveWeeklyQuestStatus(SQLTransaction& trans)
{
    if (!m_WeeklyQuestChanged || m_weeklyquestSaves.empty())
        return;

    // we don't need transactions here.
    PreparedStatement* stmt = nullptr;
    for (QuestSet::const_iterator iter = m_weeklyquestSaves.begin(); iter != m_weeklyquestSaves.end(); ++iter)
    {
        uint32 quest_id  = *iter;
        ObjectGuid::LowType guid = GetGUIDLow();
        Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
        if (quest && quest->QuestInfoID == QUEST_INFO_ACCOUNT)
            guid = 0;

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_WEEKLYQUESTSTATUS);
        stmt->setUInt64(0, guid);
        stmt->setUInt32(1, quest_id);
        stmt->setUInt32(2, GetSession()->GetAccountId());
        trans->Append(stmt);
    }

    m_weeklyquestSaves.clear();
    m_WeeklyQuestChanged = false;
}

void Player::_SaveSeasonalQuestStatus(SQLTransaction& trans)
{
    if (!m_SeasonalQuestChanged || m_seasonalquestSaves.empty())
        return;

    // we don't need transactions here.
    PreparedStatement* stmt = nullptr;
    for (SeasonalEventQuestMap::const_iterator iter = m_seasonalquestSaves.begin(); iter != m_seasonalquestSaves.end(); ++iter)
    {
        uint16 event_id = iter->first;
        for (SeasonalQuestSet::const_iterator itr = iter->second.begin(); itr != iter->second.end(); ++itr)
        {
            uint32 quest_id = (*itr);
            ObjectGuid::LowType guid = GetGUIDLow();
            Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
            if (quest && quest->QuestInfoID == QUEST_INFO_ACCOUNT)
                guid = 0;

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_SEASONALQUESTSTATUS);
            stmt->setUInt64(0, guid);
            stmt->setUInt32(1, quest_id);
            stmt->setUInt32(2, event_id);
            stmt->setUInt32(3, GetSession()->GetAccountId());
            trans->Append(stmt);
        }
    }

    m_seasonalquestSaves.clear();
    m_SeasonalQuestChanged = false;
}

void Player::_SaveAdventureQuest(SQLTransaction& trans)
{
    if (!m_AdventureQuestChanged)
        return;

    // we don't need transactions here.
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER_ADVENTURE_QUEST);
    stmt->setUInt64(0, GetGUIDLow());
    trans->Append(stmt);

    if (m_adventure_questID)
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHARACTER_ADVENTURE_QUEST);
        stmt->setUInt64(0, GetGUIDLow());
        stmt->setUInt32(1, m_adventure_questID);
        trans->Append(stmt);
    }

    m_AdventureQuestChanged = false;
}

void Player::_SaveSkills(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;
    // we don't need transactions here.
    for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end();)
    {
        if (itr->second.uState == SKILL_UNCHANGED)
        {
            ++itr;
            continue;
        }

        if (itr->second.uState == SKILL_DELETED)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SKILL_BY_SKILL);
            stmt->setUInt64(0, GetGUIDLow());
            stmt->setUInt32(1, itr->first);
            trans->Append(stmt);

            (*mSkillStatusVector)[itr->first] = NULL;
            mSkillStatus.erase(itr++);
            continue;
        }

        uint16 field = itr->second.pos / 2;
        uint8 offset = itr->second.pos & 1;

        uint16 value = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset);
        uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset);

        switch (itr->second.uState)
        {
            case SKILL_NEW:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_SKILLS);
                stmt->setUInt64(0, GetGUIDLow());
                stmt->setUInt16(1, uint16(itr->first));
                stmt->setUInt16(2, value);
                stmt->setUInt16(3, max);
                trans->Append(stmt);
                break;
            case SKILL_CHANGED:
                stmt = CharacterDatabase.GetPreparedStatement(CHAR_UDP_CHAR_SKILLS);
                stmt->setUInt16(0, value);
                stmt->setUInt16(1, max);
                stmt->setUInt64(2, GetGUIDLow());
                stmt->setUInt16(3, uint16(itr->first));
                trans->Append(stmt);
                break;
            default:
                break;
        }

        itr->second.uState = SKILL_UNCHANGED;
        ++itr;
    }
}

void Player::_SaveSpells(SQLTransaction& trans)
{
    PreparedStatement* stmt = NULL;

    for (PlayerSpellMap::iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
    {
        if (itr->second.state == PLAYERSPELL_TEMPORARY)
            continue;

        if (itr->second.state == PLAYERSPELL_REMOVED || itr->second.state == PLAYERSPELL_CHANGED)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_SPELL_BY_SPELL);
            stmt->setUInt32(0, itr->first);
            stmt->setUInt64(1, GetGUIDLow());
            trans->Append(stmt);
        }

        // add only changed/new not dependent spells
        if (!itr->second.dependent && (itr->second.state == PLAYERSPELL_NEW || itr->second.state == PLAYERSPELL_CHANGED))
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_SPELL);
            stmt->setUInt64(0, GetGUIDLow());
            stmt->setUInt32(1, itr->first);
            stmt->setBool(2, itr->second.active);
            stmt->setBool(3, itr->second.disabled);
            trans->Append(stmt);
        }

        if (itr->second.state == PLAYERSPELL_REMOVED)
            m_spells.erase_at(itr);
        else
            itr->second.state = PLAYERSPELL_UNCHANGED;
    }
}

void Player::_SaveCUFProfiles(SQLTransaction& trans)
{
    ObjectGuid::LowType playerGuid = GetGUIDLow();

    for (uint8 i = 0; i < MAX_CUF_PROFILES; ++i)
    {
        // delete unused profile
        if (!_CUFProfiles[i])
            trans->PAppend("DELETE FROM character_cuf_profiles WHERE guid = '%u' and profileId = '%u'", playerGuid, i);
        else
        {
            // REPLACE INTO character_cuf_profiles (guid, profileId, profileName, frameHeight, frameWidth, sortBy, healthText, boolOptions, unk146, unk147, unk148, unk150, unk152, unk154) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CUF_PROFILES);
            stmt->setUInt64(0, playerGuid);
            stmt->setUInt8(1, i);
            stmt->setString(2, _CUFProfiles[i]->ProfileName);
            stmt->setUInt16(3, _CUFProfiles[i]->FrameHeight);
            stmt->setUInt16(4, _CUFProfiles[i]->FrameWidth);
            stmt->setUInt8(5, _CUFProfiles[i]->SortBy);
            stmt->setUInt8(6, _CUFProfiles[i]->HealthText);
            stmt->setUInt32(7, _CUFProfiles[i]->BoolOptions.to_ulong());
            stmt->setUInt8(8, _CUFProfiles[i]->TopPoint);
            stmt->setUInt8(9, _CUFProfiles[i]->BottomPoint);
            stmt->setUInt8(10, _CUFProfiles[i]->LeftPoint);
            stmt->setUInt16(11, _CUFProfiles[i]->TopOffset);
            stmt->setUInt16(12, _CUFProfiles[i]->BottomOffset);
            stmt->setUInt16(13, _CUFProfiles[i]->LeftOffset);

            trans->Append(stmt);
        }
    }
}

void Player::_SaveBrackets(SQLTransaction& trans)
{
    for (uint8 i = 0; i < MAX_BRACKET_SLOT; ++i)
        if (Bracket* br = getBracket(i))
            br->SaveStats(&trans); 
        if (Bracket* br = getBracket(MS::Battlegrounds::BracketType::Arena1v1))
            br->SaveStats(&trans);
        if (Bracket* br = getBracket(MS::Battlegrounds::BracketType::ArenaSoloQ3v3))
            br->SaveStats(&trans);
        
}

void Player::outDebugValues() const
{
    if (!sLog->ShouldLog(LOG_FILTER_UNITS, LOG_LEVEL_DEBUG))
        return;

    TC_LOG_DEBUG(LOG_FILTER_UNITS, "HP is: \t\t\t%u\t\tMP is: \t\t\t%u", GetMaxHealth(), GetMaxPower(POWER_MANA));
    TC_LOG_DEBUG(LOG_FILTER_UNITS, "AGILITY is: \t\t%f\t\tSTRENGTH is: \t\t%f", GetStat(STAT_AGILITY), GetStat(STAT_STRENGTH));
    TC_LOG_DEBUG(LOG_FILTER_UNITS, "INTELLECT is: \t\t%f\t\t", GetStat(STAT_INTELLECT));
    TC_LOG_DEBUG(LOG_FILTER_UNITS, "STAMINA is: \t\t%f", GetStat(STAT_STAMINA));
    TC_LOG_DEBUG(LOG_FILTER_UNITS, "Armor is: \t\t%u\t\tBlock is: \t\t%f", GetArmor(), GetFloatValue(PLAYER_FIELD_BLOCK_PERCENTAGE));
    TC_LOG_DEBUG(LOG_FILTER_UNITS, "HolyRes is: \t\t%u\t\tFireRes is: \t\t%u", GetResistance(SPELL_SCHOOL_HOLY), GetResistance(SPELL_SCHOOL_FIRE));
    TC_LOG_DEBUG(LOG_FILTER_UNITS, "NatureRes is: \t\t%u\t\tFrostRes is: \t\t%u", GetResistance(SPELL_SCHOOL_NATURE), GetResistance(SPELL_SCHOOL_FROST));
    TC_LOG_DEBUG(LOG_FILTER_UNITS, "ShadowRes is: \t\t%u\t\tArcaneRes is: \t\t%u", GetResistance(SPELL_SCHOOL_SHADOW), GetResistance(SPELL_SCHOOL_ARCANE));
    TC_LOG_DEBUG(LOG_FILTER_UNITS, "MIN_DAMAGE is: \t\t%f\tMAX_DAMAGE is: \t\t%f", GetFloatValue(UNIT_FIELD_MIN_DAMAGE), GetFloatValue(UNIT_FIELD_MAX_DAMAGE));
    TC_LOG_DEBUG(LOG_FILTER_UNITS, "MIN_OFFHAND_DAMAGE is: \t%f\tMAX_OFFHAND_DAMAGE is: \t%f", GetFloatValue(UNIT_FIELD_MIN_OFF_HAND_DAMAGE), GetFloatValue(UNIT_FIELD_MAX_OFF_HAND_DAMAGE));
    TC_LOG_DEBUG(LOG_FILTER_UNITS, "MIN_RANGED_DAMAGE is: \t%f\tMAX_RANGED_DAMAGE is: \t%f", GetFloatValue(UNIT_FIELD_MIN_RANGED_DAMAGE), GetFloatValue(UNIT_FIELD_MAX_RANGED_DAMAGE));
    TC_LOG_DEBUG(LOG_FILTER_UNITS, "ATTACK_TIME is: \t%u\t\tRANGE_ATTACK_TIME is: \t%u", GetAttackTime(BASE_ATTACK), GetAttackTime(RANGED_ATTACK));
}

/*********************************************************/
/***               FLOOD FILTER SYSTEM                 ***/
/*********************************************************/

void Player::UpdateSpeakTime()
{
    // ignore chat spam protection for GMs in any mode
    if (!AccountMgr::IsPlayerAccount(GetSession()->GetSecurity()))
        return;

    time_t current = time (NULL);
    if (m_speakTime > current)
    {
        uint32 max_count = sWorld->getIntConfig(CONFIG_CHATFLOOD_MESSAGE_COUNT);
        if (!max_count)
            return;

        ++m_speakCount;
        if (m_speakCount >= max_count)
        {
            // prevent overwrite mute time, if message send just before mutes set, for example.
            time_t new_mute = current + sWorld->getIntConfig(CONFIG_CHATFLOOD_MUTE_TIME);
            if (GetSession()->m_muteTime < new_mute)
                GetSession()->m_muteTime = new_mute;

            m_speakCount = 0;
        }
    }
    else
        m_speakCount = 0;

    m_speakTime = current + sWorld->getIntConfig(CONFIG_CHATFLOOD_MESSAGE_DELAY);
}

bool Player::CanSpeak() const
{
    return  GetSession()->m_muteTime <= time (NULL);
}

/*********************************************************/
/***              LOW LEVEL FUNCTIONS:Notifiers        ***/
/*********************************************************/

void Player::SavePositionInDB(uint32 mapid, float x, float y, float z, float o, uint32 zone, ObjectGuid guid)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER_POSITION);

    stmt->setFloat(0, x);
    stmt->setFloat(1, y);
    stmt->setFloat(2, z);
    stmt->setFloat(3, o);
    stmt->setUInt16(4, uint16(mapid));
    stmt->setUInt16(5, uint16(zone));
    stmt->setUInt64(6, guid.GetCounter());

    CharacterDatabase.Execute(stmt);
}

void Player::SetUInt32ValueInArray(Tokenizer& tokens, uint16 index, uint32 value)
{
    char buf[11];
    snprintf(buf, 11, "%u", value);

    if (index >= tokens.size())
        return;

    tokens[index] = buf;
}

void Player::Customize(ObjectGuid::LowType guid, WorldPackets::Character::CharCustomizeInfo* info)
{
    //uint8 gender, uint8 skin, uint8 face, uint8 hairStyle, uint8 hairColor, uint8 facialHair
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GENDER_PLAYERBYTES);

    stmt->setUInt8(0, info->SkinID);
    stmt->setUInt8(1, info->SexID);
    stmt->setUInt8(2, info->FaceID);
    stmt->setUInt8(3, info->HairStyleID);
    stmt->setUInt8(4, info->HairColorID);
    stmt->setUInt8(5, info->FacialHairStyleID);
    stmt->setUInt8(6, info->CustomDisplay[0]);
    stmt->setUInt8(7, info->CustomDisplay[1]);
    stmt->setUInt8(8, info->CustomDisplay[2]);
    stmt->setUInt64(9, guid);

    CharacterDatabase.Execute(stmt);
}

void Player::SendAttackSwingError(AttackSwingReason error)
{
    SendDirectMessage(WorldPackets::Combat::AttackSwingError(error).Write());
}

void Player::SendCancelAutoRepeat(Unit* target)
{
    WorldPackets::Combat::CancelAutoRepeat cancelAutoRepeat;
    cancelAutoRepeat.Guid = target->GetGUID();
    SendDirectMessage(cancelAutoRepeat.Write());
}

void Player::SendExplorationExperience(uint32 areaID, uint32 exp)
{
    SendDirectMessage(WorldPackets::Misc::ExplorationExperience(exp, areaID).Write());
}

void Player::SendDungeonDifficulty(int32 forcedDifficulty /*= -1*/)
{
    WorldPackets::Misc::DungeonDifficultySet dungeonDifficultySet;
    dungeonDifficultySet.DifficultyID = forcedDifficulty == -1 ? GetDungeonDifficultyID() : forcedDifficulty;
    SendDirectMessage(dungeonDifficultySet.Write());
}

void Player::SendRaidDifficulty(bool legacy, int32 forcedDifficulty /*= -1*/)
{
    WorldPackets::Misc::RaidDifficultySet raidDifficultySet;
    raidDifficultySet.DifficultyID = forcedDifficulty == -1 ? (legacy ? GetLegacyRaidDifficultyID() : GetRaidDifficultyID()) : forcedDifficulty;
    raidDifficultySet.Legacy = legacy;
    SendDirectMessage(raidDifficultySet.Write());
}

void Player::SendResetFailedNotify()
{
    SendDirectMessage(WorldPackets::Instance::ResetFailedNotify().Write());
}

/// Reset all solo instances and optionally send a message on success for each
void Player::ResetInstances(uint8 method, bool isRaid, bool isLegacy)
{
    // method can be INSTANCE_RESET_ALL, INSTANCE_RESET_CHANGE_DIFFICULTY, INSTANCE_RESET_GROUP_JOIN

    // we assume that when the difficulty changes, all instances that can be reset will be
    Difficulty diff = GetDungeonDifficultyID();
    uint8 boundType = sObjectMgr->GetboundTypeFromDifficulty(diff);
    if (isRaid)
    {
        if (!isLegacy)
            diff = GetRaidDifficultyID();
        else
            diff = GetLegacyRaidDifficultyID();
    }

    for (BoundInstancesMap::iterator itr = m_boundInstances[boundType].begin(); itr != m_boundInstances[boundType].end();)
    {
        InstanceSave* p = itr->second.save;
        const MapEntry* entry = sMapStore.LookupEntry(itr->first);
        if (!entry || entry->IsRaid() != isRaid || !p->CanReset())
        {
            ++itr;
            continue;
        }

        if (method == INSTANCE_RESET_ALL)
        {
            // the "reset all instances" method can only reset normal maps
            if (entry->IsRaid() || diff == DIFFICULTY_HEROIC)
            {
                ++itr;
                continue;
            }
        }

        // if the map is loaded, reset it
        Map* map = sMapMgr->FindMap(p->GetMapId(), p->GetInstanceId());
        if (map && map->IsDungeon())
            if (!(static_cast<InstanceMap*>(map))->Reset(method))
            {
                ++itr;
                continue;
            }

        // since this is a solo instance there should not be any players inside
        if (method == INSTANCE_RESET_ALL || method == INSTANCE_RESET_CHANGE_DIFFICULTY)
            SendResetInstanceSuccess(p->GetMapId());

        p->DeleteFromDB();
        m_boundInstances[boundType].erase(itr++);

        // the following should remove the instance save from the manager and delete it as well
        p->RemovePlayer(this);
    }
}

void Player::SendResetInstanceSuccess(uint32 MapId)
{
    SendDirectMessage(WorldPackets::Instance::InstanceReset(MapId).Write());
}

void Player::SendResetInstanceFailed(ResetFailedReason reason, uint32 mapID) const
{
    WorldPackets::Instance::InstanceResetFailed failed;
    failed.MapID = mapID;
    failed.ResetFailedReason = static_cast<uint8>(reason);
    SendDirectMessage(failed.Write());
}

/*********************************************************/
/***              Update timers                        ***/
/*********************************************************/

///checks the 15 afk reports per 5 minutes limit
void Player::UpdateAfkReport(time_t currTime)
{
    if (m_bgData.BgAfkReportedTimer <= currTime)
    {
        m_bgData.BgAfkReportedCount = 0;
        m_bgData.BgAfkReportedTimer = currTime + 5 * MINUTE;
    }
}

void Player::UpdateContestedPvP(uint32 diff)
{
    if (!m_contestedPvPTimer || isInCombat())
        return;

    if (m_contestedPvPTimer != -1 && m_contestedPvPTimer <= static_cast<int32>(diff))
        ResetContestedPvP();
    else
        m_contestedPvPTimer -= diff;
}

void Player::ResetContestedPvP()
{
    ClearUnitState(UNIT_STATE_ATTACK_PLAYER);
    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_CONTESTED_PVP);
    m_contestedPvPTimer = 0;
}

void Player::UpdatePvPFlag(time_t currTime)
{
    if (!IsPvP() || InBattleground() || InArena())
        return;

    if (pvpInfo.endTimer == 0 || currTime < (pvpInfo.endTimer + 300) || pvpInfo.inHostileArea)
        return;

    UpdatePvP(false);
}

// initiator of duel trigger real started of duel
void Player::UpdateDuelFlag(uint32 diff)
{
    if (!duel || duel->state != DUEL_COUNTDOWN)
        return;

    if (duel->initiator != GetGUID())
        return;

    if (duel->countdownTimer <= diff)
    {
        Player* dueler = ObjectAccessor::FindPlayer(duel->opponent);

        if (!dueler)
            return;

        sScriptMgr->OnPlayerDuelStart(this, dueler);

        duel->countdownTimer = 0;
        duel->state = DUEL_STARTED;

        dueler->duel->countdownTimer = 0;
        dueler->duel->state = DUEL_STARTED;

        SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 1);
        dueler->SetUInt32Value(PLAYER_FIELD_DUEL_TEAM, 2);

        if (HasAuraType(SPELL_AURA_RESET_COOLDOWNS_AT_DUEL_START))
            RemoveArenaSpellCooldowns(true);

        if (dueler->HasAuraType(SPELL_AURA_RESET_COOLDOWNS_AT_DUEL_START))
            dueler->RemoveArenaSpellCooldowns(true);
    }
    else
        duel->countdownTimer -= diff;
}

Pet* Player::GetPet() const
{
    ObjectGuid pet_guid = GetPetGUID();
    if (!pet_guid.IsEmpty())
    {
        if (!pet_guid.IsPet())
            return NULL;

        Pet* pet = ObjectAccessor::GetPet(*this, pet_guid);

        if (!pet)
            return NULL;

        if (IsInWorld() && pet)
            return pet;

        //there may be a guardian in slot
        //TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::GetPet: Pet %u not exist.", GUID_LOPART(pet_guid));
        //const_cast<Player*>(this)->SetPetGUID(0);
    }

    return NULL;
}


Pet* Player::SummonPet(uint32 entry, float x, float y, float z, float ang, PetType petType, uint32 duration, uint32 spellId)
{
    if (getClass() == CLASS_HUNTER)
        petType = HUNTER_PET;

    Pet* pet = new Pet(this, petType);

    pet->Relocate(x, y, z, ang);

    //summoned pets always non-curent!
    if (petType == SUMMON_PET || petType == HUNTER_PET)
    {
        // This check done in LoadPetFromDB, but we should not continue this function if pet not alowed
        if (!CanSummonPet(entry))
        {
            delete pet;
            return NULL;
        }

        if (pet->LoadPetFromDB(this, entry, 0))
        {
            if (duration > 0)
                pet->SetDuration(duration);

            return pet;
        }
    }

    // petentry == 0 for hunter "call pet" (current pet summoned if any)
    if (!entry)
    {
        TC_LOG_ERROR(LOG_FILTER_PETS, "no such entry %u", entry);
        delete pet;
        return NULL;
    }

    if (!pet->IsPositionValid())
    {
        TC_LOG_ERROR(LOG_FILTER_PETS, "Pet (guidlow %d, entry %d) not summoned. Suggested coordinates isn't valid (X: %f Y: %f)", pet->GetGUIDLow(), pet->GetEntry(), pet->GetPositionX(), pet->GetPositionY());
        delete pet;
        return NULL;
    }

    Map* map = GetMap();
    uint32 pet_number = sObjectMgr->GeneratePetNumber();
    if (!pet->Create(sObjectMgr->GetGenerator<HighGuid::Pet>()->Generate(), map, GetPhaseMask(), entry, pet_number))
    {
        TC_LOG_ERROR(LOG_FILTER_PETS, "no such creature entry %u", entry);
        delete pet;
        return NULL;
    }

    pet->SetTratsport(GetTransport());
    pet->SetCreatorGUID(GetGUID());
    pet->SetUInt32Value(UNIT_FIELD_FACTION_TEMPLATE, getFaction());
    pet->SetUInt32Value(UNIT_FIELD_NPC_FLAGS, 0);
    pet->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
    pet->SetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL, spellId);
    pet->InitStatsForLevel(GetEffectiveLevel(), petType != SUMMON_PET);

    if (IsPlayer())
        pet->AddUnitTypeMask(UNIT_MASK_CREATED_BY_PLAYER);

    if (petType == SUMMON_PET)
        pet->GetCharmInfo()->SetPetNumber(pet_number, true);

    // After SetPetNumber
    SetMinion(pet, true);

    map->AddToMap(pet->ToCreature());

    if (petType == SUMMON_PET)
    {
        pet->SynchronizeLevelWithOwner();
        pet->InitPetCreateSpells();
        pet->SavePetToDB();
        PetSpellInitialize();
        SendTalentsInfoData(true);
    }

    if (getClass() == CLASS_WARLOCK)
        if (HasAura(196099))
            RemoveAura(196099);

    if (pet->isControlled() && !pet->isTemporarySummoned())
        SetLastPetEntry(entry);

    if (duration > 0)
        pet->SetDuration(duration);

    //TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "SummonPet entry %i, petType %i, spellId %i", entry, petType, spellId);

    pet->CastPetAuras(true);
    return pet;
}

void Player::RemovePet(Pet* pet, bool isDelete)
{
    if (!pet)
        pet = GetPet();

    if (pet)
    {
        TC_LOG_DEBUG(LOG_FILTER_PETS, "RemovePet %u, isDelete %u", pet->GetEntry(), isDelete);

        if (pet->m_removed)
            return;
    }

    if (!pet || pet->GetOwnerGUID() != GetGUID())
        return;

    pet->CastPetAuras(false);
    pet->CombatStop();
    // only if current pet in slot
    pet->SavePetToDB(isDelete);

    SetMinion(pet, false);

    pet->AddObjectToRemoveList();
    pet->m_removed = true;

    if (pet->isControlled())
    {
        SendRemoveControlBar();
        SetGroupUpdateFlag(GROUP_UPDATE_FLAG_PET);
    }

    WorldPackets::PetPackets::PetDismissSound packet;
    packet.ModelID = pet->GetNativeDisplayId();
    packet.ModelPosition = pet->GetPosition();
    SendDirectMessage(packet.Write());

    //RemoveFlag(PLAYER_FIELD_LOCAL_FLAGS, PLAYER_LOCAL_FLAG_CONTROLLING_PET);
}

void Player::StopCastingCharm()
{
    Unit* charm = GetCharm();
    if (!charm)
        return;

    if (charm->IsCreature())
    {
        if (charm->ToCreature()->HasUnitTypeMask(UNIT_MASK_PUPPET))
            ((Puppet*)charm)->UnSummon();
        else if (charm->IsVehicle())
            ExitVehicle();
    }
    if (GetCharmGUID())
        charm->RemoveCharmAuras();

    if (GetCharmGUID())
    {
        TC_LOG_FATAL(LOG_FILTER_PLAYER, "Player %s (GUID: " UI64FMTD " is not able to uncharm unit (GUID: " UI64FMTD " Entry: %u, Type: %u)", GetName(), GetGUID().GetCounter(), GetCharmGUID().GetCounter(), charm->GetEntry(), charm->GetTypeId());
        if (charm->GetCharmerGUID())
        {
            TC_LOG_FATAL(LOG_FILTER_PLAYER, "Charmed unit has charmer guid " UI64FMTD, charm->GetCharmerGUID().GetCounter());
            // ASSERT(false);
        }
        else
            SetCharm(charm, false);
    }
}

void Player::Say(std::string const& text, const uint32 language, bool isSpamm)
{
    std::string _text(text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_SAY, language, _text);
    
    if (_text.empty())
        return;

    WorldPackets::Chat::Chat packet;
    packet.Initialize(CHAT_MSG_SAY, static_cast<Language>(language), this, this, _text);

    if (isSpamm)
        SendDirectMessage(packet.Write());
    else
        SendChatMessageToSetInRange(packet.Write(), sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), true, false);
}

void Player::Yell(std::string const& text, const uint32 language, bool isSpamm)
{
    std::string _text(text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_YELL, language, _text);

    if (_text.empty())
        return;
    
    WorldPackets::Chat::Chat packet;
    packet.Initialize(CHAT_MSG_YELL, static_cast<Language>(language), this, this, _text);

    if (isSpamm)
        SendDirectMessage(packet.Write());
    else
        SendChatMessageToSetInRange(packet.Write(), sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL), true, false);
}

void Player::TextEmote(std::string const& text, bool isSpamm)
{
    std::string _text(text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_EMOTE, LANG_UNIVERSAL, _text);
    
    if (_text.empty())
        return;

    WorldPackets::Chat::Chat packet;
    packet.Initialize(CHAT_MSG_EMOTE, LANG_UNIVERSAL, this, this, _text);

    if (isSpamm)
        SendDirectMessage(packet.Write());
    else
        SendMessageToSetInRange(packet.Write(), sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_TEXTEMOTE), true, !sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_CHAT));
}

void Player::BossWhisper(std::string const& text, const uint32 language, ObjectGuid receiver)
{
    Player* rPlayer = ObjectAccessor::FindPlayer(receiver);
    if (!rPlayer)
        return;

    std::string _text(text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_RAID_BOSS_WHISPER, LANG_UNIVERSAL, _text, rPlayer);

    if (_text.empty())
        return;

    WorldPackets::Chat::Chat packet;
    packet.Initialize(CHAT_MSG_RAID_BOSS_WHISPER, LANG_UNIVERSAL, this, rPlayer, _text);
    rPlayer->SendDirectMessage(packet.Write());
}

void Player::WhisperAddon(std::string const& text, std::string const& prefix, Player* receiver)
{
    std::string _text(text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_WHISPER, LANG_ADDON, _text, receiver);
    
    if (_text.empty())
        return;

    if (!receiver->GetSession()->IsAddonRegistered(prefix))
        return;

    WorldPackets::Chat::Chat packet;
    packet.Initialize(CHAT_MSG_WHISPER, LANG_ADDON, this, this, _text);
    receiver->SendDirectMessage(packet.Write());
}

void Player::Whisper(std::string const& text, uint32 language, ObjectGuid receiver, bool isSpamm)
{
    Player* rPlayer = ObjectAccessor::FindPlayer(receiver);
    if(!rPlayer)
        return;

    std::string _text(text);
    sScriptMgr->OnPlayerChat(this, CHAT_MSG_WHISPER, language, _text, rPlayer);
    
    if (_text.empty())
        return;

    // when player you are whispering to is dnd, he cannot receive your message, unless you are in gm mode
    if (!rPlayer->isDND() || isGameMaster())
    {
        WorldPackets::Chat::Chat packet;
        packet.Initialize(CHAT_MSG_WHISPER, static_cast<Language>(language), this, rPlayer, _text);
        if (!isSpamm)
            rPlayer->SendDirectMessage(packet.Write());

        packet.Initialize(CHAT_MSG_WHISPER_INFORM, static_cast<Language>(language), rPlayer, rPlayer, _text);
        SendDirectMessage(packet.Write());
    }
    else // announce to player that player he is whispering to is dnd and cannot receive his message
        ChatHandler(this).PSendSysMessage(LANG_PLAYER_DND, rPlayer->GetName(), rPlayer->dndMsg.c_str());

    if (!isAcceptWhispers() && !isGameMaster() && !rPlayer->isGameMaster())
    {
        SetAcceptWhispers(true);
        ChatHandler(this).SendSysMessage(LANG_COMMAND_WHISPERON);
    }

    // announce to player that player he is whispering to is afk
    if (rPlayer->isAFK())
        ChatHandler(this).PSendSysMessage(LANG_PLAYER_AFK, rPlayer->GetName(), rPlayer->afkMsg.c_str());

    // if player whisper someone, auto turn of dnd to be able to receive an answer
    if (isDND() && !rPlayer->isGameMaster())
        ToggleDND();
}

Item* Player::GetMItem(ObjectGuid::LowType id)
{
    return Trinity::Containers::MapGetValuePtr(mMitems, id);
}

void Player::AddMItem(Item* it)
{
    ASSERT(it);
    //ASSERT deleted, because items can be added before loading
    mMitems[it->GetGUIDLow()] = it;
}

bool Player::RemoveMItem(ObjectGuid::LowType id)
{
    return mMitems.erase(id) ? true : false;
}

bool Player::SearchItemOnMail(uint32 entry)
{
    if (m_mailsLoaded)
        for (auto iter = mMitems.begin(); iter != mMitems.end(); ++iter)
            if (Item* pItem = iter->second)
                if (pItem->GetEntry() == entry)
                    return true;

    return false;
}

void Player::SendOnCancelExpectedVehicleRideAura()
{
    SendDirectMessage(WorldPackets::Vehicle::OnCancelExpectedRideVehicleAura().Write());
}

void Player::setSelectedChatLogo(std::string const& text) 
{
    if (!getSelectedChatLogo().empty())
        buyed_chat_logos[getSelectedChatLogo()] = false;
    
    selected_chat_logo = text;
    if (!text.empty())
        buyed_chat_logos[text] = true;
}

bool Player::hasChatLogo(std::string const& logo) const
{
    if (buyed_chat_logos.find(logo) != buyed_chat_logos.end())
        return true;
    
    return false;
}

bool Player::BuyChatLogoByDeathMatch(std::string const& logo, uint32 cost)
{
    if (dmScore.totalKills < cost && !isGameMaster())
        return false;
    
    if (hasChatLogo(logo))
        return false;
    
    buyed_chat_logos.insert(std::pair<std::string, bool>(logo, true));
    
    setSelectedChatLogo(logo);
    
    if (!isGameMaster())
        dmScore.totalKills -= cost;
    return true;
}

void Player::PetSpellInitialize()
{
    Pet* pet = GetPet();
    if (!pet)
        return;

    TC_LOG_DEBUG(LOG_FILTER_PETS, "Player::PetSpellInitialize entry %i", pet->GetEntry());
    CharmInfo* charmInfo = pet->GetCharmInfo();

    WorldPackets::PetPackets::Spells spellsMessage;
    spellsMessage.PetGUID = pet->GetGUID();
    spellsMessage.CreatureFamily = pet->GetCreatureTemplate()->Family;
    spellsMessage.Specialization = pet->GetSpecializationId();
    spellsMessage.TimeLimit = pet->GetDuration();
    spellsMessage.ReactState = pet->GetReactState();
    spellsMessage.CommandState = charmInfo->GetCommandState();
    
    for (uint32 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
        spellsMessage.Buttons[i] = charmInfo->PetActionBar[i].packedData;

    if (pet->IsPermanentPetFor(this))
    {
        for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
        {
            if (itr->second.state == PETSPELL_REMOVED)
                continue;

            spellsMessage.Actions.push_back(MAKE_UNIT_ACTION_BUTTON(itr->first, itr->second.active));
        }
    }

    time_t curTime = time(nullptr);

    for (CreatureSpellCooldowns::iterator itr = pet->m_CreatureSpellCooldowns.begin(); itr != pet->m_CreatureSpellCooldowns.end(); ++itr)
    {
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itr->first);
        if (!spellInfo)
            continue;

        CreatureSpellCooldowns::iterator categoryitr = pet->m_CreatureCategoryCooldowns.find(spellInfo->Categories.Category);
        if (categoryitr != pet->m_CreatureCategoryCooldowns.end())
        {
            WorldPackets::PetPackets::Spells::Cooldown cooldowns;
            cooldowns.SpellID = itr->first;
            cooldowns.Duration = (itr->second > curTime) ? (itr->second - curTime) * IN_MILLISECONDS : 0;
            cooldowns.CategoryDuration = (categoryitr->second > curTime) ? (categoryitr->second - curTime) * IN_MILLISECONDS : 0x80000000;
            cooldowns.Category = spellInfo->Categories.Category;
            spellsMessage.Cooldowns.push_back(cooldowns);
        }
        else
        {
            WorldPackets::PetPackets::Spells::Cooldown cooldowns;
            cooldowns.SpellID = itr->first;
            spellsMessage.Cooldowns.push_back(cooldowns);
        }
    }

    SendDirectMessage(spellsMessage.Write());

    WorldPackets::PetPackets::Mode mode;
    mode.PetGUID = pet->GetGUID();
    mode._reactState = pet->GetReactState();
    mode._commandState = charmInfo->GetCommandState();
    SendDirectMessage(mode.Write());
}

void Player::PossessSpellInitialize()
{
    Unit* charm = GetCharm();
    if (!charm)
        return;

    CharmInfo* charmInfo = charm->GetCharmInfo();
    if (!charmInfo)
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::PossessSpellInitialize(): charm (" UI64FMTD ") has no charminfo!", charm->GetGUID().GetCounter());
        return;
    }

    WorldPackets::PetPackets::Spells spellsMessage;
    spellsMessage.PetGUID = charm->GetGUID();
    for (uint32 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
        spellsMessage.Buttons[i] = charmInfo->PetActionBar[i].packedData;

    SendDirectMessage(spellsMessage.Write());

    WorldPackets::PetPackets::Mode mode;
    mode.PetGUID = charm->GetGUID();
    SendDirectMessage(mode.Write());
}

void Player::VehicleSpellInitialize()
{
    Creature* vehicle = GetVehicleCreatureBase();
    if (!vehicle)
        return;

    WorldPackets::PetPackets::Spells spellsMessage;
    spellsMessage.PetGUID = vehicle->GetGUID();
    spellsMessage.TimeLimit = vehicle->isSummon() ? vehicle->ToTempSummon()->GetTimer() : 0;
    spellsMessage.ReactState = vehicle->GetReactState();
    spellsMessage.CommandState = COMMAND_FOLLOW;
    spellsMessage.Flag = 0x8;

    for (uint32 i = 0; i < MAX_SPELL_CONTROL_BAR; ++i)
    {
        uint32 spellId = i < CREATURE_MAX_SPELLS ? vehicle->m_templateSpells[i] : 0;
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
        if (!spellInfo)
        {
            spellsMessage.Buttons[i] = MAKE_UNIT_ACTION_BUTTON(0, i + 8);
            continue;
        }

        ConditionList conditions = sConditionMgr->GetConditionsForVehicleSpell(vehicle->GetEntry(), spellId);
        if (!sConditionMgr->IsObjectMeetToConditions(this, vehicle, conditions))
        {
            TC_LOG_DEBUG(LOG_FILTER_CONDITIONSYS, "VehicleSpellInitialize: conditions not met for Vehicle entry %u spell %u", vehicle->ToCreature()->GetEntry(), spellId);
            spellsMessage.Buttons[i] = MAKE_UNIT_ACTION_BUTTON(0, i + 8);
            continue;
        }

        if (spellInfo->IsPassive())
            vehicle->CastSpell(vehicle, spellId, true);

        spellsMessage.Buttons[i] = MAKE_UNIT_ACTION_BUTTON(spellId, i + 8);
    }

    time_t now = sWorld->GetGameTime();
    for (CreatureSpellCooldowns::iterator itr = vehicle->m_CreatureSpellCooldowns.begin(); itr != vehicle->m_CreatureSpellCooldowns.end(); ++itr)
    {
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itr->first);
        if (!spellInfo)
            continue;

        CreatureSpellCooldowns::iterator categoryitr = vehicle->m_CreatureCategoryCooldowns.find(spellInfo->Categories.Category);
        time_t cooldown = (itr->second > now) ? (itr->second - now) * IN_MILLISECONDS : 0;

        if (categoryitr != vehicle->m_CreatureCategoryCooldowns.end())
        {
            WorldPackets::PetPackets::Spells::Cooldown cooldowns;
            cooldowns.SpellID = itr->first;
            cooldowns.Duration = cooldown;
            cooldowns.CategoryDuration = (categoryitr->second > now) ? (categoryitr->second - now) * IN_MILLISECONDS : 0;
            cooldowns.Category = spellInfo->Categories.Category;
            spellsMessage.Cooldowns.push_back(cooldowns);
        }
        else
        {
            WorldPackets::PetPackets::Spells::Cooldown cooldowns;
            cooldowns.SpellID = itr->first;
            spellsMessage.Cooldowns.push_back(cooldowns);
        }
    }

    SendDirectMessage(spellsMessage.Write());

    WorldPackets::PetPackets::Mode mode;
    mode.PetGUID = vehicle->GetGUID();
    mode._reactState = vehicle->GetReactState();
    mode._commandState = 0;
    mode._flag = 0x800;
    SendDirectMessage(mode.Write());

}

void Player::CharmSpellInitialize()
{
    Unit* charm = GetFirstControlled();
    if (!charm)
        return;

    CharmInfo* charmInfo = charm->GetCharmInfo();
    if (!charmInfo)
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player::CharmSpellInitialize(): the player's charm (" UI64FMTD ") has no charminfo!", charm->GetGUID().GetCounter());
        return;
    }

    uint8 addlist = 0;
    if (!charm->IsPlayer())
    {
        //CreatureInfo const* cinfo = charm->ToCreature()->GetCreatureTemplate();
        //if (cinfo && cinfo->type == CREATURE_TYPE_DEMON && getClass() == CLASS_WARLOCK)
        {
            for (uint32 i = 0; i < MAX_SPELL_CHARM; ++i)
                if (charmInfo->GetCharmSpell(i)->GetAction())
                    ++addlist;
        }
    }

    WorldPackets::PetPackets::Spells spellsMessage;
    spellsMessage.PetGUID = charm->GetGUID();

    if (charm->IsCreature())
    {
        spellsMessage.ReactState = charm->ToCreature()->GetReactState();
        spellsMessage.CommandState = charmInfo->GetCommandState();
    }    
    for (uint32 i = 0; i < MAX_UNIT_ACTION_BAR_INDEX; ++i)
        spellsMessage.Buttons[i] = charmInfo->PetActionBar[i].packedData;

    if (addlist)
    {
        for (uint32 i = 0; i < MAX_SPELL_CHARM; ++i)
        {
            CharmSpellInfo* cspell = charmInfo->GetCharmSpell(i);
            if (cspell->GetAction())
                spellsMessage.Actions.push_back(cspell->packedData);
        }
    }

    SendDirectMessage(spellsMessage.Write());

    WorldPackets::PetPackets::Mode mode;
    mode.PetGUID = charm->GetGUID();
    mode._reactState = charm->ToCreature() ? charm->ToCreature()->GetReactState() : 0;
    mode._commandState = charmInfo->GetCommandState();
    SendDirectMessage(mode.Write());
}

void Player::SendRemoveControlBar()
{
    SendDirectMessage(WorldPackets::PetPackets::Spells().Write());
}

bool Player::IsAffectedBySpellmod(SpellInfo const* spellInfo, SpellModifier* mod, Spell* spell) const
{
    if (!mod || !spellInfo)
        return false;

    if (spell && mod->charges == -1 && spell->m_appliedMods.find(mod->ownerAura) == spell->m_appliedMods.end())
        return false;

    if (mod->op == SPELLMOD_DURATION && spellInfo->GetDuration() == -1)
        return false;

    if (auto affectSpell = sSpellMgr->GetSpellInfo(mod->spellId))
        if (mod->op == SPELLMOD_DAMAGE && !HasItemFitToSpellRequirements(affectSpell))
            return false;

    return spellInfo->IsAffectedBySpellMod(mod);
}

template <class T>
void Player::ApplySpellMod(uint32 spellId, SpellModOp op, T& basevalue, Spell* spell) const
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return;

    float totalmul = 1.0f;
    float totalflat = 0;

    SpellModifier* modCost = nullptr;
    SpellModifier* modCast = nullptr;

    if (m_spellModTakingSpell)
        spell = m_spellModTakingSpell;

    for (auto itr = m_spellMods[op].cbegin(); itr != m_spellMods[op].cend(); ++itr)
    {
        SpellModifier* mod = *itr;
        if (!mod->ownerAura)
            ASSERT(mod->charges == 0);

        if (!IsAffectedBySpellmod(spellInfo, mod, spell))
            continue;

        SpellInfo const* affectSpell = sSpellMgr->GetSpellInfo(mod->spellId);
        if (!affectSpell)
            continue;

        if ((affectSpell->HasAttribute(SPELL_ATTR0_ONLY_STEALTHED)) && !HasStealthAura())
            continue;

        if (mod->value == 0 || (totalmul <= 0.0f && mod->value < 0) || (totalflat < 0.f && ((basevalue + totalflat) <= 0.f) && mod->value < 0))
            continue;

        if (mod->type == SPELLMOD_FLAT)
            totalflat += mod->value;
        else if (mod->type == SPELLMOD_PCT)
        {
            if (mod->op == SPELLMOD_CASTING_TIME && basevalue >= T(10000) && mod->value <= -100)
                continue;

            if (mod->op == SPELLMOD_CASTING_TIME && mod->value < 0)
            {
                if (!modCast || mod->value <= modCast->value)
                    modCast = mod;

                continue;
            }
            if (mod->op == SPELLMOD_COST && mod->value < 0)
            {
                if (!modCost || mod->value <= modCost->value)
                    modCost = mod;

                continue;
            }

            AddPct(totalmul, mod->value);
        }

        DropModCharge(mod, spell);
    }

    if (modCast)
    {
        AddPct(totalmul, modCast->value);
        DropModCharge(modCast, spell);
    }
    if (modCost)
    {
        AddPct(totalmul, modCost->value);
        DropModCharge(modCost, spell);
    }

    basevalue = T(float(basevalue + totalflat) * totalmul);
}

template void Player::ApplySpellMod(uint32 spellId, SpellModOp op, int32& basevalue, Spell* spell) const;
template void Player::ApplySpellMod(uint32 spellId, SpellModOp op, uint32& basevalue, Spell* spell) const;
template void Player::ApplySpellMod(uint32 spellId, SpellModOp op, float& basevalue, Spell* spell) const;
template void Player::ApplySpellMod(uint32 spellId, SpellModOp op, double& basevalue, Spell* spell) const;
template void Player::ApplySpellMod(uint32 spellId, SpellModOp op, int16& basevalue, Spell* spell) const;

void Player::AddSpellMod(SpellModifier* mod, bool apply)
{
    if (!mod)
        return;

    TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::AddSpellMod %d value %f", mod->spellId, mod->value);

    int i = 0;
    flag128 _mask;

    /// @todo Implement sending of bulk modifiers instead of single

    WorldPackets::Spells::SetSpellModifier packet(mod->type == SPELLMOD_FLAT ? SMSG_SET_FLAT_SPELL_MODIFIER : SMSG_SET_PCT_SPELL_MODIFIER);
    packet.Modifiers.resize(1);
    WorldPackets::Spells::SpellModifier& spellMod = packet.Modifiers[0];

    spellMod.ModIndex = mod->op;

    for (int eff = 0; eff < 128; ++eff)
    {
        if (eff != 0 && (eff % 32) == 0)
            _mask[i++] = 0;

        _mask[i] = uint32(1) << (eff - (32 * i));
        if (mod->mask & _mask)
        {
            WorldPackets::Spells::SpellModifierData modData;

            if (mod->type == SPELLMOD_FLAT)
            {
                modData.ModifierValue = 0.0f;
                for (SpellModList::iterator itr = m_spellMods[mod->op].begin(); itr != m_spellMods[mod->op].end(); ++itr)
                    if ((*itr)->type == mod->type && (*itr)->mask & _mask)
                        modData.ModifierValue += (*itr)->value;

                modData.ModifierValue += apply ? mod->value : -(mod->value);
            }
            else
            {
                modData.ModifierValue = 1.0f;
                for (SpellModList::iterator itr = m_spellMods[mod->op].begin(); itr != m_spellMods[mod->op].end(); ++itr)
                    if ((*itr)->type == mod->type && ((*itr)->mask & _mask) && (apply || (!apply && mod != *itr)))
                        AddPct(modData.ModifierValue, (*itr)->value);

                if (apply)
                    AddPct(modData.ModifierValue, mod->value);
            }

            modData.ClassIndex = eff;

            spellMod.ModifierData.push_back(modData);
        }
    }

    SendDirectMessage(packet.Write());

    if (apply)
        m_spellMods[mod->op].push_back(mod);
    else
    {
        m_spellMods[mod->op].remove(mod);
        // mods bound to aura will be removed in AuraEffect::~AuraEffect
        if (!mod->ownerAura)
            delete mod;
    }
}

void Player::SendSpellMods()
{
    uint8 mods[] = { SPELLMOD_FLAT, SPELLMOD_PCT };
    for (uint8 k = 0; k < 2; ++k)
    {
        WorldPackets::Spells::SetSpellModifier packet(mods[k] == SPELLMOD_FLAT ? SMSG_SET_FLAT_SPELL_MODIFIER : SMSG_SET_PCT_SPELL_MODIFIER);
        packet.Modifiers.resize(MAX_SPELLMOD);

        for (uint32 j = 0; j < MAX_SPELLMOD; ++j)
        {
            if (m_spellMods[j].empty())
                continue;

            WorldPackets::Spells::SpellModifier& spellMod = packet.Modifiers[j];
            spellMod.ModIndex = j;

            int i = 0;
            flag128 _mask = 0;

            for (int eff = 0; eff < 128; ++eff)
            {
                if (eff != 0 && (eff % 32) == 0)
                    _mask[i++] = 0;

                _mask[i] = uint32(1) << (eff - (32 * i));
                if (mods[k] == SPELLMOD_PCT)
                {
                    float val = 1.0f;

                    bool found = false;
                    for (SpellModList::iterator itr = m_spellMods[j].begin(); itr != m_spellMods[j].end(); ++itr)
                        if ((*itr)->type == mods[k] && (*itr)->mask & _mask)
                        {
                            AddPct(val, (*itr)->value);
                            found = true;
                        }
                    if (!found)
                        continue;

                    WorldPackets::Spells::SpellModifierData modData;
                    modData.ModifierValue = val;
                    modData.ClassIndex = eff;
                    spellMod.ModifierData.push_back(modData);
                }
                else
                {
                    int32 val = 0;
                    bool found = false;
                    for (SpellModList::iterator itr = m_spellMods[j].begin(); itr != m_spellMods[j].end(); ++itr)
                        if ((*itr)->type == mods[k] && (*itr)->mask & _mask)
                        {
                            val += (*itr)->value;
                            found = true;
                        }
                    if (!found)
                        continue;

                    WorldPackets::Spells::SpellModifierData modData;
                    modData.ModifierValue = val;
                    modData.ClassIndex = eff;
                    spellMod.ModifierData.push_back(modData);
                }
            }
        }

        SendDirectMessage(packet.Write());
    }
}

// Restore spellmods in case of failed cast
void Player::RestoreSpellMods(Spell* spell, uint32 ownerAuraId, Aura* aura)
{
    if (!spell || spell->m_appliedMods.empty())
        return;

    for (uint8 i=0; i<MAX_SPELLMOD; ++i)
    {
        for (SpellModList::iterator itr = m_spellMods[i].begin(); itr != m_spellMods[i].end(); ++itr)
        {
            SpellModifier* mod = *itr;

            // spellmods without aura set cannot be charged
            if (!mod->ownerAura || !mod->ownerAura->HasAuraAttribute(AURA_ATTR_IS_USING_CHARGES))
                continue;

            // Restore only specific owner aura mods
            if (ownerAuraId && (ownerAuraId != mod->ownerAura->GetSpellInfo()->Id))
                continue;

            if (aura && mod->ownerAura != aura)
                continue;

            // check if mod affected this spell
            // first, check if the mod aura applied at least one spellmod to this spell
            UsedSpellMods::iterator iterMod = spell->m_appliedMods.find(mod->ownerAura);
            if (iterMod == spell->m_appliedMods.end())
                continue;
            // secondly, check if the current mod is one of the spellmods applied by the mod aura
            if (!(mod->mask & spell->m_spellInfo->ClassOptions.SpellClassMask))
                continue;

            // remove from list
            spell->m_appliedMods.erase(iterMod);

            // add mod charges back to mod
            if (mod->charges == -1)
                mod->charges = 1;
            else
                mod->charges++;

            // Do not set more spellmods than avalible
            if (mod->ownerAura->GetCharges() < mod->charges)
                mod->charges = mod->ownerAura->GetCharges();

            // Skip this check for now - aura charges may change due to various reason
            // TODO: trac these changes correctly
            //ASSERT (mod->ownerAura->GetCharges() <= mod->charges);
        }
    }
}

void Player::RestoreAllSpellMods(uint32 ownerAuraId, Aura* aura)
{
    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
        if (m_currentSpells[i])
            RestoreSpellMods(m_currentSpells[i], ownerAuraId, aura);
}

void Player::RemoveSpellMods(Spell* spell, bool casting)
{
    if (!spell)
        return;

    if (spell->m_appliedMods.empty())
        return;

    for (uint8 i=0; i<MAX_SPELLMOD; ++i)
    {
        for (SpellModList::const_iterator itr = m_spellMods[i].begin(); itr != m_spellMods[i].end();)
        {
            SpellModifier* mod = *itr;
            ++itr;

            // spellmods without aura set cannot be charged
            if (!mod->ownerAura || !mod->ownerAura->HasAuraAttribute(AURA_ATTR_IS_USING_CHARGES) || mod->ownerAura->GetSpellInfo()->GetAuraOptions(m_spawnMode)->ProcTypeMask != 0)
                continue;

            // check if mod affected this spell
            UsedSpellMods::iterator iterMod = spell->m_appliedMods.find(mod->ownerAura);
            if (iterMod == spell->m_appliedMods.end())
                continue;

            if(casting && (mod->op != SPELLMOD_CASTING_TIME || !(mod->ownerAura->GetSpellInfo()->HasAttribute(SPELL_ATTR6_USE_SPELL_CAST_EVENT))))
                continue;
            if(!casting && mod->op == SPELLMOD_CASTING_TIME && (mod->ownerAura->GetSpellInfo()->HasAttribute(SPELL_ATTR6_USE_SPELL_CAST_EVENT)))
                continue;

            // remove from list
            spell->m_appliedMods.erase(iterMod);

            if (mod->ownerAura->DropCharge(AURA_REMOVE_BY_DROP_CHARGERS))
                itr = m_spellMods[i].begin();
        }
    }
}

void Player::DropModCharge(SpellModifier* mod, Spell* spell) const
{
    auto spellInfo = sSpellMgr->GetSpellInfo(mod->spellId);
    if (!spellInfo || !spell)
        return;

    // TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "DropModCharge spell %i, modId %i, charges %i, GetCharges %i, GetStackAmount %i, op %i", spell->GetSpellInfo()->Id, mod->spellId, mod->charges, mod->ownerAura->GetCharges(), mod->ownerAura->GetStackAmount(), mod->op);

    if (spellInfo->GetAuraOptions(m_spawnMode)->ProcTypeMask)
    {
        spell->m_appliedProcMods.insert(mod->spellId);
        return;
    }

    if (mod->ownerAura && mod->charges > 0)
    {
        if (--mod->charges == 0)
            mod->charges = -1;

        spell->m_appliedMods.insert(mod->ownerAura);
    }
}

void Player::SetSpellModTakingSpell(Spell* spell, bool apply)
{
    if (!spell || (m_spellModTakingSpell && m_spellModTakingSpell != spell))
        return;

    if (apply && spell->getState() == SPELL_STATE_FINISHED)
        return;

    m_spellModTakingSpell = apply ? spell : NULL;
}

// send Proficiency
void Player::SendProficiency(ItemClass itemClass, uint32 itemSubclassMask)
{
    WorldPackets::Item::SetProficiency packet;
    packet.ProficiencyMask = itemSubclassMask;
    packet.ProficiencyClass = itemClass;
    SendDirectMessage(packet.Write());
}

void Player::RemovePetitionsAndSigns(ObjectGuid guid)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_PETITION_SIG_BY_GUID);
    stmt->setUInt64(0, guid.GetCounter());
    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
    {
        do
        {
            Field* fields = result->Fetch();
            if (Player* owner = ObjectAccessor::FindPlayer(ObjectGuid::Create<HighGuid::Player>(fields[0].GetUInt64())))
                owner->GetSession()->SendPetitionQueryOpcode(ObjectGuid::Create<HighGuid::Item>(fields[1].GetUInt64()));
        }
        while (result->NextRow());

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_ALL_PETITION_SIGNATURES);
        stmt->setUInt64(0, guid.GetCounter());
        CharacterDatabase.Execute(stmt);
    }

    SQLTransaction trans = CharacterDatabase.BeginTransaction();

    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_BY_OWNER);
    stmt->setUInt64(0, guid.GetCounter());
    trans->Append(stmt);

    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PETITION_SIGNATURE_BY_OWNER);
    stmt->setUInt64(0, guid.GetCounter());
    trans->Append(stmt);

    CharacterDatabase.CommitTransaction(trans);
}

void Player::SetRestBonus(float rest_bonus_new)
{
    // Prevent resting on max level
    if (getLevel() >= sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
        rest_bonus_new = 0;

    if (rest_bonus_new < 0)
        rest_bonus_new = 0;

    float rest_bonus_max = (float)GetUInt32Value(PLAYER_FIELD_NEXT_LEVEL_XP)*1.5f/2;

    if (rest_bonus_new > rest_bonus_max)
        m_rest_bonus = rest_bonus_max;
    else
        m_rest_bonus = rest_bonus_new;

    // update data for client
    if (GetSession()->IsARecruiter() || (GetSession()->GetRecruiterId() != 0))
        SetUInt32Value(PLAYER_FIELD_REST_INFO + REST_STATE_XP, REST_STATE_RAF_LINKED);
    else if (m_rest_bonus <= 1)
        SetUInt32Value(PLAYER_FIELD_REST_INFO + REST_STATE_XP, REST_STATE_NOT_RAF_LINKED);  // Set Reststate = Normal
    else// if (m_rest_bonus > 10)
        SetUInt32Value(PLAYER_FIELD_REST_INFO + REST_STATE_XP, REST_STATE_RESTED);          // Set Reststate = Rested

    SetUInt32Value(PLAYER_FIELD_REST_INFO + REST_RESTED_XP, uint32(m_rest_bonus));
    //SetUInt32Value(PLAYER_FIELD_REST_INFO + REST_STATE_HONOR, 0);
    //SetUInt32Value(PLAYER_FIELD_REST_INFO + REST_RESTED_HONOR, 0);
}

bool Player::ActivateTaxiPathTo(std::vector<uint32> const& nodes, Creature* npc /*= NULL*/, uint32 spellid /*= 0*/, uint32 preferredMountDisplay /*= 0*/)
{
    if (nodes.size() < 2)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXINOSUCHPATH);
        return false;
    }

    // not let cheating with start flight in time of logout process || while in combat || has type state: stunned || has type state: root
    if (GetSession()->isLogingOut() || isInCombat() || HasUnitState(UNIT_STATE_STUNNED) || HasUnitState(UNIT_STATE_ROOT))
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXIPLAYERBUSY);
        return false;
    }

    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_REMOVE_CLIENT_CONTROL))
        return false;

    RemoveAurasByType(SPELL_AURA_MOUNTED);

    if (IsInDisallowedMountForm())
        RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);

    if (Spell* spell = GetCurrentSpell(CURRENT_GENERIC_SPELL))
        if (spell->m_spellInfo->Id != spellid)
            InterruptSpell(CURRENT_GENERIC_SPELL, false);

    InterruptSpell(CURRENT_AUTOREPEAT_SPELL, false);

    if (Spell* spell = GetCurrentSpell(CURRENT_CHANNELED_SPELL))
        if (spell->m_spellInfo->Id != spellid)
            InterruptSpell(CURRENT_CHANNELED_SPELL, true);

    uint32 sourcenode = nodes[0];

    // starting node too far away (cheat?)
    TaxiNodesEntry const* node = sTaxiNodesStore.LookupEntry(sourcenode);
    if (!node)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXINOSUCHPATH);
        return false;
    }

    // check node starting pos data set case if provided
    if (node->Pos.X != 0.0f || node->Pos.Y != 0.0f || node->Pos.Z != 0.0f)
    {
        // if (node->MapID != GetMapId() ||
            // (node->Pos.X - GetPositionX())*(node->Pos.X - GetPositionX()) +
            // (node->Pos.Y - GetPositionY())*(node->Pos.Y - GetPositionY()) +
            // (node->Pos.Z - GetPositionZ())*(node->Pos.Z - GetPositionZ()) >
            // (2*INTERACTION_DISTANCE)*(2*INTERACTION_DISTANCE)*(2*INTERACTION_DISTANCE))
        // {
            // GetSession()->SendActivateTaxiReply(ERR_TAXITOOFARAWAY);
            // return false;
        // }
    }
    // node must have pos if taxi master case (npc != NULL)
    else if (npc)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXIUNSPECIFIEDSERVERERROR);
        return false;
    }
    // Prepare to flight start now

    // stop combat at start taxi flight if any
    CombatStop();

    StopCastingCharm();
    StopCastingBindSight();
    ExitVehicle();

    // stop trade (client cancel trade at taxi map open but cheating tools can be used for reopen it)
    TradeCancel(true);

    // clean not finished taxi path if any
    m_taxi.ClearTaxiDestinations();

    // 0 element current node
    m_taxi.AddTaxiDestination(sourcenode);

    // fill destinations path tail
    uint32 sourcepath = 0;
    uint32 totalcost = 0;
    uint32 firstcost = 0;

    uint32 prevnode = sourcenode;
    uint32 lastnode = 0;

    for (size_t i = 1; i < nodes.size(); ++i)
    {
        uint32 path, cost;

        lastnode = nodes[i];
        sObjectMgr->GetTaxiPath(prevnode, lastnode, path, cost);

        if (!path)
        {
            GetSession()->SendActivateTaxiReply(ERR_TAXINOTVISITED);
            m_taxi.ClearTaxiDestinations();
            return false;
        }

        totalcost += cost;
        if (i == 1)
            firstcost = cost;

        if (prevnode == sourcenode)
            sourcepath = path;

        m_taxi.AddTaxiDestination(lastnode);

        prevnode = lastnode;
    }

    // get mount model (in case non taximaster (npc == NULL) allow more wide lookup)
    //
    // Hack-Fix for Alliance not being able to use Acherus taxi. There is
    // only one mount ID for both sides. Probably not good to use 315 in case DBC nodes
    // change but I couldn't find a suitable alternative. OK to use class because only DK
    // can use this taxi.
    uint32 mount_display_id = 0;
    if (node->Flags & TAXI_NODE_FLAG_USE_FAVORITE_MOUNT && preferredMountDisplay)
        mount_display_id = preferredMountDisplay;
    else
        mount_display_id = sObjectMgr->GetTaxiMountDisplayId(sourcenode, GetTeam(), npc == nullptr || (sourcenode == 315 && getClass() == CLASS_DEATH_KNIGHT));

    // in spell case allow 0 model
    if ((mount_display_id == 0 && spellid == 0) || sourcepath == 0)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXIUNSPECIFIEDSERVERERROR);
        m_taxi.ClearTaxiDestinations();
        return false;
    }

    uint64 money = GetMoney();

    if (npc)
        totalcost = (uint32)ceil(totalcost*GetReputationPriceDiscount(npc));

    if (money < totalcost)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXINOTENOUGHMONEY);
        m_taxi.ClearTaxiDestinations();
        return false;
    }

    //Checks and preparations done, DO FLIGHT
    UpdateAchievementCriteria(CRITERIA_TYPE_FLIGHT_PATHS_TAKEN, 1);

    // prevent stealth flight
    //RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TALK);

    if (sWorld->getBoolConfig(CONFIG_INSTANT_TAXI))
    {
        uint32 nodeID = nodes[nodes.size()-1];
        m_taxi.ClearTaxiDestinations();
        ModifyMoney(-int64(totalcost));
        UpdateAchievementCriteria(CRITERIA_TYPE_GOLD_SPENT_FOR_TRAVELLING, totalcost);

        AddDelayedEvent(100, [this, nodeID]() -> void
        {
            if (TaxiNodesEntry const* lastPathNode = sTaxiNodesStore.LookupEntry(nodeID))
                TeleportTo(lastPathNode->ContinentID, lastPathNode->Pos.X, lastPathNode->Pos.Y, lastPathNode->Pos.Z, GetOrientation());
        });
        return false;
    }
    ModifyMoney(-int64(firstcost));
    UpdateAchievementCriteria(CRITERIA_TYPE_GOLD_SPENT_FOR_TRAVELLING, firstcost);
    GetSession()->SendActivateTaxiReply(ERR_TAXIOK);
    GetSession()->SendDoFlight(mount_display_id, sourcepath);
    return true;
}

bool Player::ShortTaxiPathTo(TaxiNodesEntry const* from, TaxiNodesEntry const* to)
{
    if (!from || !to)
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXINOSUCHPATH);
        return false;
    }

    // not let cheating with start flight in time of logout process || while in combat || has type state: stunned || has type state: root
    if (GetSession()->isLogingOut() || isInCombat() || HasUnitState(UNIT_STATE_STUNNED) || HasUnitState(UNIT_STATE_ROOT))
    {
        GetSession()->SendActivateTaxiReply(ERR_TAXIPLAYERBUSY);
        return false;
    }

    if (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_REMOVE_CLIENT_CONTROL))
        return false;

    RemoveAurasByType(SPELL_AURA_MOUNTED);

    if (IsInDisallowedMountForm())
        RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);

    InterruptSpell(CURRENT_GENERIC_SPELL, false);
    InterruptSpell(CURRENT_AUTOREPEAT_SPELL, false);
    InterruptSpell(CURRENT_CHANNELED_SPELL, true);

    // stop combat at start taxi flight if any
    CombatStop();

    StopCastingCharm();
    StopCastingBindSight();
    ExitVehicle();

    // stop trade (client cancel trade at taxi map open but cheating tools can be used for reopen it)
    TradeCancel(true);

    // clean not finished taxi path if any
    m_taxi.ClearTaxiDestinations();

    //Checks and preparations done, DO FLIGHT
    UpdateAchievementCriteria(CRITERIA_TYPE_FLIGHT_PATHS_TAKEN, 1);

    AddDelayedEvent(100, [this, to]() -> void
    {
        TeleportTo(to->ContinentID, to->Pos.X, to->Pos.Y, to->Pos.Z, GetOrientation());
    });

    GetSession()->SendActivateTaxiReply(ERR_TAXIOK);
    return true;
}

bool Player::ActivateTaxiPathTo(uint32 taxi_path_id, uint32 spellid /*= 0*/)
{
    TaxiPathEntry const* entry = sTaxiPathStore.LookupEntry(taxi_path_id);
    if (!entry)
        return false;

    std::vector<uint32> nodes;

    nodes.resize(2);
    nodes[0] = entry->FromTaxiNode;
    nodes[1] = entry->ToTaxiNode;

    return ActivateTaxiPathTo(nodes, NULL, spellid);
}

void Player::CleanupAfterTaxiFlight(bool zoneUpdate /*true*/)
{
    m_taxi.ClearTaxiDestinations();        // not destinations, clear source node
    StopMoving();
    Dismount();
    ClearUnitState(UNIT_STATE_IN_FLIGHT);
    RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_REMOVE_CLIENT_CONTROL | UNIT_FLAG_TAXI_FLIGHT);
    getHostileRefManager().setOnlineOfflineState(true);

    if (zoneUpdate)
    {
        // Garrison support
        uint32 newzone, newarea;
        GetZoneAndAreaId(newzone, newarea);
        UpdateZone(newzone, newarea);
    }
}

void Player::ContinueTaxiFlight()
{
    uint32 sourceNode = m_taxi.GetTaxiSource();
    if (!sourceNode)
        return;

    TC_LOG_DEBUG(LOG_FILTER_UNITS, "WORLD: Restart character %u taxi flight", GetGUIDLow());

    uint32 mountDisplayId = sObjectMgr->GetTaxiMountDisplayId(sourceNode, GetTeam(), true);
    if (!mountDisplayId)
        return;

    uint32 path = m_taxi.GetCurrentTaxiPath();

    // search appropriate start path node
    uint32 startNode = 0;

    TaxiPathNodeList const& nodeList = sTaxiPathNodesByPath[path];

    if (nodeList.empty())
        return;

    float distPrev = MAP_SIZE*MAP_SIZE;
    float distNext =
        (nodeList[0]->Loc.X - GetPositionX())*(nodeList[0]->Loc.X - GetPositionX()) +
        (nodeList[0]->Loc.Y - GetPositionY())*(nodeList[0]->Loc.Y - GetPositionY()) +
        (nodeList[0]->Loc.Z - GetPositionZ())*(nodeList[0]->Loc.Z - GetPositionZ());

    for (size_t i = 1; i < nodeList.size(); ++i)
    {
        TaxiPathNodeEntry const* node = nodeList[i];
        TaxiPathNodeEntry const* prevNode = nodeList[i-1];

        // skip nodes at another map
        if (node->ContinentID != GetMapId())
            continue;

        distPrev = distNext;

        distNext =
            (node->Loc.X - GetPositionX()) * (node->Loc.X - GetPositionX()) +
            (node->Loc.Y - GetPositionY()) * (node->Loc.Y - GetPositionY()) +
            (node->Loc.Z - GetPositionZ()) * (node->Loc.Z - GetPositionZ());

        float distNodes =
            (node->Loc.X - prevNode->Loc.X) * (node->Loc.X - prevNode->Loc.X) +
            (node->Loc.Y - prevNode->Loc.Y) * (node->Loc.Y - prevNode->Loc.Y) +
            (node->Loc.Z - prevNode->Loc.Z) * (node->Loc.Z - prevNode->Loc.Z);

        if (distNext + distPrev < distNodes)
        {
            startNode = i;
            break;
        }
    }

    GetSession()->SendDoFlight(mountDisplayId, path, startNode);
}

void Player::ProhibitSpellSchool(SpellSchoolMask idSchoolMask, uint32 unTimeMs)
{
    WorldPackets::Spells::SpellCooldown cooldowns;
    cooldowns.Caster = GetGUID();
    cooldowns.Flags = 0;

    std::list<AuraType> auratypelist;
    auratypelist.push_back(SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS);
    auratypelist.push_back(SPELL_AURA_OVERRIDE_ACTIONBAR_SPELLS_2);
    Unit::AuraEffectList swaps;
    GetAuraEffectsByListType(&auratypelist, swaps);

    double curTime = getPreciseTime();
    for (PlayerSpellMap::iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
    {
        PlayerSpell* spellPtr_ = &itr->second;
        if (!spellPtr_ || spellPtr_->state == PLAYERSPELL_REMOVED || spellPtr_->disabled)
            continue;

        uint32 unSpellId = itr->first;
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(unSpellId);
        if (!spellInfo)
            continue;

        if (swaps.begin() != swaps.end())
        {
            for (Unit::AuraEffectList::iterator iter = swaps.begin(); iter != swaps.end(); ++iter)
            {
                if ((*iter)->IsAffectingSpell(spellInfo))
                {
                    if (SpellInfo const* newInfo = sSpellMgr->GetSpellInfo((*iter)->GetAmount()))
                    {
                        spellInfo = newInfo;
                        unSpellId = newInfo->Id;
                    }
                    break;
                }
            }
        }

        // Not send cooldown for this spells
        if (spellInfo->HasAttribute(SPELL_ATTR0_DISABLED_WHILE_ACTIVE))
            continue;

        if (spellInfo->Categories.PreventionType & SPELL_PREVENTION_TYPE_PACIFY || !spellInfo->Categories.PreventionType)
            continue;

        uint32 _SchoolMask = 1 << GetFirstSchoolInMask(spellInfo->GetSchoolMask());
        _SchoolMask &= uint32(~idSchoolMask);

        if ((_SchoolMask == 0) && GetSpellCooldownDelay(unSpellId) < unTimeMs * 1.0 / IN_MILLISECONDS)
        {
            cooldowns.SpellCooldowns.emplace_back(unSpellId, unTimeMs);
            AddSpellCooldown(unSpellId, 0, curTime + unTimeMs * 1.0 /IN_MILLISECONDS);
        }
    }

    SendDirectMessage(cooldowns.Write());
}

void Player::InitDataForForm(bool reapplyMods)
{
    ShapeshiftForm form = GetShapeshiftForm();
    bool FierceTiger = false;

    SpellShapeshiftFormEntry const* ssEntry = sSpellShapeshiftFormStore.LookupEntry(form);

    if (ssEntry && ssEntry->CombatRoundTime)
    {
        SetAttackTime(BASE_ATTACK, ssEntry->CombatRoundTime);
        SetAttackTime(OFF_ATTACK, ssEntry->CombatRoundTime);
        SetAttackTime(RANGED_ATTACK, BASE_ATTACK_TIME);
    }
    else
        SetRegularAttackTime();

    switch (form)
    {
        case FORM_FIERCE_TIGER:
        {
            FierceTiger = true;
            if (getPowerType() != POWER_ENERGY)
                setPowerType(POWER_ENERGY);
            break;
        }
        case FORM_STURDY_OX:
        case FORM_GHOUL:
        case FORM_CAT:
        {
            if (getPowerType() != POWER_ENERGY)
                setPowerType(POWER_ENERGY);
            break;
        }
        case FORM_BEAR:
        {
            if (getPowerType() != POWER_RAGE)
                setPowerType(POWER_RAGE);
            break;
        }
        case FORM_SPIRITED_CRANE:
        case FORM_WISE_SERPENT:
        case FORM_GHOSTWOLF:
        {
            if (getPowerType() != POWER_MANA)
                setPowerType(POWER_MANA);
            break;
        }
        default:                                            // 0, for example
        {
            SetFieldPowerType(GetPowerTypeBySpecId(GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID)));
            break;
        }
    }

    // update auras at form change, ignore this at mods reapply (.reset stats/etc) when form not change.
    if (!reapplyMods && !FierceTiger)
        UpdateEquipSpellsAtFormChange();

    SendUpdateStat(USM_MELEE_AP | USM_RANGE_AP);
}

void Player::InitDisplayIds()
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    if (!info)
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player %u has incorrect race/class pair. Can't init display ids.", GetGUIDLow());
        return;
    }

    uint8 gender = getGender();
    switch (gender)
    {
        case GENDER_FEMALE:
            SetDisplayId(info->displayId_f);
            SetNativeDisplayId(info->displayId_f);
            break;
        case GENDER_MALE:
            SetDisplayId(info->displayId_m);
            SetNativeDisplayId(info->displayId_m);
            break;
        default:
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Invalid gender %u for player", gender);
            return;
    }
}

void Player::TakeExtendedCost(uint32 extendedCostId, uint32 count)
{
    ItemExtendedCostEntry const* extendedCost = sItemExtendedCostStore.LookupEntry(extendedCostId);
    
    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
    {
        if (extendedCost->ItemID[i])
            DestroyItemCount(extendedCost->ItemID[i], (extendedCost->ItemCount[i] * count), true);
    }

    for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
    {
        if (extendedCost->CurrencyID[i] == CURRENCY_NONE)
            continue;

        if (extendedCost->IsSeasonCurrencyRequirement(i))
            continue;

        ModifyCurrency(extendedCost->CurrencyID[i], -int32(extendedCost->CurrencyCount[i] * count), false, true);
    }
}

inline bool Player::_StoreOrEquipNewItem(uint32 vendorslot, uint32 item, uint8 count, uint8 bag, uint8 slot, int64 price, ItemTemplate const *pProto, Creature *pVendor, VendorItem const* crItem, bool bStore)
{
    ItemPosCountVec vDest;
    uint16 uiDest = 0;

    InventoryResult msg = bStore ?
        CanStoreNewItem(bag, slot, vDest, item, count) :
        CanEquipNewItem(slot, uiDest, item, false);
    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, NULL, NULL, item);
        return false;
    }
    
    if (!crItem->DonateCost)
        ModifyMoney(-price);
    else
    {
        if (!ChangeTokenCount(sWorld->getIntConfig(CONFIG_DONATE_VENDOR_TOKEN_TYPE), -price, Battlepay::BattlepayCustomType::VendorBuyItem, item))
            return false;
    }

    if (crItem->ExtendedCost) // case for new honor system
    {
        if (ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost))
        {
            for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
                if (iece->ItemID[i])
                    DestroyItemCount(iece->ItemID[i], iece->ItemCount[i], true);

            for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
            {
                if (iece->IsSeasonCurrencyRequirement(i))
                    continue;

                if (iece->CurrencyID[i])
                    ModifyCurrency(iece->CurrencyID[i], -int32(iece->CurrencyCount[i]), false, true);
            }
        }
    }

    ItemRandomEnchantmentId RandomPropertiesID = crItem->RandomPropertiesID;
    if (RandomPropertiesID.Id == 0)
        RandomPropertiesID = Item::GenerateItemRandomPropertyId(item, GetLootSpecID());

    bool isRefund = bool(pProto->GetFlags() & ITEM_FLAG_ITEM_PURCHASE_RECORD && crItem->ExtendedCost && pProto->GetMaxStackSize() == 1 && !crItem->DonateCost);

    Item* it = bStore ?
        StoreNewItem(vDest, item, true, RandomPropertiesID, GuidSet(), crItem->BonusListIDs, crItem->Context, isRefund) :
        EquipNewItem(uiDest, item, true, RandomPropertiesID.Id, crItem->BonusListIDs, crItem->Context, isRefund);
    if (it)
    {
        uint32 new_count = pVendor->UpdateVendorItemCurrentCount(crItem, count);

        WorldPackets::Item::BuySucceeded packet;
        packet.VendorGUID = pVendor->GetGUID();
        packet.Muid = vendorslot + 1;
        packet.NewQuantity = crItem->maxcount > 0 ? new_count : 0xFFFFFFFF;
        packet.QuantityBought = count;
        SendDirectMessage(packet.Write());

        SendNewItem(it, count, true, false, false);

        if (!bStore)
            AutoUnequipOffhandIfNeed();

        if (isRefund)
        {
            it->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE);
            it->SetRefundRecipient(GetGUID());
            it->SetPaidMoney(price);
            it->SetPaidExtendedCost(crItem->ExtendedCost);
            it->SaveRefundDataToDB();
            AddRefundReference(it->GetGUID());
        }

        if (crItem->DonateCost)
        {
            if (!sWorld->getBoolConfig(CONFIG_DONATE_ON_TESTS))
            {
                it->SetDonateItem(true);
                TC_LOG_DEBUG(LOG_FILTER_DONATE, "[Buy] Item guid = %u, entry = %u, cost = " SI64FMTD ", DonateStoreId = %d %s", it->GetGUIDLow(), it->GetEntry(), price, crItem->DonateStoreId, GetInfoForDonate().c_str());
            }
            it->SetState(ITEM_CHANGED, this);
            it->SetBinding(true);
            SaveToDB();
            SQLTransaction temp = SQLTransaction(NULL);
            it->SaveToDB(temp);


            //CharacterDatabase.PExecute("INSERT INTO character_donate (`owner_guid`, `itemguid`, `itemEntry`, `efircount`, `count`)"
            //" VALUES('%u', '%u', '%u', '%u', '%u')", GetGUIDLow(), it->GetGUIDLow(), it->GetEntry(), uicount, count);
        }
    }

    // event vendors items log
    switch (pVendor->GetEntry())
    {
    case 542000:
        sLog->outWarden("Player %s (GUID: %u) buy item %u (%u - count) from vendor (Entry: %u)", GetName(), GetGUIDLow(), item, count, pVendor->GetEntry());
        break;
    }
    return true;
}

bool Player::BuyCurrencyFromVendorSlot(ObjectGuid vendorGuid, uint32 vendorSlot, uint32 currency, uint32 count)
{
    // cheating attempt
    if (count < 1 || count > 1) count = 1;

    if (!isAlive())
        return false;

    CurrencyTypesEntry const* proto = sCurrencyTypesStore.LookupEntry(currency);
    if (!proto)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, currency);
        return false;
    }

    Creature* creature = GetNPCIfCanInteractWith(vendorGuid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "WORLD: BuyCurrencyFromVendorSlot - Unit (GUID: %u) not found or you can't interact with him.", vendorGuid.GetGUIDLow());
        SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, currency);
        return false;
    }

    VendorItemData const* vItems = creature->GetVendorItems();
    if (!vItems || vItems->Empty())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency);
        return false;
    }

    if (vendorSlot >= vItems->GetItemCount())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency);
        return false;
    }

    VendorItem const* crItem = vItems->GetItem(vendorSlot);
    // store diff item (cheating)
    if (!crItem || crItem->item != currency || crItem->Type != ITEM_VENDOR_TYPE_CURRENCY)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency);
        return false;
    }

    if (crItem->PlayerConditionID && !sConditionMgr->IsPlayerMeetingCondition(this, crItem->PlayerConditionID))
    {
        SendEquipError(EQUIP_ERR_ITEM_LOCKED);
        return false;
    }

    if (crItem->ExtendedCost)
    {
        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        if (!iece)
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Currency %u have wrong ExtendedCost field value %u", currency, crItem->ExtendedCost);
            return false;
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
        {
            if (iece->ItemID[i] && !HasItemCount(iece->ItemID[i], (iece->ItemCount[i] * count)))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS);
                return false;
            }
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (!iece->CurrencyID[i])
                continue;

            CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(iece->CurrencyID[i]);
            if (!entry)
            {
                SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, currency); // Find correct error
                return false;
            }

            int32 cost = int32(iece->CurrencyCount[i] * count);

            bool hasCount = iece->IsSeasonCurrencyRequirement(i) ? HasCurrencySeason(iece->CurrencyID[i], cost) : HasCurrency(iece->CurrencyID[i], cost);
            if (!hasCount)
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS); // Find correct error
                return false;
            }
        }

        // check for personal arena rating requirement
        if (GetMaxPersonalArenaRatingRequirement(iece->ArenaBracket) < iece->RequiredArenaRating)
        {
            // probably not the proper equip err
            SendEquipError(EQUIP_ERR_CANT_EQUIP_RANK);
            return false;
        }
    }

    uint64 price = 0;
    if (uint64 extGold = crItem->Money) //Assume price cannot be negative (do not know why it is int32)
    {
        uint32 maxCount = MAX_MONEY_AMOUNT / extGold;
        if (count > maxCount)
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player %s tried to buy %u currency id %u, causing overflow", GetName(), (uint32)count, currency);
            count = maxCount;
        }
        price = extGold * count; //it should not exceed MAX_MONEY_AMOUNT

        // reputation discount
        price *= double(GetReputationPriceDiscount(creature));

        if (crItem->DonateCost != 0)
            price = crItem->DonateCost;

        if (!HasEnoughMoney(price) && !crItem->DonateCost)
        {
            SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, currency);
            return false;
        }
    }

    uint32 totalCap = GetTotalCurrencyCap(currency);
    if (totalCap > 0 && GetCurrency(currency) >= totalCap)
    {
        SendBuyError(BUY_ERR_CANT_CARRY_MORE);
        return false;
    }

    if (proto->MaxEarnablePerWeek && GetCurrencyOnWeek(currency) >= proto->MaxEarnablePerWeek)
    {
        SendBuyError(BUY_ERR_CANT_CARRY_MORE);
        return false;
    }

    if (crItem->DonateCost)
    {
        if (!ChangeTokenCount(sWorld->getIntConfig(CONFIG_DONATE_VENDOR_TOKEN_TYPE), -crItem->DonateCost, Battlepay::BattlepayCustomType::VendorBuyCurrency, currency))
            return false;
        
        TC_LOG_DEBUG(LOG_FILTER_DONATE, "[Buy] Currency entry = %u, cost = %u, %s", currency, crItem->DonateCost, GetInfoForDonate().c_str());
    }
    else
    {
        if (crItem->ExtendedCost)
            TakeExtendedCost(crItem->ExtendedCost, count);

        ModifyMoney(-price);
    }

    ModifyCurrency(currency, crItem->maxcount * sDB2Manager.GetCurrencyPrecision(proto->ID), true, true);

    return true;
}

// Return true is the bought item has a max count to force refresh of window by caller
bool Player::BuyItemFromVendorSlot(ObjectGuid vendorguid, uint32 vendorslot, uint32 item, uint8 count, uint8 bag, uint8 slot)
{
    // cheating attempt
    if (count < 1) count = 1;

    // cheating attempt
    if (slot > MAX_BAG_SIZE && slot != NULL_SLOT)
        return false;

    if (!isAlive())
        return false;

    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(item);
    if (!pProto)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, NULL, item);
        return false;
    }

    if(pProto->GetMaxStackSize() < count)
        count = pProto->GetMaxStackSize();

    Creature* creature = GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
    if (!creature)
    {
        TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "WORLD: BuyItemFromVendor - Unit (GUID: %u) not found or you can't interact with him.", uint32(vendorguid.GetGUIDLow()));
        SendBuyError(BUY_ERR_DISTANCE_TOO_FAR, NULL, item);
        return false;
    }

    VendorItemData const* vItems;
    if (CustomMultiDonate && (creature->GetEntry() == 230000 || creature->GetEntry() == 230001))
         vItems = sObjectMgr->GetNpcDonateVendorItemList(CustomMultiDonate);
    else
         vItems = creature->GetVendorItems();
     
    if (!vItems || vItems->Empty())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item);
        return false;
    }

    if (vendorslot >= vItems->GetItemCount())
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item);
        return false;
    }

    VendorItem const* crItem = vItems->GetItem(vendorslot);
    // store diff item (cheating)
    if (!crItem || crItem->item != item)
    {
        SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item);
        return false;
    }

    if (crItem->PlayerConditionID && !sConditionMgr->IsPlayerMeetingCondition(this, crItem->PlayerConditionID))
    {
        SendEquipError(EQUIP_ERR_ITEM_LOCKED);
        return false;
    }

    // check current item amount if it limited
    if (crItem->maxcount != 0)
    {
        if (creature->GetVendorItemCurrentCount(crItem) < pProto->VendorStackCount * count)
        {
            SendBuyError(BUY_ERR_ITEM_ALREADY_SOLD, creature, item);
            return false;
        }
    }

    if (pProto->GetMinFactionID() && (uint32(GetReputationRank(pProto->GetMinFactionID())) < pProto->GetMinReputation()))
    {
        SendBuyError(BUY_ERR_REPUTATION_REQUIRE, creature, item);
        return false;
    }

    if (crItem->DonateCost)
    {
        uint32 stacks = count / pProto->VendorStackCount;
        if (!HasToken(sWorld->getIntConfig(CONFIG_DONATE_VENDOR_TOKEN_TYPE), crItem->DonateCost * stacks))
        {
            SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS);
            return false;
        }
    }
    else if (crItem->ExtendedCost)
    {
        // Can only buy full stacks for extended cost
        if (pProto->VendorStackCount != count)
        {
            SendEquipError(EQUIP_ERR_CANT_BUY_QUANTITY);
            return false;
        }

        uint32 stacks = count / pProto->VendorStackCount;
        ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(crItem->ExtendedCost);
        if (!iece)
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Item %u have wrong ExtendedCost field value %u", pProto->GetId(), crItem->ExtendedCost);
            return false;
        }


        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
        {
            if (iece->ItemID[i] && !HasItemCount(iece->ItemID[i], (iece->ItemCount[i] * stacks)))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS);
                return false;
            }         
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (!iece->CurrencyID[i])
                continue;

            CurrencyTypesEntry const* entry = sCurrencyTypesStore.LookupEntry(iece->CurrencyID[i]);
            if (!entry)
            {
                SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item);
                return false;
            }

            // Second field in dbc is season count except two strange rows
            if (i == 1 && iece->ID != 2999)
            {
                if (iece->CurrencyCount[i] > GetCurrencyOnSeason(iece->CurrencyID[i]))
                {
                    SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS);
                    return false;
                }
            }
            else if (!HasCurrency(iece->CurrencyID[i], (iece->CurrencyCount[i] * stacks)))
            {
                SendEquipError(EQUIP_ERR_VENDOR_MISSING_TURNINS);
                return false;
            }
        }

        // check for personal arena rating requirement
        if (GetMaxPersonalArenaRatingRequirement(iece->ArenaBracket) < iece->RequiredArenaRating)
        {
            // probably not the proper equip err
            SendEquipError(EQUIP_ERR_CANT_EQUIP_RANK, NULL, NULL);
            return false;
        }
    }
    
    if (!crItem->DonateCost)  // BOA on donate
    {
        std::vector<GuildReward> const& rewards = sGuildMgr->GetGuildRewards();

        for (std::vector<GuildReward>::const_iterator reward = rewards.begin(); reward != rewards.end(); ++reward)
        {
            if (pProto->GetId() != reward->Entry)
                continue;

            Guild* guild = sGuildMgr->GetGuildById(this->GetGuildId());

            if (!guild)
            {
                SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item);
                return false;
            }

            if (reward->Standing)
            {
                if (this->GetReputationRank(REP_GUILD) < reward->Standing)
                {
                    SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item);
                    return false;
                }
            }

            for (size_t i = 0; i < reward->AchievementsRequired.size(); ++i)
            {
                uint32 achievementID = reward->AchievementsRequired[i];
                if (achievementID && !guild->GetAchievementMgr().HasAchieved(achievementID))
                {
                    SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item);
                    return false;
                }
            }

            if (reward->Racemask)
            {
                if (!(this->getRaceMask() & reward->Racemask))
                {
                    SendBuyError(BUY_ERR_CANT_FIND_ITEM, creature, item);
                    return false;
                }
            }
        }
    }
    
    uint64 extGold = crItem->Money;
    uint64 price = 0;
    if (extGold || crItem->IsGoldRequired(pProto) && pProto->GetBuyPrice() > 0) //Assume price cannot be negative (do not know why it is int32)
    {
        uint32 maxCount = MAX_MONEY_AMOUNT / (extGold ? extGold : pProto->GetBuyPrice());
        if ((uint32)count > maxCount)
        {
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "Player %s tried to buy %u item id %u, causing overflow", GetName(), (uint32)count, pProto->GetId());
            count = (uint8)maxCount;
        }
        price = (extGold ? extGold : pProto->GetBuyPrice()) * count; //it should not exceed MAX_MONEY_AMOUNT

        // reputation discount
        price *= double(GetReputationPriceDiscount(creature));

        //if (int32 priceMod = GetTotalAuraModifier(SPELL_AURA_MOD_VENDOR_ITEMS_PRICES))
            //price -= CalculatePct(price, priceMod);

            
        if (!HasEnoughMoney(price) && !crItem->DonateCost)
        {
            SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, item);
            return false;
        }
    }
    
    if (crItem->DonateCost)
    {
        //Hack for donate
        uint32 stacks = count / pProto->VendorStackCount;
        price = crItem->DonateCost * stacks;
    }

    if ((bag == NULL_BAG && slot == NULL_SLOT) || IsInventoryPos(bag, slot))
    {
        if (!_StoreOrEquipNewItem(vendorslot, item, count, bag, slot, price, pProto, creature, crItem, true))
            return false;
    }
    else if (IsEquipmentPos(bag, slot))
    {
        if (count != 1)
        {
            SendEquipError(EQUIP_ERR_NOT_EQUIPPABLE);
            return false;
        }
        if (!_StoreOrEquipNewItem(vendorslot, item, count, bag, slot, price, pProto, creature, crItem, false))
            return false;
    }
    else
    {
        SendEquipError(EQUIP_ERR_WRONG_SLOT);
        return false;
    }

    if (crItem->maxcount != 0) // bought
    { 
        if (pProto->GetQuality() > ITEM_QUALITY_EPIC || (pProto->GetQuality() == ITEM_QUALITY_EPIC && pProto->ItemLevel >= MinNewsItemLevel[CURRENT_EXPANSION]))
            if (!pProto->IsNotAppearInGuildNews())
                if (Guild* guild = sGuildMgr->GetGuildById(GetGuildId()))
                    guild->AddGuildNews(GUILD_NEWS_ITEM_PURCHASED, GetGUID(), 0, item);

        return true;
    }
    return false;
}

uint32 Player::GetMaxPersonalArenaRatingRequirement(uint8 minarenaslot) const
{
    // returns the maximal personal arena rating that can be used to purchase items requiring this condition
    // the personal rating of the arena team must match the required limit as well
    // so return max[in arenateams](min(personalrating[teamtype], teamrating[teamtype]))
    uint32 max_personal_rating = 0;
    for (uint8 i = minarenaslot; i < MAX_ARENA_SLOT; ++i)
    {
        uint32 p_rating = getBracket(i)->getRating();
        if (max_personal_rating < p_rating)
           max_personal_rating = p_rating;
    }
    return max_personal_rating;
}

void Player::UpdateHomebindTime(uint32 time)
{
    if (!GetMap() || GetMap()->IsGarrison())
        return;

    // GMs never get homebind timer online
    if (m_InstanceValid || isGameMaster())
    {
        if (m_HomebindTimer) // instance valid, but timer not reset
            SendRaidGroupOnlyMessage(RaidGroupReason::NONE, 0);

        // instance is valid, reset homebind timer
        m_HomebindTimer = 0;
    }
    else if (m_HomebindTimer > 0)
    {
        if (time >= m_HomebindTimer)
        {
            // teleport to nearest graveyard
            RepopAtGraveyard(GetMap()->Instanceable() && !GetGroup());
        }
        else
            m_HomebindTimer -= time;
    }
    else
    {
        m_HomebindTimer = 0;
        SendRaidGroupOnlyMessage(RaidGroupReason::REQUIREMENTS_UNMATCH, m_HomebindTimer);

        TC_LOG_DEBUG(LOG_FILTER_MAPS, "PLAYER: Player '%s' (GUID: %u) will be teleported to homebind in 60 seconds", GetName(), GetGUIDLow());
        RepopAtGraveyard(true);
    }
}

void Player::UpdatePvPState(bool onlyFFA)
{
    if (InFFAPvPArea())
    {
        pvpInfo.inFFAPvPArea = true;
        pvpInfo.inHostileArea = true;
        pvpInfo.inNoPvPArea = false;
    }

    // TODO: should we always synchronize UNIT_FIELD_BYTES_2, 1 of controller and controlled?
    // no, we shouldn't, those are checked for affecting player by client
    if (!pvpInfo.inNoPvPArea && !isGameMaster() && !IsSpectator() && (pvpInfo.inFFAPvPArea || sWorld->IsFFAPvPRealm()))
    {
        if (!IsFFAPvP())
        {
            SetByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);
            SetGroupUpdateFlag(GROUP_UPDATE_FLAG_STATUS);
            for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
                if(Unit* unit = ObjectAccessor::GetUnit(*this, *itr))
                    unit->SetByteValue(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);
        }
    }
    else if (IsFFAPvP())
    {
        RemoveByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);
        SetGroupUpdateFlag(GROUP_UPDATE_FLAG_STATUS);
        for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
            if(Unit* unit = ObjectAccessor::GetUnit(*this, *itr))
                unit->RemoveByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PVP_FLAG, UNIT_BYTE2_FLAG_FFA_PVP);
    }

    if (onlyFFA)
        return;

    if (pvpInfo.inHostileArea)                               // in hostile area
    {
        if (!IsPvP() || pvpInfo.endTimer != 0)
            UpdatePvP(true, true);
    }
    else                                                    // in friendly area
    {
        if (IsPvP() && !HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_IN_PVP) && pvpInfo.endTimer == 0)
            pvpInfo.endTimer = time(0);                     // start toggle-off
    }
}

void Player::SetPvP(bool state)
{
    Unit::SetPvP(state);
    for (ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
        if(Unit* unit = ObjectAccessor::GetUnit(*this, *itr))
            unit->SetPvP(state);
}

void Player::UpdatePvP(bool state, bool override)
{
    SetPvP(state);
    if (!state || override)
        pvpInfo.endTimer = 0;
    else
        pvpInfo.endTimer = time(nullptr);
}

bool Player::HasSpellCooldown(uint32 spell_id)
{
    SpellCooldowns::const_iterator itr = m_spellCooldowns.find(spell_id);
    return itr != m_spellCooldowns.end() && itr->second.end > getPreciseTime();
}

double Player::GetSpellCooldownDelay(uint32 spell_id)
{
    SpellCooldowns::const_iterator itr = m_spellCooldowns.find(spell_id);
    double t = getPreciseTime();
    return double(itr != m_spellCooldowns.end() && itr->second.end > t ? itr->second.end - t : 0.0);
}

void Player::AddSpellAndCategoryCooldowns(SpellInfo const* spellInfo, uint32 itemId, Spell* spell, bool onHold)
{
    if (spellInfo->IsBattleResurrection())
        if (InstanceScript* instanceScript = GetInstanceScript())
            if (instanceScript->IsEncounterInProgress() && instanceScript->instance->IsRaid())
                return;

    // init cooldown values
    uint32 categoryId = 0;
    int32 cooldown = -1;
    int32 categoryCooldown = -1;

    // some special item spells without correct cooldown in SpellInfo
    // cooldown information stored in item prototype
    // This used in same way in WorldSession::HandleItemQuerySingleOpcode data sending to client.

    if (itemId)
    {
        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
        {
            for (ItemEffectEntry const* effectData : proto->Effects)
            {
                if (effectData->SpellID == spellInfo->Id)
                {
                    categoryId = effectData->SpellCategoryID;
                    cooldown = effectData->CoolDownMSec;
                    categoryCooldown = effectData->CategoryCoolDownMSec;
                    break;
                }
            }
        }
    }

    // if no cooldown found above then base at DBC data
    if (cooldown < 0 && categoryCooldown < 0)
    {
        categoryId = spellInfo->Categories.Category;
        cooldown = spellInfo->Cooldowns.RecoveryTime;
        categoryCooldown = spellInfo->Cooldowns.CategoryRecoveryTime;
    }

    double curTime = getPreciseTime();
    double categoryCooldownTime;
    double cooldownTime;

    if (!spellInfo->IsChanneled() && (spellInfo->HasAttribute(SPELL_ATTR8_HASTE_AFFECT_DURATION_RECOVERY)))
        cooldown = int32(cooldown * GetFloatValue(UNIT_FIELD_MOD_SPELL_HASTE));

    cooldown = int32(cooldown * GetFloatValue(UNIT_FIELD_MOD_TIME_RATE));
    categoryCooldown = int32(categoryCooldown * GetFloatValue(UNIT_FIELD_MOD_TIME_RATE));

    // overwrite time for selected category
    if (onHold)
    {
        // use +MONTH as infinity mark for spell cooldown (will checked as MONTH/2 at save ans skipped)
        // but not allow ignore until reset or re-login
        categoryCooldownTime = categoryCooldown > 0 ? (curTime + infinityCooldownDelay) : curTime;
        cooldownTime = cooldown > 0 ? (curTime + infinityCooldownDelay) : categoryCooldownTime;
    }
    else
    {
        // shoot spells used equipped item cooldown values already assigned in GetAttackTime(RANGED_ATTACK)
        // prevent 0 cooldowns set by another way
        if (cooldown <= 0 && categoryCooldown <= 0 && (categoryId == 76 || (spellInfo->IsAutoRepeatRangedSpell() && spellInfo->Id != 75)))
            cooldown = GetAttackTime(RANGED_ATTACK);

        if (cooldown > 0)
            ApplySpellMod(spellInfo->Id, SPELLMOD_COOLDOWN, cooldown, spell);

        if (categoryCooldown > 0 && !spellInfo->HasAttribute(SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS))
            ApplySpellMod(spellInfo->Id, SPELLMOD_COOLDOWN, categoryCooldown, spell);

        if (HasAuraTypeWithAffectMask(SPELL_AURA_MOD_SPELL_COOLDOWN_BY_HASTE, spellInfo))
        {
            cooldown = int32(cooldown * GetFloatValue(UNIT_FIELD_MOD_HASTE));
            categoryCooldown = int32(categoryCooldown * GetFloatValue(UNIT_FIELD_MOD_HASTE));
        }

        if (HasAuraTypeWithAffectMask(SPELL_AURA_MOD_COOLDOWN_BY_HASTE_REGEN, spellInfo))
        {
            cooldown = int32(cooldown * GetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN));
            categoryCooldown = int32(categoryCooldown * GetFloatValue(UNIT_FIELD_MOD_HASTE_REGEN));
        }

        if (int32 cooldownMod = GetTotalAuraModifier(SPELL_AURA_MOD_COOLDOWN))
        {
            // Apply SPELL_AURA_MOD_COOLDOWN only to own spells
            if (HasSpell(spellInfo->Id))
            {
                cooldown += cooldownMod * IN_MILLISECONDS;   // SPELL_AURA_MOD_COOLDOWN does not affect category cooldows, verified with shaman shocks
                SendSpellCooldown(spellInfo->Id, 0, cooldown);
            }
        }

        cooldown = int32(cooldown * SpellCooldownModByRate(spellInfo, true));

        // Apply SPELL_AURA_MOD_SPELL_CATEGORY_COOLDOWN modifiers
        // Note: This aura applies its modifiers to all cooldowns of spells with set category, not to category cooldown only
        if (categoryId)
        {
            if (int32 categoryModifier = GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SPELL_CATEGORY_COOLDOWN, categoryId))
            {
                if (cooldown > 0)
                    cooldown += categoryModifier;

                if (categoryCooldown > 0)
                    categoryCooldown += categoryModifier;
            }

            SpellCategoryEntry const* categoryEntry = sSpellCategoryStore.LookupEntry(categoryId);
            if (categoryEntry && categoryEntry->Flags & SPELL_CATEGORY_FLAG_COOLDOWN_EXPIRES_AT_DAILY_RESET)
                categoryCooldown = int32(std::chrono::duration_cast<std::chrono::milliseconds>(SystemClock::from_time_t(sWorld->GetNextDailyQuestsResetTime()) - SystemClock::now()).count());
        }

        // replace negative cooldowns by 0
        if (cooldown < 0)
            cooldown = 0;

        if (categoryCooldown < 0)
            categoryCooldown = 0;

        // no cooldown after applying spell mods
        if (cooldown == 0 && categoryCooldown == 0)
            return;

        categoryCooldownTime = categoryCooldown ? curTime + categoryCooldown / IN_MILLISECONDS : curTime;
        cooldownTime = cooldown ? curTime + cooldown / IN_MILLISECONDS : categoryCooldownTime;
    }

    // self spell cooldown
    if (cooldownTime != curTime)
    {
        AddSpellCooldown(spellInfo->Id, itemId, cooldownTime);

        // TODO: delete after implement Commentator system
        if (HaveSpectators())
        {
            SpectatorAddonMsg msg;
            msg.SetPlayer(GetGUID());
            msg.AddCooldown(spellInfo->Id, cooldownTime - curTime);
            SendSpectatorAddonMsgToBG(msg);
        }

        // TODO: rewrite this shit
        switch (spellInfo->Id)
        {
            case 34861:
            {
                if (HasAura(238136)) // Cosmic Ripple
                {
                    int32 delay = (cooldownTime - curTime) * IN_MILLISECONDS;
                    AddDelayedEvent(delay, [this]() -> void
                    {
                        if (this)
                            CastSpell(this, 243241, true);
                    });
                }
                break;
            }
            case 72757: // Will of the Forsaken Cooldown Trigger (WOTF)
            {
                uint32 spellId = GetCrowdControlSpellId();

                if (spellId == 208683 || spellId == 195710)
                {
                    uint32 spellCool = GetSpellCooldownDelay(spellId);

                    if (!spellCool || spellCool >= categoryCooldown)
                    {
                        PlayerDynamicFieldArenaCooldowns aCool = PlayerDynamicFieldArenaCooldowns(spellId, m_timeSyncClient, m_timeSyncClient + categoryCooldown);
                        SetDynamicStructuredValue(PLAYER_DYNAMIC_FIELD_ARENA_COOLDOWNS, 0, &aCool);
                    }
                }
                break;
            }
            case 208683: // Honorable Medallion
            case 195710: // Gladiator's Medallion
            {
                if (InArena() && spell)
                {
                    PlayerDynamicFieldArenaCooldowns aCool = PlayerDynamicFieldArenaCooldowns(spellInfo->Id, m_timeSyncClient, m_timeSyncClient + categoryCooldown);
                    SetDynamicStructuredValue(PLAYER_DYNAMIC_FIELD_ARENA_COOLDOWNS, 0, &aCool);
                }
                break;
            }
        }
    }

    // category spells - DELETE LATER after implementation SpellHistory
    if (categoryId && categoryCooldown > 0)
    {
        DB2Manager::SpellCategoryContainer::const_iterator _cat = sDB2Manager._spellCategory.find(categoryId);
        if (_cat != sDB2Manager._spellCategory.end())
        {
            for (DB2Manager::SpellCategorySet::const_iterator _scset = _cat->second.begin(); _scset != _cat->second.end(); ++_scset)
            {
                if (*_scset == spellInfo->Id)                    // skip main spell, already handled above
                    continue;

                AddSpellCooldown(*_scset, itemId, categoryCooldownTime);
            }
        }
    }
}

float Player::SpellCooldownModByRate(SpellInfo const* spellInfo, bool sendSpeedRate/* = false*/)
{
    float amount = 0.0f;
    float Multiplier = 1.0f;
    AuraEffectList const* spellCooldownByHaste = GetAuraEffectsByType(SPELL_AURA_MOD_COOLDOWN_SPEED_RATE);
    if (!spellCooldownByHaste)
        return Multiplier;

    for (AuraEffectList::const_iterator itr = spellCooldownByHaste->begin(); itr != spellCooldownByHaste->end(); ++itr)
    {
        switch ((*itr)->GetId())
        {
            case 209376: // Forbearant Faithful
                if (spellInfo->Id == 1022 || spellInfo->Id == 204018 || spellInfo->Id == 642 || spellInfo->Id == 633)
                    amount = (*itr)->GetAmount();
                break;
            case 214170: // Spiritual Journey
                if (spellInfo->Id == 51533)
                    amount = (*itr)->GetAmount();
                break;
            case 202776: // Blurred Time
                amount = (*itr)->GetAmount();
                break;
            case 216331: // Avenging Crusader (Honor Talent)
                if (spellInfo->Id == 35395 || spellInfo->Id == 20271)
                    amount = (*itr)->GetAmount();
                break;
            case 204366: // Thundercharge (Honor Talent)
                if ((*itr)->GetEffIndex() != EFFECT_0)
                    break;
                amount = (*itr)->GetAmount();
                break;
            case 233397: // Delirium
                if (spellInfo->HasAura(SPELL_AURA_MOD_INCREASE_SPEED) || spellInfo->HasAura(SPELL_AURA_MOD_SPEED_NO_CONTROL))
                    amount = (*itr)->GetAmount();
                break;
            case 214975: // Heartstop Aura (Honor Talent)
                amount = (*itr)->GetAmount();
                break;
            case 152173: // Serenity
                if (spellInfo->Id == 107428 || spellInfo->Id == 113656 || spellInfo->Id == 205320 || spellInfo->Id == 116847)
                    amount = (*itr)->GetAmount();
                break;
            default:
                break;
        }
    }

    if (!amount)
        return Multiplier;

    ApplyPercentModFloatVar(Multiplier, amount, false);


    if (sendSpeedRate)
    {
        uint32 delay = 200;

        if (Map* map = GetMap())
            delay += map->GetCurrentDiff();

        if (uint16 cat = spellInfo->Categories.ChargeCategory)
        {
            AddDelayedEvent(delay, [this, cat, Multiplier]()
            {
                if (IsInWorld())
                {
                    WorldPackets::Spells::ModifyChargeRecoverySpeed package;
                    package.SpellID = cat;
                    package.Multiplier = Multiplier;
                    package.Multiplier2 = std::min(Multiplier, 1.f);
                    SendDirectMessage(package.Write());
                }
            });
        }
        else
        {
            uint32 spellid = spellInfo->Id;

            AddDelayedEvent(delay, [this, spellid, Multiplier]()
            {
                if (IsInWorld())
                {
                    WorldPackets::Spells::ModifyCooldownRecoverySpeed package;
                    package.SpellID = spellid;
                    package.Multiplier = Multiplier;
                    package.Multiplier2 = Multiplier;
                    SendDirectMessage(package.Write());
                }
            });
        }
    }

    return Multiplier;
}

void Player::AddSpellCooldown(uint32 spellId, uint32 itemId, double cooldownEnd)
{
    m_spellCooldowns.erase(spellId);
    m_spellCooldowns.emplace(spellId, SpellCooldown(cooldownEnd, itemId));
}

void Player::AddRPPMSpellCooldown(uint32 spellid, ObjectGuid itemGUID, double end_time)
{
    bool findIt = false;
    for (RPPMSpellCooldowns::iterator itr = m_rppmspellCooldowns.begin(); itr != m_rppmspellCooldowns.end(); ++itr)
        if (itr->spellId == spellid && itr->itemGUID == itemGUID)
        {
            findIt = true;
            itr->end_time = end_time;
        }

    if (!findIt)
    {
        RPPMSpellCooldown sc;
        sc.spellId = spellid;
        sc.end_time = end_time;
        sc.itemGUID = itemGUID;
        sc.lastChanceToProc = 0;
        sc.lastSuccessfulProc = 0;

        m_rppmspellCooldowns.push_back(sc);
    }
}

double Player::GetRPPMSpellCooldownDelay(uint32 spell_id, ObjectGuid itemGUID)
{
    double cooldown = 0.0;

    for (auto itr : m_rppmspellCooldowns)
    {
        if (itr.spellId == spell_id && itr.itemGUID == itemGUID)
        {
            double t = getPreciseTime();
            double e_t = itr.end_time;

            if (e_t > t)
                cooldown = e_t - t;
        }
    }

    return cooldown;
}

bool Player::GetRPPMProcChance(double &cooldown, float RPPM, const SpellInfo* spellProto, ObjectGuid itemGUID)
{
    if (cooldown)
    {
        SetLastChanceToProc(spellProto->Id, getPreciseTime(), itemGUID);
        return false;
    }

    double preciseTime = getPreciseTime();
    double averageProcInterval = 60.0f / RPPM;
    double timeSinceLastSuccessfulProc = preciseTime - GetLastSuccessfulProc(spellProto->Id, itemGUID);
    double timeSinceLastChanceToProc = preciseTime - GetLastChanceToProc(spellProto->Id, itemGUID);

    if (timeSinceLastChanceToProc > 10.0)
        timeSinceLastChanceToProc = 10.0;

    if (timeSinceLastSuccessfulProc > 1000.0)
        timeSinceLastSuccessfulProc = 1000.0;

    float multiplier = std::max(1.0f, 1.0f + (float(timeSinceLastSuccessfulProc / averageProcInterval) - 1.5f) * 3.0f);
    float chance = multiplier * RPPM * (timeSinceLastChanceToProc) / 60.0f * 100.0f;

    cooldown = spellProto->GetAuraOptions(m_spawnMode)->ProcCategoryRecovery / 1000.0;

    SetLastChanceToProc(spellProto->Id, preciseTime, itemGUID);

    return roll_chance_f(chance);
}

double Player::GetLastSuccessfulProc(uint32 spell_id, ObjectGuid itemGUID)
{
    double lastSuccessfulProc = 0.0;

    for (auto itr : m_rppmspellCooldowns)
        if (itr.spellId == spell_id && itr.itemGUID == itemGUID)
            lastSuccessfulProc = itr.lastSuccessfulProc;

    return lastSuccessfulProc;
}
double Player::GetLastChanceToProc(uint32 spell_id, ObjectGuid itemGUID)
{
    double lastChanceToProc = 0.0;

    for (auto itr : m_rppmspellCooldowns)
        if (itr.spellId == spell_id && itr.itemGUID == itemGUID)
            lastChanceToProc = itr.lastChanceToProc;

    return lastChanceToProc;
}
void Player::SetLastSuccessfulProc(uint32 spell_id, double time, ObjectGuid itemGUID)
{
    for (RPPMSpellCooldowns::iterator itr = m_rppmspellCooldowns.begin(); itr != m_rppmspellCooldowns.end(); ++itr)
        if (itr->spellId == spell_id && itr->itemGUID == itemGUID)
            itr->lastSuccessfulProc = time;
}
void Player::SetLastChanceToProc(uint32 spell_id, double time, ObjectGuid itemGUID)
{
    for (RPPMSpellCooldowns::iterator itr = m_rppmspellCooldowns.begin(); itr != m_rppmspellCooldowns.end(); ++itr)
        if (itr->spellId == spell_id && itr->itemGUID == itemGUID)
            itr->lastChanceToProc = time;
}

void Player::SendCooldownEvent(SpellInfo const* spellInfo, uint32 itemId /*= 0*/, Spell* spell /*= NULL*/, bool setCooldown /*= true*/)
{
    if (setCooldown)
        AddSpellAndCategoryCooldowns(spellInfo, itemId, spell);
    
    SendDirectMessage(WorldPackets::Spells::CooldownEvent(false, spellInfo->Id).Write());
}

void Player::UpdatePotionCooldown(Spell* spell)
{
    // no potion used i combat or still in combat
    if (!m_lastPotionId || isInCombat())
        return;

    if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(55004))
        SendCooldownEvent(spellInfo, 0, nullptr, false);

    // Call not from spell cast, send cooldown event for item spells if no in combat
    if (!spell)
    {
        // spell/item pair let set proper cooldown (except not existed charged spell cooldown spellmods for potions)
        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(m_lastPotionId))
            for (ItemEffectEntry const* effectData : proto->Effects)
                if (effectData->TriggerType == ITEM_SPELLTRIGGER_ON_USE)
                    if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(effectData->SpellID))
                        SendCooldownEvent(spellInfo, m_lastPotionId);
    }
    // from spell cases (m_lastPotionId set in Spell::SendSpellCooldown)
    else
        SendCooldownEvent(spell->m_spellInfo, m_lastPotionId, spell);

    m_lastPotionId = 0;
}

                                                           //slot to be excluded while counting
bool Player::EnchantmentFitsRequirements(uint32 enchantmentcondition, int8 slot)
{
    if (!enchantmentcondition)
        return true;

    SpellItemEnchantmentConditionEntry const* Condition = sSpellItemEnchantmentConditionStore.LookupEntry(enchantmentcondition);
    if (!Condition)
        return true;

    uint8 curcount[4] = {0, 0, 0, 0};

    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == slot)
            continue;

        Item* item2 = GetItemByPos(INVENTORY_SLOT_BAG_0, i);
        if (item2 && !item2->CantBeUse())
        {
            for (ItemDynamicFieldGems const& gemData : item2->GetGems())
            {
                ItemTemplate const* gemProto = sObjectMgr->GetItemTemplate(gemData.ItemId);
                if (!gemProto)
                    continue;

                GemPropertiesEntry const* gemProperty = sGemPropertiesStore.LookupEntry(gemProto->GetGemProperties());
                if (!gemProperty)
                    continue;

                for (uint8 b = 0, tmpcolormask = 1; b < 4; b++, tmpcolormask <<= 1)
                    if (tmpcolormask & gemProperty->Type)
                        ++curcount[b];
            }
        }
    }

    bool activate = true;

    for (uint8 i = 0; i < 5; i++)
    {
        if (!Condition->LtOperandType[i])
            continue;

        uint32 _cur_gem = curcount[Condition->LtOperandType[i] - 1];
        uint32 _cmp_gem = Condition->RtOperandType[i] ? curcount[Condition->RtOperandType[i] - 1]: Condition->RtOperand[i];

        switch (Condition->Operator[i])
        {
            case 2:
                activate &= (_cur_gem < _cmp_gem) ? true : false;
                break;
            case 3:
                activate &= (_cur_gem > _cmp_gem) ? true : false;
                break;
            case 5:
                activate &= (_cur_gem >= _cmp_gem) ? true : false;
                break;
        }
    }

    return activate;
}

void Player::CorrectMetaGemEnchants(uint8 exceptslot, bool apply)
{
    for (uint32 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        if (slot == exceptslot)
            continue;

        Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
        if (!item || !item->GetSocketColor(0))
            continue;

        for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
        {
            uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(enchant_slot));
            if (!enchant_id)
                continue;

            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
            if (!enchantEntry)
                continue;

            if (uint32 condition = enchantEntry->ConditionID)
            {
                bool wasactive = EnchantmentFitsRequirements(condition, apply ? exceptslot : -1);
                if (wasactive ^ EnchantmentFitsRequirements(condition, apply ? -1 : exceptslot))
                    ApplyEnchantment(item, EnchantmentSlot(enchant_slot), !wasactive, true, true);
            }
        }
    }
}

                                                            //if false -> then toggled off if was on| if true -> toggled on if was off AND meets requirements
void Player::ToggleMetaGemsActive(uint8 exceptslot, bool apply)
{
    for (uint32 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
    {
        if (slot == exceptslot)
            continue;

        Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
        if (!item || !item->GetSocketColor(0))
            continue;

        for (uint32 enchantSlot = SOCK_ENCHANTMENT_SLOT; enchantSlot < SOCK_ENCHANTMENT_SLOT + 3; ++enchantSlot)
        {
            uint32 enchantID = item->GetEnchantmentId(EnchantmentSlot(enchantSlot));
            if (!enchantID)
                continue;

            if (SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchantID))
                if (enchantEntry->ConditionID)
                    ApplyEnchantment(item, EnchantmentSlot(enchantSlot), apply);
        }
    }
}

void Player::SetBattlegroundId(uint32 val, uint16 bgTypeId)
{
    m_bgData.BgInstanceID = val;
    m_bgData.BgTypeID = bgTypeId;
}

void Player::SetBattlegroundEntryPoint()
{
    // Taxi path store
    if (!m_taxi.empty())
    {
        m_bgData.MountSpellID  = 0;
        m_bgData.TaxiPath[0] = m_taxi.GetTaxiSource();
        m_bgData.TaxiPath[1] = m_taxi.GetTaxiDestination();

        // On taxi we don't need check for dungeon
        m_bgData.JoinPosition = WorldLocation(GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
    }
    else
    {
        m_bgData.ClearTaxiPath();

        // Mount spell id storing
        if (IsMounted())
        {
            if (AuraEffectList const* auras = GetAuraEffectsByType(SPELL_AURA_MOUNTED))
                if (auras->begin() != auras->end())
                    m_bgData.MountSpellID = (*auras->begin())->GetId();
        }
        else
            m_bgData.MountSpellID = 0;

        // If map is dungeon find linked graveyard
        if (GetMap()->IsDungeon())
        {
            if (const WorldSafeLocsEntry* entry = sObjectMgr->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam()))
                m_bgData.JoinPosition = WorldLocation(entry->MapID, entry->Loc.X, entry->Loc.Y, entry->Loc.Z, 0.0f);
            else
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "SetBattlegroundEntryPoint: Dungeon map %u has no linked graveyard, setting home location as entry point.", GetMapId());
        }
        // If new entry point is not BG or arena set it
        else if (!GetMap()->IsBattlegroundOrArena())
            m_bgData.JoinPosition = WorldLocation(GetMapId(), GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation());
    }

    if (m_bgData.JoinPosition.m_mapId == MAPID_INVALID) // In error cases use homebind position
        m_bgData.JoinPosition = WorldLocation(m_homebindMapId, m_homebindX, m_homebindY, m_homebindZ, 0.0f);
}

void Player::SetBGTeam(uint32 team)
{
    m_bgData.BgTeam = team;
}

uint32 Player::GetBGTeam() const
{
    return m_bgData.BgTeam ? m_bgData.BgTeam : GetTeam();
}

TeamId Player::GetBGTeamId() const
{
    if (GetBGTeam() == ALLIANCE)
        return TEAM_ALLIANCE;

    if (GetBGTeam() == HORDE)
        return TEAM_HORDE;

    return TEAM_NEUTRAL;
}

uint16 Player::GetLastActiveSpec(bool lfgOrBg /*= false*/) const
{
    return lfgOrBg ? m_lastActiveLFGRole : m_bgData.LastActiveSpecID;
}

void Player::SaveLastSpecialization(bool lfgOrBg /*= false*/)
{
    if (!lfgOrBg)
        m_bgData.LastActiveSpecID = GetSpecializationId();
    else
        m_lastActiveLFGRole = GetSpecializationId();
}

void Player::LeaveBattleground(bool teleportToEntryPoint)
{
    Battleground* bg = GetBattleground();
    if (!bg)
        return;

    bg->RemovePlayerAtLeave(GetGUID(), teleportToEntryPoint, true);

    if (!IsSpectator() && !isGameMaster() && sWorld->getBoolConfig(CONFIG_BATTLEGROUND_CAST_DESERTER))
    {
        if (bg->IsBattleground())
        {
            if (bg->GetStatus() == STATUS_IN_PROGRESS || bg->GetStatus() == STATUS_WAIT_JOIN)
            {
                if (IsBeingTeleportedFar())
                {
                    ScheduleDelayedOperation(DELAYED_SPELL_CAST_DESERTER);
                    return;
                }

                CastSpell(this, SPELL_BG_DESERTER, true); // Deserter
            }
        }
        else if (bg->IsArena() && bg->GetJoinType() != MS::Battlegrounds::JoinType::Arena1v1 && !bg->IsWargame())
        {
            if (bg->GetStatus() == STATUS_IN_PROGRESS || bg->GetStatus() == STATUS_WAIT_JOIN || bg->GetRemainingTime() == Minutes(2))
                SendOperationsAfterDelay(OAD_ARENA_DESERTER);
        }
    }
}

bool Player::CanJoinToBattleground(uint8 pvpIternalType) const
{
    if (pvpIternalType >= MS::Battlegrounds::IternalPvpTypes::Max)
        return false;

    switch (pvpIternalType)
    {
        case MS::Battlegrounds::IternalPvpTypes::Brawl:
        case MS::Battlegrounds::IternalPvpTypes::Battleground:
            return !(HasAura(SPELL_BG_DESERTER));
        case MS::Battlegrounds::IternalPvpTypes::Arena:
        case MS::Battlegrounds::IternalPvpTypes::Skirmish:
            return !(HasAura(SPELL_BG_CRAVEN));
        // case ashran:
        // return !(HasAura(194958));
        default:
            return true;
    }
}

bool Player::CanReportAfkDueToLimit()
{
    // a player can complain about 15 people per 5 minutes
    if (m_bgData.BgAfkReportedCount++ >= 15)
        return false;

    return true;
}

void Player::ReportedAfkBy(Player* reporter)
{
    WorldPackets::Battleground::ReportPvPPlayerAFKResult reportAfkResult;
    reportAfkResult.Offender = GetGUID();
    Battleground* bg = GetBattleground();
    if (!bg || bg != reporter->GetBattleground() || GetTeam() != reporter->GetTeam() || bg->GetStatus() != STATUS_IN_PROGRESS)
    {
        reporter->SendDirectMessage(reportAfkResult.Write());
        return;
    }

    if (m_bgData.BgAfkReporter.find(reporter->GetGUIDLow()) == m_bgData.BgAfkReporter.end() && !HasAura(43680) && !HasAura(SPELL_BG_AURA_PLAYER_INACTIVE) && reporter->CanReportAfkDueToLimit())
    {
        m_bgData.BgAfkReporter.insert(reporter->GetGUIDLow());
        if (m_bgData.BgAfkReporter.size() >= 3)
        {
            CastSpell(this, 43680, true);
            reportAfkResult.NumBlackMarksOnOffender = m_bgData.BgAfkReporter.size();
            reportAfkResult.NumPlayersIHaveReported = reporter->m_bgData.BgAfkReportedCount;
            reportAfkResult.Result = WorldPackets::Battleground::ReportPvPPlayerAFKResult::PVP_REPORT_AFK_SUCCESS;

            m_bgData.BgAfkReporter.clear();
        }
    }

    reporter->SendDirectMessage(reportAfkResult.Write());
}

WorldLocation Player::GetStartPosition() const
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    uint32 mapId = info->mapId;
    if (getClass() == CLASS_DEATH_KNIGHT && IsQuestRewarded(13166))
        mapId = 0;
    return WorldLocation(mapId, info->positionX, info->positionY, info->positionZ, 0);
}

bool Player::IsNeverVisible(WorldObject const* /*seer*/) const
{
    if (Unit::IsNeverVisible())
        return true;

    if (GetSession()->PlayerLogout() || GetSession()->PlayerLoading())
        return true;

    return false;
}

bool Player::CanAlwaysSee(WorldObject const* obj) const
{
    // Always can see self
    if (m_mover == obj)
        return true;

    ObjectGuid guid = GetGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT);
    if (!guid.IsEmpty())
        if (obj->GetGUID() == guid)
            return true;

    return false;
}

bool Player::IsAlwaysDetectableFor(WorldObject const* seer) const
{
    if (Unit::IsAlwaysDetectableFor(seer))
        return true;

    if (const Player* seerPlayer = seer->ToPlayer())
        if (IsGroupVisibleFor(seerPlayer))
            return true;

     return false;
 }

bool Player::IsVisibleGloballyFor(Player const* u) const
{
    if (!u)
        return false;

    // Always can see self
    if (u == this)
        return true;

    AccountTypes security = u->GetSession()->GetSecurity();

    if (!security && m_ExtraFlags & PLAYER_EXTRA_INVISIBLE_STATUS)
        return false;

    // Visible units, always are visible for all players
    if (IsVisible())
        return true;

    // GMs are visible for higher gms (or players are visible for gms)
    if (!AccountMgr::IsPlayerAccount(u->GetSession()->GetSecurity()))
        return GetSession()->GetSecurity() <= security;

    // non faction visibility non-breakable for non-GMs
    if (!IsVisible())
        return false;

    // non-gm stealth/invisibility not hide from global player lists
    return true;
}

template<class T>
void UpdateVisibilityOf_helper(Player* p, T* target, std::set<Unit*>& /*v*/)
{
    p->AddClient(target->GetGUID());
}

template<>
inline void UpdateVisibilityOf_helper(Player* p, GameObject* target, std::set<Unit*>& /*v*/)
{
   p->AddClient(target->GetGUID());
}

template<>
inline void UpdateVisibilityOf_helper(Player* p, Creature* target, std::set<Unit*>& v)
{
    p->AddClient(target->GetGUID());
    v.insert(target);
}

template<>
inline void UpdateVisibilityOf_helper(Player* p, Player* target, std::set<Unit*>& v)
{
    p->AddClient(target->GetGUID());
    v.insert(target);
}

template<class T>
void BeforeVisibilityDestroy(T* /*t*/, Player* /*p*/)
{
}

template<>
inline void BeforeVisibilityDestroy<Creature>(Creature* t, Player* p)
{
    if (p->GetPetGUID() == t->GetGUID() && t->ToCreature()->isPet())
        ((Pet*)t)->Remove();
}

void Player::UpdateVisibilityOf(WorldObject* target)
{
    if (HaveAtClient(target))
    {
        if (!canSeeOrDetect(target, false, true))
        {
            if (Creature* creature = target->ToCreature())
            {
                BeforeVisibilityDestroy<Creature>(creature, this);
                if (creature->IsAIEnabled)
                    creature->AI()->RemoveClientVisibility(GetGUID());
            }

            target->DestroyForPlayer(this);
            RemoveClient(target->GetGUID());
            GetVignetteMgr().OnWorldObjectDisappear(target);

            #ifdef TRINITY_DEBUG
                TC_LOG_DEBUG(LOG_FILTER_MAPS, "Object %u (Type: %u) out of range for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), GetGUIDLow(), GetDistance(target));
            #endif
        }
    }
    else
    {
        if (canSeeOrDetect(target, false, true))
        {
            target->SendUpdateToPlayer(this);
            AddClient(target->GetGUID());

            if (Creature* creature = target->ToCreature())
                if (creature->IsAIEnabled)
                    creature->AI()->AddClientVisibility(GetGUID());

            GetVignetteMgr().OnWorldObjectAppear(target);

            #ifdef TRINITY_DEBUG
                TC_LOG_DEBUG(LOG_FILTER_MAPS, "Object %u (Type: %u) is visible now for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), GetGUIDLow(), GetDistance(target));
            #endif

            // target aura duration for caster show only if target exist at caster client
            // send data at target visibility change (adding to client)
            if (target->IsUnit())
                SendInitialVisiblePackets((Unit*)target);
        }
    }
}

void Player::UpdateTriggerVisibility()
{
    if (m_clientGUIDs.empty())
        return;

    if (!IsInWorld())
        return;

    UpdateData udata(GetMapId());
    WorldPacket packet;
    for (auto itr = m_clientGUIDs.begin(); itr != m_clientGUIDs.end(); ++itr)
    {
        if ((*itr).IsCreature())
        {
            Creature* obj = GetMap()->GetCreature(*itr);
            if (!obj || !(obj->isTrigger() || obj->HasAuraType(SPELL_AURA_TRANSFORM)))  // can transform into triggers
                continue;

            obj->SetFieldNotifyFlag(UF_FLAG_PUBLIC);
            obj->BuildValuesUpdateBlockForPlayer(&udata, this);
            obj->RemoveFieldNotifyFlag(UF_FLAG_PUBLIC);
        }
    }

    if (!udata.HasData())
        return;

    if (udata.BuildPacket(&packet))
        GetSession()->SendPacket(&packet);
}

void Player::UpdateCustomField()
{
    if (m_clientGUIDs.empty())
        return;

    if (!IsInWorld())
        return;

    needUpdateDynamicFlags = true;

    UpdateData udata(GetMapId());
    WorldPacket packet;
    for (auto itr = m_clientGUIDs.begin(); itr != m_clientGUIDs.end(); ++itr)
    {
        if ((*itr).IsUnit())
        {
            if (Unit* obj = ObjectAccessor::GetUnit(*this, *itr))
                obj->BuildValuesUpdateBlockForPlayer(&udata, this);
        }
    }

    needUpdateDynamicFlags = false;

    if (!udata.HasData())
        return;

    if (udata.BuildPacket(&packet))
        GetSession()->SendPacket(&packet);
}

void Player::SendInitialVisiblePackets(Unit* target)
{
    SendAurasForTarget(target);
    if (target->isAlive())
    {
        if (target->HasUnitState(UNIT_STATE_MELEE_ATTACKING) && target->getVictim())
            target->SendMeleeAttackStart(target->getVictim());
    }
}

template<class T>
void Player::UpdateVisibilityOf(T* target, UpdateData& data, std::set<Unit*>& visibleNow)
{
    if (HaveAtClient(target))
    {
        if (!canSeeOrDetect(target, false, true))
        {
            BeforeVisibilityDestroy<T>(target, this);

            if (Creature* creature = target->ToCreature())
                if (creature->IsAIEnabled)
                    creature->AI()->RemoveClientVisibility(GetGUID());

            target->BuildOutOfRangeUpdateBlock(&data);
            RemoveClient(target->GetGUID());
            GetVignetteMgr().OnWorldObjectDisappear(target);

            #ifdef TRINITY_DEBUG
                TC_LOG_DEBUG(LOG_FILTER_MAPS, "Object %u (Type: %u, Entry: %u) is out of range for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), target->GetEntry(), GetGUIDLow(), GetDistance(target));
            #endif
        }
    }
    else //if (visibleNow.size() < 30 || target->IsCreature() && target->ToCreature()->IsVehicle())
    {
        if (canSeeOrDetect(target, false, true))
        {
            if (Creature* creature = target->ToCreature())
                if (creature->IsAIEnabled)
                    creature->AI()->AddClientVisibility(GetGUID());

            target->BuildCreateUpdateBlockForPlayer(&data, this);
            UpdateVisibilityOf_helper(this, target, visibleNow);
            GetVignetteMgr().OnWorldObjectAppear(target);

            #ifdef TRINITY_DEBUG
                TC_LOG_DEBUG(LOG_FILTER_MAPS, "Object %u (Type: %u, Entry: %u) is visible now for player %u. Distance = %f", target->GetGUIDLow(), target->GetTypeId(), target->GetEntry(), GetGUIDLow(), GetDistance(target));
            #endif
        }
    }
}

template void Player::UpdateVisibilityOf(Player*        target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(Creature*      target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(Corpse*        target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(GameObject*    target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(DynamicObject* target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(AreaTrigger*   target, UpdateData& data, std::set<Unit*>& visibleNow);
template void Player::UpdateVisibilityOf(Conversation*  target, UpdateData& data, std::set<Unit*>& visibleNow);

void Player::UpdateVisibilityForPlayer()
{
    if (!m_seer)
        return;

    // updates visibility of all objects around point of view for current player
    Trinity::VisibleNotifier notifier(*this);
    notifier.AddMaxVisible();   // add global object, need first
    Trinity::VisitNearbyObject(m_seer, GetSightRange(), notifier);
    notifier.SendToSelf();   // send gathered data
}

void Player::InitPrimaryProfessions()
{
    SetFreePrimaryProfessions(sWorld->getIntConfig(CONFIG_MAX_PRIMARY_TRADE_SKILL));
}

uint64 Player::GetMoney() const
{
    return GetUInt64Value(PLAYER_FIELD_COINAGE);
}

bool Player::ModifyMoney(int64 amount, bool sendError /*= true*/)
{
    if (!amount)
        return true;

    sScriptMgr->OnPlayerMoneyChanged(this, amount);

    if (amount < 0)
        SetMoney (GetMoney() > uint64(-amount) ? GetMoney() + amount : 0);
    else
    {
        if (GetMoney() < MAX_MONEY_AMOUNT - static_cast<uint64>(amount))
            SetMoney(GetMoney() + amount);
        else
        {
            if (sendError)
                SendEquipError(EQUIP_ERR_TOO_MUCH_GOLD);
            return false;
        }
    }

    return true;
}

bool Player::HasEnoughMoney(uint64 amount) const
{
    return GetMoney() >= amount;
}

bool Player::HasEnoughMoney(int64 amount) const
{
    if (amount > 0)
        return (GetMoney() >= (uint64)amount);

    return true;
}

void Player::SetMoney(uint64 value)
{
    SetUInt64Value(PLAYER_FIELD_COINAGE, value);
    MoneyChanged(value);
    UpdateAchievementCriteria(CRITERIA_TYPE_HIGHEST_GOLD_VALUE_OWNED);
}

Unit* Player::GetSelectedUnit() const
{
    if (m_curSelection)
        return ObjectAccessor::GetUnit(*this, m_curSelection);
    return NULL;
}

Unit* Player::GetLastSelectedUnit() const
{
    if (m_lastSelection)
        return ObjectAccessor::GetUnit(*this, m_lastSelection);
    return NULL;
}


Player* Player::GetSelectedPlayer() const
{
    if (m_curSelection)
        return ObjectAccessor::GetPlayer(*this, m_curSelection);
    return NULL;
}

void Player::SetSelection(ObjectGuid const& guid)
{
    if (m_curSelection)
        m_lastSelection = m_curSelection;
    m_curSelection = guid;
    SetGuidValue(UNIT_FIELD_TARGET, guid);

    if (HaveSpectators())
    {
        SpectatorAddonMsg msg;
        msg.SetPlayer(GetGUID());
        msg.SetTarget(guid);
        SendSpectatorAddonMsgToBG(msg);
    }
}

void Player::SetGroup(Group* group, int8 subgroup)
{
    if (group == NULL)
        m_group.unlink();
    else
    {
        // never use SetGroup without a subgroup unless you specify NULL for group
        ASSERT(subgroup >= 0);
        m_group.link(group, this);
        m_group.setSubGroup((uint8)subgroup);
    }

    UpdateObjectVisibility(false);
}

void Player::SetPartyType(GroupCategory category, uint8 type)
{
    ASSERT(category < MAX_GROUP_CATEGORY);
    uint8 value = GetPartyTypeValue();
    value &= ~uint8(uint8(0xFF) << (category * 4));
    value |= uint8(uint8(type) << (category * 4));
    SetByteValue(PLAYER_FIELD_BYTES_3, PLAYER_BYTES_3_OFFSET_PARTY_TYPE, value);
    
    SetGroupUpdateFlag(GROUP_UPDATE_FLAG_OTHER_PARTY);
}

void Player::ResetGroupUpdateSequenceIfNeeded(Group const* group)
{
    GroupCategory category = group->GetGroupCategory();
    if (m_groupUpdateSequences[category].GroupGuid != group->GetGUID())
    {
        m_groupUpdateSequences[category].GroupGuid = group->GetGUID();
        m_groupUpdateSequences[category].UpdateSequenceNumber = 1;
    }
}

int32 Player::NextGroupUpdateSequenceNumber(GroupCategory category)
{
    return m_groupUpdateSequences[category].UpdateSequenceNumber++;
}

//! Before send self obj. update 
void Player::SendInitialPacketsBeforeAddToMap(bool login)
{
    m_zoneForce = true;
    GetZoneAndAreaId(m_zoneId, m_areaId);

    if (!(m_teleport_options & TELE_TO_SEAMLESS))
    {
        m_sequenceIndex = 0;
        ResetTimeSync();
    }

    SendTimeSync();

    if (login) // Don`t send when teleported
        GetSocial()->SendSocialList(this, SOCIAL_FLAG_ALL);

    SendCategoryCooldownMods();

    // guild bank list wtf?

    SendBindPointUpdate();

    SendSpellMods();

    SendTalentsInfoData(false);

    SendDirectMessage(WorldPackets::Spells::SendUnlearnSpells().Write());

    SendKnownSpells();
    SendSpellHistoryData();
    SendSpellChargeData();

    SendInitialActionButtons();

    // SendDirectMessage(WorldPackets::Misc::CorpseReclaimDelay().Write()); // if send this, buged ressurect timer

    if (login) // Don`t send when teleported
    {
        m_achievementMgr->SendAllAccountCriteriaData(this);
        m_reputationMgr.SendInitialReputations();

        SendCurrencies();

        LearnSpecializationSpells();
    }

    // Reset Vignitte data
    SendDirectMessage(WorldPackets::Update::VignetteUpdate(true).Write());

    if (login) // Don`t send when teleported
    {
        SendEquipmentSetList();
        uint32 speedtime = ((sWorld->GetGameTime() - sWorld->GetUptime()) + (sWorld->GetUptime()));
        m_achievementMgr->SendAllAchievementData(this);

        WorldPackets::Misc::LoginSetTimeSpeed loginSetTimeSpeed;
        loginSetTimeSpeed.NewSpeed = 0.01666667f;
        loginSetTimeSpeed.GameTime = speedtime;
        loginSetTimeSpeed.ServerTime = speedtime;
        SendDirectMessage(loginSetTimeSpeed.Write());
    }

    GetPhaseMgr().Recalculate();
    SendMountSpells();

    if (login) // Don`t send when teleported
    {
        WorldPackets::Toy::AccountToysUpdate toysUpdate;
        toysUpdate.IsFullUpdate = true;
        toysUpdate.Toys = &GetCollectionMgr()->GetAccountToys();
        SendDirectMessage(toysUpdate.Write());

        WorldPackets::Toy::AccountHeirloomUpdate heirloomUpdate;
        heirloomUpdate.IsFullUpdate = true;
        heirloomUpdate.Heirlooms = &GetCollectionMgr()->GetAccountHeirlooms();
        SendDirectMessage(heirloomUpdate.Write());
        
        GetCollectionMgr()->SendFavoriteAppearances();

        WorldPackets::Misc::SetAllTaskProgress taskProgress;
        taskProgress.Progress.clear();
        SendDirectMessage(taskProgress.Write());

        WorldPackets::Character::InitialSetup initialSetup;
        initialSetup.ServerExpansionLevel = CURRENT_EXPANSION;
        SendDirectMessage(initialSetup.Write());

        SendPvpRatedStats();
    }

    // First obj create should be with dynamic data
    if (GetSkillValue(SKILL_ARCHAEOLOGY) && sWorld->getBoolConfig(CONFIG_ARCHAEOLOGY_ENABLED))
        ShowResearchSites();

    if (login) // Don`t send when teleported
    {
        WorldPackets::Talent::ActiveGlyphs activeGlyphs;
        activeGlyphs.Glyphs.reserve(GetGlyphs(GetActiveTalentGroup()).size());
        for (uint32 glyphId : GetGlyphs(GetActiveTalentGroup()))
            if (std::vector<uint32> const* bindableSpells = sDB2Manager.GetGlyphBindableSpells(glyphId))
                for (uint32 bindableSpell : *bindableSpells)
                    if (HasSpell(bindableSpell) && m_overrideSpells.find(bindableSpell) == m_overrideSpells.end())
                        activeGlyphs.Glyphs.emplace_back(uint32(bindableSpell), uint16(glyphId));

        activeGlyphs.IsFullUpdate = true;
        SendDirectMessage(activeGlyphs.Write());
    }
}

//! After send self obj. update 
void Player::SendInitialPacketsAfterAddToMap(bool login)
{
    // update zone
    uint32 newzone, newarea;
    GetZoneAndAreaId(newzone, newarea);
    UpdateZone(newzone, newarea);                            // also call SendInitWorldStates();

    if (GetInstanceId())
    {
        SendDirectMessage(WorldPackets::Instance::NullSmsg(SMSG_INSTANCE_ENCOUNTER_END).Write());
        SendDirectMessage(WorldPackets::Instance::NullSmsg(SMSG_INSTANCE_ENCOUNTER_PHASE_SHIFT_CHANGED).Write());
    }

    SendDirectMessage(WorldPackets::WorldState::StartElapsedTimers().Write());

    WorldPackets::Misc::WorldServerInfo worldServerInfo;
    worldServerInfo.DifficultyID = GetMap()->GetDifficultyID();
    //worldServerInfo.XRealmPvpAlert = false;
    //worldServerInfo.RestrictedAccountMaxLevel;
    //worldServerInfo.RestrictedAccountMaxMoney;
    worldServerInfo.InstanceGroupSize = GetMap()->GetMapDifficulty() ? GetMap()->GetMapDifficulty()->MaxPlayers : 0;
    //worldServerInfo.IsTournamentRealm = 0;
    SendDirectMessage(worldServerInfo.Write());

    CastSpell(this, 836, false);                             // LOGINEFFECT

    // set some aura effects that send packet to player client after add player to map
    // SendMessageToSet not send it to player not it map, only for aura that not changed anything at re-apply
    // same auras state lost at far teleport, send it one more time in this case also
    static const AuraType auratypes[] =
    {
        SPELL_AURA_MOD_FEAR,     SPELL_AURA_TRANSFORM,                 SPELL_AURA_WATER_WALK,
        SPELL_AURA_FEATHER_FALL, SPELL_AURA_HOVER,                     SPELL_AURA_SAFE_FALL,
        SPELL_AURA_FLY,          SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED, SPELL_AURA_NONE
    };
    for (AuraType const* itr = &auratypes[0]; itr && itr[0] != SPELL_AURA_NONE; ++itr)
    {
        if (Unit::AuraEffectList const* auraList = GetAuraEffectsByType(*itr))
            if (auraList->begin() != auraList->end())
                (*auraList->begin())->HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true);
    }

    if (HasAuraType(SPELL_AURA_MOD_STUN))
        SetRooted(true);

    WorldPackets::Movement::MoveSetCompoundState setCompoundState;
    // manual send package (have code in HandleEffect(this, AURA_EFFECT_HANDLE_SEND_FOR_CLIENT, true); that must not be re-applied.
    if (HasAuraType(SPELL_AURA_MOD_ROOT) || HasAuraType(SPELL_AURA_MOD_ROOTED))
        setCompoundState.StateChanges.emplace_back(SMSG_MOVE_ROOT, m_sequenceIndex++);

    if (HasAuraType(SPELL_AURA_FEATHER_FALL))
        setCompoundState.StateChanges.emplace_back(SMSG_MOVE_SET_FEATHER_FALL, m_sequenceIndex++);

    if (HasAuraType(SPELL_AURA_WATER_WALK))
        setCompoundState.StateChanges.emplace_back(SMSG_MOVE_SET_WATER_WALK, m_sequenceIndex++);

    if (HasAuraType(SPELL_AURA_HOVER))
        setCompoundState.StateChanges.emplace_back(SMSG_MOVE_SET_HOVERING, m_sequenceIndex++);

    if (HasAuraType(SPELL_AURA_CAN_TURN_WHILE_FALLING))
        setCompoundState.StateChanges.emplace_back(SMSG_MOVE_SET_CAN_TURN_WHILE_FALLING, m_sequenceIndex++);

    if (HasAura(SPELL_DH_DOUBLE_JUMP))
        setCompoundState.StateChanges.emplace_back(SMSG_MOVE_ENABLE_DOUBLE_JUMP, m_sequenceIndex++);

    if (!setCompoundState.StateChanges.empty())
    {
        setCompoundState.MoverGUID = GetGUID();
        SendDirectMessage(setCompoundState.Write());
    }

    ApplyWargameItemModifications();

    SendAurasForTarget(this);
    SendEnchantmentDurations();                             // must be after add to map
    SendItemDurations();                                    // must be after add to map

    // raid downscaling - send difficulty to player
    if (GetMap()->IsRaid())
    {
        m_prevMapDifficulty = GetMap()->GetDifficultyID();
        DifficultyEntry const* difficulty = sDifficultyStore.AssertEntry(m_prevMapDifficulty);
        SendRaidDifficulty((difficulty->Flags & DIFFICULTY_FLAG_LEGACY) != 0, m_prevMapDifficulty);
    }
    else if (GetMap()->IsNonRaidDungeon())
    {
        m_prevMapDifficulty = GetMap()->GetDifficultyID();
        SendDungeonDifficulty(m_prevMapDifficulty);
    }
    else if (!GetMap()->Instanceable())
    {
        // DifficultyEntry const* difficulty = sDifficultyStore.AssertEntry(m_prevMapDifficulty);
        // SendRaidDifficulty((difficulty->Flags & DIFFICULTY_FLAG_LEGACY) != 0);
        // When login in game sand all difficulty
        SendRaidDifficulty(true);
        SendRaidDifficulty(false);
    }

    GetSession()->SendBattlePetJournal();

    if (_garrison)
        _garrison->SendRemoteInfo();

    if (getClass() == CLASS_DEATH_KNIGHT)
        SetPower(POWER_RUNIC_POWER, 0);

    GetSession()->SendStablePet();

    InstanceMap* inst = GetMap()->ToInstanceMap();
    // send step data when entering scenarios
    if (uint32 instanceId = inst && InInstance() ? inst->GetInstanceId() : 0)
        if (Scenario* progress = sScenarioMgr->GetScenario(instanceId))
            progress->SendStepUpdate(this, true);

    SetMover(this);

    if (login)
    {
        ContinueTaxiFlight();

        // Send CUF profiles (new raid UI 4.2)
        GetSession()->SendLoadCUFProfiles();
    }

    sLFGMgr->StartAllOtherQueue(GetGUID(), 0);
    SendLfgUpdatePlayer();

    sLFGListMgr->OnPlayerLogin(this);
}

void Player::SendSpellHistoryData()
{
    time_t curTime = time(NULL);
    time_t infTime = curTime + infinityCooldownDelayCheck;

    WorldPackets::Spells::SendSpellHistory history;
    history.Entries.reserve(m_spellCooldowns.size());
    WorldPackets::Spells::SpellHistoryEntry entryData;

    for (SpellCooldowns::iterator itr = m_spellCooldowns.begin(); itr != m_spellCooldowns.end(); ++itr)
    {
        SpellInfo const *info = sSpellMgr->GetSpellInfo(itr->first);
        if (!info)
            continue;

        time_t cooldown = itr->second.end > curTime ? (itr->second.end - curTime) * IN_MILLISECONDS : 0;

        entryData.SpellID = itr->first;
        entryData.ItemID = itr->second.itemid;
        entryData.Category = info->Categories.Category;
        entryData.RecoveryTime = cooldown;
        entryData.CategoryRecoveryTime = cooldown;
        entryData.OnHold = itr->second.end >= infTime;
        history.Entries.push_back(entryData);
    }

    SendDirectMessage(history.Write());
}

void Player::SendSpellChargeData()
{
    WorldPackets::Spells::SendSpellCharges charges;
    WorldPackets::Spells::SpellChargeEntry entry;
    charges.Entries.reserve(m_spellChargeData.size());

    for (SpellChargeDataMap::const_iterator itr = m_spellChargeData.begin(); itr != m_spellChargeData.end(); ++itr)
    {
        SpellChargeData const& chargeData = itr->second;
        int32 diff = int32(chargeData.categoryEntry->ChargeRecoveryTime) - int32(chargeData.timer);
        if (diff < 0)
            diff = 0;

        entry.Category = itr->first;
        entry.NextRecoveryTime = chargeData.charges != chargeData.maxCharges ? diff : 0;
        entry.ConsumedCharges = chargeData.maxCharges - chargeData.charges;

        charges.Entries.push_back(entry);
    }

    SendDirectMessage(charges.Write());
}

void Player::SendUpdateToOutOfRangeGroupMembers()
{
    if (m_groupUpdateMask == GROUP_UPDATE_FLAG_NONE)
        return;

    if (Group* group = GetGroup())
        group->UpdatePlayerOutOfRange(this);

    m_groupUpdateMask = GROUP_UPDATE_FLAG_NONE;

    if (Pet* pet = GetPet())
        pet->ResetGroupUpdateFlag();
}

void Player::SendTransferAborted(uint32 mapID, TransferAbortReason reason, uint8 arg)
{
    WorldPackets::Movement::TransferAborted aborted;
    aborted.TransfertAbort = reason;
    aborted.Arg = arg;
    aborted.MapID = mapID;
    SendDirectMessage(aborted.Write());
}

void Player::SendInstanceResetWarning(uint32 mapid, Difficulty difficulty, uint32 time)
{
    // type of warning, based on the time remaining until reset
    uint32 type;
    if (time > 3600)
        type = RAID_INSTANCE_WELCOME;
    else if (time > 900 && time <= 3600)
        type = RAID_INSTANCE_WARNING_HOURS;
    else if (time > 300 && time <= 900)
        type = RAID_INSTANCE_WARNING_MIN;
    else
        type = RAID_INSTANCE_WARNING_MIN_SOON;

    WorldPackets::Instance::RaidInstanceMessage message;
    message.Type = type;
    message.MapID = mapid;
    message.DifficultyID = difficulty;
    message.Extended = false;
    if (InstancePlayerBind const* bind = GetBoundInstance(mapid, difficulty))
    {
        if (InstanceSave* pSave = bind->save)
            message.Extended = pSave->GetExtended();
        if (!message.Extended)
            message.Locked = bind->perm;
    }
    SendDirectMessage(message.Write());
}

void Player::SetItemCooldown(Item* pItem, uint32 cooldown)
{
    if (pItem->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_NO_EQUIP_COOLDOWN))
        return;

    for (ItemEffectEntry const* effectData : pItem->GetTemplate()->Effects)
    {
        if (effectData->TriggerType != ITEM_SPELLTRIGGER_ON_USE)
            continue;

        AddSpellCooldown(effectData->SpellID, pItem->GetEntry(), getPreciseTime() + cooldown);

        WorldPackets::Item::ItemCooldown data;
        data.ItemGuid = pItem->GetGUID();
        data.SpellID = effectData->SpellID;
        data.Cooldown = cooldown * IN_MILLISECONDS;
        SendDirectMessage(data.Write());
    }
}

void Player::resetSpells()
{
    // not need after this call
    if (HasAtLoginFlag(AT_LOGIN_RESET_SPELLS))
        RemoveAtLoginFlag(AT_LOGIN_RESET_SPELLS, true);

    for (PlayerSpellMap::iterator iter = m_spells.begin(); iter != m_spells.end(); ++iter)
    {
        bool isSkill = false;
        SkillLineAbilityMapBounds spellBounds = sSpellMgr->GetSkillLineAbilityMapBounds(iter->first);
        for (SkillLineAbilityMap::const_iterator spell_idx = spellBounds.first; spell_idx != spellBounds.second; ++spell_idx)
        {
            uint32 skill = spell_idx->second->SkillLine;
            if (skill == SKILL_ALL_GUILD_PERKS || IsProfessionOrRidingSkill(skill))
            {
                isSkill = true;
                break;
            }
        }

        if (!isSkill)
            removeSpell(iter->first, false, false);           // only iter->first can be accessed, object by iter->second can be deleted already
    }

    LearnDefaultSkills();
    LearnDefaultSpells();
    learnQuestRewardedSpells();
    UpdateSkillsForLevel();
}

void Player::UpdateSkillsForLevel()
{
    // GetMaxSkillValueForLevel seems deprecated... but need more extensive research
    uint32 maxSkill = GetMaxSkillValueForLevel();

    for (SkillStatusMap::iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end(); ++itr)
    {
        if (itr->second.uState == SKILL_DELETED)
            continue;

        uint32 pskill = itr->first;
        SkillRaceClassInfoEntry const* rcEntry = sDB2Manager.GetSkillRaceClassInfo(pskill, getRace(), getClass());
        if (!rcEntry)
            continue;

        uint16 field = itr->second.pos / 2;
        uint8 offset = itr->second.pos & 1; // itr->second.pos % 2

        if (GetSkillRangeType(rcEntry) == SKILL_RANGE_LEVEL)
        {
            if (!IsWeaponSkill(rcEntry->SkillID))
            {
                uint16 max = GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset);

                /// update only level dependent max skill values
                if (max != 1)
                {
                    SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, maxSkill);
                    SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, maxSkill);
                    if (itr->second.uState != SKILL_NEW)
                        itr->second.uState = SKILL_CHANGED;
                }
            }
        }

        //// Update level dependent skillline spells
        learnSkillRewardedSpells(rcEntry->SkillID, GetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset));
    }
}

void Player::LearnDefaultSkills()
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    for (PlayerCreateInfoSkills::const_iterator itr = info->skills.begin(); itr != info->skills.end(); ++itr)
    {
        SkillRaceClassInfoEntry const* rcInfo = *itr;
        if (HasSkill(rcInfo->SkillID))
            continue;

        if (rcInfo->MinLevel > getLevel())
            continue;

        LearnDefaultSkill(rcInfo);
    }

    // is this really needed?
    if (getRace() == RACE_WORGEN && GetMapId() != 654)
    {
        learnSpell(68975, true);
        learnSpell(68976, true);
        learnSpell(68978, true);
        learnSpell(68992, true);
        learnSpell(68996, true);
        learnSpell(94293, true);
    }
}

void Player::LearnDefaultSpells()
{
    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
    for (PlayerCreateInfoSpells::const_iterator itr = info->spell.begin(); itr != info->spell.end(); ++itr)
    {
        if (HasSpell(*itr))
            continue;

        learnSpell(*itr, true);
    }
    if (PlayerInfo const* allInfo = sObjectMgr->GetPlayerInfo(RACE_NONE, CLASS_NONE))
    {
        for (PlayerCreateInfoSpells::const_iterator itr = allInfo->spell.begin(); itr != allInfo->spell.end(); ++itr)
        {
            if (HasSpell(*itr))
                continue;

            learnSpell(*itr, true);
        }
    }
}

void Player::LearnDefaultSkill(SkillRaceClassInfoEntry const* rcInfo)
{
    uint16 skillId = rcInfo->SkillID;
    switch (GetSkillRangeType(rcInfo))
    {
        case SKILL_RANGE_LANGUAGE:
            SetSkill(skillId, 0, 300, 300);
            break;
        case SKILL_RANGE_LEVEL:
        {
            uint16 skillValue = 1;
            uint16 maxValue = GetMaxSkillValueForLevel();
            if (rcInfo->Flags & SKILL_FLAG_ALWAYS_MAX_VALUE)
                skillValue = maxValue;
            else if (getClass() == CLASS_DEATH_KNIGHT || getClass() == CLASS_DEMON_HUNTER)
                skillValue = std::min(std::max<uint16>({ 1, uint16((getLevel() - 1) * 5) }), maxValue);
            else if (skillId == SKILL_FIST_WEAPONS)
                skillValue = std::max<uint16>(1, GetSkillValue(SKILL_UNARMED));
            else if (skillId == SKILL_LOCKPICKING)
                skillValue = std::max<uint16>(1, GetSkillValue(SKILL_LOCKPICKING));

            SetSkill(skillId, 0, skillValue, maxValue);
            break;
        }
        case SKILL_RANGE_MONO:
            SetSkill(skillId, 0, 1, 1);
            break;
        case SKILL_RANGE_RANK:
        {
            uint16 rank = 1;
            if (getClass() == CLASS_DEATH_KNIGHT && skillId == SKILL_FIRST_AID)
                rank = 4;

            SkillTiersEntry const* tier = sObjectMgr->GetSkillTier(rcInfo->SkillTierID);
            uint16 maxValue = tier->Value[std::max<int32>(rank - 1, 0)];
            uint16 skillValue = 1;
            uint16 skillmaxval = GetPureMaxSkillValue(skillId);
            if (skillmaxval > maxValue)
                maxValue = skillmaxval;

            if (rcInfo->Flags & SKILL_FLAG_ALWAYS_MAX_VALUE)
                skillValue = maxValue;
            else if (getClass() == CLASS_DEATH_KNIGHT)
                skillValue = std::min(std::max(uint16(1), uint16((getLevel() - 1) * 5)), maxValue);

            SetSkill(skillId, rank, skillValue, maxValue);
            break;
        }
        default:
            break;
    }
}

void Player::learnQuestRewardedSpells(Quest const* quest)
{
    if (!quest->RewardSpell)
        return;

    // if RewSpellCast = -1 we remove aura do to SrcSpell from player.
    if (quest->RewardSpell == -1 && quest->SourceSpellID)
    {
        RemoveAurasDueToSpell(quest->SourceSpellID);
        return;
    }

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(quest->RewardSpell);
    if (!spellInfo)
        return;

    // check learned spells state
    bool found = false;
    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
    {
        if (spellInfo->EffectMask < uint32(1 << i))
            break;

        if (spellInfo->Effects[i]->Effect == SPELL_EFFECT_LEARN_SPELL && !HasSpell(spellInfo->Effects[i]->TriggerSpell))
        {
            found = true;
            break;
        }
    }

    // skip quests with not teaching spell or already known spell
    if (!found)
        return;

    // prevent learn non first rank unknown profession and second specialization for same profession)
    uint32 learned_0 = spellInfo->Effects[0]->TriggerSpell;
    if (sSpellMgr->GetSpellRank(learned_0) > 1 && !HasSpell(learned_0))
    {
        // not have first rank learned (unlearned prof?)
        uint32 first_spell = sSpellMgr->GetFirstSpellInChain(learned_0);
        if (!HasSpell(first_spell))
            return;

        SpellInfo const* learnedInfo = sSpellMgr->GetSpellInfo(learned_0);
        if (!learnedInfo)
            return;

        for (auto const& requirePair : sSpellMgr->GetSpellsRequiredForSpellBounds(learned_0))
        {
            uint32 profSpell = requirePair.second;

            // specialization
            if (learnedInfo->Effects[0]->Effect == SPELL_EFFECT_TRADE_SKILL && learnedInfo->Effects[1]->Effect == 0 && profSpell)
            {
                // search other specialization for same prof
                for (PlayerSpellMap::iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
                {
                    PlayerSpell* spellPtr_ = &itr->second;
                    if (!spellPtr_ || spellPtr_->state == PLAYERSPELL_REMOVED || itr->first == learned_0)
                        continue;

                    SpellInfo const* itrInfo = sSpellMgr->GetSpellInfo(itr->first);
                    if (!itrInfo)
                        return;

                    // compare only specializations
                    if (itrInfo->Effects[0]->Effect != SPELL_EFFECT_TRADE_SKILL || itrInfo->Effects[1]->Effect != 0)
                        continue;

                    // compare same chain spells
                    if (sSpellMgr->IsSpellRequiringSpell(itr->first, profSpell))
                        return;
                }
            }
        }
    }

    // skill requeare
    SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(learned_0);
    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
    {
        SkillLineEntry const* pSkill = sSkillLineStore.LookupEntry(_spell_idx->second->SkillLine);
        if (!pSkill)
            continue;

        if (!HasSkill(_spell_idx->second->SkillLine))
            return;
    }

    CastSpell(this, quest->RewardSpell, true);
}

void Player::learnQuestRewardedSpells()
{
    // learn spells received from quest completing
    for (RewardedQuestSet::const_iterator itr = m_RewardedQuests.begin(); itr != m_RewardedQuests.end(); ++itr)
    {
        Quest const* quest = sQuestDataStore->GetQuestTemplate(*itr);
        if (!quest)
            continue;

        learnQuestRewardedSpells(quest);
    }
}

void Player::learnSkillRewardedSpells(uint32 skillId, uint32 skillValue)
{
    // bad hack to work around data being suited only for the client - AcquireMethod == SKILL_LINE_ABILITY_LEARNED_ON_SKILL_LEARN for riding client uses it to show riding in spellbook as trainable
    if (skillId == SKILL_RIDING)
        return;

    uint64 raceMask  = getRaceMask();
    uint32 classMask = getClassMask();
    for (SkillLineAbilityEntry const* ability : sDB2Manager._skillLineAbilityContainer[skillId])
    {
        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(ability->Spell);
        if (!spellInfo)
            continue;

        if (HasSpell(spellInfo->Id))
            continue;

        if (ability->AcquireMethod != SKILL_LINE_ABILITY_LEARNED_ON_SKILL_VALUE && ability->AcquireMethod != SKILL_LINE_ABILITY_LEARNED_ON_SKILL_LEARN && ability->AcquireMethod != SKILL_LINE_ABILITY_NOT_AUTO_LEARN)
            continue;

        if (ability->AcquireMethod == SKILL_LINE_ABILITY_NOT_AUTO_LEARN)
        {
            //First Aid in Draenor don't learning misc spells
            if (skillId == SKILL_FIRST_AID || (skillId == SKILL_DEMON_HUNTER && IsLoXpMap(GetMapId())))
                continue;
        }
        else
        {
            if (ability->RaceMask && !(ability->RaceMask & raceMask))
                continue;

            if (ability->ClassMask && !(ability->ClassMask & classMask))
                continue;
        }

        // check level, skip class spells if not high enough
        if (getLevel() < spellInfo->SpellLevel)
            continue;

        // need unlearn spell
        if (skillValue < ability->MinSkillLineRank && ability->AcquireMethod == SKILL_LINE_ABILITY_LEARNED_ON_SKILL_VALUE)
            removeSpell(ability->Spell);
        // need learn
        else if (!IsInWorld())
            addSpell(ability->Spell, true, true, true, false, false, ability->SkillLine);
        else
            learnSpell(ability->Spell, true, ability->SkillLine);
    }
}

void Player::SendAurasForTarget(Unit* target)
{
    if (!target || target->GetVisibleAuras().empty()) // speedup things
        return;

    Unit::VisibleAuraContainer const& visibleAuras = target->GetVisibleAuras();

    WorldPackets::Spells::AuraUpdate update;
    update.UpdateAll = true;
    update.UnitGUID = target->GetGUID();
    update.Auras.reserve(visibleAuras.size());

    WorldPackets::Spells::LossOfControlAuraUpdate lossOfControl;
    lossOfControl.TargetGuid = target->GetGUID();

    for (AuraApplication* auraApp : visibleAuras)
    {
        WorldPackets::Spells::AuraInfo auraInfo;
        auraApp->BuildUpdatePacket(auraInfo, false);
        auraApp->BuildLossOfControlPacket(lossOfControl);
        update.Auras.push_back(auraInfo);

        if (auto stream = target->ToPlayer())
            if (stream->HaveSpectators() && IsSpectator())
                if (auto aura = auraApp->GetBase())
                {
                    SpectatorAddonMsg msg;
                    ObjectGuid casterID;
                    if (aura->GetCaster() && aura->GetCaster()->IsPlayer())
                        casterID = aura->GetCaster()->GetGUID();
                    msg.SetPlayer(stream->GetGUID());
                    msg.CreateAura(casterID, aura->GetSpellInfo()->Id, aura->GetSpellInfo()->IsPositive(), 0/*aura->GetSpellInfo()->Dispel*/, aura->GetDuration(), aura->GetMaxDuration(), aura->GetStackAmount(), false);
                    msg.SendPacket(GetGUID());
                }
    }

    SendDirectMessage(update.Write());
    if (target == this && !lossOfControl.Infos.empty())
    {
        WorldPacket data = *lossOfControl.Write();
        AddDelayedEvent(10, [target, data]() -> void { if (target) target->ToPlayer()->SendDirectMessage(&data); });
    }
}

void Player::SetDailyQuestStatus(uint32 quest_id)
{
    if (Quest const* qQuest = sQuestDataStore->GetQuestTemplate(quest_id))
    {
        if (!qQuest->IsDFQuest())
        {
            if (m_dailyquests.find(quest_id) == m_dailyquests.end())
            {
                m_dailyquests.insert(quest_id);
                m_lastDailyQuestTime = time(NULL);              // last daily quest time
                m_DailyQuestChanged = true;
            }
        }
        else
        {
            m_DFQuests.insert(quest_id);
            m_lastDailyQuestTime = time(NULL);
            m_DailyQuestChanged = true;
        }
    }
}

void Player::SetWeeklyQuestStatus(uint32 quest_id)
{
    m_weeklyquests.insert(quest_id);
    m_weeklyquestSaves.insert(quest_id);
    m_WeeklyQuestChanged = true;
}

void Player::SetSeasonalQuestStatus(uint32 quest_id)
{
    Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
    if (!quest)
        return;

    m_seasonalquests[sGameEventMgr->GetEventIdForQuest(quest)].insert(quest_id);
    m_seasonalquestSaves[sGameEventMgr->GetEventIdForQuest(quest)].insert(quest_id);
    m_SeasonalQuestChanged = true;
}

void Player::DailyReset()
{
    for (uint32 questId : GetDynamicValues(PLAYER_DYNAMIC_FIELD_DAILY_QUESTS_COMPLETED))
        SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(questId), false);

    ClearDynamicValue(PLAYER_DYNAMIC_FIELD_DAILY_QUESTS_COMPLETED);

    m_dailyquests.clear();
    m_DFQuests.clear(); // Dungeon Finder Quests.

    // DB data deleted in caller
    m_DailyQuestChanged = false;
    m_lastDailyQuestTime = 0;

    if (_garrison)
        _garrison->ResetFollowerActivationLimit();
}

void Player::ResetWeeklyQuestStatus()
{
    if (m_weeklyquests.empty())
        return;

    for (uint32 questId : m_weeklyquests)
        SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(questId), false);

    m_weeklyquests.clear();
    m_weeklyquestSaves.clear();
    // DB data deleted in caller
    m_WeeklyQuestChanged = false;
}

void Player::ResetSeasonalQuestStatus(uint16 event_id)
{
    auto eventItr = m_seasonalquests.find(event_id);
    if (eventItr == m_seasonalquests.end())
        return;

    if (eventItr->second.empty())
        return;

    for (uint32 questId : eventItr->second)
        SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(questId), false);

    m_seasonalquests.erase(eventItr);
    // DB data deleted in caller
    m_SeasonalQuestChanged = false;
}

/*void Player::ResetMonthlyQuestStatus()
{
    if (m_monthlyquests.empty())
        return;

    for (uint32 questId : m_monthlyquests)
        SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(questId), false);

    m_monthlyquests.clear();
    // DB data deleted in caller
    m_MonthlyQuestChanged = false;
}*/

Battleground* Player::GetBattleground() const
{
    if (GetBattlegroundId() == 0)
        return NULL;

    return sBattlegroundMgr->GetBattleground(GetBattlegroundId(), m_bgData.BgTypeID);
}

uint32 Player::GetBattlegroundQueueJoinTime(uint8 bgQueueTypeId) const
{
    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == bgQueueTypeId)
            return m_bgBattlegroundQueueID[i].joinTime;
    return 0;
}

bool Player::InBattlegroundQueue() const
{
    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId != MS::Battlegrounds::BattlegroundQueueTypeId::None)
            return true;

    return false;
}

uint8 Player::GetBattlegroundQueueTypeId(uint32 index) const
{
    return m_bgBattlegroundQueueID[index].bgQueueTypeId;
}

uint32 Player::GetBattlegroundQueueIndex(uint8 bgQueueTypeId) const
{
    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == bgQueueTypeId)
            return i;

    return PLAYER_MAX_BATTLEGROUND_QUEUES;
}

bool Player::IsInvitedForBattlegroundQueueType(uint8 bgQueueTypeId) const
{
    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == bgQueueTypeId)
            return m_bgBattlegroundQueueID[i].invitedToInstance != 0;

    return false;
}

bool Player::InBattlegroundQueueForBattlegroundQueueType(uint8 bgQueueTypeId) const
{
    return GetBattlegroundQueueIndex(bgQueueTypeId) < PLAYER_MAX_BATTLEGROUND_QUEUES;
}

uint32 Player::AddBattlegroundQueueId(uint8 bgTypeId)
{
    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
    {
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == MS::Battlegrounds::BattlegroundQueueTypeId::None || m_bgBattlegroundQueueID[i].bgQueueTypeId == bgTypeId)
        {
            m_bgBattlegroundQueueID[i].bgQueueTypeId = bgTypeId;
            m_bgBattlegroundQueueID[i].invitedToInstance = 0;
            m_bgBattlegroundQueueID[i].joinTime = time(nullptr);
            return i;
        }
    }

    return PLAYER_MAX_BATTLEGROUND_QUEUES;
}

bool Player::HasFreeBattlegroundQueueId()
{
    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == MS::Battlegrounds::BattlegroundQueueTypeId::None)
            return true;

    return false;
}

void Player::RemoveBattlegroundQueueId(uint8 bgQueueTypeId)
{
    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
    {
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == bgQueueTypeId)
        {
            m_bgBattlegroundQueueID[i].bgQueueTypeId = MS::Battlegrounds::BattlegroundQueueTypeId::None;
            m_bgBattlegroundQueueID[i].invitedToInstance = 0;
            m_bgBattlegroundQueueID[i].joinTime = 0;
            return;
        }
    }
}

void Player::SetInviteForBattlegroundQueueType(uint8 bgQueueTypeId, uint32 instanceId)
{
    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].bgQueueTypeId == bgQueueTypeId)
            m_bgBattlegroundQueueID[i].invitedToInstance = instanceId;
}

bool Player::IsInvitedForBattlegroundInstance(uint32 instanceId) const
{
    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
        if (m_bgBattlegroundQueueID[i].invitedToInstance == instanceId)
            return true;

    return false;
}

WorldLocation const& Player::GetBattlegroundEntryPoint() const
{
    return m_bgData.JoinPosition;
}

bool Player::InBattleground() const
{
    return m_bgData.BgInstanceID != 0;
}

bool Player::InArena() const
{
    Battleground* bg = GetBattleground();
    if (!bg || !bg->IsArena())
        return false;

    return true;
}

bool Player::HasTournamentRules() const
{
    if (Battleground* bg = GetBattleground())
        return bg->UseTournamentRules();

    return false;
}

bool Player::InRBG() const
{
    Battleground* bg = GetBattleground();
    if (!bg || !bg->IsRBG())
        return false;

    return true;
}

uint32 Player::GetBattlegroundId()  const
{
    return m_bgData.BgInstanceID;
}

uint16 Player::GetBattlegroundTypeId() const
{
    return m_bgData.BgTypeID;
}

bool Player::InTournaments() const
{
    return InBattleground() && GetBattleground() && GetBattleground()->UseTournamentRules();
}

void Player::SetCrowdControlSpellId(uint32 spellId)
{
    m_crowdControlSpellId = spellId;
}

uint32 Player::GetCrowdControlSpellId() const
{
    return m_crowdControlSpellId;
}

void Player::SendMessageToPlayer(const char * format /*std::ostringstream ss_info.str().c_str()*/)
{
    ChatHandler(this).PSendSysMessage(format);
}

bool Player::GetBGAccessByLevel(uint16 bgTypeId) const
{
    // get a template bg instead of running one
    Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(bgTypeId);
    if (!bg)
        return false;

    // limit check leel to dbc compatible level range
    uint32 level = getLevel();
    if (level > MAX_LEVEL)
        level = MAX_LEVEL;

    if (level < bg->GetMinLevel() || level > bg->GetMaxLevel())
        return false;

    return true;
}

float Player::GetReputationPriceDiscount(Creature const* creature) const
{
    FactionTemplateEntry const* vendor_faction = creature->getFactionTemplateEntry();
    if (!vendor_faction || !vendor_faction->Faction)
        return 1.0f;

    ReputationRank rank = GetReputationRank(vendor_faction->Faction);
    if (rank <= REP_NEUTRAL)
        return 1.0f;

    return 1.0f - 0.05f* (rank - REP_NEUTRAL);
}

Player* Player::GetTrader() const
{
    return m_trade ? m_trade->GetTrader() : NULL;
}

TradeData* Player::GetTradeData() const
{
    return m_trade;
}

bool Player::IsSpellFitByClassAndRace(uint32 spell_id) const
{
    uint64 racemask  = getRaceMask();
    uint32 classmask = getClassMask();

    SkillLineAbilityMapBounds bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spell_id);
    if (bounds.first == bounds.second)
        return true;

    for (SkillLineAbilityMap::const_iterator _spell_idx = bounds.first; _spell_idx != bounds.second; ++_spell_idx)
    {
        // skip wrong race skills
        if (_spell_idx->second->RaceMask && (_spell_idx->second->RaceMask & racemask) == 0)
            continue;

        // skip wrong class skills
        if (_spell_idx->second->ClassMask && (_spell_idx->second->ClassMask & classmask) == 0)
            continue;

        return true;
    }

    return false;
}

bool Player::HasQuestForGO(int32 GOId) const
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        QuestStatusData const* qs = const_cast<Player*>(this)->getQuestStatus(questid);
        if (!qs)
            continue;

        if (qs->Status == QUEST_STATUS_INCOMPLETE)
        {
            Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid);
            if (!qInfo)
                continue;

            if (GetGroup() && GetGroup()->isRaidGroup() && !qInfo->IsAllowedInRaid(GetMap()->GetDifficultyID()))
                continue;

            for (QuestObjective const& obj : qInfo->GetObjectives())
            {
                if (obj.Type != QUEST_OBJECTIVE_GAMEOBJECT) //skip non GO case
                    continue;

                if (GOId == obj.ObjectID && GetQuestObjectiveData(qInfo, obj.StorageIndex) < obj.Amount)
                    return true;
            }
        }
    }
    return false;
}

void Player::UpdateForQuestWorldObjects()
{
    if (m_clientGUIDs.empty())
        return;

    bool buildUpdateBlock = false;

    UpdateData udata(GetMapId());
    WorldPacket packet;
    for (GuidSet::const_iterator itr = m_clientGUIDs.begin(), next; itr != m_clientGUIDs.end(); itr = next)
    {
        next = itr;
        ++next;
        buildUpdateBlock = false;
        ObjectGuid guid = (*itr);

        if (guid.IsGameObject())
        {
            if (GameObject* obj = ObjectAccessor::GetGameObject(*this, guid))
                obj->BuildValuesUpdateBlockForPlayer(&udata, this);
        }
        else if (guid.IsCreatureOrPetOrVehicle())
        {
            Creature* obj = ObjectAccessor::GetCreatureOrPetOrVehicle(*this, guid);
            if (!obj)
                continue;

            // check if this unit requires quest specific flags
            if (obj->HasFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK))
            {
                SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(obj->GetEntry());
                for (SpellClickInfoContainer::const_iterator _itr = clickPair.first; _itr != clickPair.second; ++_itr)
                {
                    //! This code doesn't look right, but it was logically converted to condition system to do the exact
                    //! same thing it did before. It definitely needs to be overlooked for intended functionality.
                    ConditionList conds = sConditionMgr->GetConditionsForSpellClickEvent(obj->GetEntry(), _itr->second.spellId);

                    for (ConditionList::const_iterator jtr = conds.begin(); jtr != conds.end() && !buildUpdateBlock; ++jtr)
                        if ((*jtr)->ConditionType == CONDITION_QUESTREWARDED || (*jtr)->ConditionType == CONDITION_QUESTTAKEN)
                        {
                            buildUpdateBlock = true;
                            break;
                        }
                }
            }
            if (!buildUpdateBlock && obj->HasFlag(UNIT_FIELD_NPC_FLAGS2, UNIT_NPC_FLAG2_GARRISON_ARCHITECT))
            {
                if (Garrison* garr = GetGarrisonPtr())
                    if (garr->GetCountOfBluePrints())
                        buildUpdateBlock = true;
            }
            if (!buildUpdateBlock && obj->HasFlag(UNIT_FIELD_NPC_FLAGS2, UNIT_NPC_FLAG2_GARRISON_MISSION_NPC | UNIT_NPC_FLAG2_SHIPMENT_CRAFTER))
            {
                if (Garrison* garr = GetGarrisonPtr())
                    if (garr->GetCountOFollowers())
                        buildUpdateBlock = true;
            }
            if (buildUpdateBlock)
                obj->BuildValuesUpdateBlockForPlayer(&udata, this);
        }
    }
    if (udata.BuildPacket(&packet))
        GetSession()->SendPacket(&packet);
}

void Player::UpdateAvailableQuestLines()
{
    ClearDynamicValue(PLAYER_DYNAMIC_FIELD_AVAILABLE_QUEST_LINE_XQUEST_IDS);

    for (auto const& questLineEntry : sQuestLineStore)
    {
        if (auto const& quests = sDB2Manager.GetQuestsByQuestLine(questLineEntry->ID))
        {
            for (auto const& questLineXQuestEntry : *quests)
            {
                auto const& qInfo = sQuestDataStore->GetQuestTemplate(questLineXQuestEntry->QuestID);
                if (!qInfo)
                    continue;

                if (CanTakeQuest(qInfo, false))
                {
                    AddDynamicValue(PLAYER_DYNAMIC_FIELD_AVAILABLE_QUEST_LINE_XQUEST_IDS, questLineXQuestEntry->ID);
                    break;
                }
            }
        }
    }
}

void Player::SummonIfPossible(bool agree)
{
    if (!agree)
    {
        m_summon_expire = 0;
        return;
    }

    // expire and auto declined
    if (m_summon_expire < time(NULL))
        return;

    // stop taxi flight at summon
    if (isInFlight())
    {
        GetMotionMaster()->MovementExpired();
        CleanupAfterTaxiFlight();
    }

    // drop flag at summon
    // this code can be reached only when GM is summoning player who carries flag, because player should be immune to summoning spells when he carries flag
    if (Battleground* bg = GetBattleground())
        bg->EventPlayerDroppedFlag(this);

    m_summon_expire = 0;

    UpdateAchievementCriteria(CRITERIA_TYPE_ACCEPTED_SUMMONINGS, 1);

    TeleportTo(m_summon_mapid, m_summon_x, m_summon_y, m_summon_z, GetOrientation());
}

void Player::RemoveItemDurations(Item* item)
{
    for (ItemDurationList::iterator itr = m_itemDuration.begin(); itr != m_itemDuration.end(); ++itr)
    {
        if (*itr == item)
        {
            m_itemDuration.erase(itr);
            break;
        }
    }
}

void Player::AddItemDurations(Item* item)
{
    if (item->GetUInt32Value(ITEM_FIELD_EXPIRATION))
    {
        m_itemDuration.push_back(item);
        item->SendTimeUpdate(this);
    }
}

void Player::AutoUnequipOffhandIfNeed(bool force /*= false*/)
{
    Item* offItem = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    if (!offItem)
        return;

     // unequip offhand weapon if player doesn't have dual wield anymore
    if (!CanDualWield()
        && ((offItem->GetTemplate()->GetInventoryType() == INVTYPE_WEAPONOFFHAND && !(offItem->GetTemplate()->GetFlags3() & ITEM_FLAG3_ALWAYS_ALLOW_DUAL_WIELD))
            || offItem->GetTemplate()->GetInventoryType() == INVTYPE_WEAPON))
        force = true;

    // need unequip offhand for 2h-weapon without TitanGrip (in any from hands)
     if (!force && (CanTitanGrip() || (offItem->GetTemplate()->GetInventoryType() != INVTYPE_2HWEAPON && !IsTwoHandUsed())))
        return;

    ItemPosCountVec off_dest;
    uint8 off_msg = CanStoreItem(NULL_BAG, NULL_SLOT, off_dest, offItem, false);
    if (off_msg == EQUIP_ERR_OK)
    {
        RemoveItem(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND, true);
        StoreItem(off_dest, offItem, true);
    }
    else
    {
        MoveItemFromInventory(offItem, true);
        SQLTransaction trans = CharacterDatabase.BeginTransaction();
        offItem->DeleteFromInventoryDB(trans);                   // deletes item from character's inventory
        offItem->SaveToDB(trans);                                // recursive and not have transaction guard into self, item not in inventory and can be save standalone

        std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);
        MailDraft(subject, "There were problems with equipping one or several items").AddItem(offItem).SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);

        CharacterDatabase.CommitTransaction(trans);
    }
}

bool Player::HasItemFitToSpellRequirements(SpellInfo const* spellInfo, Item const* ignoreItem) const
{
    if (spellInfo->EquippedItemClass < 0)
        return true;

    switch (spellInfo->EquippedItemClass)
    {
        case ITEM_CLASS_WEAPON:
        {
            for (uint8 i= EQUIPMENT_SLOT_MAINHAND; i < EQUIPMENT_SLOT_TABARD; ++i)
                if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i))
                    if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                        return true;
            break;
        }
        case ITEM_CLASS_ARMOR:
            if (!spellInfo->HasAttribute(SPELL_ATTR8_ARMOR_SPECIALIZATION))
            {
                for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_MAINHAND; ++i)
                    if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i))
                        if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                            return true;

                if (Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
                    if (item != ignoreItem && item->IsFitToSpellRequirements(spellInfo))
                        return true;
            }
            else
            {
                for (uint8 i : {EQUIPMENT_SLOT_HEAD, EQUIPMENT_SLOT_SHOULDERS, EQUIPMENT_SLOT_CHEST, EQUIPMENT_SLOT_WAIST, EQUIPMENT_SLOT_LEGS, EQUIPMENT_SLOT_FEET, EQUIPMENT_SLOT_WRISTS, EQUIPMENT_SLOT_HANDS})
                {
                    Item* item = GetUseableItemByPos(INVENTORY_SLOT_BAG_0, i);
                    if (!item || !item->IsFitToSpellRequirements(spellInfo))
                        return false;
                }
            }
        default:
            TC_LOG_ERROR(LOG_FILTER_PLAYER, "HasItemFitToSpellRequirements: Not handled spell requirement for item class %u", spellInfo->EquippedItemClass);
            break;
    }

    return false;
}

bool Player::CanNoReagentCast(SpellInfo const* spellInfo) const
{
    // don't take reagents for spells with SPELL_ATTR5_NO_REAGENT_WHILE_PREP
    if (spellInfo->HasAttribute(SPELL_ATTR5_NO_REAGENT_WHILE_PREP) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PREPARATION))
        return true;

    // Check no reagent use mask
    flag128 noReagentMask;
    for (uint8 i = 0; i < 4; ++i)
        noReagentMask[i] = GetUInt32Value(PLAYER_FIELD_NO_REAGENT_COST_MASK + i);
    if (spellInfo->ClassOptions.SpellClassMask & noReagentMask)
        return true;

    return false;
}

void Player::RemoveItemDependentAurasAndCasts(Item* pItem)
{
    for (AuraMap::iterator itr = m_ownedAuras.begin(); itr != m_ownedAuras.end();)
    {
        Aura* aura = itr->second;

        // skip passive (passive item dependent spells work in another way) and not self applied auras
        SpellInfo const* spellInfo = aura->GetSpellInfo();
        if (aura->IsPassive() ||  aura->GetCasterGUID() != GetGUID())
        {
            ++itr;
            continue;
        }

        // skip if not item dependent or have alternative item
        if (HasItemFitToSpellRequirements(spellInfo, pItem))
        {
            ++itr;
            continue;
        }

        // no alt item, remove aura, restart check
        RemoveOwnedAura(itr);
    }

    // currently casted spells can be dependent from item
    for (uint32 i = 0; i < CURRENT_MAX_SPELL; ++i)
        if (Spell* spell = GetCurrentSpell(CurrentSpellTypes(i)))
            if (spell->getState() != SPELL_STATE_DELAYED && !HasItemFitToSpellRequirements(spell->m_spellInfo, pItem))
                InterruptSpell(CurrentSpellTypes(i));
}

void Player::InitializeSelfResurrectionSpells()
{
    ClearDynamicValue(PLAYER_DYNAMIC_FIELD_SELF_RES_SPELLS);
    uint32 spells[3] = {};

    if (AuraEffectList const* dummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY))
    {
        for (auto itr = dummyAuras->cbegin(); itr != dummyAuras->cend(); ++itr)
        {
            if ((*itr)->GetId() == 20707) // Soulstone Resurrection  // prio: 3 (max, non death persistent)
                spells[0] = 3026;
            
            if ((*itr)->GetId() == 23701 && roll_chance_i(10)) // Twisting Nether  // prio: 2 (max)
                spells[1] = 23700;
        }
    }


    if (!InRBG() && !InArena())
    {
        if (Aura* aura = GetAura(207498))
        {
            for (auto itr : aura->m_loadedScripts)
            {
                if (uint32 spellId = itr->CallSpecialFunction())
                {
                    spells[2] = spellId;
                    break;
                }
            }
        }
        else if (HasAura(20608) && !HasSpellCooldown(21169)) // Reincarnation (passive spell)  // prio: 1
        {
            spells[2] = 21169;
            CastSpell(this, 225080, true);
        }
    }

    for (auto selfResSpell : spells)
        if (selfResSpell)
            AddDynamicValue(PLAYER_DYNAMIC_FIELD_SELF_RES_SPELLS, selfResSpell);
}

// Used in triggers for check "Only to targets that grant experience or honor" req
bool Player::isHonorOrXPTarget(Unit* victim)
{
    uint8 v_level = victim->getLevelForTarget(this);
    uint8 k_grey  = Trinity::XP::GetGrayLevel(getLevelForTarget(victim));

    // Victim level less gray level
    if (v_level < k_grey)
        return false;

    if (victim->IsCreature())
    {
        if (victim->ToCreature()->isTotem() ||
            victim->ToCreature()->isPet() ||
            victim->ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_XP_AT_KILL)
                return false;
    }
    return true;
}

float Player::GetsAFriendBonus(bool forXP)
{
    float recruitAFriend = 0.0f;
    uint32 goup_size = 0;
    if (getLevel() <= sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL) || !forXP)
    {
        if (Group* group = this->GetGroup())
        {
            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
            {
                Player* player = itr->getSource();
                if (!player)
                    continue;

                if (!player->IsAtRecruitAFriendDistance(this))
                    continue;                               // member (alive or dead) or his corpse at req. distance

                if (forXP)
                {
                    // level must be allowed to get RaF bonus
                    if (player->getLevel() > sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL))
                        continue;

                    // level difference must be small enough to get RaF bonus, UNLESS we are lower level
                    if (player->getLevel() < getLevel())
                        if (uint8(getLevel() - player->getLevel()) > sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL_DIFFERENCE))
                            continue;
                }

                bool ARecruitedB = (player->GetSession()->GetRecruiterId() == GetSession()->GetAccountId());
                bool BRecruitedA = (GetSession()->GetRecruiterId() == player->GetSession()->GetAccountId());
                if (ARecruitedB || BRecruitedA)
                {
                    recruitAFriend = 2.0f;
                    break;
                }
                // level difference must be small enough to get bonus, UNLESS we are lower level
                int32 levelDiff = abs(getLevel() - player->getLevel());
                if (levelDiff > (int32)sWorld->getIntConfig(CONFIG_MAX_RECRUIT_A_FRIEND_BONUS_PLAYER_LEVEL_DIFFERENCE))
                    return 0.0f;
                if(player->IsInWorld())
                    goup_size++;
            }
        }
    }
    return recruitAFriend;
}

void Player::RewardPlayerAndGroupAtKill(Unit* victim, bool isBattleGround)
{
    KillRewarder(this, victim, isBattleGround).Reward();
}

void Player::RewardPlayerAndGroupAtEvent(uint32 creatureID, WorldObject* pRewardSource)
{
    if (!IsInWorld() || !pRewardSource || !pRewardSource->IsInWorld())
        return;

    ObjectGuid creatureGUID = (pRewardSource->IsCreature()) ? pRewardSource->GetGUID() : ObjectGuid::Empty;
    if (TalkedToCreature(creatureID, creatureGUID))
        return;

    // prepare data for near group iteration
    if (Group* group = GetGroup())
    {
        for (GroupReference* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
        {
            Player* player = itr->getSource();
            if (!player || !player->IsInWorld())
                continue;

            if (!player->IsAtGroupRewardDistance(pRewardSource))
                continue; // member (alive or dead) or his corpse at req. distance

            // quest objectives updated only for alive group member or dead but with not released body
            if (player->isAlive()|| !player->GetCorpse())
                player->KilledMonsterCredit(creatureID, creatureGUID);
        }
    }
    else // if (!group)
        KilledMonsterCredit(creatureID, creatureGUID);
}

bool Player::IsAtGroupRewardDistance(WorldObject const* pRewardSource) const
{
    if (!pRewardSource)
        return false;

    WorldObject const* player = GetCorpse();
    if (!player || isAlive())
        player = this;

    if (!player->GetMap() || player->GetMapId() != pRewardSource->GetMapId() || (InInstance() && player->GetInstanceId() != pRewardSource->GetInstanceId()))
        return false;

    if (player->GetMap()->IsDungeon())
        return true;

    return pRewardSource->GetDistance(player) <= sWorld->getFloatConfig(CONFIG_GROUP_XP_DISTANCE);
}

bool Player::IsAtRecruitAFriendDistance(WorldObject const* pOther) const
{
    if (!pOther)
        return false;
    const WorldObject* player = GetCorpse();
    if (!player || isAlive())
        player = this;

    if (player->GetMapId() != pOther->GetMapId() || (InInstance() && player->GetInstanceId() != pOther->GetInstanceId()))
        return false;

    return pOther->GetDistance(player) <= sWorld->getFloatConfig(CONFIG_MAX_RECRUIT_A_FRIEND_DISTANCE);
}

void Player::SetClientControl(Unit* target, bool allowMove)
{
    WorldPackets::Movement::ControlUpdate update;
    update.Guid = target->GetGUID();
    update.On = allowMove;
    SendDirectMessage(update.Write());

    if (target == this && allowMove)
        SetMover(this);
}

void Player::UpdateZoneDependentAuras(uint32 newZone)
{
    // Some spells applied at enter into zone (with subzones), aura removed in UpdateAreaDependentAuras that called always at zone->area update
    SpellAreaForAreaMapBounds saBounds = sSpellMgr->GetSpellAreaForAreaMapBounds(newZone);
    for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        if (itr->second->autocast && itr->second->IsFitToRequirements(this, newZone, 0))
            if (!HasAura(itr->second->spellId))
                CastSpell(this, itr->second->spellId, true);
}

void Player::UpdateAreaDependentAuras(uint32 newArea)
{
    UpdateMount();

    // remove auras from spells with area limitations
    for (AuraMap::iterator iter = m_ownedAuras.begin(); iter != m_ownedAuras.end();)
    {
        // use m_zoneId for speed: UpdateArea called from UpdateZone or instead UpdateZone in both cases m_zoneId up-to-date
        if (iter->second->GetSpellInfo()->CheckLocation(GetMapId(), m_zoneId, newArea, this) != SPELL_CAST_OK)
            RemoveOwnedAura(iter);
        else
            ++iter;
    }

    // some auras applied at subzone enter
    SpellAreaForAreaMapBounds saBounds = sSpellMgr->GetSpellAreaForAreaMapBounds(newArea);
    for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        if (itr->second->autocast && itr->second->IsFitToRequirements(this, m_zoneId, newArea))
            if (!HasAura(itr->second->spellId))
                CastSpell(this, itr->second->spellId, true);

    if (newArea == 4273 && GetVehicleCreatureBase() && GetPositionX() > 400) // Ulduar
    {
        switch (GetVehicleBase()->GetEntry())
        {
            case 33062:
            case 33109:
            case 33060:
                GetVehicleCreatureBase()->DespawnOrUnsummon();
                break;
        }
    }
}

void Player::UpdateAreaQuestTasks(uint32 newAreaId, uint32 oldAreaId)
{
    // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "UpdateAreaQuestTasks newAreaId %u oldAreaId %u", newAreaId, oldAreaId);

    std::list<uint32> questAdd;

    if (std::set<Quest const*> const* qInfo = sQuestDataStore->GetQuestTask(newAreaId))
    {
        for (Quest const* quest : *qInfo)
        {
            if (FindQuestSlot(quest->GetQuestId()) < MAX_QUEST_LOG_SIZE)
            {
                questAdd.push_back(quest->GetQuestId());
                continue;
            }

            if (quest->IsEmissary() || quest->IsWorld())
                continue;

            if (QuestV2CliTaskEntry const* questTask = sQuestV2CliTaskStore.LookupEntry(quest->GetQuestId()))
            {
                if (!sConditionMgr->IsPlayerMeetingCondition(this, questTask->ConditionID))
                    continue;

                // if (questTask->WorldStateExpressionID)
                // {
                    // auto expressionEntry = sWorldStateExpressionStore.LookupEntry(questTask->WorldStateExpressionID);
                    // if (!expressionEntry || !expressionEntry->Eval(this))
                        // continue;
                // }

                if (questTask->FiltMinSkillID && GetSkillValue(questTask->FiltMinSkillID) < questTask->FiltMinSkillValue)
                    continue;

                if (questTask->FiltMinLevel != -1 && getLevel() < questTask->FiltMinLevel)
                    continue;

                if (questTask->FiltMaxLevel != -1 && getLevel() > questTask->FiltMaxLevel)
                    continue;

                bool needQuest = false;
                bool canStart = true;
                for (uint8 slot = 0; slot < QUEST_REQUIRED; ++slot)
                    if (questTask->FiltCompletedQuest[slot])
                        needQuest = true;

                if (needQuest)
                    for (uint8 slot = 0; slot < QUEST_REQUIRED; ++slot)
                        if (questTask->FiltCompletedQuest[slot] && GetQuestStatus(questTask->FiltCompletedQuest[slot]) != QUEST_STATUS_REWARDED)
                            canStart = false;

                //if (questTask->StartItem && !HasAura(questTask->StartItem))
                //    continue;

                if (needQuest && !canStart)
                    continue;

                if (CanAddQuest(quest, true) && !IsQuestRewarded(quest->GetQuestId()))
                {
                    AddQuest(quest, NULL);
                    UpdateQuestObjectiveData(quest);
                    questAdd.push_back(quest->GetQuestId());
                }
            }
            else
            {
                if (CanAddQuest(quest, true))
                {
                    AddQuest(quest, NULL);
                    UpdateQuestObjectiveData(quest);
                    questAdd.push_back(quest->GetQuestId());
                }
            }
        }
    }

    if (std::set<Quest const*> const* qInfo = sQuestDataStore->GetQuestTask(oldAreaId))
    {
        for (Quest const* quest : *qInfo)
        {
            bool questRemove = true;

            for (uint32 questId : questAdd)
                if (questId == quest->GetQuestId())
                    questRemove = false;

            if (!questRemove)
                continue;

            for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
            {
                uint32 logQuest = GetQuestSlotQuestId(slot);
                if (logQuest == quest->GetQuestId())
                {
                    SetQuestSlot(slot, 0);

                    // we ignore unequippable quest items in this case, its' still be equipped
                    TakeQuestSourceItem(logQuest, false);
                }
            }
        }
    }

    questAdd.clear();

    if (!sWorld->getBoolConfig(CONFIG_WORLD_QUEST))
        return;

    if (std::set<Quest const*> const* qInfo = sQuestDataStore->GetWorldQuestTask(newAreaId))
    {
        for (Quest const* quest : *qInfo)
        {
            // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "UpdateAreaQuestTasks GetQuestId %u", quest->GetQuestId());

            if (FindQuestSlot(quest->GetQuestId()) < MAX_QUEST_LOG_SIZE)
            {
                questAdd.push_back(quest->GetQuestId());
                continue;
            }

            WorldQuest const* wq = sQuestDataStore->GetWorldQuest(quest);
            if (!wq || wq->ResetTime <= time(NULL) || WorldQuestCompleted(quest->GetQuestId())) // World quest activated only if World Quest active
                continue;

            if (GetGroup() && GetGroup()->isRaidGroup() && !quest->IsAllowedInRaid(GetMap()->GetDifficultyID()))
                continue;

            if (sQuestDataStore->WorldLegionInvasionZoneID && sQuestDataStore->WorldLegionInvasionZoneID == wq->quest->QuestSortID && !wq->worldQuest->PrimaryID && !wq->quest->IsLegionInvasion())
                continue;

            if (QuestV2CliTaskEntry const* questTask = sQuestV2CliTaskStore.LookupEntry(quest->GetQuestId()))
            {
                if (!sConditionMgr->IsPlayerMeetingCondition(this, questTask->ConditionID))
                    continue;

                // if (questTask->WorldStateExpressionID)
                // {
                    // auto expressionEntry = sWorldStateExpressionStore.LookupEntry(questTask->WorldStateExpressionID);
                    // if (!expressionEntry || !expressionEntry->Eval(this))
                        // continue;
                // }

                if (questTask->FiltMinSkillID && GetSkillValue(questTask->FiltMinSkillID) < questTask->FiltMinSkillValue)
                    continue;

                if (questTask->FiltMinLevel != -1 && getLevel() < questTask->FiltMinLevel)
                    continue;

                if (questTask->FiltMaxLevel != -1 && getLevel() > questTask->FiltMaxLevel)
                    continue;

                if (questTask->FiltRaces &&  (questTask->FiltRaces & getRaceMask()) == 0)
                    continue;

                if (questTask->FiltClasses && (questTask->FiltClasses & getClassMask()) == 0)
                    continue;

                bool needQuest = false;
                bool canStart = true;
                for (uint8 slot = 0; slot < QUEST_REQUIRED; ++slot)
                    if (questTask->FiltCompletedQuest[slot])
                        needQuest = true;

                if (needQuest)
                    for (uint8 slot = 0; slot < QUEST_REQUIRED; ++slot)
                        if (questTask->FiltCompletedQuest[slot] && GetQuestStatus(questTask->FiltCompletedQuest[slot]) != QUEST_STATUS_REWARDED)
                            canStart = false;

                //if (questTask->StartItem && !HasAura(questTask->StartItem))
                //    continue;

                if (needQuest && !canStart)
                    continue;

                if (CanAddQuest(quest, true))
                {
                    AddQuest(quest, NULL);
                    UpdateQuestObjectiveData(quest);
                    questAdd.push_back(quest->GetQuestId());
                }
            }
            else
            {
                if (CanAddQuest(quest, true))
                {
                    AddQuest(quest, NULL);
                    UpdateQuestObjectiveData(quest);
                    questAdd.push_back(quest->GetQuestId());
                }
            }
        }
    }

    if (std::set<Quest const*> const* qInfo = sQuestDataStore->GetWorldQuestTask(oldAreaId))
    {
        for (Quest const* quest : *qInfo)
        {
            bool questRemove = true;

            for (uint32 questId : questAdd)
                if (questId == quest->GetQuestId())
                    questRemove = false;

            if (!questRemove)
                continue;

            for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
            {
                uint32 logQuest = GetQuestSlotQuestId(slot);
                if (logQuest == quest->GetQuestId())
                {
                    SetQuestSlot(slot, 0);

                    // we ignore unequippable quest items in this case, its' still be equipped
                    TakeQuestSourceItem(logQuest, false);
                }
            }
        }
    }
}

uint32 Player::GetCorpseReclaimDelay(bool pvp) const
{
    if (pvp)
    {
        if (!sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP))
            return copseReclaimDelay[0];
    }
    else if (!sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE))
        return 0;

    time_t now = time(NULL);
    // 0..2 full period
    // should be ceil(x)-1 but not floor(x)
    uint64 count = (now < m_deathExpireTime - 1) ? (m_deathExpireTime - 1 - now)/DEATH_EXPIRE_STEP : 0;
    return copseReclaimDelay[count];
}

void Player::UpdateCorpseReclaimDelay()
{
    bool pvp = (m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH) != 0;

    if ((pvp && !sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP)) ||
        (!pvp && !sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE)))
        return;

    time_t now = time(NULL);
    if (now < m_deathExpireTime)
    {
        // full and partly periods 1..3
        uint64 count = (m_deathExpireTime - now)/DEATH_EXPIRE_STEP +1;
        if (count < MAX_DEATH_COUNT)
            m_deathExpireTime = now+(count+1)*DEATH_EXPIRE_STEP;
        else
            m_deathExpireTime = now+MAX_DEATH_COUNT*DEATH_EXPIRE_STEP;
    }
    else
        m_deathExpireTime = now+DEATH_EXPIRE_STEP;
}

void Player::SendCorpseReclaimDelay(bool load)
{
    Corpse* corpse = GetCorpse();
    if (load && !corpse)
        return;

    bool pvp;
    if (corpse)
        pvp = (corpse->GetType() == CORPSE_RESURRECTABLE_PVP);
    else
        pvp = (m_ExtraFlags & PLAYER_EXTRA_PVP_DEATH) != 0;

    time_t delay;
    if (load)
    {
        if (corpse->GetGhostTime() > m_deathExpireTime)
            return;

        uint64 count;
        if ((pvp && sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVP)) ||
           (!pvp && sWorld->getBoolConfig(CONFIG_DEATH_CORPSE_RECLAIM_DELAY_PVE)))
        {
            count = (m_deathExpireTime-corpse->GetGhostTime())/DEATH_EXPIRE_STEP;
            if (count >= MAX_DEATH_COUNT)
                count = MAX_DEATH_COUNT-1;
        }
        else
            count=0;

        time_t expected_time = corpse->GetGhostTime()+copseReclaimDelay[count];

        time_t now = time(NULL);
        if (now >= expected_time)
            return;

        delay = expected_time-now;
    }
    else
        delay = GetCorpseReclaimDelay(pvp);

    if (load && !delay)
        return;

    //! corpse reclaim delay 30 * 1000ms or longer at often deaths
    WorldPackets::Misc::CorpseReclaimDelay packet;
    packet.Remaining = delay * IN_MILLISECONDS;
    SendDirectMessage(packet.Write());
}

Player* Player::GetNextRandomRaidMember(float radius)
{
    Group* group = GetGroup();
    if (!group)
        return NULL;

    std::vector<Player*> nearMembers;
    nearMembers.reserve(group->GetMembersCount());

    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
    {
        Player* Target = itr->getSource();

        // IsHostileTo check duel and controlled by enemy
        if (Target && Target != this && IsWithinDistInMap(Target, radius) &&
            !Target->HasInvisibilityAura() && !IsHostileTo(Target))
            nearMembers.push_back(Target);
    }

    if (nearMembers.empty())
        return NULL;

    uint32 randTarget = urand(0, nearMembers.size()-1);
    return nearMembers[randTarget];
}

PartyResult Player::CanUninviteFromGroup() const
{
    Group const* grp = GetGroup();
    if (!grp)
        return ERR_NOT_IN_GROUP;

    if (grp->isLFGGroup())
    {
        ObjectGuid gguid = grp->GetGUID();
        if (!sLFGMgr->GetKicksLeft(gguid))
            return ERR_PARTY_LFG_BOOT_LIMIT;

        uint32 queueId = sLFGMgr->GetQueueId(gguid);
        if (!queueId)
            return ERR_PARTY_LFG_BOOT_LIMIT;

        lfg::LfgState state = sLFGMgr->GetState(gguid, queueId);
        if (state == lfg::LFG_STATE_BOOT)
            return ERR_PARTY_LFG_BOOT_IN_PROGRESS;

        if (grp->GetMembersCount() <= sLFGMgr->GetVotesNeededForKick(grp->GetGUID()))
            return ERR_PARTY_LFG_BOOT_TOO_FEW_PLAYERS;

        if (state == lfg::LFG_STATE_FINISHED_DUNGEON)
            return ERR_PARTY_LFG_BOOT_DUNGEON_COMPLETE;

        if (grp->isRollLootActive())
            return ERR_PARTY_LFG_BOOT_LOOT_ROLLS;

        // TODO: Should also be sent when anyone has recently left combat, with an aprox ~5 seconds timer.
        for (GroupReference const* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
            if (itr->getSource() && itr->getSource()->isInCombat())
                return ERR_PARTY_LFG_BOOT_IN_COMBAT;

        /* Missing support for these types
            return ERR_PARTY_LFG_BOOT_COOLDOWN_S;
            return ERR_PARTY_LFG_BOOT_NOT_ELIGIBLE_S;
        */
    }
    else
    {
        if (!grp->IsLeader(GetGUID()) && !grp->IsAssistant(GetGUID()) && !(grp->GetGroupFlags() & GROUP_FLAG_EVERYONE_ASSISTANT))
            return ERR_NOT_LEADER;

        if (InBattleground())
            return ERR_INVITE_RESTRICTED;
    }

    return ERR_PARTY_RESULT_OK;
}

bool Player::isUsingLfg()
{
    return sLFGMgr->HasQueue(GetGUID());
}

bool Player::CanKickFromChallenge()
{
    auto grp = GetGroup();
    if (!grp)
        return false;

    if (auto instance = GetInstanceScript())
        if (grp->InChallenge() && instance->IsEncounterInProgress())
            return false;

    if (HasAura(305284))
        return false;

    return true;
}

void Player::SetLfgBonusFaction(uint32 factionId)
{
    if (!factionId)
    {
        SetUInt32Value(PLAYER_FIELD_LFG_BONUS_FACTION_ID, 0);
        return;
    }

    if (FactionEntry const* faction = sFactionStore.LookupEntry(factionId))
        if (faction->CanBeLfgBonus() && GetReputationMgr().IsVisible(faction->ReputationIndex))
            SetUInt32Value(PLAYER_FIELD_LFG_BONUS_FACTION_ID, factionId);
}

uint32 Player::GetLfgBonusFaction() const
{
    return GetUInt32Value(PLAYER_FIELD_LFG_BONUS_FACTION_ID);
}

void Player::SetBattlegroundOrBattlefieldRaid(Group* group, int8 subgroup)
{
    //we must move references from m_group to m_originalGroup
    SetOriginalGroup(GetGroup(), GetSubGroup());

    m_group.unlink();
    m_group.link(group, this);
    m_group.setSubGroup((uint8)subgroup);
}

void Player::RemoveFromBattlegroundOrBattlefieldRaid()
{
    //remove existing reference
    m_group.unlink();
    if (Group* group = GetOriginalGroup())
    {
        m_group.link(group, this);
        m_group.setSubGroup(GetOriginalSubGroup());
    }
    SetOriginalGroup(NULL);
}

void Player::SetOriginalGroup(Group* group, int8 subgroup)
{
    if (group == NULL)
        m_originalGroup.unlink();
    else
    {
        // never use SetOriginalGroup without a subgroup unless you specify NULL for group
        ASSERT(subgroup >= 0);
        m_originalGroup.link(group, this);
        m_originalGroup.setSubGroup((uint8)subgroup);
    }
}

void Player::UpdateUnderwaterState(Map* m, float x, float y, float z)
{
    Zliquid_status = m->getLiquidStatus(x, y, z, MAP_ALL_LIQUIDS, &liquid_status);
    if (!Zliquid_status)
    {
        m_MirrorTimerFlags &= ~(UNDERWATER_INWATER | UNDERWATER_INLAVA | UNDERWATER_INSLIME | UNDERWARER_INDARKWATER);
        if (_lastLiquid && _lastLiquid->SpellID)
            RemoveAurasDueToSpell(_lastLiquid->SpellID);

        _lastLiquid = NULL;
        return;
    }

    if (uint32 liqEntry = liquid_status.entry)
    {
        LiquidTypeEntry const* liquid = sLiquidTypeStore.LookupEntry(liqEntry);
        if (_lastLiquid && _lastLiquid->SpellID && _lastLiquid->ID != liqEntry)
            RemoveAurasDueToSpell(_lastLiquid->SpellID);

        if (liquid && liquid->SpellID)
        {
            if (Zliquid_status & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER))
            {
                if (!HasAura(liquid->SpellID))
                    CastSpell(this, liquid->SpellID, true);
            }
            else
                RemoveAurasDueToSpell(liquid->SpellID);
        }

        _lastLiquid = liquid;
    }
    else if (_lastLiquid && _lastLiquid->SpellID)
    {
        RemoveAurasDueToSpell(_lastLiquid->SpellID);
        _lastLiquid = NULL;
    }


    // All liquids type - check under water position
    if (liquid_status.type_flags & (MAP_LIQUID_TYPE_WATER | MAP_LIQUID_TYPE_OCEAN | MAP_LIQUID_TYPE_MAGMA | MAP_LIQUID_TYPE_SLIME))
    {
        if (Zliquid_status & LIQUID_MAP_UNDER_WATER)
            m_MirrorTimerFlags |= UNDERWATER_INWATER;
        else
            m_MirrorTimerFlags &= ~UNDERWATER_INWATER;
    }

    // Allow travel in dark water on taxi or transport
    if ((liquid_status.type_flags & MAP_LIQUID_TYPE_DARK_WATER) && !isInFlight() && !GetTransport())
        m_MirrorTimerFlags |= UNDERWARER_INDARKWATER;
    else
        m_MirrorTimerFlags &= ~UNDERWARER_INDARKWATER;

    // in lava check, anywhere in lava level
    if (liquid_status.type_flags & MAP_LIQUID_TYPE_MAGMA)
    {
        if (Zliquid_status & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK))
            m_MirrorTimerFlags |= UNDERWATER_INLAVA;
        else
            m_MirrorTimerFlags &= ~UNDERWATER_INLAVA;
    }
    // in slime check, anywhere in slime level
    if (liquid_status.type_flags & MAP_LIQUID_TYPE_SLIME)
    {
        if (Zliquid_status & (LIQUID_MAP_UNDER_WATER | LIQUID_MAP_IN_WATER | LIQUID_MAP_WATER_WALK))
            m_MirrorTimerFlags |= UNDERWATER_INSLIME;
        else
            m_MirrorTimerFlags &= ~UNDERWATER_INSLIME;
    }
}

void Player::SetCanParry(bool value)
{
    if (m_canParry == value)
        return;

    m_canParry = value;
    UpdateParryPercentage();
}

void Player::SetCanBlock(bool value)
{
    if (m_canBlock == value)
        return;

    m_canBlock = value;
    UpdateBlockPercentage();
}

bool ItemPosCount::isContainedIn(ItemPosCountVec const& vec) const
{
    for (ItemPosCountVec::const_iterator itr = vec.begin(); itr != vec.end(); ++itr)
        if (itr->pos == pos)
            return true;
    return false;
}

void PetInfoData::UpdateData(Field* fields)
{
    id = fields[0].GetUInt32();
    entry = fields[1].GetUInt32();
    modelid = fields[3].GetUInt32();
    level = fields[4].GetUInt16();
    exp = fields[5].GetUInt32();
    reactstate = ReactStates(fields[6].GetUInt8());
    name = fields[7].GetString();
    renamed = fields[8].GetBool();
    curhealth = fields[9].GetUInt32();
    curmana = fields[10].GetUInt32();
    abdata = fields[11].GetString();
    savetime = fields[12].GetUInt32();
    CreatedBySpell = fields[13].GetUInt32();
    pet_type = PetType(fields[14].GetUInt8());
    specialization = fields[15].GetUInt32();
}

void PetInfoData::UpdateData(Pet* pet)
{
    id = pet->GetCharmInfo()->GetPetNumber();
    entry = pet->GetEntry();
    modelid = pet->GetDisplayId();
    level = pet->getLevel();
    exp = pet->GetUInt32Value(UNIT_FIELD_PET_EXPERIENCE);
    reactstate = pet->GetReactState();
    name = pet->GetName();
    renamed = pet->HasByteFlag(UNIT_FIELD_BYTES_2, UNIT_BYTES_2_OFFSET_PET_FLAGS, UNIT_CAN_BE_RENAMED) ? 0 : 1;
    curhealth = pet->GetHealth();
    curmana = pet->GetPower(POWER_MANA);
    std::ostringstream ss;
    ss.str("");
    for (uint32 i = ACTION_BAR_INDEX_START; i < ACTION_BAR_INDEX_END; ++i)
        ss << uint32(pet->GetCharmInfo()->GetActionBarEntry(i)->GetType()) << ' ' << uint32(pet->GetCharmInfo()->GetActionBarEntry(i)->GetAction()) << ' ';

    abdata = ss.str();
    savetime = time(NULL);
    CreatedBySpell = pet->GetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL);
    pet_type = pet->getPetType();
    specialization = pet->GetSpecializationId();
}

void Player::StopCastingBindSight()
{
    if (WorldObject* target = GetViewpoint())
    {
        if (target->IsUnit())
        {
            target->ToUnit()->RemoveAurasByType(SPELL_AURA_BIND_SIGHT, GetGUID());
            target->ToUnit()->RemoveAurasByType(SPELL_AURA_MOD_POSSESS, GetGUID());
        }
    }
}

void Player::SetViewpoint(WorldObject* target, bool apply)
{
    if (apply)
    {
        TC_LOG_DEBUG(LOG_FILTER_MAPS, "Player::CreateViewpoint: Player %s create seer %u (TypeId: %u).", GetName(), target->GetEntry(), target->GetTypeId());

        if (IsSpectator() && _spectateFrom)
        {
            SetViewpoint(_spectateFrom, false);
            _spectateFrom = nullptr;
        }

        if (!AddGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT, target->GetGUID()))
        {
            TC_LOG_FATAL(LOG_FILTER_PLAYER, "Player::CreateViewpoint: Player %s cannot add new viewpoint!", GetName());
            return;
        }

        // farsight dynobj or puppet may be very far away
        UpdateVisibilityOf(target);

        if (target->IsUnit() && !GetVehicle())
        {
            if (IsSpectator())
                _spectateFrom = target->ToUnit();

            target->ToUnit()->AddPlayerToVision(this);
        }
    }
    else
    {
        if (IsSpectator() && !_spectateFrom)
            return;

        TC_LOG_DEBUG(LOG_FILTER_MAPS, "Player::CreateViewpoint: Player %s remove seer", GetName());

        if (!RemoveGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT, target->GetGUID()))
        {
            TC_LOG_FATAL(LOG_FILTER_PLAYER, "Player::CreateViewpoint: Player %s cannot remove current viewpoint!", GetName());
            return;
        }

        if (target->IsUnit() && !GetVehicle())
            target->ToUnit()->RemovePlayerFromVision(this);

        if (IsSpectator())
            _spectateFrom = nullptr;

        //must immediately set seer back otherwise may crash
        m_seer = this;

        //WorldPacket data(SMSG_CLEAR_FAR_SIGHT_IMMEDIATE, 0);
        //SendDirectMessage(&data);
    }
}

WorldObject* Player::GetViewpoint() const
{
    ObjectGuid guid = GetGuidValue(PLAYER_FIELD_FARSIGHT_OBJECT);
    if (!guid.IsEmpty())
        return (WorldObject*)ObjectAccessor::GetObjectByTypeMask(*this, guid, TYPEMASK_SEER);
    return NULL;
}

bool Player::CanUseBattlegroundObject()
{
    // TODO : some spells gives player ForceReaction to one faction (ReputationMgr::ApplyForceReaction)
    // maybe gameobject code should handle that ForceReaction usage
    // BUG: sometimes when player clicks on flag in AB - client won't send gameobject_use, only gameobject_report_use packet
    return (//InBattleground() &&                          // in battleground - not need, check in other cases
             //!IsMounted() && - not correct, player is dismounted when he clicks on flag
             //player cannot use object when he is invulnerable (immune)
             !isTotalImmune() &&                            // not totally immune
             //i'm not sure if these two are correct, because invisible players should get visible when they click on flag
             !HasStealthAura() &&                           // not stealthed
             !HasInvisibilityAura() &&                      // not invisible
             !HasAura(SPELL_BG_RECENTLY_DROPPED_FLAG) &&    // can't pickup
             isAlive()                                      // live player
);
}

bool Player::CanCaptureTowerPoint()
{
    return (!HasStealthAura() && !HasInvisibilityAura() &&  isAlive());
}

uint32 Player::GetBarberShopCost(BarberShopStyleEntry const* newHairStyle, uint8 newHairColor, BarberShopStyleEntry const* newFacialHair, BarberShopStyleEntry const* newSkin, BarberShopStyleEntry const* newFace, std::array<BarberShopStyleEntry const*, PLAYER_CUSTOM_DISPLAY_SIZE> const& newCustomDisplay) const
{
    uint8 hairstyle = GetHairStyleValue();
    uint8 haircolor = GetHairColorValue();
    uint8 facialhair = GetFacialStyleValue();
    uint8 skincolor = GetSkinValue();
    uint8 face = GetFaceValue();
    std::array<uint8, PLAYER_CUSTOM_DISPLAY_SIZE> customDisplay;
    for (uint32 i = 0; i < PLAYER_CUSTOM_DISPLAY_SIZE; ++i)
        customDisplay[i] = GetByteValue(PLAYER_FIELD_BYTES_2, PLAYER_BYTES_2_OFFSET_CUSTOM_DISPLAY_OPTION + i);

    if ((hairstyle == newHairStyle->Data) &&
        (haircolor == newHairColor) &&
        (facialhair == newFacialHair->Data) &&
        (!newSkin || (newSkin->Data == skincolor)) &&
        (!newFace || (newFace->Data == face)) &&
        (!newCustomDisplay[0] || (newCustomDisplay[0]->Data == customDisplay[0])) &&
        (!newCustomDisplay[1] || (newCustomDisplay[1]->Data == customDisplay[1])) &&
        (!newCustomDisplay[2] || (newCustomDisplay[2]->Data == customDisplay[2])))
        return 0;

    GtBarberShopCostBaseEntry const* bsc = sBarberShopCostBaseGameTable.GetRow(getLevel());
    if (!bsc)
        return 0xFFFFFFFF;

    uint32 cost = 0;

    if (hairstyle != newHairStyle->Data)
        cost += uint32(bsc->Cost * newHairStyle->CostModifier);

    if ((haircolor != newHairColor) && (hairstyle == newHairStyle->Data))
        cost += uint32(bsc->Cost * 0.5f);

    if (facialhair != newFacialHair->Data)
        cost += uint32(bsc->Cost * newFacialHair->CostModifier);

    if (newSkin && skincolor != newSkin->Data)
        cost += uint32(bsc->Cost * newSkin->CostModifier);

    if (newFace && face != newFace->Data)
        cost += uint32(bsc->Cost * newFace->CostModifier);

    for (uint32 i = 0; i < PLAYER_CUSTOM_DISPLAY_SIZE; ++i)
        if (newCustomDisplay[i] && customDisplay[i] != newCustomDisplay[i]->Data)
            cost += uint32(bsc->Cost * newCustomDisplay[i]->CostModifier);

    return cost;
}

bool Player::isTotalImmune()
{
    AuraEffectList const* immune = GetAuraEffectsByType(SPELL_AURA_SCHOOL_IMMUNITY);
    if (!immune)
        return false;

    uint32 immuneMask = 0;
    for (AuraEffectList::const_iterator iter = immune->begin(); iter != immune->end(); ++iter)
    {
        if(AuraEffect* const eff = *iter)
            immuneMask |= eff->GetMiscValue();
        if (immuneMask & SPELL_SCHOOL_MASK_ALL)            // total immunity
            return true;
    }
    return false;
}

bool Player::HasTitle(uint32 bitIndex)
{
    if (bitIndex > MAX_TITLE_INDEX)
        return false;

    uint32 fieldIndexOffset = bitIndex / 32;
    uint32 flag = 1 << (bitIndex % 32);
    return HasFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
}

void Player::SetTitle(CharTitlesEntry const* title, bool lost)
{
    uint32 fieldIndexOffset = title->MaskID / 32;
    uint32 flag = 1 << (title->MaskID % 32);

    if (lost)
    {
        if (!HasFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag))
            return;

        RemoveFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag);
    }
    else
    {
        if (HasFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag))
            return;

        SetFlag(PLAYER_FIELD_KNOWN_TITLES + fieldIndexOffset, flag);

        UpdateAchievementCriteria(CRITERIA_TYPE_OWN_RANK, title->ID);
        //UpdateAchievementCriteria(CRITERIA_TYPE_EARNED_PVP_TITLE, title->bit_index);
    }

    WorldPackets::Character::TitleEarned packet(lost ? SMSG_TITLE_LOST : SMSG_TITLE_EARNED);
    packet.Index = title->MaskID;
    SendDirectMessage(packet.Write());
}
                                   // Heurtoir,            Frappe hero,        Coup traumatisant
#define SPELL_WAR_ATTACK_LIST   47475,                  47450,              12809


                                // inquisition,         Consecration,       Repentir
#define SPELL_PAL_ATTACK_LIST   35395,                  48819,              20066
                                // Eclair Lumineux,     Lumiere sacree
#define SPELL_PAL_FRIEND_LIST   48785,                  48782,              48785


                                // Tir des arcanes,     Morsure de serpent, Morsure de la mangouste
#define SPELL_HUNT_ATTACK_LIST  49045,                  49001,              53339


                                // pied,                Hemoragie           suriner         Eventail de couteaux
#define SPELL_ROG_ATTACK_LIST   1766,                   48660,              1776,           51723


                                // Douleur,             Chatiment,          Flammes sacrees
#define SPELL_PRI_ATTACK_LIST   48125,                  48123,              48135
                                // Soins rapides,       Renovation,         Priere de guerison
#define SPELL_PRI_FRIEND_LIST   48071,                  48068,              48113


                                // frappe au coeur,     Toucher de glace,   Mort et decompo
#define SPELL_DK_ATTACK_LIST    55262,                  49909,              49938


                                // Chaine d'eclairs,    Horion de flammes,  Orage
#define SPELL_CHA_ATTACK_LIST   49271,                  49233,              59159
                                // Salve de guerison    Vague de soin       Bouclier de terre
#define SPELL_CHA_FRIEND_LIST   55459,                  49273,              49284


                                // Boule de feu,        Nova de givre,      Eclair de givrefeu
#define SPELL_MAG_ATTACK_LIST   42833,                  42917,              44614


                                // Immolation,          Drain de vie,       Hurlement de terreur
#define SPELL_DEM_ATTACK_LIST   47811,                  47857,              17928


                                // Colere,              Eclat Lunaire,      Lucioles
#define SPELL_DRU_ATTACK_LIST   48461,                  48463,              770
                                // Recuperation,        Toucher guerriseur, Tranquillite
#define SPELL_DRU_FRIEND_LIST   48441,                  48378,              48447
                                // Breath of fire       //Blackout kick     //Chi burst
#define SPELL_MONK_ATTACK_LIST  123725,                 128531,             130651

uint32 rand_number(uint32 value1, uint32 value2, uint32 value3 = 0, uint32 value4 = 0)
{
    switch (rand() % 4)
    {
        case 0:        return value1;
        case 1:        return value2;
        case 2:        return value3;
        case 3:        return value4;
        default:    return 0;
    }
}


void Player::UpdateCharmedAI()
{
    //This should only called in Player::Update
  Creature* charmer = GetCharmer()->ToCreature();

    //kill self if charm aura has infinite duration
    if (charmer->IsInEvadeMode())
    {
        if (AuraEffectList const* auras = GetAuraEffectsByType(SPELL_AURA_MOD_CHARM))
        {
            for (AuraEffectList::const_iterator iter = auras->begin(); iter != auras->end(); ++iter)
                if ((*iter)->GetCasterGUID() == charmer->GetGUID() && (*iter)->GetBase()->IsPermanent())
                {
                    charmer->DealDamage(this, GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
                    return;
                }
        }
    }

    if (!charmer->isInCombat())
        GetMotionMaster()->MoveFollow(charmer, GetFollowDistance(), charmer->GetFollowAngle());

    Unit* target = getVictim();
    if (!target || !charmer->IsValidAttackTarget(target))
    {
        target = charmer->SelectNearestPlayerNotGM();
        if (!target)
            return;

        GetMotionMaster()->MoveChase(target);
        Attack(target, true);
    }
    else
    {
        if (HasUnitState(UNIT_STATE_CASTING))
            return;
        if (target && GetMotionMaster()->GetCurrentMovementGeneratorType() != CHASE_MOTION_TYPE)
            GetMotionMaster()->MoveChase(target);

        // On laisse quelques attaques en melee deux fois sur trois
        if (urand(0, 2))
            return;

        // On s'arrete pour cast le spell
        GetMotionMaster()->MoveIdle();

        // 0 : Friendly, 1-2-3 : attack
        bool attack = urand(0 , 3);

        switch (getClass())
        {
            case CLASS_WARRIOR:
            {
                CastSpell(target, rand_number(SPELL_WAR_ATTACK_LIST));
                break;
            }
            case CLASS_PALADIN:
            {
                if (attack)
                    CastSpell(target, rand_number(SPELL_PAL_ATTACK_LIST));
                else
                    CastSpell(charmer, rand_number(SPELL_PAL_FRIEND_LIST));
                break;
            }
            case CLASS_HUNTER:
            {
                CastSpell(target, rand_number(SPELL_HUNT_ATTACK_LIST));
                break;
            }
            case CLASS_ROGUE:
            {
                CastSpell(target, rand_number(SPELL_ROG_ATTACK_LIST));
                break;
            }
            case CLASS_PRIEST:
            {
                if (attack)
                    CastSpell(target, rand_number(SPELL_PRI_ATTACK_LIST));
                else
                    CastSpell(charmer, rand_number(SPELL_PRI_FRIEND_LIST));
                break;
            }
            case CLASS_DEATH_KNIGHT:
            {
                CastSpell(target, rand_number(SPELL_DK_ATTACK_LIST));
                break;
            }
            case CLASS_SHAMAN:
            {
                if (attack)
                    CastSpell(target, rand_number(SPELL_CHA_ATTACK_LIST));
                else
                    CastSpell(charmer, rand_number(SPELL_CHA_FRIEND_LIST));
                break;
            }
            case CLASS_MAGE:
            {
                CastSpell(target, rand_number(SPELL_MAG_ATTACK_LIST));
                break;
            }
            case CLASS_WARLOCK:
            {
                CastSpell(target, rand_number(SPELL_DEM_ATTACK_LIST));
                break;
            }
            case CLASS_DRUID:
            {
                if (attack)
                    CastSpell(target, rand_number(SPELL_DRU_ATTACK_LIST));
                else
                    CastSpell(charmer, rand_number(SPELL_DRU_FRIEND_LIST));
                break;
            }
            case CLASS_MONK:
            {
                CastSpell(target, rand_number(SPELL_MONK_ATTACK_LIST));
                break;
            }
            default:
                break;
        }
    }
}

float Player::GetRuneBaseCooldown() const
{
    return float(RUNE_BASE_COOLDOWN * GetRuneCooldownCoef()); // For use coef need info how sync CD with client
}

uint32 Player::GetRuneCooldown(uint8 index) const
{
    if (GetRunesState() & (1 << index))
        return 0;

    int32 cooldown = GetRuneBaseCooldown() - m_runes.Cooldown[index];
    return cooldown > 0 ? cooldown : 0;
}

void Player::SetRuneCooldown(uint8 index, uint32 cooldown)
{
    m_runes.SetRuneState(index, (cooldown == 0) ? true : false);
    m_runes.Cooldown[index] = GetRuneBaseCooldown() - cooldown;
}

void Player::ModRuneCooldown(uint8 index, uint32 regenTime)
{
    m_runes.Cooldown[index] += regenTime;
}

ActionButton::ActionButton(uint32 action, uint8 type, ActionButtonUpdateState state): uType(type), uAction(action), uState(state)
{
    packedData = 0;
    uint64 newData = uAction | (uint64(uType) << 56);
    if (newData != packedData || uState == ACTIONBUTTON_DELETED)
    {
        packedData = newData;
        if (uState != ACTIONBUTTON_NEW)
            uState = ACTIONBUTTON_CHANGED;
    }
}

ActionButtonType ActionButton::GetType() const
{
    return ActionButtonType(ACTION_BUTTON_TYPE(packedData));
}

uint32 ActionButton::GetAction() const
{
    return ACTION_BUTTON_ACTION(packedData);
}

void ActionButton::SetActionAndType(uint32 action, ActionButtonType type)
{
    uint64 newData = action | (uint64(type) << 56);
    if (newData != packedData || uState == ACTIONBUTTON_DELETED)
    {
        packedData = newData;
        if (uState != ACTIONBUTTON_NEW)
            uState = ACTIONBUTTON_CHANGED;
    }
}

void Runes::SetRuneState(uint8 index, bool set /*= true*/)
{
    auto itr = std::find(CooldownOrder.begin(), CooldownOrder.end(), index);
    if (set)
    {
        RuneState |= (1 << index);                      // usable
        if (itr != CooldownOrder.end())
            CooldownOrder.erase(itr);
    }
    else
    {
        RuneState &= ~(1 << index);                     // on cooldown
        if (itr == CooldownOrder.end())
            CooldownOrder.push_back(index);
    }
}

void Player::ResyncRunes(uint8 count)
{
    // WorldPackets::Spells::ResyncRunes data(count);

    // for (uint32 i = 0; i < count; ++i)
    // {
        // WorldPackets::Spells::ResyncRunes::ResyncRune rune;
        // rune.Rune = i;
        // rune.Cooldown = uint8(255 - (GetRuneCooldown(i) * 51));
        // data.Runes.push_back(rune);
    // }
    // SendDirectMessage(data.Write());
}

//! 6.1.2
void Player::AddRunePower(uint8 index)
{
    TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "AddRunePower index %i", index);

    ModifyPower(POWER_RUNES, 1);
    WorldPacket data(SMSG_ADD_RUNE_POWER, 4);
    data << uint32(1 << index);                             // mask (0x00-0x3F probably)
    SendDirectMessage(&data);
}

void Player::InitRunes()
{
    if (getClass() != CLASS_DEATH_KNIGHT)
        return;

    m_runes.RuneState = 0;

    for (uint8 i = 0; i < MAX_RUNES; ++i)
        SetRuneCooldown(i, 0);
}

bool Player::AutoStoreLoot(uint8 bag, uint8 slot, uint32 loot_id, LootStore const& store, bool broadcast, uint32 itemContext)
{
    Loot loot;
    loot._isItemLoot = true;
    loot._itemContext = itemContext;
    loot.FillLoot(loot_id, store, this, true);

    uint32 max_slot = loot.GetMaxSlotInLootFor(this);
    for (uint32 i = 0; i < max_slot; ++i)
    {
        LootItem* lootItem = loot.LootItemInSlot(i, this);
        if (!loot.AllowedForPlayer(this, lootItem->item.ItemID, lootItem->type, lootItem->needs_quest, lootItem))
            continue;

        if (lootItem->currency)
        {
            uint32 id = lootItem->item.ItemID;
            if (!sCurrencyTypesStore.LookupEntry(id))
                continue;

            if (uint32 totalCap = GetTotalCurrencyCap(id))
            {
                if (GetCurrency(id) + lootItem->count > totalCap)
                {
                    SendEquipError(EQUIP_ERR_ITEM_MAX_COUNT);
                    continue;
                }
            }

            ModifyCurrency(id, lootItem->count, true);

            // log Veiled Argunite and Wakening Essence currency
            if (id == 1508 || id == 1533 || id == 1160)
            {
                std::string lootSource = "unknown";
                if (loot.objGuid.IsGameObject())
                    lootSource = "gameobject";
                else if (loot.objGuid.IsCreature())
                    lootSource = "creature";
                else if (loot.objGuid.IsItem())
                    lootSource = "item";
                sLog->outWarden("Player %s (GUID: %u) adds a currency value %u (%u) from loot source %s (Entry: %u) and type %u", GetName(), GetGUIDLow(), lootItem->count, id, lootSource.c_str(), loot.objEntry, loot.loot_type);
            }
        }
        else
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanStoreNewItem(bag, slot, dest, lootItem->item.ItemID, lootItem->count);
            if (msg != EQUIP_ERR_OK && slot != NULL_SLOT)
                msg = CanStoreNewItem(bag, NULL_SLOT, dest, lootItem->item.ItemID, lootItem->count);
            if (msg != EQUIP_ERR_OK && bag != NULL_BAG)
                msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, lootItem->item.ItemID, lootItem->count);
            if (msg != EQUIP_ERR_OK)
            {
                SendEquipError(msg, NULL, NULL, lootItem->item.ItemID);
                continue;
            }

            Item* pItem = StoreNewItem(dest, lootItem->item.ItemID, true, lootItem->item.RandomPropertiesID, GuidSet(), lootItem->item.ItemBonus.BonusListIDs, lootItem->item.ItemBonus.Context);
            SendNewItem(pItem, lootItem->count, false, false, broadcast);
        }
    }
    if (max_slot > 0)
        return true;

    return false;
}

void Player::StoreLootItem(uint8 lootSlot, Loot* loot)
{
    QuestItem* qitem = NULL;
    QuestItem* ffaitem = NULL;
    QuestItem* conditem = NULL;
    QuestItem* currency = NULL;

    LootItem* item = loot->LootItemInSlot(lootSlot, this, &qitem, &ffaitem, &conditem, &currency);
    if (!item)
    {
        TC_LOG_DEBUG(LOG_FILTER_LOOT, "StoreLootItem Item not found");
        SendEquipError(EQUIP_ERR_LOOT_GONE);
        return;
    }

    // questitems use the blocked field for other purposes
    if (!qitem && item->is_blocked)
    {
        SendLootRelease(GetLootGUID(), loot->GetGUID());
        return;
    }

    if (loot->shipmentBuildingType)
    {
        if (Garrison* garr = GetGarrisonPtr())
            garr->FreeShipmentChest(loot->shipmentBuildingType);
    }

    if (currency)
    {
        // TC_LOG_DEBUG(LOG_FILTER_LOOT, "Player::StoreLootItem currency %i count %u lootSlot %u", item->item.ItemID, item->count, lootSlot);

        if (sCurrencyTypesStore.LookupEntry(item->item.ItemID))
        {
            ModifyCurrency(item->item.ItemID, item->count, true);

            // log Veiled Argunite and Wakening Essence currency
            if (item->item.ItemID == 1508 || item->item.ItemID == 1533 || item->item.ItemID == 1160)
            {
                std::string lootSource = "unknown";
                if (loot->objGuid.IsGameObject())
                    lootSource = "gameobject";
                else if (loot->objGuid.IsCreature())
                    lootSource = "creature";
                else if (loot->objGuid.IsItem())
                    lootSource = "item";
                sLog->outWarden("Player %s (GUID: %u) adds a currency value %u (%u) from loot source %s (Entry: %u) and type %u", GetName(), GetGUIDLow(), item->count, item->item.ItemID, lootSource.c_str(), loot->objEntry, loot->loot_type);
            }
        }

        SendNotifyLootItemRemoved(lootSlot, loot);
        currency->is_looted = true;
        --loot->unlootedCount;

        if (loot->personal)
            SendDisplayToast(item->item.ItemID, ToastType::CURRENCY, false/*loot->bonusLoot*/, item->count, DisplayToastMethod::DISPLAY_TOAST_ENTRY_LOOT_PERSONAL_1);

        return;
    }

    switch (item->item.ItemID)
    {
        case 128956:
            KilledMonsterCredit(97574); //Q: 38669
            break;
        case 132243:
            KilledMonsterCredit(98369); //Q: 38669
            break;
        default:
            break;
    }

    volatile uint32 ItemID = item->item.ItemID;
    volatile uint32 count = item->count;
    volatile uint32 objEntry = loot->objEntry;
    volatile ObjectGuid objGuid = loot->objGuid;

    // TC_LOG_DEBUG(LOG_FILTER_LOOT, "Player::StoreLootItem ItemID %u count %u objEntry %u", ItemID, count, objEntry);
    SpecialLootLogs(loot->LootSourceGuid, ItemID);

    ItemPosCountVec dest;
    InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->item.ItemID, item->count, NULL, bool(qitem));
    if (msg != EQUIP_ERR_OK)
    {
        SendEquipError(msg, NULL, NULL, item->item.ItemID);
        return;
    }

    Item* newitem = StoreNewItem(dest, item->item.ItemID, true, item->item.RandomPropertiesID, item->GetAllowedLooters(), item->item.ItemBonus.BonusListIDs, item->item.ItemBonus.Context);
    if (!newitem)
        return;

    if (qitem)
    {
        qitem->is_looted = true;
        //freeforall is 1 if everyone's supposed to get the quest item.
        if (item->freeforall || loot->GetPlayerQuestItems().size() == 1)
            SendNotifyLootItemRemoved(lootSlot, loot);
        else
            loot->NotifyQuestItemRemoved(qitem->index);
    }
    else
    {
        if (ffaitem)
        {
            //freeforall case, notify only one player of the removal
            ffaitem->is_looted = true;
            SendNotifyLootItemRemoved(lootSlot, loot);
        }
        else
        {
            //not freeforall, notify everyone
            if (conditem)
                conditem->is_looted = true;
            if (loot->personal)
                SendNotifyLootItemRemoved(lootSlot, loot);
            else
                loot->NotifyItemRemoved(lootSlot);
        }
    }

    newitem->dungeonEncounterID = loot->dungeonEncounterID;

    //if only one person is supposed to loot the item, then set it to looted
    if (!item->freeforall)
        item->is_looted = true;

    --loot->unlootedCount;

    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->item.ItemID))
    {
        if (newitem->GetQuality() > ITEM_QUALITY_EPIC || (newitem->GetQuality() == ITEM_QUALITY_EPIC && proto->ItemLevel >= MinNewsItemLevel[CURRENT_EXPANSION]))
            if (Guild* guild = sGuildMgr->GetGuildById(GetGuildId()))
                if (!proto->IsNotAppearInGuildNews())
                    guild->AddGuildNews(GUILD_NEWS_ITEM_LOOTED, GetGUID(), 0, item->item.ItemID, newitem);

        if (loot->personal && newitem->GetQuality() >= uint32(ITEM_QUALITY_UNCOMMON))
            SendDisplayToast(item->item.ItemID, ToastType::ITEM, loot->bonusLoot, item->count, (DisplayToastMethod)newitem->GetDisplayToastMethod(), 0, newitem);
        else if (newitem->GetQuality() >= uint32(ITEM_QUALITY_LEGENDARY))
            SendDisplayToast(item->item.ItemID, ToastType::ITEM, loot->bonusLoot, item->count, (DisplayToastMethod)newitem->GetDisplayToastMethod(), 0, newitem);

        if (proto->GetQuality() == ITEM_QUALITY_LEGENDARY && proto->GetExpansion() == EXPANSION_LEGION)
            m_killPoints = 0.0f;
    }

    SendNewItem(newitem, uint32(item->count), false, false, true, loot->bonusLoot);
    UpdateAchievementCriteria(CRITERIA_TYPE_LOOT_ITEM, item->item.ItemID, item->count);
    UpdateAchievementCriteria(CRITERIA_TYPE_LOOT_TYPE, loot->loot_type, item->count);
    UpdateAchievementCriteria(CRITERIA_TYPE_LOOT_EPIC_ITEM, item->item.ItemID, item->count);

    //AddTrackingQuestIfNeeded(loot->LootSourceGuid);
	sScriptMgr->OnLootItem(this, newitem, item->count);
}

uint8 Player::CalculateTalentsPoints() const
{
    uint8 const* rowLevels = (getClass() != CLASS_DEATH_KNIGHT) ? (getClass() == CLASS_DEMON_HUNTER ? DHTalentRowLevels : DefaultTalentRowLevels) : DKTalentRowLevels;
    for (uint8 i = MAX_TALENT_TIERS; i; --i)
        if (getLevel() >= rowLevels[i - 1])
            return i;

    return 0;
}

void Player::learnSpellHighRank(uint32 spellid)
{
    learnSpell(spellid, false);

    if (uint32 next = sSpellMgr->GetNextSpellInChain(spellid))
        learnSpellHighRank(next);
}

void Player::_LoadSkills(PreparedQueryResult result)
{
    //                                                           0      1      2
    // SetPQuery(PLAYER_LOGIN_QUERY_LOADSKILLS,          "SELECT skill, value, max FROM character_skills WHERE guid = '%u'", GUID_LOPART(m_guid));

    uint32 count = 0;
    uint8 professionCount = 0;
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint16 skill    = fields[0].GetUInt16();
            uint16 value    = fields[1].GetUInt16();
            uint16 max      = fields[2].GetUInt16();

            SkillRaceClassInfoEntry const* rcEntry = sDB2Manager.GetSkillRaceClassInfo(skill, getRace(), getClass());
            if (!rcEntry)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Character %u has skill %u that does not exist.", GetGUIDLow(), skill);
                mSkillStatus.insert(std::make_pair(skill, SkillStatusData(0, SKILL_DELETED)));
                continue;
            }

            // set fixed skill ranges
            switch (GetSkillRangeType(rcEntry))
            {
                case SKILL_RANGE_LANGUAGE:                      // 300..300
                    value = max = 300;
                    break;
                case SKILL_RANGE_MONO:                          // 1..1, grey monolite bar
                    value = max = 1;
                    break;
                case SKILL_RANGE_LEVEL:
                    max = GetMaxSkillValueForLevel();
                default:
                    break;
            }

            if (value == 0)
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Character %u has skill %u with value 0. Will be deleted.", GetGUIDLow(), skill);

                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHARACTER_SKILL);

                stmt->setUInt64(0, GetGUIDLow());
                stmt->setUInt16(1, skill);

                CharacterDatabase.Execute(stmt);

                continue;
            }

            uint16 field = count / 2;
            uint8 offset = count & 1;

            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_ID_OFFSET + field, offset, skill);
            uint16 step = 0;

            SkillLineEntry const* skillLine = sSkillLineStore.LookupEntry(rcEntry->SkillID);
            if (skillLine)
            {
                if (skillLine->CategoryID == SKILL_CATEGORY_SECONDARY)
                    step = max / 75;

                if (skillLine->CategoryID == SKILL_CATEGORY_PROFESSION)
                {
                    step = max / 75;

                    if (professionCount < 2)
                        SetUInt32Value(PLAYER_FIELD_PROFESSION_SKILL_LINE + professionCount++, skill);
                }
            }

            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset, step);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, value);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, max);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset, 0);
            SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset, 0);

            auto insertR = mSkillStatus.insert(std::make_pair(skill, SkillStatusData(count, SKILL_UNCHANGED)));
            if (insertR.second)
                (*mSkillStatusVector)[skill] = &insertR.first->second;

            learnSkillRewardedSpells(skill, value);

            ++count;

            if (count >= PLAYER_MAX_SKILLS)                      // client limit
            {
                TC_LOG_ERROR(LOG_FILTER_PLAYER, "Character %u has more than %u skills.", GetGUIDLow(), PLAYER_MAX_SKILLS);
                break;
            }
        }
        while (result->NextRow());
    }

    for (; count < PLAYER_MAX_SKILLS; ++count)
    {
        uint16 field = count / 2;
        uint8 offset = count & 1;

        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_ID_OFFSET + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_STEP_OFFSET + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_RANK_OFFSET + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_MAX_RANK_OFFSET + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_TEMP_BONUS_OFFSET + field, offset, 0);
        SetUInt16Value(PLAYER_FIELD_SKILL + SKILL_PERM_BONUS_OFFSET + field, offset, 0);
    }

    // special settings
    if (getClass() == CLASS_DEATH_KNIGHT)
    {
        uint8 base_level = std::min<uint8>(getLevel(), 55);
        if (base_level < 1)
            base_level = 1;
        uint16 base_skill = (base_level-1)*5;               // 270 at starting level 55
        if (base_skill < 1)
            base_skill = 1;                                 // skill mast be known and then > 0 in any case

        if (GetPureSkillValue(SKILL_FIRST_AID) < base_skill)
            SetSkill(SKILL_FIRST_AID, 0, base_skill, base_skill);
    }
}

InventoryResult Player::CanEquipUniqueItem(Item* item, uint8 eslot, uint32 limit_count) const
{
    ItemTemplate const* itemTemplate = item->GetTemplate();
    if (InventoryResult res = CanEquipUniqueItem(itemTemplate, eslot, limit_count))
        return res;

    for (ItemDynamicFieldGems const& gemData : item->GetGems())
    {
        ItemTemplate const* gem = sObjectMgr->GetItemTemplate(gemData.ItemId);
        if (!gem)
            continue;

        if (InventoryResult res = CanEquipUniqueItem(gem, eslot, !item->IsEquipped() && gem->GetLimitCategory() ? item->GetGemCountWithLimitCategory(gem->GetLimitCategory()) : 1))
            return res;
    }

    return EQUIP_ERR_OK;
}

InventoryResult Player::CanEquipUniqueItem(ItemTemplate const* itemProto, uint8 except_slot, uint32 limit_count) const
{
    // check unique-equipped on item
    if (itemProto->GetFlags() & ITEM_FLAG_UNIQUE_EQUIPPABLE)
    {
        // there is an equip limit on this item
        if (HasItemOrGemWithIdEquipped(itemProto->GetId(), 1, except_slot))
            return EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE;
    }

    // check unique-equipped limit
    if (itemProto->GetLimitCategory())
    {
        ItemLimitCategoryEntry const* limitEntry = sItemLimitCategoryStore.LookupEntry(itemProto->GetLimitCategory());
        if (!limitEntry)
            return EQUIP_ERR_NOT_EQUIPPABLE;

        // NOTE: limitEntry->mode not checked because if item have have-limit then it applied and to equip case

       //! Legendary items
        uint32 quantity = limitEntry->Quantity;
        if (itemProto->GetLimitCategory() == 357)
        {
			if (sWorld->getBoolConfig(CONFIG_PLAYER_UNLIMITED_LEGION_LEGENDARIES))
				return EQUIP_ERR_OK;

            if (Garrison* garr = const_cast<Player*>(this)->GetGarrisonPtr())
            {
                if (garr->hasLegendLimitUp())
                    ++quantity;
            }

			auto equipLegendaryCount = sWorld->getIntConfig(CONFIG_PLAYER_LEGION_LEGENDARY_EQUIP_COUNT);
			if (equipLegendaryCount > 0)
				quantity += equipLegendaryCount;
        }

        if (limit_count > quantity)
            return EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED_IS;

        // there is an equip limit on this item
        if (HasItemOrGemWithLimitCategoryEquipped(itemProto->GetLimitCategory(), quantity - limit_count + 1, except_slot))
            return itemProto->GetLimitCategory() == 357 ? EQUIP_ERR_ITEM_MAX_LIMIT_CATEGORY_EQUIPPED_EXCEEDED_IS : EQUIP_ERR_ITEM_MAX_COUNT_EQUIPPED_SOCKETED;
    }

    return EQUIP_ERR_OK;
}

void Player::SetFallInformation(uint32 time, float z)
{
    m_lastFallTime = time;
    m_lastFallZ = z;
}

void Player::HandleFall(MovementInfo const& movementInfo)
{
    // calculate total z distance of the fall
    float z_diff = m_lastFallZ - movementInfo.Pos.GetPositionZ();
    //TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "zDiff = %f", z_diff);

    //Players with low fall distance, Feather Fall or physical immunity (charges used) are ignored
    // 14.57 can be calculated by resolving damageperc formula below to 0
    if (z_diff >= 14.57f && !isDead() && !isGameMaster() && !IsSpectator() &&
        !HasAuraType(SPELL_AURA_HOVER) && !HasAuraType(SPELL_AURA_FEATHER_FALL) &&
        !HasAuraType(SPELL_AURA_FLY) && !IsImmunedToDamage(SPELL_SCHOOL_MASK_NORMAL))
    {
        //Safe fall, fall height reduction
        int32 safe_fall = GetTotalAuraModifier(SPELL_AURA_SAFE_FALL);

        float damageperc = (0.018f*(z_diff-safe_fall)-0.2426f) * GetTotalAuraMultiplier(SPELL_AURA_MOD_FALL_DAMAGE);

        if (damageperc > 0)
        {
            uint32 damage = (uint32)(damageperc * GetMaxHealth()*sWorld->getRate(RATE_DAMAGE_FALL));

            float height = movementInfo.Pos.m_positionZ;
            UpdateGroundPositionZ(movementInfo.Pos.m_positionX, movementInfo.Pos.m_positionY, height);

            if (damage > 0)
            {
                //Prevent fall damage from being more than the player maximum health
                if (damage > GetMaxHealth())
                    damage = GetMaxHealth();

                // Gust of Wind
                if (HasAura(43621))
                    damage = GetMaxHealth()/2;

                uint32 original_health = GetHealth();
                uint32 final_damage = EnvironmentalDamage(DAMAGE_FALL, damage);

                // recheck alive, might have died of EnvironmentalDamage, avoid cases when player die in fact like Spirit of Redemption case
                if (isAlive() && final_damage < original_health)
                    UpdateAchievementCriteria(CRITERIA_TYPE_FALL_WITHOUT_DYING, uint32(z_diff*100));
            }

            //Z given by moveinfo, LastZ, FallTime, WaterZ, MapZ, Damage, Safefall reduction
            TC_LOG_DEBUG(LOG_FILTER_NETWORKIO, "FALLDAMAGE z=%f sz=%f pZ=%f FallTime=%d mZ=%f damage=%d SF=%d", movementInfo.Pos.GetPositionZ(), height, GetPositionZ(), movementInfo.fall.fallTime, height, damage, safe_fall);
        }
    }
    RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_LANDING); // No fly zone - Parachute
    //RemoveAllAurasByType(SPELL_AURA_CAN_TURN_WHILE_FALLING);
}

void Player::UpdateAchievementCriteria(CriteriaTypes type, uint32 miscValue1 /*= 0*/, uint32 miscValue2 /*= 0*/, uint32 miscValue3 /*= 0*/, Unit* unit /*= NULL*/, bool ignoreGroup /*=false*/)
{
    AchievementCachePtr referenceCache = std::make_shared<AchievementCache>(this, unit, type, miscValue1, miscValue2, miscValue3);

    Map* map = GetMap();
    m_achievementMgr->UpdateAchievementCriteria(referenceCache);

    // Collect for legendary drop KP
    if (map && map->GetEntry()->ExpansionID == EXPANSION_LEGION)
    {
        switch (type)
        {
            case CRITERIA_TYPE_USE_GAMEOBJECT:
            {
                GameObjectTemplate const* goinfo = sObjectMgr->GetGameObjectTemplate(miscValue1);
                if (goinfo && goinfo->chest.chestPersonalLoot)
                    m_killPoints += 0.002f;
                if (goinfo && goinfo->IsOploteChest())
                    m_killPoints += 15.0f;
                break;
            }
            case CRITERIA_TYPE_KILL_CREATURE:
            {
                m_killPoints += 0.002f;
                if (unit)
                    if (Creature const* creature = unit->ToCreature())
                        if (uint32 questId = creature->GetTrackingQuestID())
                            if(!IsQuestRewarded(questId))
                                m_killPoints += 1.0f;
                break;
            }
            case CRITERIA_TYPE_WIN_ARENA:
                m_killPoints += 0.1f;
                break;
            case CRITERIA_TYPE_WIN_BG:
            case CRITERIA_TYPE_WIN_BATTLEGROUND:
                m_killPoints += 1.0f;
                break;
            case CRITERIA_TYPE_COMPLETE_DUNGEON_ENCOUNTER:
            {
                float addKillPoints = 0.0f;
                switch(map->GetDifficultyID())
                {
                    case DIFFICULTY_LFR_RAID:
                        addKillPoints = 2.0f;
                        break;
                    case DIFFICULTY_NONE: // For world boss
                    case DIFFICULTY_NORMAL_RAID:
                        addKillPoints = 3.0f;
                        break;
                    case DIFFICULTY_HEROIC_RAID:
                        addKillPoints = 4.0f;
                        break;
                    case DIFFICULTY_MYTHIC_RAID:
                        addKillPoints = 6.0f;
                        break;
                    default:
                        break;
                }
                if (unit)
                {
                    if (Creature const* creature = unit->ToCreature())
                    {
                        if(creature->IsPersonal())
                        {
                            uint32 cooldownid = creature->GetEntry();
                            uint32 cooldowntype = TYPE_CREATURE;
                            if(PersonalLootData const* plData = sObjectMgr->GetPersonalLootData(creature->GetEntry(), cooldowntype))
                            {
                                if(plData->cooldownid)
                                {
                                    cooldownid = plData->cooldownid;
                                    cooldowntype = plData->cooldowntype;
                                }
                            }
                            if (IsPlayerLootCooldown(cooldownid, cooldowntype, map->GetDifficultyID()))
                                addKillPoints = 0.0f;
                        }
                        AddKillCreature(creature->GetEntry(), 1, true);
                    }
                }
                m_killPoints += addKillPoints;
                break;
            }
            case CRITERIA_TYPE_COMPLETE_SCENARIO:
            {
                switch(GetMap()->GetDifficultyID())
                {
                    case DIFFICULTY_NORMAL:
                    case DIFFICULTY_HEROIC:
                        m_killPoints += 2.0f;
                        break;
                    case DIFFICULTY_MYTHIC_DUNGEON:
                        m_killPoints += 3.0f;
                        break;
                    case DIFFICULTY_MYTHIC_KEYSTONE:
                        m_killPoints += 4.0f;
                        break;
                    default:
                        break;
                }
                break;
            }
            case CRITERIA_TYPE_COMPLETE_WORLD_QUEST:
            {
                if (miscValue2 == QUEST_INFO_EMISSARY_QUEST)
                    m_killPoints += 4.0f;
                break;
            }
        }
    }

    // Update only individual achievement criteria here, otherwise we may get multiple updates
    // from a single boss kill
    if (!ignoreGroup && sAchievementMgr->IsGroupCriteriaType(type))
        return;

    // Update scenario/challenge criterias
    if (uint32 instanceId =  map && InInstance() ? map->GetInstanceId() : 0)
        if (Scenario* progress = sScenarioMgr->GetScenario(instanceId))
            progress->GetAchievementMgr().UpdateAchievementCriteria(referenceCache);

    // Update only individual achievement criteria here, otherwise we may get multiple updates
    if (Guild* guild = sGuildMgr->GetGuildById(GetGuildId()))
        if (type != CRITERIA_TYPE_GAIN_REPUTATION)
            guild->GetAchievementMgr().UpdateAchievementCriteria(referenceCache);
}

void Player::CompletedAchievement(AchievementEntry const* entry)
{
    m_achievementMgr->CompletedAchievement(entry, this);
}

bool Player::HasAchieved(uint32 achievementId)
{
    if (m_session && m_session->HasAchievement(achievementId))
        return true;
    return m_achievementMgr->HasAchieved(achievementId, GetGUIDLow());
}

uint32 Player::GetAchievementPoints() const
{
    return m_achievementMgr->GetAchievementPoints();
}

// TODO : Check cheat-hack issue with packet-editing
bool Player::LearnTalent(uint32 talentId)
{
    WorldPackets::Talent::LearnTalentFailed failed;
    failed.Talent.SpecID = GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID);
    failed.Talent.TalentIDs.push_back(talentId);
    TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentId);
    if (!talentInfo)
    {
        failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::CantRemoveTalent;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (isDead())
    {
        failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::CantDoThatRightNow;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (isInCombat())
    {
        failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::AffectingCombat;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (HasAura(ChallengersBurden))
    {
        failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::ChallengeModeActive;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (talentInfo->SpecID && talentInfo->SpecID != GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID))
    {
        TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::LearnTalent SpecID %u GetSpecializationId %u", talentInfo->SpecID, GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID));
        failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::CantDoThatRightNow;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (talentInfo->ClassID != getClass())
    {
        TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::LearnTalent ClassID %u getClass %u", talentInfo->ClassID, getClass());
        failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::CantDoThatRightNow;
        SendDirectMessage(failed.Write());
        return false;
    }

    // check if we have enough talent points
    if (talentInfo->TierID >= GetUInt32Value(PLAYER_FIELD_MAX_TALENT_TIERS) || talentInfo->TierID > MAX_TALENT_TIERS)
    {
        failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::NotEnoughTalentInPrimaryTree;
        SendDirectMessage(failed.Write());
        return false;
    }

    TalentEntry const* bestSlotMatch = nullptr;
    for (TalentEntry const* talent : sDB2Manager._talentByPos[getClass()][talentInfo->TierID][talentInfo->ColumnIndex])
    {
        if (!talent->SpecID)
            bestSlotMatch = talent;
        else if (talent->SpecID == GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID))
        {
            bestSlotMatch = talent;
            break;
        }
    }

    if (talentInfo != bestSlotMatch)
    {
        TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::LearnTalent talentInfo != bestSlotMatch");
        failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::CantDoThatRightNow;
        SendDirectMessage(failed.Write());
        return false;
    }

    for (uint32 c = 0; c < MAX_TALENT_COLUMNS; ++c)
        for (TalentEntry const* talent : sDB2Manager._talentByPos[getClass()][talentInfo->TierID][c])
            if (HasTalent(talent->ID, GetActiveTalentGroup()))
            {
                if (!HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) && !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHANGING_TALENTS))
                {
                    failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::RestArea;
                    SendDirectMessage(failed.Write());
                    return false;
                }

                if (HasSpellCooldown(talent->SpellID))
                {
                    failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::CantRemoveTalent;
                    SendDirectMessage(failed.Write());
                    return false;
                }

                RemoveTalent(talent);
            }

    if (!talentInfo->SpellID)
    {
        TC_LOG_ERROR(LOG_FILTER_PLAYER, "Talent.db2 have for talent: %uspell id = 0", talentId);

        failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::CantRemoveTalent;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (HasTalent(talentId, GetActiveTalentGroup()) || HasSpell(talentInfo->SpellID))
    {
        TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::LearnTalent HasTalent %u HasSpell %u", HasTalent(talentId, GetActiveTalentGroup()), HasSpell(talentInfo->SpellID));
        failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::CantDoThatRightNow;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (!AddTalent(talentInfo, GetActiveTalentGroup(), true))
    {
        TC_LOG_DEBUG(LOG_FILTER_SPELLS_AURAS, "Player::LearnTalent !AddTalent");
        failed.Talent.Reason = WorldPackets::Talent::LearnTalentReasons::CantDoThatRightNow;
        SendDirectMessage(failed.Write());
        return false;
    }
    
    learnSpell(talentInfo->SpellID, false);

    TC_LOG_INFO(LOG_FILTER_GENERAL, "TalentID: %u Spell: %u Spec: %u\n", talentId, talentInfo->SpellID, GetActiveTalentGroup());
    return true;
}

bool Player::LearnPvpTalent(uint16 talentID)
{
    WorldPackets::Talent::LearnPvPTalentFailed failed;
    failed.PvPTalent.SpecID = GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID);
    failed.PvPTalent.TalentIDs.push_back(talentID);
    auto talentInfo = sPvpTalentStore.LookupEntry(talentID);
    if (!talentInfo)
    {
        failed.PvPTalent.Reason = WorldPackets::Talent::LearnTalentReasons::CantRemoveTalent;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (isInCombat())
    {
        failed.PvPTalent.Reason = WorldPackets::Talent::LearnTalentReasons::AffectingCombat;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (!GetPrestigeLevel() && sDB2Manager.GetRequiredHonorLevelForPvpTalent(talentInfo) > m_honorInfo.HonorLevel)
    {
        failed.PvPTalent.Reason = WorldPackets::Talent::LearnTalentReasons::NotEnoughTalentInPrimaryTree;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (talentInfo->SpecID && talentInfo->SpecID != GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID))
    {
        failed.PvPTalent.Reason = WorldPackets::Talent::LearnTalentReasons::CantDoThatRightNow;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (talentInfo->ClassID && talentInfo->ClassID != getClass())
    {
        failed.PvPTalent.Reason = WorldPackets::Talent::LearnTalentReasons::CantDoThatRightNow;
        SendDirectMessage(failed.Write());
        return false;
    }

    for (uint32 c = 0; c < MAX_TALENT_COLUMNS; ++c)
        for (auto const& talent : sDB2Manager.GetPvpTalentByPosition(getClass(), talentInfo->TierID, c))
            if (HasPvPTalent(talent->SpellID))
            {
                if (!HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_RESTING) && !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHANGING_TALENTS))
                {
                    failed.PvPTalent.Reason = WorldPackets::Talent::LearnTalentReasons::CantDoThatRightNow;
                    SendDirectMessage(failed.Write());
                    return false;
                }

                if (HasSpellCooldown(talent->SpellID))
                {
                    failed.PvPTalent.Reason = WorldPackets::Talent::LearnTalentReasons::CantRemoveTalent;
                    SendDirectMessage(failed.Write());
                    return false;
                }
                RemovePvPTalent(talent->SpellID, GetActiveTalentGroup(), true, false);
            }

    if (!talentInfo->SpellID)
    {
        failed.PvPTalent.Reason = WorldPackets::Talent::LearnTalentReasons::CantRemoveTalent;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (HasAura(ChallengeSpells::ChallengersBurden))
    {
        failed.PvPTalent.Reason = WorldPackets::Talent::LearnTalentReasons::ChallengeModeActive;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (!AddPvPTalent(talentInfo, GetActiveTalentGroup()))
    {
        failed.PvPTalent.Reason = WorldPackets::Talent::LearnTalentReasons::CantDoThatRightNow;
        SendDirectMessage(failed.Write());
        return false;
    }

    if (HasPvpRulesEnabled())
    {
        if (talentInfo->OverrideSpellID)
            AddOverrideSpell(talentInfo->OverrideSpellID, talentInfo->SpellID);

        learnSpell(talentInfo->SpellID, true);
    }

	// Remove Hunter's Wild Protector buff if pet is active and player has changed pvp talent
	if(GetSpecializationId() == SPEC_HUNTER_BEASTMASTER && GetEffectiveLevel() >= 110)
		if (!HasPvPTalent(204190))
			if (Pet* pet = GetPet())
				pet->RemoveAurasDueToSpell(204358);

    return true;
}

void Player::ResetTalentSpecialization()
{
    uint32 class_ = getClass();
    for (uint8 t = 0; t < MAX_TALENT_TIERS; ++t)
        for (uint8 c = 0; c < MAX_TALENT_COLUMNS; ++c)
            if (sDB2Manager._talentByPos[class_][t][c].size() > 1)
                for (TalentEntry const* talent : sDB2Manager._talentByPos[class_][t][c])
                    RemoveTalent(talent, true, true, true);

    RemoveAllPvPTalent();
    RemoveSpecializationSpells();

    if (getLevel() < 10)
    {
        ChrSpecializationEntry const* defaultSpec = ASSERT_NOTNULL(sDB2Manager.GetDefaultChrSpecializationForClass(getClass()));
        SetPrimarySpecialization(defaultSpec->ID);
        SetActiveTalentGroup(defaultSpec->OrderIndex);
        SetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID, defaultSpec->ID);
    }

    LearnSpecializationSpells();

    SendTalentsInfoData(false);
    InitialPowers();
    _ApplyOrRemoveItemEquipDependentAuras(ObjectGuid::Empty, false);
}

void Player::UpdateFallInformationIfNeed(MovementInfo const& minfo, uint16 opcode)
{
    if (m_lastFallTime >= minfo.fall.fallTime || m_lastFallZ <= minfo.Pos.GetPositionZ() || opcode == CMSG_MOVE_FALL_LAND)
        SetFallInformation(minfo.fall.fallTime, minfo.Pos.GetPositionZ());
}

void Player::UnsummonPetTemporaryIfAny()
{
    Pet* pet = GetPet();
    if (!pet)
        return;

    if (!m_temporaryUnsummonedPetNumber && pet->isControlled() && !pet->isTemporarySummoned())
    {
        m_temporaryUnsummonedPetNumber = pet->GetCharmInfo()->GetPetNumber();
        m_oldpetspell = pet->GetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL);
    }

    RemovePet(pet);
}

void Player::ResummonPetTemporaryUnSummonedIfAny()
{
    if (!m_temporaryUnsummonedPetNumber)
        return;

    if (IsSpectator())
        return;

    // not resummon in not appropriate state
    if (IsPetNeedBeTemporaryUnsummoned())
        return;

    if (GetPetGUID())
        return;

    Pet* NewPet = new Pet(this);

    if (!NewPet->LoadPetFromDB(this, 0, m_temporaryUnsummonedPetNumber))
        delete NewPet;

    m_temporaryUnsummonedPetNumber = 0;
}

bool Player::canSeeSpellClickOn(Creature const* c) const
{
    if (!c->HasFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK))
        return false;

    SpellClickInfoMapBounds clickPair = sObjectMgr->GetSpellClickInfoMapBounds(c->GetEntry());
    if (clickPair.first == clickPair.second)
        return true;

    bool res = true;
    for (SpellClickInfoContainer::const_iterator itr = clickPair.first; itr != clickPair.second; ++itr)
    {
        if (!itr->second.IsFitToRequirements(this, c))
        {
            res = false;
            continue;
        }

        ConditionList conds = sConditionMgr->GetConditionsForSpellClickEvent(c->GetEntry(), itr->second.spellId);
        ConditionSourceInfo info = ConditionSourceInfo(const_cast<Player*>(this), const_cast<Creature*>(c));
        if (!sConditionMgr->IsObjectMeetToConditions(info, conds))
        {
            res = false;
            continue;
        }

        return true;
    }

    return res;
}

void Player::SendTalentsInfoData(bool pet)
{
    if (pet)
    {
        Pet* pPet = GetPet();
        SendDirectMessage(WorldPackets::PetPackets::SetPetSpecialization(pPet ? pPet->GetSpecializationId() : 0).Write());
        return;
    }

    WorldPackets::Talent::UpdateTalentData packet;
    //packet.Info.ActiveGroup = GetActiveTalentGroup();
    packet.Info.ActiveSpecID = GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID);

    WorldPackets::Talent::TalentGroupInfo groupInfoPkt;
    groupInfoPkt.SpecID = GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID);

    for (auto const& v : *GetTalentMap(GetActiveTalentGroup()))
    {
        if (v.second == PLAYERSPELL_REMOVED)
            continue;

        TalentEntry const* talentInfo = sTalentStore.LookupEntry(v.first);
        if (!talentInfo)
            continue;

        if (talentInfo->ClassID != getClass())
            continue;

        if (!sSpellMgr->GetSpellInfo(talentInfo->SpellID))
            continue;

        groupInfoPkt.TalentIDs.push_back(uint16(v.first));
    }

    for (auto const& v : *GetPvPTalentMap(GetActiveTalentGroup()))
        if (v.second != PLAYERSPELL_REMOVED)
            if (auto const& talentEntry = sDB2Manager.GetPvpTalentBySpellID(v.first))
                groupInfoPkt.PvPTalentIDs.push_back(uint16(talentEntry->ID));

    packet.Info.TalentGroups.push_back(groupInfoPkt);

    SendDirectMessage(packet.Write());
}

void Player::SendEquipmentSetList()
{
    WorldPackets::EquipmentSet::LoadEquipmentSet data;

    for (auto const& eqSet : _equipmentSets)
        if (eqSet.second.State != EQUIPMENT_SET_DELETED)
            data.SetData.push_back(&eqSet.second.Data);

    SendDirectMessage(data.Write());
}

void Player::SetEquipmentSet(EquipmentSetInfo::EquipmentSetData const& newEqSet)
{
    if (newEqSet.Guid != 0)
    {
        EquipmentSetInfo& eqSlot = _equipmentSets[newEqSet.Guid];
        EquipmentSetUpdateState oldState = eqSlot.State;
        eqSlot.Data = newEqSet;
        EquipmentSetContainer::const_iterator itr = _equipmentSets.find(newEqSet.SetID);
        if (itr == _equipmentSets.end() || itr->second.Data.Guid != newEqSet.Guid)
        {
            eqSlot.State = EQUIPMENT_SET_CHANGED;
            return;
        }
    }

    EquipmentSetInfo& eqSlot = _equipmentSets[newEqSet.Guid];
    EquipmentSetUpdateState oldState = eqSlot.State;
    eqSlot.Data = newEqSet;
    if (eqSlot.Data.Guid == 0)
    {
        eqSlot.Data.Guid = sObjectMgr->GenerateEquipmentSetGuid();

        WorldPackets::EquipmentSet::EquipmentSetID data;
        data.GUID = eqSlot.Data.Guid;
        data.SetID = eqSlot.Data.SetID;
        data.Type = eqSlot.Data.Type;
        SendDirectMessage(data.Write());
    }

    eqSlot.State = oldState == EQUIPMENT_SET_NEW ? EQUIPMENT_SET_NEW : EQUIPMENT_SET_CHANGED;
}

void Player::_SaveEquipmentSets(SQLTransaction& trans)
{
    for (EquipmentSetContainer::iterator itr = _equipmentSets.begin(); itr != _equipmentSets.end();)
    {
        EquipmentSetInfo& eqSet = itr->second;
        PreparedStatement* stmt = nullptr;
        uint8 j = 0;
        switch (eqSet.State)
        {
            case EQUIPMENT_SET_UNCHANGED:
                ++itr;
                break;
            case EQUIPMENT_SET_CHANGED:
            {
                if (eqSet.Data.Type == EquipmentSetInfo::EQUIPMENT)
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_EQUIP_SET);
                    stmt->setString(j++, eqSet.Data.SetName);
                    stmt->setString(j++, eqSet.Data.SetIcon);
                    stmt->setUInt32(j++, eqSet.Data.IgnoreMask);
                    stmt->setInt32(j++, eqSet.Data.AssignedSpecIndex);
                    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; ++i)
                        stmt->setUInt64(j++, eqSet.Data.Pieces[i].GetCounter());
                    stmt->setUInt64(j++, GetGUID().GetCounter());
                    stmt->setUInt64(j++, eqSet.Data.Guid);
                    stmt->setUInt32(j, eqSet.Data.SetID);
                }
                else
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_TRANSMOG_OUTFIT);
                    stmt->setString(j++, eqSet.Data.SetName);
                    stmt->setString(j++, eqSet.Data.SetIcon);
                    stmt->setUInt32(j++, eqSet.Data.IgnoreMask);
                    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; ++i)
                        stmt->setInt32(j++, eqSet.Data.Appearances[i]);
                    for (std::size_t i = 0; i < eqSet.Data.Enchants.size(); ++i)
                        stmt->setInt32(j++, eqSet.Data.Enchants[i]);
                    stmt->setUInt64(j++, GetGUID().GetCounter());
                    stmt->setUInt64(j++, eqSet.Data.Guid);
                    stmt->setUInt32(j, eqSet.Data.SetID);
                }
                trans->Append(stmt);
                eqSet.State = EQUIPMENT_SET_UNCHANGED;
                ++itr;
                break;
            }
            case EQUIPMENT_SET_NEW:
            {
                if (eqSet.Data.Type == EquipmentSetInfo::EQUIPMENT)
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_EQUIP_SET);
                    stmt->setUInt64(j++, GetGUID().GetCounter());
                    stmt->setUInt64(j++, eqSet.Data.Guid);
                    stmt->setUInt32(j++, eqSet.Data.SetID);
                    stmt->setString(j++, eqSet.Data.SetName);
                    stmt->setString(j++, eqSet.Data.SetIcon);
                    stmt->setUInt32(j++, eqSet.Data.IgnoreMask);
                    stmt->setInt32(j++, eqSet.Data.AssignedSpecIndex);
                    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; ++i)
                        stmt->setUInt64(j++, eqSet.Data.Pieces[i].GetCounter());
                }
                else
                {
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_TRANSMOG_OUTFIT);
                    stmt->setUInt64(j++, GetGUID().GetCounter());
                    stmt->setUInt64(j++, eqSet.Data.Guid);
                    stmt->setUInt32(j++, eqSet.Data.SetID);
                    stmt->setString(j++, eqSet.Data.SetName);
                    stmt->setString(j++, eqSet.Data.SetIcon);
                    stmt->setUInt32(j++, eqSet.Data.IgnoreMask);
                    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; ++i)
                        stmt->setInt32(j++, eqSet.Data.Appearances[i]);
                    for (std::size_t i = 0; i < eqSet.Data.Enchants.size(); ++i)
                        stmt->setInt32(j++, eqSet.Data.Enchants[i]);
                }
                trans->Append(stmt);
                eqSet.State = EQUIPMENT_SET_UNCHANGED;
                ++itr;
                break;
            }
            case EQUIPMENT_SET_DELETED:
                if (eqSet.Data.Type == EquipmentSetInfo::EQUIPMENT)
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_EQUIP_SET);
                else
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_TRANSMOG_OUTFIT);
                stmt->setUInt64(0, eqSet.Data.Guid);
                trans->Append(stmt);
                itr = _equipmentSets.erase(itr);
                break;
        }
    }
}

void Player::_SaveBGData(SQLTransaction& trans)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_BGDATA);
    stmt->setUInt64(0, GetGUIDLow());
    trans->Append(stmt);
    /* guid, bgInstanceID, bgTeam, x, y, z, o, map, taxi[0], taxi[1], mountSpell */
    stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_PLAYER_BGDATA);
    stmt->setUInt64(0, GetGUIDLow());
    stmt->setUInt32(1, m_bgData.BgInstanceID);
    stmt->setUInt16(2, m_bgData.BgTeam);
    stmt->setFloat (3, m_bgData.JoinPosition.GetPositionX());
    stmt->setFloat (4, m_bgData.JoinPosition.GetPositionY());
    stmt->setFloat (5, m_bgData.JoinPosition.GetPositionZ());
    stmt->setFloat (6, m_bgData.JoinPosition.GetOrientation());
    stmt->setUInt16(7, m_bgData.JoinPosition.GetMapId());
    stmt->setUInt16(8, m_bgData.TaxiPath[0]);
    stmt->setUInt16(9, m_bgData.TaxiPath[1]);
    stmt->setUInt16(10, m_bgData.MountSpellID);
    stmt->setUInt16(11, m_bgData.LastActiveSpecID);
    trans->Append(stmt);
}

void Player::DeleteEquipmentSet(uint64 setGuid)
{
    for (EquipmentSetContainer::iterator itr = _equipmentSets.begin(); itr != _equipmentSets.end(); ++itr)
    {
        if (itr->second.Data.Guid == setGuid)
        {
            if (itr->second.State == EQUIPMENT_SET_NEW)
                _equipmentSets.erase(itr);
            else
                itr->second.State = EQUIPMENT_SET_DELETED;
            break;
        }
    }
}

void Player::RemoveAtLoginFlag(AtLoginFlags flags, bool persist /*= false*/)
{
    m_atLoginFlags &= ~flags;

    if (persist)
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_REM_AT_LOGIN_FLAG);

        stmt->setUInt16(0, uint16(flags));
        stmt->setUInt64(1, GetGUIDLow());

        CharacterDatabase.Execute(stmt);
    }
}

void Player::SendClearCooldown(uint32 spellID, Unit* target)
{
    WorldPackets::Spells::ClearCooldown cooldown;
    cooldown.IsPet = target->isPet();
    cooldown.SpellID = spellID;
    cooldown.ClearOnHold = target == this;
    SendDirectMessage(cooldown.Write());
}

void Player::ResetMap()
{
    // this may be called during Map::Update
    // after decrement+unlink, ++m_mapRefIter will continue correctly
    // when the first element of the list is being removed
    // nocheck_prev will return the padding element of the RefManager
    // instead of NULL in the case of prev
    GetMap()->UpdateIteratorBack(this);
    Unit::ResetMap();
    GetMapRef().unlink();

    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
        if (m_items[i])
            m_items[i]->ResetMap();
}

void Player::SetMap(Map* map)
{
    Unit::SetMap(map);
    m_mapRef.link(map, this);

    for (uint8 i = PLAYER_SLOT_START; i < PLAYER_SLOT_END; ++i)
        if (m_items[i])
            m_items[i]->SetMap(map);
}

void Player::_LoadGlyphs(PreparedQueryResult result)
{
    // SELECT talentGroup, glyphId from character_glyphs WHERE guid = ?
    if (!result)
        return;

    do
    {
        Field* fields = result->Fetch();

        uint8 spec = fields[0].GetUInt8();
        if (spec >= MAX_SPECIALIZATIONS || !sDB2Manager.GetChrSpecializationByIndex(getClass(), spec))
            continue;

        uint16 glyphId = fields[1].GetUInt16();
        if (!sGlyphPropertiesStore.LookupEntry(glyphId))
            continue;

        GetGlyphs(spec).push_back(glyphId);

    } while (result->NextRow());
}

void Player::_SaveGlyphs(SQLTransaction& trans)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_GLYPHS);
    stmt->setUInt64(0, GetGUID().GetCounter());
    trans->Append(stmt);

    for (uint8 spec = 0; spec < MAX_SPECIALIZATIONS; ++spec)
    {
        for (uint32 glyphId : GetGlyphs(spec))
        {
            uint8 index = 0;

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_GLYPHS);
            stmt->setUInt64(index++, GetGUID().GetCounter());
            stmt->setUInt8(index++, spec);
            stmt->setUInt16(index++, uint16(glyphId));

            trans->Append(stmt);
        }
    }
}

void Player::_LoadTalents(PreparedQueryResult result, PreparedQueryResult result2)
{
    if (result)
    {
        do
            if (TalentEntry const* talent = sTalentStore.LookupEntry((*result)[0].GetUInt32()))
                AddTalent(talent, (*result)[1].GetUInt8(), false);
        while (result->NextRow());
    }

    if (result2)
    {
        do
            if (auto const& talentEntry = sDB2Manager.GetPvpTalentBySpellID((*result2)[0].GetUInt32()))
                AddPvPTalent(talentEntry, (*result2)[1].GetUInt8());
        while (result2->NextRow());
    }
}

void Player::_SaveTalents(SQLTransaction& trans)
{
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT);
    stmt->setUInt64(0, GetGUIDLow());
    trans->Append(stmt);

    PlayerTalentMap* talents = nullptr;
    for (uint8 group = 0; group < MAX_SPECIALIZATIONS; ++group)
    {
        talents = GetTalentMap(group);
        for (PlayerTalentMap::iterator itr = talents->begin(); itr != talents->end();)
        {
            if (itr->second == PLAYERSPELL_REMOVED)
            {
                itr = talents->erase(itr);
                continue;
            }

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_TALENT);
            stmt->setUInt64(0, GetGUIDLow());
            stmt->setUInt32(1, itr->first);
            stmt->setUInt8(2, group);
            trans->Append(stmt);
            ++itr;
        }
    }

    stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_CHAR_TALENT_PVP);
    stmt->setUInt64(0, GetGUIDLow());
    trans->Append(stmt);

    for (uint8 group = 0; group < MAX_SPECIALIZATIONS; ++group)
    {
        PlayerPvPTalentMap* talentPvps = GetPvPTalentMap(group);
        for (PlayerPvPTalentMap::iterator itr = talentPvps->begin(); itr != talentPvps->end();)
        {
            if (itr->second == PLAYERSPELL_REMOVED)
            {
                itr = talentPvps->erase(itr);
                continue;
            }

            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHAR_TALENT_PVP);
            stmt->setUInt64(0, GetGUIDLow());
            stmt->setUInt32(1, itr->first);
            stmt->setUInt8(2, group);
            trans->Append(stmt);
            ++itr;
        }
    }
}

void Player::ActivateTalentGroup(ChrSpecializationEntry const* spec)
{
    if (GetActiveTalentGroup() == spec->OrderIndex)
        return;

    if (IsNonMeleeSpellCast(false))
        InterruptNonMeleeSpells(false);

    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    _SaveActions(trans);
    CharacterDatabase.CommitTransaction(trans);

    // TO-DO: We need more research to know what happens with warlock's reagent
    if (Pet* pet = GetPet())
        RemovePet(pet);

    ClearAllReactives();
    UnsummonAllTotems();
    ExitVehicle();
    RemoveAllControlled();
    RemoveAllAurasOnDeath();
    if (GetPet())
        GetPet()->RemoveAllAurasOnDeath();

    RemoveMultiSingleTargetAuras();
    //RemoveAllAuras(GetGUID(), NULL, false, true); // removes too many auras
    //ExitVehicle(); // should be impossible to switch specs from inside a vehicle..

    // Let client clear his current Actions
    SendActionButtons(2);
    // m_actionButtons.clear() is called in the next _LoadActionButtons

    SendDirectMessage(WorldPackets::Spells::SendUnlearnSpells().Write());

    for (TalentEntry const* talentInfo : sTalentStore)
        if (talentInfo->ClassID == getClass() && talentInfo->SpellID)
            RemoveTalent(talentInfo, false, false);

    RemoveAllPvPTalent(false);

    if (const std::vector<SpellTalentLinked> *spell_triggered = sSpellMgr->GetSpelltalentLinked(0))
    {
        for (std::vector<SpellTalentLinked>::const_iterator i = spell_triggered->begin(); i != spell_triggered->end(); ++i)
        {
            Unit* target = ToUnit();
            Unit* caster = ToUnit();

            if(i->caster == 1)
                if (Pet* pet = GetPet())
                    caster = pet->ToUnit();
            if(i->target == 1)
                if (Pet* pet = GetPet())
                    target = pet->ToUnit();

            switch (i->type)
            {
                case 0: //remove or add auras
                {
                    if (i->triger < 0)
                        target->RemoveAurasDueToSpell(-(i->triger));
                    else
                        caster->CastSpell(target, i->triger, true);
                    break;
                }
                case 1: //remove or add spell
                {
                    if (i->triger < 0)
                        removeSpell(-(i->triger), false, true, false);
                    else
                        learnSpell(i->triger, false, 0, false);
                    break;
                }
                case 2: //remove pet
                {
                    RemovePet(NULL);
                    m_currentPetNumber = 0;
                    m_temporaryUnsummonedPetNumber = 0;
                    break;
                }
                case 4: // Remove summons
                {
                    if (SpellInfo const* _spellInfo = sSpellMgr->GetSpellInfo(i->triger))
                    {
                        for (int i = 0; i < MAX_SPELL_EFFECTS; ++i)
                        {
                            if (_spellInfo->EffectMask < uint32(1 << i))
                                break;

                            if (_spellInfo->Effects[i]->Effect != SPELL_EFFECT_SUMMON)
                                continue;

                            RemoveAllMinionsByFilter(_spellInfo->Effects[i]->MiscValue);
                        }
                    }
                    break;
                }
                case 5: //remove my aura
                {
                    RemoveMyAurasDueToSpell(abs(i->triger));
                    break;
                }
            }
        }
    }

    RemoveSpecializationSpells();

    for (uint32 glyphId : GetGlyphs(GetActiveTalentGroup()))
        RemoveAurasDueToSpell(sGlyphPropertiesStore.AssertEntry(glyphId)->SpellID);

    SetActiveTalentGroup(spec->OrderIndex);
    SetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID, spec->ID);
    if (!GetPrimarySpecialization())
        SetPrimarySpecialization(spec->ID);

    for (TalentEntry const* talentInfo : sTalentStore)
    {
        if (talentInfo->ClassID != getClass())
            continue;

        if (!talentInfo->SpellID)
            continue;

        if (HasTalent(talentInfo->ID, GetActiveTalentGroup()))
        {
            learnSpell(talentInfo->SpellID, false);
            if (talentInfo->OverridesSpellID)
                AddOverrideSpell(talentInfo->OverridesSpellID, talentInfo->SpellID);
        }
    }

    SetCreateMana(sObjectMgr->GetPlayerClassLevelInfo(getClass(), GetEffectiveLevel()));

    LearnSpecializationSpells();

    SendKnownSpells();
    SendDirectMessage(WorldPackets::Spells::SendUnlearnSpells().Write());

    InitTalentForLevel();
    _ApplyOrRemoveItemEquipDependentAuras(ObjectGuid::Empty, false);

    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_CHARACTER_ACTIONS_SPEC);
    stmt->setUInt64(0, GetGUIDLow());
    stmt->setUInt8(1, GetActiveTalentGroup());
    if (PreparedQueryResult result = CharacterDatabase.Query(stmt))
        _LoadActions(result);

    SendActionButtons(1);
    InitialPowers();

    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (Item* equippedItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (CanUseItem(equippedItem) != EQUIP_ERR_OK)
            {
                if (equippedItem->GetTemplate()->GetArtifactID())
                {
                    if (ItemChildEquipmentEntry const* childItemEntry = sDB2Manager.GetItemChildEquipment(equippedItem->GetEntry()))
                    {
                        if (Item* childItem = GetItemByEntry(childItemEntry->ChildItemID))
                        {
                            if (childItem->IsEquipped())
                            {
                                ItemPosCountVec destChildren;
                                InventoryResult msg = CanStoreItem(NULL_BAG, NULL_SLOT, destChildren, childItem, false);
                                if (msg == EQUIP_ERR_OK)
                                {
                                    RemoveItem(childItem->GetBagSlot(), childItem->GetSlot(), true);
                                    StoreItem(destChildren, childItem, true);
                                }
                            }
                        }
                    }
                }
                ItemPosCountVec dest;
                InventoryResult msg = CanStoreItem(NULL_BAG, NULL_SLOT, dest, equippedItem, false);
                if (msg == EQUIP_ERR_OK)
                {
                    RemoveItem(equippedItem->GetBagSlot(), equippedItem->GetSlot(), true);
                    StoreItem(dest, equippedItem, true);
                }
                else
                {
                    SQLTransaction trans = CharacterDatabase.BeginTransaction();

                    MoveItemFromInventory(equippedItem, true);
                    equippedItem->DeleteFromInventoryDB(trans);     // deletes item from character's inventory
                    equippedItem->SaveToDB(trans);                  // recursive and not have transaction guard into self, item not in inventory and can be save standalone

                    if (!equippedItem->GetTemplate()->GetArtifactID()) // don't send art by mail
                    {
                        std::string subject = GetSession()->GetTrinityString(LANG_NOT_EQUIPPED_ITEM);
                        MailDraft draft(subject, "There were problems with equipping item(s).");
                        draft.AddItem(equippedItem);
                        draft.SendMailTo(trans, this, MailSender(this, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_COPIED);
                    }

                    CharacterDatabase.CommitTransaction(trans);
                }
            }
            else
                SetVisibleItemSlot(i, equippedItem);
        }
    }

    for (uint32 glyphId : GetGlyphs(spec->OrderIndex))
        CastSpell(this, sGlyphPropertiesStore.AssertEntry(glyphId)->SpellID, true);

    WorldPackets::Talent::ActiveGlyphs activeGlyphs;
    activeGlyphs.Glyphs.reserve(GetGlyphs(spec->OrderIndex).size());
    for (uint32 glyphId : GetGlyphs(spec->OrderIndex))
        if (std::vector<uint32> const* bindableSpells = sDB2Manager.GetGlyphBindableSpells(glyphId))
            for (uint32 bindableSpell : *bindableSpells)
                if (HasSpell(bindableSpell) && m_overrideSpells.find(bindableSpell) == m_overrideSpells.end())
                    activeGlyphs.Glyphs.emplace_back(uint32(bindableSpell), uint16(glyphId));

    activeGlyphs.IsFullUpdate = true;
    SendDirectMessage(activeGlyphs.Write());

    SetGroupUpdateFlag(GROUP_UPDATE_FLAG_SPECIALIZATION_ID);

    AddDelayedEvent(100, [this]() -> void
    {
        PhaseUpdateData phaseUdateData;
        phaseUdateData.AddConditionType(CONDITION_SPEC_ID);
        GetPhaseMgr().NotifyConditionChanged(phaseUdateData);
    });

    AddDelayedEvent(500, [this]() -> void
    {
        for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); ++i)
        {
            if (Item* pItem = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
            {
                if (pItem->GetTemplate()->GetArtifactID())
                    if (CanUseItem(pItem) == EQUIP_ERR_OK)
                    {
                        if (!pItem->GetChildItem().IsEmpty())
                        {
                            InventoryResult childEquipResult = CanEquipChildItem(pItem);
                            if (childEquipResult != EQUIP_ERR_OK)
                                continue;
                        }

                        uint16 eDest;
                        InventoryResult msg = CanEquipItem(NULL_SLOT, eDest, pItem, false, false);
                        if (msg == EQUIP_ERR_OK)
                        {
                            RemoveItem(INVENTORY_SLOT_BAG_0, i, true);
                            EquipItem(eDest, pItem, true);
                            if (!pItem->GetChildItem().IsEmpty())
                                EquipChildItem(INVENTORY_SLOT_BAG_0, i, pItem);

                            AutoUnequipOffhandIfNeed();

                            return;
                        }
                    }

            }
        }

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        {
            if (Bag* bag = GetBagByPos(i))
            {
                for (uint32 j = 0; j < bag->GetBagSize(); j++)
                {
                    if (Item* item = bag->GetItemByPos(j))
                    {
                        if (item->GetTemplate()->GetArtifactID())
                            if (CanUseItem(item) == EQUIP_ERR_OK)
                            {
                                if (!item->GetChildItem().IsEmpty())
                                {
                                    InventoryResult childEquipResult = CanEquipChildItem(item);
                                    if (childEquipResult != EQUIP_ERR_OK)
                                        continue;
                                }

                                uint16 eDest;
                                InventoryResult msg = CanEquipItem(NULL_SLOT, eDest, item, false, false);
                                if (msg == EQUIP_ERR_OK)
                                {
                                    RemoveItem(i, j, true);
                                    EquipItem(eDest, item, true);
                                    if (!item->GetChildItem().IsEmpty())
                                        EquipChildItem(i, j, item);

                                    AutoUnequipOffhandIfNeed();

                                    return;
                                }
                            }

                    }
                }
            }
        }
    });
}

void Player::ForceChangeTalentGroup(uint32 specId)
{
    if (specId == GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID))
        return;

    if (ChrSpecializationEntry const* specialization = sChrSpecializationStore.LookupEntry(specId))
    {
        if (specialization->ClassID == getClass())
            ActivateTalentGroup(specialization);
        else
            return;
    }
    else
        return;

    SendOperationsAfterDelay(OAD_RECALC_ITEMS);

    if (AuraEffect* eff = GetAuraEffect(115043, EFFECT_0)) // Player Damage Reduction
    {
        eff->SetCanBeRecalculated(true);
        eff->RecalculateAmount();
    }
}

uint8 Player::GetQueueRoleMask(uint8 bracketId, bool temp) const
{
    if (!temp)
    {
        auto itr = m_bgQueueRoles.find(bracketId);
        if (itr != m_bgQueueRoles.end())
            return (*itr).second;
        else
            return GetSpecializationRoleMaskForGroup();
    }
    else
    {
        auto itr = m_bgQueueRolesTemp.find(bracketId);
        if (itr != m_bgQueueRolesTemp.end())
            return (*itr).second;
        else
            return GetQueueRoleMask(bracketId, false);
    }
}

int8 Player::GetSingleQueueRole(uint8 bracketId) const
{
    auto roleMask = GetQueueRoleMask(bracketId);
    if (roleMask == lfg::LfgRoles::PLAYER_ROLE_TANK)
        return ROLES_TANK;
    if (roleMask == lfg::LfgRoles::PLAYER_ROLE_HEALER)
        return ROLES_HEALER;
    if (roleMask == lfg::LfgRoles::PLAYER_ROLE_DAMAGE)
        return ROLES_DPS;

    return -1;
}

void Player::ChangeSpecializationForBGIfNeed(uint8 bracketId)
{
    ChangeSpecializationifNeed(ConvertLFGRoleToRole(GetQueueRoleMask(bracketId, true)));
}

void Player::ChangeSpecializationifNeed(uint8 role)
{
    uint8 ourRole = ConvertLFGRoleToRole(GetSpecializationRoleMaskForGroup());

    if (ourRole == role) // it's equal now
        return;

    uint32 specId = 0;
    for (uint32 i = 0; i < 4; ++i)
    {
        if (ChrSpecializationEntry const* specialization = sDB2Manager.GetChrSpecializationByIndex(getClass(), i))
        {
            if (specialization->Role == role)
            {
                specId = specialization->ID;
                break;
            }
        }
    }
    if (specId)
        ForceChangeTalentGroup(specId);
}

bool Player::IsCanChangeSpecToAnotherRole() const
{
    Group const* grp = GetGroup();
    if (!grp)
        return true;

    return !grp->isBGGroup();
}


void Player::ResetTimeSync()
{
    m_timeSyncTimer = 0;
    m_timeSyncClient = 0;
    m_timeSyncServer = getMSTime();
}

void Player::SendTimeSync()
{
    m_timeSyncQueue.push(m_sequenceIndex++);

    WorldPackets::Movement::TimeSyncRequest packet;
    packet.SequenceIndex = m_timeSyncQueue.back();
    SendDirectMessage(packet.Write());

    // Schedule next sync in 5 sec
    m_timeSyncTimer = 5000;
    m_timeSyncServer = getMSTime();

    if (m_timeSyncQueue.size() > 3)
        TC_LOG_TRACE(LOG_FILTER_NETWORKIO, "Not received CMSG_TIME_SYNC_RESP for over 30 seconds from 5s (%s), possible cheater", GetGUID().ToString().c_str());
}

void Player::SetReputation(uint32 factionentry, uint32 value)
{
    GetReputationMgr().SetReputation(sFactionStore.LookupEntry(factionentry), value);
}

uint32 Player::GetReputation(uint32 factionentry)
{
    return GetReputationMgr().GetReputation(sFactionStore.LookupEntry(factionentry));
}

std::string Player::GetGuildName()
{
    return GetGuildId() ? (sGuildMgr->GetGuildById(GetGuildId()) ? sGuildMgr->GetGuildById(GetGuildId())->GetName() : "") : "";
}

Guild* Player::GetGuild()
{
    return GetGuildId() ? sGuildMgr->GetGuildById(GetGuildId()) : NULL;
}

void Player::SendDuelCountdown(uint32 counter)
{
    SendDirectMessage(WorldPackets::Duel::DuelCountdown(counter).Write());
}

void Player::AddRefundReference(ObjectGuid it)
{
    m_refundableItems.insert(it);
}

void Player::DeleteRefundReference(ObjectGuid it)
{
    GuidSet::iterator itr = m_refundableItems.find(it);
    if (itr != m_refundableItems.end())
    {
        m_refundableItems.erase(itr);
    }
}

void Player::SendRefundInfo(Item* item)
{
    // This function call unsets ITEM_FLAGS_REFUNDABLE if played time is over 2 hours.
    // item->UpdatePlayedTime(this);

    if (!item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE))
    {
        //TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "Item refund: item not refundable!");
        return;
    }

    if (GetGUID() != item->GetRefundRecipient()) // Formerly refundable item got traded
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "Item refund: item was traded!");
        item->SetNotRefundable(this);
        return;
    }

    ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(item->GetPaidExtendedCost());
    if (!iece)
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "Item refund: cannot find extendedcost data.");
        return;
    }

    WorldPackets::Item::SetItemPurchaseData purchaseData;
    purchaseData.ItemGUID = item->GetGUID();
    purchaseData.PurchaseTime = GetTotalPlayedTime() - item->GetPlayedTime();
    purchaseData.Contents.Money = item->GetPaidMoney();

    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
    {
        purchaseData.Contents.Items[i].ItemCount = iece->ItemCount[i];
        purchaseData.Contents.Items[i].ItemID = iece->ItemID[i];
    }

    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
    {
        if (iece->IsSeasonCurrencyRequirement(i))
            continue;

        purchaseData.Contents.Currencies[i].CurrencyCount = iece->CurrencyCount[i];
        purchaseData.Contents.Currencies[i].CurrencyID = iece->CurrencyID[i];
    }

    SendDirectMessage(purchaseData.Write());
}

bool Player::AddItem(uint32 itemId, uint32 count, uint32* noSpaceForCount, ObjectGuid guid)
{
    uint32 _noSpaceForCount = 0;
    ItemPosCountVec dest;
    InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, count, &_noSpaceForCount);
    if (msg != EQUIP_ERR_OK)
        count -= _noSpaceForCount;

    if (noSpaceForCount)
        *noSpaceForCount = _noSpaceForCount;

    if (count == 0 || dest.empty())
    {
        // -- TODO: Send to mailbox if no space
        ChatHandler(this).PSendSysMessage("You don't have any space in your bags.");
        return false;
    }

    Item* item = StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId, GetLootSpecID()));
    if (item)
    {
        if (!guid.IsEmpty())
            item->SetGuidValue(OBJECT_FIELD_GUID, guid); // hack
        
        SendNewItem(item, count, true, false);
    }
    else
        return false;
            
    return true;
}

void Player::SendItemRefundResult(Item* item, ItemExtendedCostEntry const* iece, uint8 error)
{
    WorldPackets::Item::ItemPurchaseRefundResult refundResult;
    refundResult.ItemGUID = item->GetGUID();
    refundResult.Result = error;
    if (!error)
    {
        refundResult.Contents = boost::in_place();
        refundResult.Contents->Money = item->GetPaidMoney();
        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
        {
            refundResult.Contents->Items[i].ItemCount = iece->ItemCount[i];
            refundResult.Contents->Items[i].ItemID = iece->ItemID[i];
        }

        for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
        {
            if (iece->IsSeasonCurrencyRequirement(i))
                continue;

            refundResult.Contents->Currencies[i].CurrencyCount = iece->CurrencyCount[i];
            refundResult.Contents->Currencies[i].CurrencyID = iece->CurrencyID[i];
        }
    }

    SendDirectMessage(refundResult.Write());
}

void Player::RefundItem(Item* item)
{
    if (!item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ITEM_FLAG_REFUNDABLE))
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "Item refund: item not refundable!");
        return;
    }

    if (item->IsInUse())
        return;

    if (item->IsRefundExpired())    // item refund has expired
    {
        item->SetNotRefundable(this);
        SendItemRefundResult(item, NULL, 10);
        return;
    }

    if (GetGUID() != item->GetRefundRecipient()) // Formerly refundable item got traded
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "Item refund: item was traded!");
        item->SetNotRefundable(this);
        return;
    }

    ItemExtendedCostEntry const* iece = sItemExtendedCostStore.LookupEntry(item->GetPaidExtendedCost());
    if (!iece)
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER_ITEMS, "Item refund: cannot find extendedcost data.");
        return;
    }

    bool store_error = false;
    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_ITEMS; ++i)
    {
        uint32 count = iece->ItemCount[i];
        uint32 itemid = iece->ItemID[i];

        if (count && itemid)
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemid, count);
            if (msg != EQUIP_ERR_OK)
            {
                store_error = true;
                break;
            }
         }
    }

    if (store_error)
    {
        SendItemRefundResult(item, iece, 10);
        return;
    }

    for (int i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
    {
        if (iece->CurrencyID[i] == CURRENCY_NONE)
            continue;

        if (iece->IsSeasonCurrencyRequirement(i))
            continue;

        ModifyCurrency(iece->CurrencyID[i], int32(iece->CurrencyCount[i]), false, true, false, false, false, true);
    }

    if (!item->IsBag())
    {
        uint32 transmogId = sDB2Manager.GetTransmogId(item->GetEntry(), item->_bonusData.AppearanceModID);
        if (transmogId && GetCollectionMgr()->HasItemAppearance(transmogId))
            GetCollectionMgr()->RemoveTransmogCondition(transmogId, false);
    }

    SendItemRefundResult(item, iece, 0);

    uint64 moneyRefund = item->GetPaidMoney();  // item-> will be invalidated in DestroyItem

    // Save all relevant data to DB to prevent desynchronisation exploits
    SQLTransaction trans = CharacterDatabase.BeginTransaction();

    // Delete any references to the refund data
    item->SetNotRefundable(this, true, &trans);

    // Destroy item
    DestroyItem(item->GetBagSlot(), item->GetSlot(), true);

    // Grant back extendedcost items
    for (uint8 i = 0; i < MAX_ITEM_EXT_COST_CURRENCIES; ++i)
    {
        uint32 count = iece->ItemCount[i];
        uint32 itemid = iece->ItemID[i];

        if (count && itemid)
        {
            ItemPosCountVec dest;
            InventoryResult msg = CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemid, count);
            ASSERT(msg == EQUIP_ERR_OK); /// Already checked before
            Item* it = StoreNewItem(dest, itemid, true);
            SendNewItem(it, count, true, false, true);
        }
    }

    // Grant back money
    if (moneyRefund)
        ModifyMoney(moneyRefund); // Saved in SaveInventoryAndGoldToDB

    // Grant back Arena and Honor points ?

    SaveInventoryAndGoldToDB(trans);

    CharacterDatabase.CommitTransaction(trans);
}

void Player::SetWinToday(bool isWinner, uint8 type, bool all)
{
    bool needSave = false;
    if (all)
    {
        for (uint8 i = 0; i < WIN_TODAY_MAX; ++i)
        {
            if (isWinner && _hasWinToday[i] != isWinner)
                needSave = true;
            _hasWinToday[i] = isWinner;
        }
    }
    else
    {
        if (isWinner && _hasWinToday[type] != isWinner)
            needSave = true;
        _hasWinToday[type] = isWinner;
    }

    if (needSave)
    {
        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_BATTLEGROUND_RANDOM);
        stmt->setUInt64(0, GetGUIDLow());
        stmt->setBool(1, _hasWinToday[WIN_TODAY_RANDOM_BG]);
        stmt->setBool(2, _hasWinToday[WIN_TODAY_RBG]);
        stmt->setBool(3, _hasWinToday[WIN_TODAY_ARENA_2v2]);
        stmt->setBool(4, _hasWinToday[WIN_TODAY_ARENA_3v3]);
        stmt->setBool(5, _hasWinToday[WIN_TODAY_SKIRMISH]);
        stmt->setBool(6, _hasWinToday[WIN_TODAY_BRAWL]);
        stmt->setBool(7, _hasWinToday[WIN_TODAY_BRAWL_ARENA]);
        CharacterDatabase.Execute(stmt);
    }
}

void Player::ModifyDeathMatchStats(uint32 kills, uint32 deaths, uint64 damage, int32 rating, uint32 totalKills, uint32 matches /* = 1 */)
{
    dmScore.kills += kills;
    dmScore.deaths += deaths;
    dmScore.damage += damage;
    if (rating < 0 && -1 * rating >= dmScore.rating)
        dmScore.rating = 0;
    else
        dmScore.rating += rating; 
    
    dmScore.totalKills += totalKills;
    dmScore.matches += matches; 
    if (matches == 1)
        dmScore.needSave = true;
}

void Player::_LoadRandomBGStatus(PreparedQueryResult result)
{
    //QueryResult result = CharacterDatabase.PQuery("SELECT bg, rbg, arena, skirmish FROM character_battleground_random WHERE guid = '%u'", GetGUIDLow());

    if (result)
    {
        Field* fields = result->Fetch();
        _hasWinToday[WIN_TODAY_RANDOM_BG] = fields[0].GetBool();
        _hasWinToday[WIN_TODAY_RBG] = fields[1].GetBool();
        _hasWinToday[WIN_TODAY_ARENA_2v2] = fields[2].GetBool();
        _hasWinToday[WIN_TODAY_ARENA_3v3] = fields[3].GetBool();
        _hasWinToday[WIN_TODAY_SKIRMISH] = fields[4].GetBool();
        _hasWinToday[WIN_TODAY_BRAWL] = fields[5].GetBool();
        _hasWinToday[WIN_TODAY_BRAWL_ARENA] = fields[6].GetBool();
    }
}

float Player::GetAverageItemLevelEquipped() const
{
    float sum = 0;
    uint32 count = 0;
    bool hasTwoHanded = false;

    for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
            continue;

        Item* item = m_items[i];
        if (item && item->GetTemplate())
        {
            if (i == EQUIPMENT_SLOT_MAINHAND && item->GetTemplate()->IsTwoHandedWeapon())
                hasTwoHanded = true;

            sum += item->GetItemLevel(getLevel());
            ++count;
        }
        else if (i == EQUIPMENT_SLOT_OFFHAND && !CanTitanGrip() && (hasTwoHanded))
            continue;
        else
            ++count;
    }

    if (!count)
        return 0;

    return sum / float(count);
}

float Player::GetAverageItemLevelTotal(bool needCalculate, bool onlyFromScan) const
{
    if (!needCalculate)
        return GetFloatValue(PLAYER_FIELD_AVG_ITEM_LEVEL + PlayerAvgItemLevelOffsets::TotalAvgItemLevel);

    uint32 equipItemLevel[EQUIPMENT_SLOT_END];
    for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
        {
            equipItemLevel[i] = 0;
            continue;
        }

        Item* item = m_items[i];
        if (item && item->GetTemplate())
        {
            equipItemLevel[i] = item->GetItemLevel(getLevel());

            // temp
            if (onlyFromScan)
            {
                if (equipItemLevel[i] > 960 && !item->GetTemplate()->IsLegionLegendary() && item->GetQuality() < ITEM_QUALITY_ARTIFACT)
                {
                    sLog->outWarden("AnticheatSpecial: Player %s (GUID: %u) has cheat item %u with itemLevel %u!", GetName(), GetGUIDLow(), item->GetEntry(), equipItemLevel[i]);
                    for (uint32 bonusListID : item->GetDynamicValues(ITEM_DYNAMIC_FIELD_BONUS_LIST_IDS))
                        sLog->outWarden("BonusListID %u", bonusListID);
                }
                else
                {
                    // check gems
                    uint8 count = 0;
                    for (ItemDynamicFieldGems const& gemData : item->GetGems())
                    {
                        ItemTemplate const* gemProto = sObjectMgr->GetItemTemplate(gemData.ItemId);
                        if (!gemProto)
                            continue;

                        ++count;
                    }

                    if (count >= 2)
                    {
                        sLog->outWarden("AnticheatSpecial: Player %s (GUID: %u) has cheat item %u with socketCount %u!", GetName(), GetGUIDLow(), item->GetEntry(), count);
                        for (uint32 bonusListID : item->GetDynamicValues(ITEM_DYNAMIC_FIELD_BONUS_LIST_IDS))
                            sLog->outWarden("BonusListID %u", bonusListID);
                    }
                }
            }

            if (i == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && item->GetTemplate()->IsTwoHandedWeapon())))
                equipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(equipItemLevel[i], equipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

            if (i == EQUIPMENT_SLOT_OFFHAND && item->GetTemplate()->GetClass() == ITEM_CLASS_WEAPON)
                equipItemLevel[EQUIPMENT_SLOT_MAINHAND] = std::max(equipItemLevel[i], equipItemLevel[EQUIPMENT_SLOT_MAINHAND]);

            continue;
        }

        equipItemLevel[i] = 0;
    }

    equipItemLevel[EQUIPMENT_SLOT_TRINKET1] = std::max(equipItemLevel[EQUIPMENT_SLOT_TRINKET1], equipItemLevel[EQUIPMENT_SLOT_TRINKET2]);
    equipItemLevel[EQUIPMENT_SLOT_TRINKET2] = equipItemLevel[EQUIPMENT_SLOT_TRINKET1];
    equipItemLevel[EQUIPMENT_SLOT_FINGER1] = std::max(equipItemLevel[EQUIPMENT_SLOT_FINGER1], equipItemLevel[EQUIPMENT_SLOT_FINGER2]);
    equipItemLevel[EQUIPMENT_SLOT_FINGER2] = equipItemLevel[EQUIPMENT_SLOT_FINGER1];

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); ++i)
    {
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (item->IsSuitableForItemLevelCalulcation(true))
            {
                uint8 slot = GetGuessedEquipSlot(item->GetTemplate());
                uint32 thisIlvl = item->GetItemLevel(getLevel());

                if (slot != NULL_SLOT)
                {
                    if (slot == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && item->GetTemplate()->IsTwoHandedWeapon())))
                        equipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(thisIlvl, equipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

                    if (slot == EQUIPMENT_SLOT_TRINKET1)
                        equipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(thisIlvl, equipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                    if (slot == EQUIPMENT_SLOT_FINGER1)
                        equipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(thisIlvl, equipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                    equipItemLevel[slot] = std::max(equipItemLevel[slot], thisIlvl);
                }
            }
        }
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (Bag* bag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < bag->GetBagSize(); j++)
            {
                if (Item* item = bag->GetItemByPos(j))
                {
                    if (item->IsSuitableForItemLevelCalulcation(true))
                    {
                        uint8 slot = GetGuessedEquipSlot(item->GetTemplate());
                        uint32 thisIlvl = item->GetItemLevel(getLevel());

                        if (slot != NULL_SLOT)
                        {
                            if (slot == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && item->GetTemplate()->IsTwoHandedWeapon())))
                                equipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(thisIlvl, equipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

                            if (slot == EQUIPMENT_SLOT_TRINKET1)
                                equipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(thisIlvl, equipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                            if (slot == EQUIPMENT_SLOT_FINGER1)
                                equipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(thisIlvl, equipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                            equipItemLevel[slot] = std::max(equipItemLevel[slot], thisIlvl);
                        }
                    }
                }
            }
        }
    }

    float sum = 0;
    uint32 count = 0;
    bool hasTwoHanded = false;

    for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
            continue;

        Item* item = m_items[i];
        if (item && item->GetTemplate())
        {
            if (i == EQUIPMENT_SLOT_MAINHAND && item->GetTemplate()->IsTwoHandedWeapon())
                hasTwoHanded = true;

            sum += equipItemLevel[i];
            ++count;
        }
        else if (i == EQUIPMENT_SLOT_OFFHAND && !CanTitanGrip() && (hasTwoHanded))
            continue;
        else
            ++count;
    }

    if (!count)
        return 0;

    return sum / float(count);
}

float Player::GetAverageItemLevelTotalWithOrWithoutPvPBonus(bool /*pvp*/) const
{
    uint32 equipItemLevel[EQUIPMENT_SLOT_END];
    for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
        {
            equipItemLevel[i] = 0;
            continue;
        }

        Item* item = m_items[i];
        if (item && item->GetTemplate())
        {
            equipItemLevel[i] = item->GetItemLevel(GetEffectiveLevel());

            if (i == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && item->GetTemplate()->IsTwoHandedWeapon())))
                equipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(equipItemLevel[i], equipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

            if (i == EQUIPMENT_SLOT_OFFHAND && item->GetTemplate()->GetClass() == ITEM_CLASS_WEAPON)
                equipItemLevel[EQUIPMENT_SLOT_MAINHAND] = std::max(equipItemLevel[i], equipItemLevel[EQUIPMENT_SLOT_MAINHAND]);

            continue;
        }

        equipItemLevel[i] = 0;
    }

    equipItemLevel[EQUIPMENT_SLOT_TRINKET1] = std::max(equipItemLevel[EQUIPMENT_SLOT_TRINKET1], equipItemLevel[EQUIPMENT_SLOT_TRINKET2]);
    equipItemLevel[EQUIPMENT_SLOT_TRINKET2] = equipItemLevel[EQUIPMENT_SLOT_TRINKET1];
    equipItemLevel[EQUIPMENT_SLOT_FINGER1] = std::max(equipItemLevel[EQUIPMENT_SLOT_FINGER1], equipItemLevel[EQUIPMENT_SLOT_FINGER2]);
    equipItemLevel[EQUIPMENT_SLOT_FINGER2] = equipItemLevel[EQUIPMENT_SLOT_FINGER1];

    for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); ++i)
    {
        if (Item* item = GetItemByPos(INVENTORY_SLOT_BAG_0, i))
        {
            if (item->IsSuitableForItemLevelCalulcation(true))
            {
                uint8 slot = GetGuessedEquipSlot(item->GetTemplate());
                uint32 thisIlvl = item->GetItemLevel(getLevel());

                if (slot != NULL_SLOT)
                {
                    if (slot == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && item->GetTemplate()->IsTwoHandedWeapon())))
                        equipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(thisIlvl, equipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

                    if (slot == EQUIPMENT_SLOT_TRINKET1)
                        equipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(thisIlvl, equipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                    if (slot == EQUIPMENT_SLOT_FINGER1)
                        equipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(thisIlvl, equipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                    equipItemLevel[slot] = std::max(equipItemLevel[slot], thisIlvl);
                }
            }
        }
    }

    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
    {
        if (Bag* bag = GetBagByPos(i))
        {
            for (uint32 j = 0; j < bag->GetBagSize(); j++)
            {
                if (Item* item = bag->GetItemByPos(j))
                {
                    if (item->IsSuitableForItemLevelCalulcation(true))
                    {
                        uint8 slot = GetGuessedEquipSlot(item->GetTemplate());
                        uint32 thisIlvl = item->GetItemLevel(getLevel());

                        if (slot != NULL_SLOT)
                        {
                            if (slot == EQUIPMENT_SLOT_MAINHAND && ((CanDualWield() && item->GetTemplate()->IsOneHanded()) || (CanTitanGrip() && item->GetTemplate()->IsTwoHandedWeapon())))
                                equipItemLevel[EQUIPMENT_SLOT_OFFHAND] = std::max(thisIlvl, equipItemLevel[EQUIPMENT_SLOT_OFFHAND]);

                            if (slot == EQUIPMENT_SLOT_TRINKET1)
                                equipItemLevel[EQUIPMENT_SLOT_TRINKET2] = std::max(thisIlvl, equipItemLevel[EQUIPMENT_SLOT_TRINKET2]);

                            if (slot == EQUIPMENT_SLOT_FINGER1)
                                equipItemLevel[EQUIPMENT_SLOT_FINGER2] = std::max(thisIlvl, equipItemLevel[EQUIPMENT_SLOT_FINGER2]);

                            equipItemLevel[slot] = std::max(equipItemLevel[slot], thisIlvl);
                        }
                    }
                }
            }
        }
    }

    float sum = 0;
    uint32 count = 0;

    for (uint32 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (i == EQUIPMENT_SLOT_TABARD || i == EQUIPMENT_SLOT_RANGED || i == EQUIPMENT_SLOT_BODY)
            continue;

        if (i == EQUIPMENT_SLOT_OFFHAND && !equipItemLevel[i])
            continue;

        sum += equipItemLevel[i];
        ++count;
    }

    if (!count)
        return 0;

    return sum / float(count);
}

bool Player::IsInWhisperWhiteList(ObjectGuid guid)
{
    for (GuidList::const_iterator itr = WhisperList.begin(); itr != WhisperList.end(); ++itr)
        if (*itr == guid)
            return true;

    return false;
}

void Player::SendPetTameResult(PetTameResult result)
{
    SendDirectMessage(WorldPackets::PetPackets::TameFailure(result).Write());
}

void Player::UnlockVoidStorage()
{
    SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_VOID_UNLOCKED);
}

void Player::LockVoidStorage()
{
    RemoveFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_VOID_UNLOCKED);
}

uint8 Player::GetNextVoidStorageFreeSlot() const
{
    for (uint16 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        if (!_voidStorageItems[i]) // unused item
            return i;

    return VOID_STORAGE_MAX_SLOT;
}

uint8 Player::GetNumOfVoidStorageFreeSlots() const
{
    uint8 count = 0;
    for (uint16 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        if (!_voidStorageItems[i])
            count++;

    return count;
}

uint32 Player::AddVoidStorageItem(VoidStorageItem&& item)
{
    uint8 slot = GetNextVoidStorageFreeSlot();
    if (slot >= VOID_STORAGE_MAX_SLOT)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_FULL);
        return 255;
    }

    _voidStorageItems[slot] = new VoidStorageItem(std::move(item), true);
    return slot;
}

void Player::DeleteVoidStorageItem(uint8 slot)
{
    if (slot >= VOID_STORAGE_MAX_SLOT || _voidStorageItems[slot]->deleted)
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
        return;
    }

    _voidStorageItems[slot]->change = true;
    _voidStorageItems[slot]->deleted = true;
}

bool Player::SwapVoidStorageItem(uint8 oldSlot, uint8 newSlot)
{
    if (oldSlot >= VOID_STORAGE_MAX_SLOT || newSlot >= VOID_STORAGE_MAX_SLOT || oldSlot == newSlot)
        return false;

    std::swap(_voidStorageItems[newSlot], _voidStorageItems[oldSlot]);
    if (_voidStorageItems[newSlot])
        _voidStorageItems[newSlot]->change = true;

    if (_voidStorageItems[oldSlot])
        _voidStorageItems[oldSlot]->change = true;

    return true;
}

VoidStorageItem* Player::GetVoidStorageItem(uint8 slot) const
{
    if (slot >= VOID_STORAGE_MAX_SLOT || (_voidStorageItems[slot] && _voidStorageItems[slot]->deleted))
    {
        GetSession()->SendVoidStorageTransferResult(VOID_TRANSFER_ERROR_INTERNAL_ERROR_1);
        return NULL;
    }

    return _voidStorageItems[slot];
}

VoidStorageItem* Player::GetVoidStorageItem(uint64 id, uint8& slot) const
{
    for (uint8 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
    {
        if (_voidStorageItems[i] && _voidStorageItems[i]->ItemId == id && !_voidStorageItems[i]->deleted)
        {
            slot = i;
            return _voidStorageItems[i];
        }
    }

    return nullptr;
}

void Player::SaveCUFProfile(uint8 id, std::nullptr_t)
{
    _CUFProfiles[id] = nullptr;
}

void Player::SaveCUFProfile(uint8 id, std::unique_ptr<CUFProfile> profile)
{
    _CUFProfiles[id] = std::move(profile);
}

CUFProfile* Player::GetCUFProfile(uint8 id) const
{
    return _CUFProfiles[id].get();
}

uint8 Player::GetCUFProfilesCount() const
{
    uint8 count = 0;
    for (uint8 i = 0; i < MAX_CUF_PROFILES; ++i)
        if (_CUFProfiles[i])
            ++count;
    return count;
}

void Player::ValidateMovementInfo(MovementInfo* mi)
{
    // Only remove improper flags
#define REMOVE_VIOLATING_FLAGS(check, maskToRemove) \
    { \
        if (check) \
        { \
            TC_LOG_DEBUG(LOG_FILTER_UNITS, "WorldSession::ValidateMovementInfo: Violation of MovementFlags found (%s). " \
                "MovementFlags: %u, MovementFlags2: %u for player GUID: %u. Mask %u will be removed.", \
                STRINGIZE(check), mi->GetMovementFlags(), mi->GetExtraMovementFlags(), GetGUIDLow(), maskToRemove); \
            mi->RemoveMovementFlag((maskToRemove)); \
        } \
    }

    /*! This must be a packet spoofing attempt. MOVEMENTFLAG_ROOT sent from the client is not valid
        in conjunction with any of the moving movement flags such as MOVEMENTFLAG_FORWARD.
        It will freeze clients that receive this player's movement info.
    */
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_ROOT) && mi->HasMovementFlag(MOVEMENTFLAG_MASK_MOVING),
        MOVEMENTFLAG_ROOT);

    //! Cannot ascend and descend at the same time
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_ASCENDING) && mi->HasMovementFlag(MOVEMENTFLAG_DESCENDING),
        MOVEMENTFLAG_ASCENDING | MOVEMENTFLAG_DESCENDING);

    //! Cannot move left and right at the same time
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_LEFT) && mi->HasMovementFlag(MOVEMENTFLAG_RIGHT),
        MOVEMENTFLAG_LEFT | MOVEMENTFLAG_RIGHT);

    //! Cannot strafe left and right at the same time
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_STRAFE_LEFT) && mi->HasMovementFlag(MOVEMENTFLAG_STRAFE_RIGHT),
        MOVEMENTFLAG_STRAFE_LEFT | MOVEMENTFLAG_STRAFE_RIGHT);

    //! Cannot pitch up and down at the same time
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_PITCH_UP) && mi->HasMovementFlag(MOVEMENTFLAG_PITCH_DOWN),
        MOVEMENTFLAG_PITCH_UP | MOVEMENTFLAG_PITCH_DOWN);

    //! Cannot move forwards and backwards at the same time
    REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_FORWARD) && mi->HasMovementFlag(MOVEMENTFLAG_BACKWARD),
        MOVEMENTFLAG_FORWARD | MOVEMENTFLAG_BACKWARD);

    //REMOVE_VIOLATING_FLAGS(mi->HasMovementFlag(MOVEMENTFLAG_SPLINE_ELEVATION) && G3D::fuzzyEq(mi->splineElevation, 0.0f), MOVEMENTFLAG_SPLINE_ELEVATION);

#undef REMOVE_VIOLATING_FLAGS
}

void Player::SendMovementForce(AreaTrigger const* at, Position pos /*= Position()*/, float magnitude /*= 0.0f*/, uint32 type /*= 0*/, bool apply /*= false*/)
{
    ObjectGuid triggerGuid = at->GetGUID();

    if (apply)
    {
        SetForceGUID(triggerGuid);

        WorldPackets::Movement::MoveApplyMovementForce packet;
        packet.MoverGUID = GetGUID();
        packet.SequenceIndex = m_sequenceIndex++;
        packet.Force.ID = triggerGuid;
        packet.Force.Direction = at->GetPosition();
        packet.Force.TransportPosition = pos;
        packet.Force.TransportID = 0;
        packet.Force.Magnitude = magnitude;
        packet.Force.Type = type;
        SendDirectMessage(packet.Write());

        m_movementInfo.Forces[triggerGuid] = packet.Force;
    }
    else
    {
        SetForceGUID(ObjectGuid::Empty);

        WorldPackets::Movement::MoveRemoveMovementForce packet;
        packet.MoverGUID = GetGUID();
        packet.TriggerGUID = triggerGuid;
        packet.SequenceIndex = m_sequenceIndex++;
        SendDirectMessage(packet.Write());

        m_movementInfo.Forces.erase(triggerGuid);
        m_movementInfo.RemoveForcesIDs.emplace_back(triggerGuid);
    }
}

void Player::SendMovementForceAura(ObjectGuid triggerGuid, Position wind, Position center, float magnitude, uint8 type, bool apply)
{
    if (apply)
    {
        SetForceGUID(triggerGuid);

        WorldPackets::Movement::MoveApplyMovementForce packet;
        packet.MoverGUID = GetGUID();
        packet.SequenceIndex = m_sequenceIndex++;
        packet.Force.ID = triggerGuid;
        packet.Force.Direction = center;
        packet.Force.TransportPosition = wind;
        packet.Force.TransportID = 0;
        packet.Force.Magnitude = magnitude;
        packet.Force.Type = type;
        SendDirectMessage(packet.Write());

        m_movementInfo.Forces[triggerGuid] = packet.Force;
    }
    else
    {
        SetForceGUID(ObjectGuid::Empty);

        WorldPackets::Movement::MoveRemoveMovementForce packet;
        packet.MoverGUID = GetGUID();
        packet.TriggerGUID = triggerGuid;
        packet.SequenceIndex = m_sequenceIndex++;
        SendDirectMessage(packet.Write());

        m_movementInfo.Forces.erase(triggerGuid);
        m_movementInfo.RemoveForcesIDs.emplace_back(triggerGuid);
    }
}

void Player::SendMovementSetCollisionHeight(float height, uint8 Reason)
{
    WorldPackets::Movement::MoveSetCollisionHeight setCollisionHeight;
    setCollisionHeight.MoverGUID = GetGUID();
    setCollisionHeight.SequenceIndex = m_sequenceIndex++;
    setCollisionHeight.MsgData.Height = height;
    setCollisionHeight.MsgData.Scale = GetFloatValue(OBJECT_FIELD_SCALE);
    setCollisionHeight.MountDisplayID = GetUInt32Value(UNIT_FIELD_MOUNT_DISPLAY_ID);
    setCollisionHeight.MsgData.Reason = (WorldPackets::Movement::UpdateCollisionHeightReason)Reason;
    setCollisionHeight.ScaleDuration = GetUInt32Value(UNIT_FIELD_SCALE_DURATION);
    SendDirectMessage(setCollisionHeight.Write());
}

void Player::SetMover(Unit* target)
{
    if (!target || (target != this && !target->IsInWorld()))
        return;

    m_mover->m_movedPlayer = nullptr;
    m_mover = target;
    m_mover->m_movedPlayer = this;

    WorldPackets::Movement::MoveSetActiveMover packet;
    packet.MoverGUID = target->GetGUID();
    SendDirectMessage(packet.Write());
}

void Player::ShowNeutralPlayerFactionSelectUI()
{
    SendDirectMessage(WorldPackets::Misc::NullSMsg(SMSG_SHOW_NEUTRAL_PLAYER_FACTION_SELECT_UI).Write());
}

float Player::GetCollisionHeight(bool mounted)
{
    if (mounted)
    {
        CreatureDisplayInfoEntry const* mountDisplayInfo = sCreatureDisplayInfoStore.LookupEntry(GetUInt32Value(UNIT_FIELD_MOUNT_DISPLAY_ID));
        if (!mountDisplayInfo)
            return GetCollisionHeight(false);

        CreatureModelDataEntry const* mountModelData = sCreatureModelDataStore.LookupEntry(mountDisplayInfo->ModelID);
        if (!mountModelData)
            return GetCollisionHeight(false);

        CreatureDisplayInfoEntry const* displayInfo = sCreatureDisplayInfoStore.LookupEntry(GetNativeDisplayId());
        ASSERT(displayInfo);
        CreatureModelDataEntry const* modelData = sCreatureModelDataStore.LookupEntry(displayInfo->ModelID);
        ASSERT(modelData);

        return mountModelData->MountHeight + modelData->CollisionHeight * 0.5;
    }
    //! Dismounting case - use basic default model data
    CreatureDisplayInfoEntry const* displayInfo = sCreatureDisplayInfoStore.LookupEntry(GetNativeDisplayId());
    ASSERT(displayInfo);
    CreatureModelDataEntry const* modelData = sCreatureModelDataStore.LookupEntry(displayInfo->ModelID);
    ASSERT(modelData);

    return modelData->CollisionHeight;
}

bool Player::IsVoidStorageUnlocked() const
{
    return HasFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_VOID_UNLOCKED);
}

void Player::SetPersonnalXpRate(float PersonnalXpRate)
{
    if(PersonnalXpRate != m_PersonnalXpRate)
    {
        if(PersonnalXpRate)
        {
            SQLTransaction trans = CharacterDatabase.BeginTransaction();
            trans->PAppend("REPLACE INTO character_rates VALUES ('%u', '%f');", GetGUIDLow(), PersonnalXpRate);
            CharacterDatabase.CommitTransaction(trans);
        }
        else // Rates normales
        {
            SQLTransaction trans = CharacterDatabase.BeginTransaction();
            trans->PAppend("DELETE FROM character_rates WHERE guid = '%u';", GetGUIDLow());
            CharacterDatabase.CommitTransaction(trans);
        }
    }

    m_PersonnalXpRate = PersonnalXpRate;
}

void Player::SetQuestUpdate(uint32 quest_id)
{
    uint32 zone = 0, area = 0;

    std::map<uint32, bool> apply;
    std::map<uint32, bool> remove;
    SpellAreaForQuestMapBounds saBounds = sSpellMgr->GetSpellAreaForQuestMapBounds(quest_id);
    if (saBounds.first != saBounds.second)
    {
        GetZoneAndAreaId(zone, area);

        for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        {
            if (zone != itr->second->areaId && area != itr->second->areaId)
                continue;

            if (itr->second->IsFitToRequirements(this, zone, area))
            {
                apply[itr->second->spellId] = true;
                if (itr->second->autocast)
                    if (!HasAura(itr->second->spellId))
                        CastSpell(this, itr->second->spellId, true);
            }
            else
                remove[itr->second->spellId] = true;
                //RemoveAurasDueToSpell(itr->second->spellId);
        }
    }

    saBounds = sSpellMgr->GetSpellAreaForQuestEndMapBounds(quest_id);
    if (saBounds.first != saBounds.second)
    {
        if (!zone || !area)
            GetZoneAndAreaId(zone, area);

        for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
        {
            if (zone != itr->second->areaId && area != itr->second->areaId)
                continue;

            if (itr->second->IsFitToRequirements(this, zone, area))
            {
                apply[itr->second->spellId] = true;
                if (itr->second->autocast)
                    if (!HasAura(itr->second->spellId))
                        CastSpell(this, itr->second->spellId, true);
            }
            else
                remove[itr->second->spellId] = true;
                //RemoveAurasDueToSpell(itr->second->spellId);
        }
    }

    //! multy bound support. If one bound spellID has fited requirements - no need remove aura.
    for (auto data : remove)
    {
        auto i = apply.find(data.first);
        if (i == apply.end())
            RemoveAurasDueToSpell(data.first);
    }

    UpdateAvailableQuestLines();
}

void Player::SendMusic(uint32 soundKitID)
{
    SendDirectMessage(WorldPackets::Misc::PlayMusic(soundKitID).Write());
}

void Player::SendSound(uint32 soundKitID, ObjectGuid source)
{
    SendDirectMessage(WorldPackets::Misc::PlaySound(source, soundKitID).Write());
}

void Player::SendSoundToAll(uint32 soundId, ObjectGuid source)
{
    GetMap()->ApplyOnEveryPlayer([&](Player* player)
    {
        player->SendSound(soundId, source);
    });
}

Item* Player::GetArtifactWeapon()
{
    Item* artifact = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
    if (!artifact || !artifact->GetTemplate() || !artifact->GetTemplate()->GetArtifactID())
        artifact = GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
    if (artifact && artifact->GetTemplate() && artifact->GetTemplate()->GetArtifactID())
        return artifact;

    return nullptr;
}

void Player::_LoadHonor(PreparedQueryResult result, PreparedQueryResult result2)
{
    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            KillInfo &info = m_killsPerPlayer[fields[0].GetUInt64()];
            info.state = KILL_UNCHANGED;
            info.count = fields[1].GetUInt8();
        }
        while (result->NextRow());
    }

    m_honorInfo.CurrentHonorAtLevel = 0;
    m_honorInfo.PrestigeLevel = 0;
    m_honorInfo.HonorLevel = 0;
    if (result2)
    {
        do
        {
            Field* fields = result2->Fetch();
            m_honorInfo.CurrentHonorAtLevel = fields[0].GetUInt16();
            m_honorInfo.PrestigeLevel = fields[1].GetUInt8();
            m_honorInfo.HonorLevel = fields[2].GetUInt8();
        }
        while (result2->NextRow());
    }
    m_honorInfo.NextHonorLevel = m_honorInfo.HonorLevel < m_honorInfo.MaxHonorLevel ? m_honorInfo.HonorLevel + 1 : m_honorInfo.MaxHonorLevel;
    if (GtHonorLevelEntry const* data = sHonorLevelGameTable.GetRow(m_honorInfo.NextHonorLevel))
        m_honorInfo.NextHonorAtLevel = data->Prestige[m_honorInfo.PrestigeLevel];

    SetUInt32Value(PLAYER_FIELD_HONOR, m_honorInfo.CurrentHonorAtLevel);
    SetUInt32Value(PLAYER_FIELD_HONOR_LEVEL, m_honorInfo.HonorLevel);
    SetUInt32Value(PLAYER_FIELD_HONOR_NEXT_LEVEL, m_honorInfo.NextHonorAtLevel);
    SetUInt32Value(PLAYER_FIELD_PRESTIGE, m_honorInfo.PrestigeLevel);
}

void Player::_SaveHonor()
{
    SQLTransaction trans = CharacterDatabase.BeginTransaction();
    PreparedStatement* stmt = nullptr;
    ObjectGuid::LowType lowGuid = GetGUIDLow();

    if (m_flushKills)
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_PLAYER_KILL);
        stmt->setUInt64(0, lowGuid);
        trans->Append(stmt);

        m_flushKills = false;
    }

    if (m_saveKills)
    {
        for (KillInfoMap::iterator itr = m_killsPerPlayer.begin(); itr != m_killsPerPlayer.end(); ++itr)
        {
            switch (itr->second.state)
            {
                case KILL_NEW:
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_PLAYER_KILL);
                    stmt->setUInt64(0, lowGuid);
                    stmt->setUInt64(1, itr->first);
                    stmt->setUInt8(2, itr->second.count);
                    trans->Append(stmt);
                    break;
                case KILL_CHANGED:
                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_PLAYER_KILL);
                    stmt->setUInt8(0, itr->second.count);
                    stmt->setUInt64(1, lowGuid);
                    stmt->setUInt64(2, itr->first);
                    trans->Append(stmt);
                    break;
                default:
                    break;
            }
            itr->second.state = KILL_UNCHANGED;
        }
        m_saveKills = false;
    }

    if (getLevel() >= MAX_LEVEL)
    {
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_HONOR_INFO);
        stmt->setUInt64(0, lowGuid);
        stmt->setUInt16(1, m_honorInfo.CurrentHonorAtLevel);
        stmt->setUInt8(2, m_honorInfo.PrestigeLevel);
        stmt->setUInt8(3, m_honorInfo.HonorLevel);
        trans->Append(stmt);
    }

    CharacterDatabase.CommitTransaction(trans);
}

void Player::SendCategoryCooldownMods()
{
    WorldPackets::Spells::CategoryCooldown cooldowns;

    if (AuraEffectList const* categoryCooldownAuras = GetAuraEffectsByType(SPELL_AURA_MOD_SPELL_CATEGORY_COOLDOWN))
    {
        for (auto aurEff : *categoryCooldownAuras)
        {
            uint32 categoryId = aurEff->GetMiscValue();
            auto cItr = std::find_if(cooldowns.CategoryCooldowns.begin(), cooldowns.CategoryCooldowns.end(), [categoryId](WorldPackets::Spells::CategoryCooldown::CategoryCooldownInfo const& cooldown)
            {
                return cooldown.Category == categoryId;
            });

            if (cItr == cooldowns.CategoryCooldowns.end())
                cooldowns.CategoryCooldowns.emplace_back(aurEff->GetMiscValue(), -aurEff->GetAmount());
            else
                cItr->ModCooldown -= aurEff->GetAmount();
        }
    }

    SendDirectMessage(cooldowns.Write());
}

void Player::SendModifyCooldown(uint32 spellId, int32 value)
{
    WorldPackets::Spells::ModifyCooldown cooldown;
    cooldown.IsPet = false;
    cooldown.DeltaTime = value;
    cooldown.SpellID = spellId;
    SendDirectMessage(cooldown.Write());
}

//! con't do on construct as we not now char guid at init it
void Player::InitBrackets()
{
    for (uint8 i = MS::Battlegrounds::BracketType::Arena2v2; i < MS::Battlegrounds::BracketType::Max; ++i)
        m_BracketsList[i] = sBracketMgr->TryGetOrCreateBracket(GetGUID(), i);
    
        m_BracketsList[MS::Battlegrounds::BracketType::Arena1v1] = sBracketMgr->TryGetOrCreateBracket(GetGUID(), MS::Battlegrounds::BracketType::Arena1v1);
        m_BracketsList[MS::Battlegrounds::BracketType::ArenaSoloQ3v3] = sBracketMgr->TryGetOrCreateBracket(GetGUID(), MS::Battlegrounds::BracketType::ArenaSoloQ3v3);
}

Bracket* Player::getBracket(uint8 slot) const
{
    return Trinity::Containers::MapGetValuePtr(m_BracketsList, slot);
}

// Level is
// Combantant - 810
// Gladiator - 840
// Elite Gladiator - 870
static uint32 epicPvpLeveling[8][7]
{
    // Season 0
    // 0 1  2  3  4  5  6
    { 0, 0, 0, 0, 0, 0, 0 },
    // Season 1
    // 0  1  2   3   4   5   6
    { 0, 10, 20, 25, 30, 35, 40 },
    // Season 2
    // 0  1   2   3   4   5   6
    { 15, 25, 35, 40, 45, 50, 60 },
    // Season 3
    // 0  1   2   3   4   5   6
    { 30, 40, 50, 55, 60, 65, 75 },
    // Season 4
    // 0  1   2   3   4   5   6
    { 45, 55, 65, 70, 75, 80, 90 },
    // Season 5
    // 0  1   2   3   4   5   6
    { 60, 70, 80, 85, 90, 95, 110 },
    // Season 6
    // 0  1   2   3    4    5    6
    { 75, 85, 95, 100, 105, 110, 120 },
    // Season 7
    // 0  1    2    3    4    5    6
    { 90, 100, 110, 115, 120, 125, 135 }
};

static uint32 elitPvpLeveling[8][3]
{
    // Season 0
    // 0  1  2
    { 0, 0, 0 },
    // Season 1
    // 0  1  2
    { 0, 5, 10 },
    // Season 2
    // 0  1   2
    { 15, 20, 30 },
    // Season 3
    // 0  1   2
    { 30, 35, 45 },
    // Season 4
    // 0  1   2
    { 45, 50, 60 },
    // Season 5
    // 0  1   2
    { 60, 65, 80 },
    // Season 6
    // 0  1   2
    { 75, 80, 90 },
    // Season 7
    // 0  1   2
    { 90, 95, 105 }
};

std::tuple<uint32, uint32> Player::GetItemDataForRatedQuest(uint32 bracketType)
{
    auto bracket = getBracket(bracketType);
    auto data = std::tuple<uint32, uint32>();

    uint32 rating = bracket->GetBracketInfo(BRACKET_WEEK_BEST_LAST);

    auto needLevel = [rating]() -> uint32
    {
        if (sWorld->getBoolConfig(CONFIG_PVP_LEVEL_ENABLE))
        {
            uint8 activeSeason = sWorld->getIntConfig(CONFIG_PVP_ACTIVE_SEASON);

            if (sWorld->getIntConfig(CONFIG_PVP_ACTIVE_STEP) >= 1)
            {
                if (rating >= 2400)
                    return 840 + epicPvpLeveling[activeSeason][6];

                if (rating >= 2200)
                    return 840 + epicPvpLeveling[activeSeason][5];
            }

            if (rating >= 2000)
                return 840 + epicPvpLeveling[activeSeason][4];

            if (rating >= 1800)
                return 840 + epicPvpLeveling[activeSeason][3];

            if (rating >= 1600)
                return 840 + epicPvpLeveling[activeSeason][2];

            if (rating >= 1400)
                return 840 + epicPvpLeveling[activeSeason][1];

            return 840 + epicPvpLeveling[activeSeason][0];
        }

        if (rating >= 2200)
            return 960;

        if (rating >= 2100)
            return 950;

        if (rating >= 2000)
            return 945;

        if (rating >= 1900)
            return 940;

        if (rating >= 1800)
            return 935;

        if (rating >= 1600)
            return 930;

        if (rating >= 1400)
            return 920;

        return 915;
    }();

    std::get<1>(data) = needLevel;

    switch (bracketType)
    {
        case MS::Battlegrounds::BracketType::Arena2v2:
            std::get<0>(data) = 44;
            break;
        case MS::Battlegrounds::BracketType::Arena3v3:
            std::get<0>(data) = 45;
            break;
        case MS::Battlegrounds::BracketType::RatedBattleground:
            std::get<0>(data) = 46;
            break;
        default:
            break;
    }

    return data;
}

void Player::SendPvpRatedStats()
{
    WorldPackets::Battleground::RatedInfo ratedInfo;
    for (uint8 i = MS::Battlegrounds::BracketType::Arena2v2; i < MS::Battlegrounds::BracketType::Max; ++i)
    {
        Bracket* bracket = getBracket(i);
        ASSERT(bracket);

        ratedInfo.Info[i].PersonalRating = bracket->getRating();
        ratedInfo.Info[i].Ranking = 0;
        ratedInfo.Info[i].SeasonPlayed = bracket->GetBracketInfo(BRACKET_SEASON_GAMES);
        ratedInfo.Info[i].SeasonWon = bracket->GetBracketInfo(BRACKET_SEASON_WIN);
        ratedInfo.Info[i].WeeklyPlayed = bracket->GetBracketInfo(BRACKET_WEEK_GAMES);
        ratedInfo.Info[i].WeeklyWon = bracket->GetBracketInfo(BRACKET_WEEK_WIN);
        ratedInfo.Info[i].BestWeeklyRating = bracket->GetBracketInfo(BRACKET_WEEK_BEST);
        ratedInfo.Info[i].BestSeasonRating = bracket->GetBracketInfo(BRACKET_BEST);
        ratedInfo.Info[i].BestWeeklyLastRating = bracket->GetBracketInfo(BRACKET_WEEK_BEST_LAST);
    }
    SendDirectMessage(ratedInfo.Write());
}

void Player::PvpRatedQuestReward(uint32 quest_id)
{
    PvpRewardTypes type = PvpReward_Skirmish;
    auto bracketType = 0;
    switch (quest_id)
    {
        case 44891: // 2v2 Weekly Quest UI
            type = PvpReward_Arena_2v2;
            bracketType = MS::Battlegrounds::BracketType::Arena2v2;
            break;
        case 44908: // 3v3 Weekly Quest UI
            type = PvpReward_Arena_3v3;
            bracketType = MS::Battlegrounds::BracketType::Arena3v3;
            break;
        case 44909: // 10v10 Weekly Quest UI
            type = PvpReward_RBG;
            bracketType = MS::Battlegrounds::BracketType::RatedBattleground;
            break;
        default:
            return;
    }

    PvpReward* reward = sBattlegroundMgr->GetPvpReward(type);
    if (!reward)
        return;

    auto bracket = getBracket(bracketType);
    uint32 rating = bracket->GetBracketInfo(BRACKET_WEEK_BEST_LAST);
    auto data = GetItemDataForRatedQuest(bracketType);

    uint32 needLevel = std::get<1>(data);
    uint32 itemId = 0;

    std::vector<uint32> itemModifiers = GetPvPRewardItem(itemId, type, rating, true, needLevel);
    if (itemId)
    {
        ItemPosCountVec dest;
        if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, 1) == EQUIP_ERR_OK)
        {
            if (auto item = StoreNewItem(dest, itemId, true, Item::GenerateItemRandomPropertyId(itemId, GetLootSpecID()), GuidSet(), itemModifiers))
            {
                SendNewItem(item, 1, true, false, true);
                SendDisplayToast(itemId, ToastType::ITEM, false, 1, DisplayToastMethod::DISPLAY_TOAST_ENTRY_RATED_PVP_REWARD, 0, item);
            }
        }
    }
}

void Player::GetPvPRatingAndLevel(PvpReward* reward, uint8 type, uint32& rating, uint32& needLevel, bool elit)
{
    if (sWorld->getBoolConfig(CONFIG_PVP_LEVEL_ENABLE))
    {
        GetPvPRatingAndLevelOld(reward, type, rating, needLevel, elit);
        return;
    }

    needLevel = reward->BaseLevel;

    auto bracketType = 0;
    switch (type)
    {
        case PvpReward_Arena_2v2:
            bracketType = MS::Battlegrounds::BracketType::Arena2v2;
            break;
        case PvpReward_Arena_3v3:
            bracketType = MS::Battlegrounds::BracketType::Arena3v3;
            break;
        case PvpReward_RBG:
            bracketType = MS::Battlegrounds::BracketType::RatedBattleground;
            break;
        default:
            bracketType = MS::Battlegrounds::BracketType::Skirmish2v2;
            break;
    }

    if (auto bracket = getBracket(bracketType))
        rating = bracket->getRating();

    int32 levelBonus = 0;

    //// Arena epic 915
    if (rating >= 1400 && rating < 1600)
        levelBonus += 5;
    else if (rating >= 1600 && rating < 1800)
        levelBonus += 15;
    else if (rating >= 1800 && rating < 1900)
        levelBonus += 20;

    if (elit)
    {
        // Arena elit epic 940
        if (rating >= 1900 && rating < 2000)
            levelBonus += 0;
        else if (rating >= 2000 && rating < 2100)
            levelBonus += 5;
        else if (rating >= 2100 && rating < 2200)
            levelBonus += 10;
        else if (rating >= 2200)
            levelBonus += 20;

        if (rating >= 1900)
            needLevel = reward->ElitLevel;
    }
    else
    {
        if (rating >= 1900 && rating < 2000)
            levelBonus += 25;
        else if (rating >= 2000 && rating < 2100)
            levelBonus += 30;
        else if (rating >= 2100 && rating < 2200)
            levelBonus += 35;
        else if (rating >= 2200)
            levelBonus += 45;
    }

    needLevel += levelBonus;
}

void Player::GetPvPRatingAndLevelOld(PvpReward* reward, uint8 type, uint32& rating, uint32& needLevel, bool elit)
{
    needLevel = reward->BaseLevel;

    auto bracketType = 0;
    switch (type)
    {
        case PvpReward_Arena_2v2:
            bracketType = MS::Battlegrounds::BracketType::Arena2v2;
            break;
        case PvpReward_Arena_3v3:
            bracketType = MS::Battlegrounds::BracketType::Arena3v3;
            break;
        case PvpReward_RBG:
            bracketType = MS::Battlegrounds::BracketType::RatedBattleground;
            break;
        default:
            bracketType = MS::Battlegrounds::BracketType::Skirmish2v2;
            break;
    }

    if (auto bracket = getBracket(bracketType))
        rating = bracket->getRating();

    int32 levelBonus = 0;
    uint8 activeSeason = sWorld->getIntConfig(CONFIG_PVP_ACTIVE_SEASON);

    //// Arena epic
    if (rating >= 1400 && rating < 1600)
        levelBonus += epicPvpLeveling[activeSeason][1];
    else if (rating >= 1600 && rating < 1800)
        levelBonus += epicPvpLeveling[activeSeason][2];
    else if (rating >= 1800 && rating < 2000)
        levelBonus += epicPvpLeveling[activeSeason][3];

    if (elit)
    {
        // Arena elit epic
        if (rating >= 2000 && rating < 2200)
            levelBonus += elitPvpLeveling[activeSeason][0];
        else if (rating >= 2200 && rating < 2400)
            levelBonus += elitPvpLeveling[activeSeason][1];
        else if (rating >= 2400)
            levelBonus += elitPvpLeveling[activeSeason][2];

        if (rating >= 2000)
            needLevel = reward->ElitLevel;
    }
    else
    {
        if (rating >= 2000 && rating < 2200)
            levelBonus += epicPvpLeveling[activeSeason][4];
        else if (sWorld->getIntConfig(CONFIG_PVP_ACTIVE_STEP) >= 1)
        {
            if (rating >= 2200 && rating < 2400)
                levelBonus += epicPvpLeveling[activeSeason][5];
            else if (rating >= 2400)
                levelBonus += epicPvpLeveling[activeSeason][6];
        }
    }

    needLevel += levelBonus;
}

std::vector<uint32> Player::GetPvPRewardItem(uint32& itemID, uint8 type, uint32 rating, bool elit, uint32 needLevel)
{
    PvpReward* reward = sBattlegroundMgr->GetPvpReward((PvpRewardTypes)type);
    if (!reward)
        return std::vector<uint32>();

    uint32 relicId = 0;

    std::vector<uint32> itemsContainer = GetTeam() == ALLIANCE ? reward->ItemsA : reward->ItemsH;
    std::vector<uint32> relicsContainer = reward->Relics;

    if (rating >= 1900 && elit)
    {
        itemsContainer = GetTeam() == ALLIANCE ? reward->ItemsAElit : reward->ItemsHElit;
        if (!reward->RelicsElit.empty())
            relicsContainer = reward->RelicsElit;
    }

    if (!relicsContainer.empty())
    {
        std::vector<uint32> possibleLoot;
        for (uint32 itemIDr : relicsContainer)
        {
            auto const& itemTemplate = sObjectMgr->GetItemTemplate(itemIDr);
            if (!itemTemplate)
                continue;

            if (!CanGetItemForLoot(itemTemplate))
                continue;

            possibleLoot.emplace_back(itemIDr);
        }

        if (!possibleLoot.empty())
            relicId = Trinity::Containers::SelectRandomContainerElement(possibleLoot);
    }

    if (!itemsContainer.empty())
    {
        std::vector<uint32> possibleLoot;
        std::vector<uint32> possibleLootClone;
        for (uint32 itemIDs : itemsContainer)
        {
            auto const& itemTemplate = sObjectMgr->GetItemTemplate(itemIDs);
            if (!itemTemplate)
                continue;

            if (!CanGetItemForLoot(itemTemplate))
                continue;

            if (HasItemCount(itemIDs, 1, true)) // Prevent drop if item allready exist
            {
                possibleLootClone.emplace_back(itemIDs);
                continue;
            }

            possibleLoot.emplace_back(itemIDs);
            possibleLootClone.emplace_back(itemIDs);
        }

        if (possibleLoot.empty()) // If not have item for looting copy clone
            possibleLoot = possibleLootClone;
        else if (!possibleLootClone.empty() && roll_chance_f(30.0f)) // Not full chance
            possibleLoot = possibleLootClone;

        if (relicId)
            possibleLoot.emplace_back(relicId);

        if (!possibleLoot.empty())
            itemID = Trinity::Containers::SelectRandomContainerElement(possibleLoot);
    }

    return sObjectMgr->GetItemBonusTree(itemID, GetMap()->GetDifficultyLootItemContext(), getLevel(), 0, 0, needLevel);
}

void Player::LoadPetSlot(std::string const &data)
{
    Tokenizer tokens(data, ' ');

    uint8 index = 0;
    for (Tokenizer::const_iterator iter = tokens.begin(); index < PET_SLOT_LAST && iter != tokens.end(); ++iter, ++index)
        m_PetSlots[index] = uint32(atol(*iter));

    //Clean bug slots
    for (uint32 i = PET_SLOT_HUNTER_FIRST; i < PET_SLOT_STABLE_LAST; ++i)
    {
        for (uint32 j = PET_SLOT_HUNTER_FIRST; j < PET_SLOT_STABLE_LAST; ++j)
        {
            if (m_PetSlots[i] && i != j && m_PetSlots[i] == m_PetSlots[j]) //Clear duplicate pet
                m_PetSlots[j]= 0;
        }
    }
}

void Player::cleanPetSlotForMove(PetSlot slot, uint32 petID)
{
    ASSERT(slot < PET_SLOT_LAST);

    // Clean only if we have corrcet Id, for lost link privention
    if (m_PetSlots[slot] == petID)
        m_PetSlots[slot] = 0;
}

void Player::setPetSlot(PetSlot slot, uint32 petID)
{
    ASSERT(slot < PET_SLOT_LAST);

    if (m_PetSlots[slot] && m_PetSlots[slot] != petID)
    {
        bool find = false;
        for (uint32 i = PET_SLOT_STABLE_FIRST; i < PET_SLOT_STABLE_LAST; ++i)
        {
            if (m_PetSlots[i] == petID)
            {
                find = true;
                SwapPetSlot(slot, (PetSlot)i);
                break;
            }
        }
        if(!find)
        {
            for (uint32 i = PET_SLOT_STABLE_FIRST; i < PET_SLOT_STABLE_LAST; ++i)
            {
                if (!m_PetSlots[i])
                {
                    m_PetSlots[i] = m_PetSlots[slot];
                    break;
                }
            }
        }
    }

    m_PetSlots[slot] = petID;
}

void Player::SwapPetSlot(PetSlot oldSlot, PetSlot newSlot)
{
    std::swap(m_PetSlots[newSlot], m_PetSlots[oldSlot]);
}

int16 Player::SetOnAnyFreeSlot(uint32 petID)
{
    for (uint32 i = PET_SLOT_HUNTER_FIRST; i < PET_SLOT_STABLE_LAST; ++i)
        if (!m_PetSlots[i])
        {
            m_PetSlots[i] = petID;
            return i;
        }
    return PET_SLOT_FULL_LIST;
}


PetSlot Player::getSlotForNewPet(bool full/*=false*/)
{
    uint32 last_known = PET_SLOT_OTHER_PET; //check PET_SLOT_STABLE_LAST for last
    // Call Pet Spells
    // 883 83242 83243 83244 83245
    //  1    2     3     4     5
    if (!full)
    {
        if (HasSpell(83245))
            last_known = 5;
        else if (HasSpell(83244))
            last_known = 4;
        else if (HasSpell(83243))
            last_known = 3;
        else if (HasSpell(83242))
            last_known = 2;
        else if (HasSpell(883))
            last_known = 1;
        else
            last_known = 0;
    }

    for (uint32 i = uint32(PET_SLOT_HUNTER_FIRST); i < last_known; ++i)
        if (!m_PetSlots[i])
            return PetSlot(i);

    return PET_SLOT_FULL_LIST;
}

PetSlot Player::GetSlotForPetId(uint32 petID)
{
    for (uint32 i = uint32(PET_SLOT_HUNTER_FIRST); i < uint32(PET_SLOT_STABLE_LAST); ++i)
        if (m_PetSlots[i] == petID)
            return PetSlot(i);

    return PET_SLOT_FULL_LIST;
}

PetSlot Player::GetMaxCurentPetSlot() const
{
    return PET_SLOT_HUNTER_LAST;
}

uint8 Player::GetClassFamily() const
{
    switch (getClass())
    {
        case CLASS_WARRIOR:      return SPELLFAMILY_WARRIOR;
        case CLASS_PALADIN:      return SPELLFAMILY_PALADIN;
        case CLASS_HUNTER:       return SPELLFAMILY_HUNTER;
        case CLASS_ROGUE:        return SPELLFAMILY_ROGUE;
        case CLASS_PRIEST:       return SPELLFAMILY_PRIEST;
        case CLASS_DEATH_KNIGHT: return SPELLFAMILY_DEATHKNIGHT;
        case CLASS_SHAMAN:       return SPELLFAMILY_SHAMAN;
        case CLASS_MAGE:         return SPELLFAMILY_MAGE;
        case CLASS_WARLOCK:      return SPELLFAMILY_WARLOCK;
        case CLASS_MONK:         return SPELLFAMILY_MONK;
        case CLASS_DRUID:        return SPELLFAMILY_DRUID;
        case CLASS_DEMON_HUNTER: return SPELLFAMILY_DEMON_HUNTER;
        default:
            break;
    }

    return 0;
}

bool Player::CanSummonPet(uint32 entry) const
{
    bool check = true;
    switch(entry)
    {
        case ENTRY_GHOUL:         // Raise Dead
            if (getClass() == CLASS_DEATH_KNIGHT && GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID) != SPEC_DK_UNHOLY)
                check = false;
            break;
        case ENTRY_FELGUARD:
            if (getClass() == CLASS_WARLOCK && GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID) != SPEC_WARLOCK_DEMONOLOGY)
                check = false;
            break;
        case ENTRY_WATER_ELEMENTAL:
            if (getClass() == CLASS_MAGE && GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID) != SPEC_MAGE_FROST)
                check = false;
            break;
        default:
            break;
    }
    return check;
}

void Player::ModifySpellCooldown(uint32 spell_id, int32 delta)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
    if (!spellInfo || !delta)
        return;

    double cooldown = GetSpellCooldownDelay(spell_id);
    if (G3D::fuzzyEq(cooldown, 0.0) && delta < 0)
        return;

    double result = cooldown * IN_MILLISECONDS + delta;
    if (G3D::fuzzyLt(result, 0.0))
        result = 0.0;

    if (result <= 0.0)
    {
        RemoveSpellCooldown(spell_id, true);
        return;
    }

    AddSpellCooldown(spell_id, 0, getPreciseTime() + result / IN_MILLISECONDS);

    SendModifyCooldown(spell_id, G3D::fuzzyGt(result, 0.0) ? delta : -int32(cooldown * IN_MILLISECONDS));
}

bool Player::CanSpeakLanguage(uint32 lang_id) const
{
    LanguageDesc const* langDesc = GetLanguageDescByID(lang_id);
    if (!langDesc)
        return false;

    if (isGameMaster())
        return true;

    if (langDesc->skill_id != 0 && !const_cast<Player*>(this)->HasSkill(langDesc->skill_id))
    {
        // also check SPELL_AURA_COMPREHEND_LANGUAGE (client offers option to speak in that language)
        if (Unit::AuraEffectList const* langAuras = GetAuraEffectsByType(SPELL_AURA_COMPREHEND_LANGUAGE))
            for (Unit::AuraEffectList::const_iterator i = langAuras->begin(); i != langAuras->end(); ++i)
                if ((*i)->GetMiscValue() == int32(langDesc->lang_id))
                    return true;

        return false;
    }

    return true;
}

bool Player::IsForbiddenMapForLevel(uint32 mapid, uint32 zone)
{
    if (isGameMaster())
        return false;

    uint8 minLevel = 0;

    switch (mapid)
    {
        // Eastern Kingdoms
        case 0:
            switch (zone)
            {
                case 4922: // Twilight Highlands
                case 4815: // Vashj'ir: Kelp'thar Forest
                case 5144: // Vashj'ir: Shimmering Expanse
                case 5145: // Vashj'ir: Abyssal Depths
                case 5146: // Vashj'ir
                    minLevel = 80;
                default:
                    break;
            }
            break;
        // Kalimdor
        case 1:
            //      Uldum           Hyjal
            if (zone == 5034 || zone == 616)
                minLevel = 80;
            break;
        // Outland
        case 530:
        {
            minLevel = 58;

            switch (zone) // Start location: Blood Elf and Draenei
            {
                case 4080:
                    minLevel = 70; // Isle of Quel'Danas
                    break;
                case 3430: case 3433: case 3524:
                case 3525: case 3487: case 3557:
                case 3479: case 6456: case 6455:
                    return false;
            }
            break;
        }
        // Northrend
        case 571:
            minLevel = 68;
            break;
        // Deepholm
        case 646:
            minLevel = 80;
            break;
        case 732:  //Tol Barad
        case 861:  //Molten Front
        case 1064: //Isle of Giants
            minLevel = 85;
            break;
        case 870:
            if (getClass() != CLASS_MONK)
                minLevel = 80;
            break;
        case 1116: //Draenor
        case 1265: //Dark Portal
            minLevel = 90;
            break;
        case 1220: //Legion: Broken Isles
        {
            //Allied Races start loc
            if (GetAreaId() == 7999 || GetAreaId() == 9502)
                return false;

            minLevel = 98;
            break;
        }
    }

    if (getLevel() < minLevel)
    {
        GetSession()->SendNotification(GetSession()->GetTrinityString(LANG_LEVEL_MINREQUIRED_MAP), minLevel);
        return true;
    }

    return false;
}

bool Player::IsLoXpMap(uint32 map)
{
    switch (map)
    {
        case 609:  // start DK
        case 648:  // start goblin
        case 654:  // start worgen
        case 860:  // start pandaren
        case 1265: // Dark Portal
        case 1481: // Start DH: Mardum, the Shattered Abyss
        case 1468: // Start DH: Vault of the Wardens
            return true;
        default:
            break;
    }

    return false;
}

void Player::SetSummonPoint(uint32 mapid, float x, float y, float z)
{
    m_summon_expire = time(NULL) + MAX_PLAYER_SUMMON_DELAY;
    m_summon_mapid = mapid;
    m_summon_x = x;
    m_summon_y = y;
    m_summon_z = z;
}

Difficulty Player::GetDifficultyID(MapEntry const* mapEntry) const
{
    if (m_scenarioId)
        if (lfg::LFGDungeonData const* data = sLFGMgr->GetLFGDungeon(m_scenarioId, (uint16)mapEntry->ID))
            return (Difficulty)data->dbc->DifficultyID;

    if (!mapEntry->IsRaid())
        return m_dungeonDifficulty;

    MapDifficultyEntry const* defaultDifficulty = sDB2Manager.GetDefaultMapDifficulty(mapEntry->ID);
    if (!defaultDifficulty)
        return GetLegacyRaidDifficultyID();

    DifficultyEntry const* difficulty = sDifficultyStore.LookupEntry(defaultDifficulty->DifficultyID);
    if (!difficulty || difficulty->Flags & DIFFICULTY_FLAG_LEGACY)
    {
        if (difficulty->Flags == (DIFFICULTY_FLAG_CAN_SELECT | DIFFICULTY_FLAG_LEGACY))
            return DIFFICULTY_25_N;

        return GetLegacyRaidDifficultyID();
    }

    return m_raidDifficulty;
}

Difficulty Player::CheckLoadedDungeonDifficultyID(Difficulty difficulty)
{
    DifficultyEntry const* difficultyEntry = sDifficultyStore.LookupEntry(difficulty);
    if (!difficultyEntry)
        return DIFFICULTY_NORMAL;

    if (difficultyEntry->InstanceType != MAP_INSTANCE)
        return DIFFICULTY_NORMAL;

    if (!(difficultyEntry->Flags & DIFFICULTY_FLAG_CAN_SELECT))
        return DIFFICULTY_NORMAL;

    return difficulty;
}

Difficulty Player::CheckLoadedRaidDifficultyID(Difficulty difficulty)
{
    DifficultyEntry const* difficultyEntry = sDifficultyStore.LookupEntry(difficulty);
    if (!difficultyEntry)
        return DIFFICULTY_NORMAL_RAID;

    if (difficultyEntry->InstanceType != MAP_RAID)
        return DIFFICULTY_NORMAL_RAID;

    if (!(difficultyEntry->Flags & DIFFICULTY_FLAG_CAN_SELECT) || (difficultyEntry->Flags & DIFFICULTY_FLAG_LEGACY))
        return DIFFICULTY_NORMAL_RAID;

    return difficulty;
}

Difficulty Player::CheckLoadedLegacyRaidDifficultyID(Difficulty difficulty)
{
    DifficultyEntry const* difficultyEntry = sDifficultyStore.LookupEntry(difficulty);
    if (!difficultyEntry)
        return DIFFICULTY_10_N;

    if (difficultyEntry->InstanceType != MAP_RAID)
        return DIFFICULTY_10_N;

    if (!(difficultyEntry->Flags & DIFFICULTY_FLAG_CAN_SELECT) || !(difficultyEntry->Flags & DIFFICULTY_FLAG_LEGACY))
        return DIFFICULTY_10_N;

    return difficulty;
}

void Player::SendRaidGroupOnlyMessage(RaidGroupReason reason, int32 delay) const
{
    WorldPackets::Instance::RaidGroupOnly raidGroupOnly;
    raidGroupOnly.Delay = delay;
    raidGroupOnly.Reason = static_cast<uint32>(reason);
    SendDirectMessage(raidGroupOnly.Write());
}

void Player::CastSpellInQueue()
{
    Unit* mover = m_mover;
    if (mover != this && mover->IsPlayer())
    {
        TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: mover != _player id %u", m_spellInQueue.CastData->SpellID);
        return;
    }

    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(m_spellInQueue.CastData->SpellID);
    if (!spellInfo)
    {
        TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: unknown spell id %u", m_spellInQueue.CastData->SpellID);
        return;
    }

    if (Player* plr = mover->ToPlayer())
    {
        // not have spell in spellbook or spell passive and not casted by client
        if ((!plr->HasActiveSpell(m_spellInQueue.CastData->SpellID) || spellInfo->IsPassive()) && !spellInfo->ResearchProject && m_spellInQueue.CastData->SpellID != 101054 && !spellInfo->HasEffect(SPELL_EFFECT_OPEN_LOCK) && !spellInfo->HasEffect(SPELL_EFFECT_LOOT_BONUS) &&
            !(spellInfo->HasAttribute(SPELL_ATTR8_RAID_MARKER)))
        {
            bool doneChecks = false;
            // check. Maybe it is spell from scenario ?
            Map* map = plr->GetMap();
            if (map && plr->InInstance())
                if (InstanceMap* instance = map->ToInstanceMap())
                    if (Scenario* progress = sScenarioMgr->GetScenario(instance->GetInstanceId()))
                    {
                        if (std::vector<ScenarioSpellData> const* scSpells = sObjectMgr->GetScenarioSpells(progress->GetScenarioId()))
                        {
                            for (auto scSpell : *scSpells)
                                if (scSpell.StepId == progress->GetCurrentStep())
                                    if (m_spellInQueue.CastData->SpellID == scSpell.Spells)
                                        doneChecks = true; // it is spell from scenario.
                        }
                    }
            if (!doneChecks)
            {
                if (m_spellInQueue.CastData->SpellID == 101603)
                {
                    mover->RemoveAurasDueToSpell(107837);
                    mover->RemoveAurasDueToSpell(101601);
                }
                else
                    if (m_spellInQueue.CastData->SpellID == 119393)
                    {
                        mover->RemoveAurasDueToSpell(119388);
                        mover->RemoveAurasDueToSpell(119386);
                    }
                    else if (!m_spellInQueue.CastData->Charmer.IsEmpty())
                    {
                        if (Garrison *garr = plr->GetGarrison())
                            if (!garr->CanCastTradeSkill(m_spellInQueue.CastData->Charmer, m_spellInQueue.CastData->SpellID))
                                return;
                    }
                    else
                    {
                        //cheater? kick? ban?
                        TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: cheater? kick? ban? TYPEID_PLAYER spell id %u", m_spellInQueue.CastData->SpellID);
                        return;
                    }
            }
        }
    }
    else
    {
        // spell passive and not casted by client
        if (spellInfo->IsPassive())
        {
            TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: spell passive and not casted by client id %u", m_spellInQueue.CastData->SpellID);
            return;
        }
        // not have spell in spellbook or spell passive and not casted by client
        if ((mover->IsCreature() && !mover->ToCreature()->HasSpell(m_spellInQueue.CastData->SpellID)) || spellInfo->IsPassive())
            if (mover->IsCreature() && !mover->ToCreature()->HasSpell(m_spellInQueue.CastData->SpellID))
            {
                if (HasActiveSpell(m_spellInQueue.CastData->SpellID))
                    mover = static_cast<Unit*>(this);
                else
                {
                    //cheater? kick? ban?
                    TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: not have spell in spellbook id %u", m_spellInQueue.CastData->SpellID);
                    return;
                }
            }
    }

    if (m_spellInQueue.CastData->SpellID != m_spellInQueue.CastData->SpellGuid.GetEntry())
        spellInfo = GetCastSpellInfo(spellInfo, m_spellInQueue.CastData->SpellGuid.GetEntry());

    // Client is resending autoshot cast opcode when other spell is casted during shoot rotation
    // Skip it to prevent "interrupt" message
    if (spellInfo->IsAutoRepeatRangedSpell() && GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL)
        && GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL)->m_spellInfo == spellInfo)
        return;

    // can't use our own spells when we're in possession of another unit,
    if (isPossessing())
    {
        TC_LOG_ERROR(LOG_FILTER_NETWORKIO, "WORLD: can't use our own spells when we're in possession id %u", m_spellInQueue.CastData->SpellID);
        return;
    }

    // client provided targets
    SpellCastTargets targets(mover, *m_spellInQueue.CastData);
    // auto-selection buff level base at target level (in spellInfo)
    if (targets.GetUnitTarget())
    {
        SpellInfo const* actualSpellInfo = spellInfo->GetAuraRankForLevel(targets.GetUnitTarget()->getLevel());

        // if rank not found then function return NULL but in explicit cast case original spell can be casted and later failed with appropriate error message
        if (actualSpellInfo)
            spellInfo = actualSpellInfo;
    }

    if (spellInfo->IsPassive()) // Fix cheat
        return;

    targets.m_weights.resize(m_spellInQueue.CastData->Weight.size());
    for (size_t i = 0; i < m_spellInQueue.CastData->Weight.size(); ++i)
    {
        targets.m_weights[i].type = m_spellInQueue.CastData->Weight[i].Type;
        switch (targets.m_weights[i].type)
        {
            case WEIGHT_KEYSTONE:
                targets.m_weights[i].keystone.itemId = m_spellInQueue.CastData->Weight[i].ID;
                targets.m_weights[i].keystone.itemCount = m_spellInQueue.CastData->Weight[i].Quantity;
                break;
            case WEIGHT_FRAGMENT:
                targets.m_weights[i].fragment.currencyId = m_spellInQueue.CastData->Weight[i].ID;
                targets.m_weights[i].fragment.currencyCount = m_spellInQueue.CastData->Weight[i].Quantity;
                break;
            default:
                targets.m_weights[i].raw.id = m_spellInQueue.CastData->Weight[i].ID;
                targets.m_weights[i].raw.count = m_spellInQueue.CastData->Weight[i].Quantity;
                break;
        }
    }

    if (m_session && m_spellInQueue.CastData->MoveUpdate)
        m_session->HandleMovementOpcode(CMSG_MOVE_STOP, *m_spellInQueue.CastData->MoveUpdate);

    TriggerCastData triggerData;
    triggerData.miscData0 = m_spellInQueue.CastData->Misc[0];
    triggerData.miscData1 = m_spellInQueue.CastData->Misc[1];
    triggerData.spellGuid = m_spellInQueue.CastData->SpellGuid;
    triggerData.replaced = true;

    Spell* spell = new Spell(mover, spellInfo, triggerData);
    spell->m_SpellVisual = m_spellInQueue.CastData->SpellXSpellVisualID;

    spell->prepare(&targets);
}

void Player::SendSpellScene(uint32 miscValue, SpellInfo const* /*spellInfo*/, bool apply, Position* pos)
{
    SpellScene const* spellScene = sSpellMgr->GetSpellScene(miscValue);
    if (!spellScene)
        return;

    if (apply)
    {
        WorldPackets::Scene::PlayScene scene;
        scene.SceneID = miscValue;
        scene.PlaybackFlags = spellScene->PlaybackFlags;
        scene.SceneInstanceID = ++sceneInstanceID;
        scene.SceneScriptPackageID = spellScene->SceneScriptPackageID;
        scene.Pos = pos->GetPosition();
        SendDirectMessage(scene.Write());

        // Link aura effect
        m_sceneInstanceID[sceneInstanceID] = miscValue;
        m_sceneStatus[miscValue] = SCENE_LAUNCH;
    }
    else
    {
        uint32 ID = 0;
        for (auto data : m_sceneInstanceID)
            if (data.second == miscValue) // no break. get last.
                ID = data.first;

        if (!ID)    //as we have sctipt with finishing scene it now could be 0.
            return;

        //TODO: this is a hack to "properly" reload the phase when completing the Keystone quest + scene
        // this should probably always be happening, but this I'd rather not break anything
        if (miscValue == 1142)
            SceneCompleted(ID);

        SendDirectMessage(WorldPackets::Scene::CancelScene(ID).Write());
    }
}

/*
struct SceneEventStatus
{
SCENE_NONE          = 0,
SCENE_LAUNCH        = 1,
SCENE_COMPLETE      = 2,
};

*/
void Player::SceneCompleted(uint32 instance)
{
    auto data = m_sceneInstanceID.find(instance);
    if (data == m_sceneInstanceID.end())
        return;

    // Triger some events at complete scene.
    TrigerScene(instance, "complete");

    m_sceneStatus[data->second] = SCENE_COMPLETE;

    AddDelayedEvent(100, [this]() -> void
    {
        GetPhaseMgr().RemoveUpdateFlag(PHASE_UPDATE_FLAG_ZONE_UPDATE);
    });

    if (AuraEffectList const* periodicAuras = GetAuraEffectsByType(SPELL_AURA_ACTIVATE_SCENE))
    {
        for (AuraEffectList::const_iterator i = periodicAuras->begin(); i != periodicAuras->end(); ++i)
        {
            if ((*i)->GetMiscValue() == data->second)
            {
                RemoveAurasDueToSpell((*i)->GetId());
                break;
            }
        }
    }
}

//! If check SCENE_LAUNCH return true if SCENE_COMPLETE too
bool Player::HasSceneStatus(uint32 sceneID, SceneEventStatus const& status) const
{
    auto data = m_sceneStatus.find(sceneID);
    if (data == m_sceneStatus.end())
        return false;

    return data->second >= status;
}

void Player::TrigerScene(uint32 instanceID, std::string const Event)
{
    auto data = m_sceneInstanceID.find(instanceID);
    if (data == m_sceneInstanceID.end())
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER, " >> TrigerScene can't find instance Event: %s instance %u", Event.c_str(), instanceID);
        return;
    }

    if (SpellScene const* spell_scene = sSpellMgr->GetSpellScene(data->second))
        if (sScriptMgr->OnSceneTrigger(this, spell_scene, Event))
            return;

    const std::vector<SceneTriggerEvent>* triggerEvent = sSpellMgr->GetSceneTriggerEvent(data->second);
    if (!triggerEvent)
    {
        TC_LOG_DEBUG(LOG_FILTER_PLAYER, " >> TrigerScene can't find SpellScene instance Event: %s instance %u Misc %u", Event.c_str(), instanceID, data->second);
        return;
    }

    m_sceneStatus[data->second] = SCENE_TRIGER;

    for (std::vector<SceneTriggerEvent>::const_iterator itr = triggerEvent->begin(); itr != triggerEvent->end(); ++itr)
    {
        if (itr->Event == "")
        {
            if (Event == "Visual" || Event == "Clear")
            {
                if (itr->trigerSpell)
                {
                    if (Event == "Visual" && !HasAura(itr->trigerSpell))
                        CastSpell(this, itr->trigerSpell, true);
                    else if (Event == "Clear" && HasAura(itr->trigerSpell))
                        RemoveAurasDueToSpell(itr->trigerSpell);
                }
                else
                    TC_LOG_DEBUG(LOG_FILTER_PLAYER, " >> TrigerScene unhandle Event: %s MiscValue %u", Event.c_str(), itr->MiscValue);
            }
            else
            {
                bool prock = false;
                if (itr->trigerSpell)
                {
                    prock = true;
                    CastSpell(this, itr->trigerSpell, true);
                }

                if (itr->MonsterCredit)
                {
                    prock = true;
                    KilledMonsterCredit(itr->MonsterCredit);
                }

                if (!prock)
                    TC_LOG_DEBUG(LOG_FILTER_PLAYER, " >> TrigerScene unhandle Event: %s MiscValue %u", Event.c_str(), itr->MiscValue);
            }
        }
        else if (itr->Event == Event)
        {
            if (itr->trigerSpell)
                CastSpell(this, itr->trigerSpell, true);

            if (itr->MonsterCredit)
                KilledMonsterCredit(itr->MonsterCredit);
        }
    }
}

void Player::HandleArenaDeserter()
{
    if (IsSpectator())
        return;

    RemoveAurasDueToSpell(SPELL_BG_CRAVEN);
    CastSpell(this, SPELL_BG_CRAVEN, true);
}

bool Player::HasInstantCastModForSpell(SpellInfo const* spellInfo)
{
    if (!spellInfo)
        return false;

    for (SpellModList::iterator itr = m_spellMods[SPELLMOD_CASTING_TIME].begin(); itr != m_spellMods[SPELLMOD_CASTING_TIME].end(); ++itr)
        if ((*itr)->value == -100)
            if (spellInfo->IsAffectedBySpellMod(*itr))
                return true;

    return false;
}

void Player::CreateGarrison(uint32 garrSiteId, bool skip /* = false*/)
{
    /*std::unique_ptr<Garrison> garrison(new Garrison(this));
    if (garrison->Create(garrSiteId))
        _garrison = std::move(garrison);
        */

    // multi-site support.
    _garrison->Create(garrSiteId, skip);
}

void Player::DeleteGarrison()
{
    if (_garrison)
        _garrison->Delete();
}

bool Player::CheckShipment(CharShipmentEntry const* shipmentEntry)
{
    if (shipmentEntry->DummyItemID == 146745)
        return false;
    return true;
}

uint32 Player::SelectArfiactSpellForSpec(uint32 specID)
{
    switch (specID)
    {
    case SPEC_MAGE_ARCANE:
        return 211954;
    case SPEC_MAGE_FIRE:
        return 196020;
    case SPEC_MAGE_FROST:
        return 214775;
    case SPEC_PALADIN_HOLY:
        return 211842;
    case SPEC_PALADIN_PROTECTION:
        return 210133;
    case SPEC_PALADIN_RETRIBUTION:
        return 181257;
    case SPEC_WARRIOR_ARMS:
        return 206439;
    case SPEC_WARRIOR_FURY:
        return 194201;
    case SPEC_WARRIOR_PROTECTION:
        return 208562;
    case SPEC_DRUID_BALANCE:
        return 205387;
    case SPEC_DRUID_CAT:
        return 214715;
    case SPEC_DRUID_BEAR:
        return 199963;
    case SPEC_DRUID_RESTORATION:
        return 207562;
    case SPEC_DK_BLOOD:
        return 200134;
    case SPEC_DK_FROST:
        return 186202;
    case SPEC_DK_UNHOLY:
        return 202618;
    case SPEC_HUNTER_BEASTMASTER:
        return 212011;
    case SPEC_HUNTER_MARKSMAN:
        return 200262;
    case SPEC_HUNTER_SURVIVAL:
        return 197651;
    case SPEC_PRIEST_DISCIPLINE:
        return 208011;
    case SPEC_PRIEST_HOLY:
        return 210734;
    case SPEC_PRIEST_SHADOW:
        return 201778;
    case SPEC_ROGUE_ASSASSINATION:
        return 215113;
    case SPEC_ROGUE_COMBAT:
        return 202182;
    case SPEC_ROGUE_SUBTLETY:
        return 209818;
    case SPEC_SHAMAN_ELEMENTAL:
        return 199863;
    case SPEC_SHAMAN_ENHANCEMENT:
        return 193747;
    case SPEC_SHAMAN_RESTORATION:
        return 209685;
    case SPEC_WARLOCK_AFFLICTION:
        return 204819;
    case SPEC_WARLOCK_DEMONOLOGY:
        return 211764;
    case SPEC_WARLOCK_DESTRUCTION:
        return 219839;
    case SPEC_MONK_BREWMASTER:
        return 217813;
    case SPEC_MONK_WINDWALKER:
        return 199499;
    case SPEC_MONK_MISTWEAVER:
        return 202438;
    case SPEC_DEMON_HUNER_HAVOC:
        return 189523;
    case SPEC_DEMON_HUNER_VENGEANCE:
        return 208301;
    default:
        return 0;
    }
}

void Player::OnEnterMap()
{
    GetPhaseMgr().Recalculate();
}

void Player::AchieveCriteriaCredit(uint32 criteriaID)
{
    for (uint8 i = 0; i < MAX_QUEST_LOG_SIZE; ++i)
    {
        uint32 questid = GetQuestSlotQuestId(i);
        if (questid == 0)
            continue;

        QuestStatusData* q_status = getQuestStatus(questid);

        if (!q_status || q_status->Status != QUEST_STATUS_INCOMPLETE)
            continue;

        Quest const* qInfo = sQuestDataStore->GetQuestTemplate(questid);
        if (!qInfo)
            continue;

        for (QuestObjective const& obj : qInfo->GetObjectives())
        {
            if (obj.Type != QUEST_OBJECTIVE_COMPLETE_CRITERIA_TREE)
                continue;

            if (obj.ObjectID == criteriaID)
            {
                int32 Amount = GetQuestObjectiveData(qInfo, obj.StorageIndex) + 1;
                SetQuestObjectiveData(qInfo, &obj, Amount);

                //SMSG_QUEST_UPDATE_ADD_CREDIT_SIMPLE
                if (CanCompleteQuest(questid))
                {
                    AddDelayedEvent(1000, [this, questid]() -> void { CompleteQuest(questid); });
                    break;
                }
            }
        }
    }
}

void Player::SendVersionMismatchWarinings()
{
    char buff[2048];
    sprintf(buff, GetSession()->GetTrinityString(LANG_CLIENT_VERSION_MISMATCH_MESSAGE));
    sWorld->SendServerMessage(SERVER_MSG_STRING, buff);

    GetSession()->SendNotification(LANG_CLIENT_VERSION_MISMATCH_MESSAGE_NOTIFY);
}

uint32 Player::GetGoVisualQuestData(GameObject const* go, uint32 field) const
{
    uint8 idx = GO_VISUAL_BEFORE_COMPLETE_QUEST;

    if (go->GetGOInfo()->visualQuestID)
    {
        QuestStatus status = GetQuestStatus(go->GetGOInfo()->visualQuestID);
        switch (status)
        {
            case QUEST_STATUS_COMPLETE:
            case QUEST_STATUS_REWARDED:
                idx = GO_VISUAL_AFTER_COMPLETEQUEST;
                break;
            default:
                break;
        }
    }
    return field == GAMEOBJECT_FIELD_STATE_WORLD_EFFECT_ID ? go->GetGOInfo()->visualData[idx].StateWorldEffectID : go->GetGOInfo()->visualData[idx].SpellStateVisualID;
}

Loot* Player::GetPersonalLoot(ObjectGuid const& guid)
{
    if (!CanContact())
        return NULL;

    PersonalLootMap::iterator itr = personalLoot.find(guid);
    if (itr != personalLoot.end())
        return &itr->second;

    return NULL;
}

void Player::RemoveLoot(ObjectGuid const& guid)
{
    if (!CanContact())
        return;

    std::lock_guard<std::recursive_mutex> guard(i_personalLootLock);
    personalLoot.erase(guid);
}

uint32 Player::GetGoldFromLoot()
{
    uint32 money = 0;

    if (!CanContact())
        return money;

    std::lock_guard<std::recursive_mutex> guard(i_personalLootLock);
    for (PersonalLootMap::iterator itr = personalLoot.begin(); itr != personalLoot.end();)
    {
        if (itr->second.isOpen)
        {
            if (itr->second.gold)
                SendNotifyLootMoneyRemoved(&itr->second);

            money += itr->second.gold;
            itr->second.NotifyMoneyRemoved(itr->second.gold);
            itr->second.gold = 0;
            ++itr;
            continue;
        }
        if (itr->first.IsCreatureOrPetOrVehicle() && !ObjectAccessor::GetCreatureOrPetOrVehicle(*this, itr->first))
        {
            personalLoot.erase(itr++);
            continue;
        }
        ++itr;
    }

    if (!money)
        return money;

    WorldPackets::Loot::LootMoneyNotify notify;
    notify.Money = money;
    notify.SoleLooter = true;
    SendDirectMessage(notify.Write());

    ModifyMoney(money);
    UpdateAchievementCriteria(CRITERIA_TYPE_LOOT_MONEY, money, 0, 0, this);

    return money;
}

void Player::AddNonVisibleItemToCollect()
{
    if (getLevel() == MAX_LEVEL) // World Quests Available
    {
        if (IsQuestRewarded(46319) && !HasSpell(231437)) // Druid class mount form
            learnSpell(231437, false);

        if (IsQuestRewarded(32325) && !HasAura(101508)) // The Codex of Xerrath
            learnSpell(101508, false);

        if (getClass() == CLASS_DEATH_KNIGHT)
        {
            if (!IsQuestRewarded(13188) && !IsQuestRewarded(13189))
            {
                if (GetTeam() == HORDE)
                {
                    m_RewardedQuests.insert(13189);
                    m_RewardedQuestsSave[13189] = QUEST_DEFAULT_SAVE_TYPE;
                    SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(13189), true);
                }
                else
                {
                    m_RewardedQuests.insert(13188);
                    m_RewardedQuestsSave[13188] = QUEST_DEFAULT_SAVE_TYPE;
                    SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(13188), true);
                }
            }
        }
    }

    for (auto const itemEntry : {
        134110, // Hidden Helm
        134111, // Hidden Cloak
        134112, // Hidden Shoulder
        142503, // Hidden Shirt
        142504, // Hidden Tabard
        143539  // Hidden Belt
        })
    {
        uint32 transmogId = sDB2Manager.GetTransmogId(itemEntry);
        if (transmogId && !GetCollectionMgr()->HasTransmog(transmogId))
            GetCollectionMgr()->AddTransmog(transmogId, 0);
    }
}

void Player::UnLockThirdSocketIfNeed(Item* item)
{
    // Artifact Knowledge
    if (getLevel() == MAX_LEVEL)
    {
        if (GetCurrency(CURRENCY_TYPE_ARTIFACT_KNOWLEDGE) != sWorld->getWorldState(WS_CURRENT_ARTIFACT_KNOWLEDGE))
            SetCurrency(CURRENCY_TYPE_ARTIFACT_KNOWLEDGE, sWorld->getWorldState(WS_CURRENT_ARTIFACT_KNOWLEDGE));
    }
    else if (getLevel() >= 98)
    {
        if (sWorld->getWorldState(WS_CURRENT_ARTIFACT_KNOWLEDGE) >= 26)
        {
            if (GetCurrency(CURRENCY_TYPE_ARTIFACT_KNOWLEDGE) < 26)
                SetCurrency(CURRENCY_TYPE_ARTIFACT_KNOWLEDGE, 26);
        }
        else
        {
            if (GetCurrency(CURRENCY_TYPE_ARTIFACT_KNOWLEDGE) != sWorld->getWorldState(WS_CURRENT_ARTIFACT_KNOWLEDGE))
                SetCurrency(CURRENCY_TYPE_ARTIFACT_KNOWLEDGE, sWorld->getWorldState(WS_CURRENT_ARTIFACT_KNOWLEDGE));
        }
    }

    ArtifactUnlockEntry const* unlock = sDB2Manager.GetArtifactUnlock(item->GetTemplate()->GetArtifactID());
    if (!unlock)
        return;

    uint32 bonusID = unlock->ItemBonusListID;
    uint32 questID = GetQuestForUnLockThirdSocket();


    if (item->GetTotalPurchasedArtifactPowers() > 35 && !item->GetModifier(ITEM_MODIFIER_ARTIFACT_TIER) && sWorld->getBoolConfig(CONFIG_ARTIFACT_TIER_ENABLE))
    {
        uint64 free_xp = item->GetUInt32Value(ITEM_FIELD_ARTIFACT_XP);
        for (uint32 i = 36; i <= item->GetTotalPurchasedArtifactPowers(); i++)
            if (GtArtifactLevelXPEntry const* cost = sArtifactLevelXPGameTable.GetRow(i))
                    free_xp += cost->XP;

        item->SetUInt64Value(ITEM_FIELD_ARTIFACT_XP, free_xp);

        for (ItemDynamicFieldArtifactPowers const& artifactPowerDyn : item->GetArtifactPowers())
        {
            ArtifactPowerEntry const* artifactPower = sArtifactPowerStore.AssertEntry(artifactPowerDyn.ArtifactPowerId);
            if (!artifactPower || artifactPower->MaxPurchasableRank != 20) // Find last power
                continue;

            ItemDynamicFieldArtifactPowers newPower = artifactPowerDyn;
            newPower.PurchasedRank = 1;
            newPower.CurrentRankWithBonus = 1;
            item->SetArtifactPower(&newPower);

            if (item->IsEquipped())
                if (ArtifactPowerRankEntry const* artifactPowerRank = sDB2Manager.GetArtifactPowerRank(artifactPowerDyn.ArtifactPowerId, 0))
                    ApplyArtifactPowerRank(item, artifactPowerRank, false);
        }

        WorldPackets::Artifact::ArtifactTraitsRefunded packet;
        packet.Guid = item->GetGUID();
        packet.UnkInt = 0;
        packet.UnkInt2 = 0;
        SendDirectMessage(packet.Write());

        item->SetModifier(ITEM_MODIFIER_ARTIFACT_TIER, 1);
        item->InitArtifactsTier(item->GetTemplate()->GetArtifactID());
        item->SetState(ITEM_CHANGED, this);
    }

    for (uint32 bonusListID : item->GetDynamicValues(ITEM_DYNAMIC_FIELD_BONUS_LIST_IDS))
        if (bonusListID == bonusID)
            return;

    if (unlock = sDB2Manager.GetArtifactUnlock(item->GetTemplate()->GetArtifactID()))
        if (sConditionMgr->IsPlayerMeetingCondition(this, unlock->PlayerConditionID))
            item->AddBonuses(bonusID);
}

void Player::ChaeckSeamlessTeleport(uint32 newZoneOrArea, bool isArea)
{
    if (!isArea && (m_zoneId ? m_zoneId : m_oldZoneId) != newZoneOrArea)
    {
        SeamlessTeleportData const* from = sObjectMgr->GetSeamlessTeleportZone(m_zoneId ? m_zoneId : m_oldZoneId);
        SeamlessTeleportData const* to = sObjectMgr->GetSeamlessTeleportZone(newZoneOrArea);

        if (from != to)
        {
            if (from && !to)
            {
                if (GetMapId() != from->FromMapID && GetMapId() == from->ToMapID)
                    TeleportTo(from->FromMapID, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation(), TELE_TO_SEAMLESS);
            }
            else if (to && !from)
            {
                ConditionList conditions = sConditionMgr->GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_SEAMLESS_TELEPORT, to->ToMapID);
                if (sConditionMgr->IsObjectMeetToConditions(this, conditions))
                    if (GetMapId() != to->ToMapID)
                        TeleportTo(to->ToMapID, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation(), TELE_TO_SEAMLESS);
            }
            else
            {
                if (to->ToMapID != from->ToMapID)
                    TeleportTo(to->ToMapID, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation(), TELE_TO_SEAMLESS);
            }
        }
    }

	if (isArea && m_areaId != newZoneOrArea)
    {
        SeamlessTeleportData const* from = sObjectMgr->GetSeamlessTeleportArea(m_areaId);
        SeamlessTeleportData const* to = sObjectMgr->GetSeamlessTeleportArea(newZoneOrArea);

        if (from != to)
        {
            if (from && !to)
            {
                if (GetMapId() != from->FromMapID && GetMapId() == from->ToMapID)
                    TeleportTo(from->FromMapID, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation(), TELE_TO_SEAMLESS);
            }
            else if (to && !from)
            {
                ConditionList conditions = sConditionMgr->GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_SEAMLESS_TELEPORT, to->ToMapID);
                if (sConditionMgr->IsObjectMeetToConditions(this, conditions))
                    if (GetMapId() != to->ToMapID)
                        TeleportTo(to->ToMapID, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation(), TELE_TO_SEAMLESS);
            }
            else
            {
                if (to->ToMapID != from->ToMapID)
                    TeleportTo(to->ToMapID, GetPositionX(), GetPositionY(), GetPositionZ(), GetOrientation(), TELE_TO_SEAMLESS);
            }
        }
    }
}

bool Player::InFFAPvPArea()
{
    switch (m_areaId)
    {
        case 7594: // Cloack
            if (GetMapId() == 1502 && HasAura(223202)) // After script Kloaka
            // if (GetMapId() == 1502)
                return true;
            break;
        case 7618: // Timeworn Strand
        case 8049: // Darkbrul Arena
        case 8151: // Black Rook Hold Arena
        case 8168: // Storms Reach
            return true;
    }
    
    if (GetMapId() == 1101)
        return true;
    
    return false;
}

void Player::UpdatePlayerNameData()
{
    sWorld->UpdateCharacterNameDataZoneGuild(GetGUID().GetCounter(), m_zoneId, GetGuildId(), GetRank());
}

uint16 Player::getAdventureQuestID()
{
    // if not 0 check if the adventure quest is still in the quest journal, otherwise return 0
    if (m_adventure_questID && GetQuestStatus(m_adventure_questID) != QUEST_STATUS_REWARDED && GetQuestStatus(m_adventure_questID) != QUEST_STATUS_NONE)
        return m_adventure_questID;

    return 0;
}

void Player::setAdventureQuestID(uint16 questID)
{
    Quest const* quest = sQuestDataStore->GetQuestTemplate(questID);
    if (!quest)
        return;

    m_adventure_questID = questID;
    m_AdventureQuestChanged = true;
    KilledMonsterCredit(97067);
}

int32 Player::GetCommandCooldown() const
{
    return m_playerCommandCooldown;
}

void Player::ResetCommandCooldown()
{
    m_playerCommandCooldown = sWorld->getIntConfig(CONFIG_WORLD_PLAYER_COMMAND_TIMER);
}

void Player::SendCustomMessage(std::string const& n)
{
    std::ostringstream msg;
    msg << n << "|" << " " << "|";
    ChatHandler(this).SendSysMessage(msg.str().c_str());
}

void Player::SendCustomMessage(std::string const& n, std::ostringstream const& data)
{
    std::ostringstream msg;
    msg << n << "|" << data.str() << "|";
    ChatHandler(this).SendSysMessage(msg.str().c_str());
}

void Player::SendCustomMessage(std::string const& n, std::vector<std::string> const& data)
{
    std::ostringstream msg;
    msg << n << "|";

    if (!data.empty())
    {
        for (auto const& i : data)
            msg << i << "| ";
    }
    else
        msg << " " << "|";

    ChatHandler(this).SendSysMessage(msg.str().c_str());
}

void Player::ApplyWargameItemModifications()
{
    bool inWargame = GetBattleground() && GetBattleground()->IsWargame();
    bool tournamentRules = GetBattleground() && GetBattleground()->UseTournamentRules();

    for (uint8 i = 0; i < EQUIPMENT_SLOT_END; ++i)
    {
        if (Item* item = m_items[i])
        {
            bool updateItemMods = false;

            if (inWargame)
            {
                if (item->GetTemplate()->GetFlags3() & ItemFlags3::ITEM_FLAG3_PVP_TOURNAMENT_GEAR)
                {
                    if (item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_DISABLE))
                    {
                        item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_DISABLE);
                        updateItemMods = true;
                    }
                }
                else if (tournamentRules && !item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_DISABLE))
                {
                    item->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_DISABLE);
                    updateItemMods = true;
                }
            }
            else
            {
                if (item->GetTemplate()->GetFlags3() & ItemFlags3::ITEM_FLAG3_PVP_TOURNAMENT_GEAR)
                {
                    if (!item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_DISABLE))
                    {
                        item->SetFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_DISABLE);
                        updateItemMods = true;
                    }
                }
                else if (item->HasFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_DISABLE))
                {
                    item->RemoveFlag(ITEM_FIELD_DYNAMIC_FLAGS, ItemFieldFlags::ITEM_FLAG_DISABLE);
                    updateItemMods = true;
                }
            }

            if (updateItemMods)
            {
                _ApplyItemMods(item, i, false);
                _ApplyItemMods(item, i, true);
            }
        }
    }
}

void Player::SendLfgDisabled()
{
    AddUpdatePacket(WorldPackets::LFG::NullSmsg(SMSG_LFG_DISABLED).Write());
}

void Player::SendLfgOfferContinue(uint32 dungeonEntry)
{
    AddUpdatePacket(WorldPackets::LFG::LFGOfferContinue(dungeonEntry).Write());
}

void Player::SendLfgTeleportError(uint8 err)
{
    AddUpdatePacket(WorldPackets::LFG::TeleportDenied(err).Write());
}

void Player::SendLfgUpdatePlayer()
{
    if (!sLFGMgr->HasQueue(GetGUID()))
        return;

    if (!CanContact())
        return;

    sLFGMgr->SendLfgUpdateQueue(GetGUID());
}

void Player::ModifyExcludeCasterAuraSpell(uint32 auraId, bool apply)
{
    if (apply)
    {
        std::list<uint32> removeAuraList;
        Unit::AuraApplicationMap& auras = GetAppliedAuras();
        for (Unit::AuraApplicationMap::iterator iter = auras.begin(); iter != auras.end(); ++iter)
        {
            AuraApplicationPtr auraApp = iter->second;
            if (!auraApp || !auraApp->GetBase())
                continue;

            SpellInfo const* spellProto = auraApp->GetBase()->GetSpellInfo();

            if (spellProto->Id == auraId)
                continue;

            if (spellProto->AuraRestrictions.ExcludeCasterAuraSpell == auraId && spellProto->IsPassive())
                removeAuraList.push_back(spellProto->Id);
        }

        ItemSpellList itmSpells = GetItemSpellList();
        for (ItemSpellList::iterator itr = itmSpells.begin(); itr != itmSpells.end(); ++itr)
        {
            SpellInfo const* spellProto = sSpellMgr->GetSpellInfo(*itr);

            if (spellProto->Id == auraId)
                continue;

            if (spellProto->AuraRestrictions.ExcludeCasterAuraSpell == auraId && spellProto->IsPassive())
                removeAuraList.push_back(spellProto->Id);
        }

        for (std::list<uint32>::iterator it = removeAuraList.begin(); it != removeAuraList.end(); ++it)
            RemoveAurasDueToSpell(*it);
    }
    else
    {
        ExcludeCasterSpellList auraSpells = GetExcludeCasterSpellList();
        for (ExcludeCasterSpellList::iterator itr = auraSpells.begin(); itr != auraSpells.end(); ++itr)
        {
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(*itr);
            if (!spellInfo)
                continue;

            if (spellInfo->AuraRestrictions.ExcludeCasterAuraSpell == auraId && !HasAura(spellInfo->Id))
                CastSpell(this, spellInfo->Id, true);
        }

        ItemSpellList itmSpells = GetItemSpellList();
        for (ItemSpellList::iterator itr = itmSpells.begin(); itr != itmSpells.end(); ++itr)
        {
            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(*itr);

            if (!spellInfo)
                continue;

            if (spellInfo->AuraRestrictions.ExcludeCasterAuraSpell == auraId && !HasAura(spellInfo->Id) && spellInfo->IsPassive())
                CastSpell(this, spellInfo->Id, true);
        }
    }
}

PlayerSpellMap const& Player::GetSpellMapConst()
{
    return m_spells;
}

PlayerSpellMap& Player::GetSpellMap()
{
    return m_spells;
}

const ItemSpellList& Player::GetItemSpellList()
{
    return m_itemSpellList;
}

void Player::HandleItemSpellList(uint32 spellId, bool apply)
{
    if (apply)
        m_itemSpellList.push_back(spellId);
    else
        m_itemSpellList.remove(spellId);
}

ExcludeCasterSpellList const& Player::GetExcludeCasterSpellList()
{
    return m_excludeCasterSpellList;
}

void Player::HandleExcludeCasterSpellList(uint32 spellId, bool apply)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return;

    if (!spellInfo->AuraRestrictions.ExcludeCasterAuraSpell || !spellInfo->IsPassive())
        return;

    if (apply)
        m_excludeCasterSpellList.push_back(spellId);
    else
        m_excludeCasterSpellList.remove(spellId);
}

CasterAuraStateSpellList const& Player::GetCasterAuraStateSpellList()
{
    return m_casterAuraStateSSpellList;
}

void Player::HandleCasterAuraStateSpellList(uint32 spellId, bool apply)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return;

    if (!spellInfo->AuraRestrictions.CasterAuraState || !spellInfo->IsPassive())
        return;

    if (apply)
        m_casterAuraStateSSpellList.push_back(spellId);
    else
        m_casterAuraStateSSpellList.remove(spellId);
}

SpellCooldowns const& Player::GetSpellCooldownMap() const
{
    return m_spellCooldowns;
}

void Player::AddClient(ObjectGuid guid)
{
    i_clientGUIDLock.lock();
    m_clientGUIDs.insert(guid);
    i_clientGUIDLock.unlock();
}

void Player::RemoveClient(ObjectGuid guid)
{
    i_clientGUIDLock.lock();
    m_clientGUIDs.erase(guid);
    i_clientGUIDLock.unlock();
}

GuidSet& Player::GetClient()
{
    return m_clientGUIDs;
}

void Player::ClearClient()
{
    i_clientGUIDLock.lock();
    m_clientGUIDs.clear();
    i_clientGUIDLock.unlock();
}

bool Player::HaveAtClient(WorldObject const* u)
{
    if (u == this)
        return true;

    return m_clientGUIDs.find(u->GetGUID()) != m_clientGUIDs.end();
}

void Player::SendForceUpdateToClient()
{
    if (!CanContact())
        return;

    UpdateData upd(GetMapId());
    WorldPacket packet;

    BuildValuesUpdateBlockForPlayer(&upd, this);

    if (upd.BuildPacket(&packet))
        GetSession()->SendPacket(&packet);
}

bool Player::CanContact()
{
    return !IsDelete() && IsInWorld() && !IsChangeMap() && m_session && !m_session->PlayerLoading() && !m_session->PlayerLogout();
}

void Player::SendCalendarRaidLockout(InstanceSave const* save, bool add)
{
    if (add)
    {
        time_t currTime = time(nullptr);
        WorldPackets::Calendar::CalendarRaidLockoutAdded calendarRaidLockoutAdded;
        calendarRaidLockoutAdded.InstanceID = save->GetInstanceId();
        calendarRaidLockoutAdded.ServerTime = currTime;
        calendarRaidLockoutAdded.MapID = save->GetMapId();
        calendarRaidLockoutAdded.DifficultyID = save->GetDifficultyID();
        calendarRaidLockoutAdded.TimeRemaining = save->GetResetTime() - currTime;
        SendDirectMessage(calendarRaidLockoutAdded.Write());
    }
    else
    {
        WorldPackets::Calendar::CalendarRaidLockoutRemoved calendarRaidLockoutRemoved;
        calendarRaidLockoutRemoved.InstanceID = save->GetInstanceId();
        calendarRaidLockoutRemoved.MapID = save->GetMapId();
        calendarRaidLockoutRemoved.DifficultyID = save->GetDifficultyID();
        SendDirectMessage(calendarRaidLockoutRemoved.Write());
    }
}

void Player::SendCalendarRaidLockoutUpdated(InstanceSave const* save)
{
    if (!save)
        return;

    WorldPackets::Calendar::CalendarRaidLockoutUpdated packet;
    packet.DifficultyID = save->GetDifficultyID();
    packet.MapID = save->GetMapId();
    packet.OldTimeRemaining = save->GetResetTime() - time(nullptr);
    SendDirectMessage(packet.Write());
}

void Player::DeliveryRewardPack(uint32 rewardPackID)
{
    RewardPackEntry const* entry = sRewardPackStore.LookupEntry(rewardPackID);
    if (!entry)
        return;

    ModifyMoney(entry->Money);

    if (CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(entry->CharTitleID))
        SetTitle(titleEntry);

    if (RewardPackXItemEntry const* xItemEntry = sDB2Manager.GetRewardPackXItem(rewardPackID))
    {
        uint32 ItemID = xItemEntry->ItemID;
        // blizzard hack
        if (ItemID == 140452 && GetTeamId() == TEAM_HORDE)
            ItemID = 140455;
        if (ItemID == 140453 && GetTeamId() == TEAM_HORDE)
            ItemID = 140456;
        if (ItemID == 140454 && GetTeamId() == TEAM_HORDE)
            ItemID = 140457;

        ItemPosCountVec dest;
        if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, ItemID, xItemEntry->ItemQuantity) == EQUIP_ERR_OK)
            SendNewItem(StoreNewItem(dest, ItemID, true), xItemEntry->ItemQuantity, true, false, true);
    }

    if (auto const& currencyEntry = sDB2Manager.GetRewardPackXCurrency(rewardPackID))
    {
        ModifyCurrency(currencyEntry->CurrencyTypeID, currencyEntry->Quantity);

        // log Veiled Argunite and Wakening Essence currency
        if (currencyEntry->CurrencyTypeID == 1508 || currencyEntry->CurrencyTypeID == 1533)
            sLog->outWarden("Player %s (GUID: %u) adds a currency value %u (%u) from rewardPack %u", GetName(), GetGUIDLow(), currencyEntry->Quantity, currencyEntry->CurrencyTypeID, rewardPackID);
    }

    ///< local function CreateHackRewardInfo() -- TODO:  Remove this when we can figure this out in a better way @hack from blizzard
    if (m_honorInfo.HonorLevel == 50 && m_honorInfo.PrestigeLevel == 0)
    {
        uint32 itemID[2] = { 138992, 138996 };
        ItemPosCountVec dest2;
        if (CanStoreNewItem(NULL_BAG, NULL_SLOT, dest2, itemID[GetTeamId()], 1) == EQUIP_ERR_OK)
            SendNewItem(StoreNewItem(dest2, itemID[GetTeamId()], true), 1, true, false, true);
    }
}

QuestStatusData* Player::getQuestStatus(uint32 questId)
{
    if (!sQuestDataStore->GetQuestTemplate(questId))
        return nullptr;

    return (*m_QuestStatusVector)[questId];
}

bool Player::IsQuestRewarded(uint32 quest_id) const
{
    if (Quest const* qInfo = sQuestDataStore->GetQuestTemplate(quest_id))
    {
        if (qInfo->IsDaily())
            return IsQuestDailyRewarded(quest_id);

        if (qInfo->IsWeekly())
            return IsQuestWeekRewarded(quest_id);

        if (qInfo->IsSeasonal())
            return IsQuestSeasonalRewarded(quest_id);

        if (qInfo->IsDFQuest())
            return IsQuestDFRewarded(quest_id);
    }
    return m_RewardedQuests.find(quest_id) != m_RewardedQuests.end();
}

bool Player::HasAccountQuest(uint32 quest_id) const
{
    if (GetQuestRewardStatus(quest_id))
        return true;
    return m_accuntQuests.find(quest_id) != m_accuntQuests.end();
}

bool Player::IsQuestDFRewarded(uint32 quest_id) const
{
    return m_DFQuests.find(quest_id) != m_DFQuests.end();
}

bool Player::IsQuestDailyRewarded(uint32 quest_id) const
{
    return m_dailyquests.find(quest_id) != m_dailyquests.end();
}

bool Player::IsQuestWeekRewarded(uint32 quest_id) const
{
    return m_weeklyquests.find(quest_id) != m_weeklyquests.end();
}

bool Player::IsQuestSeasonalRewarded(uint32 quest_id) const
{
    if (m_seasonalquests.empty())
        return false;

    Quest const* qInfo = sQuestDataStore->GetQuestTemplate(quest_id);
    if (!qInfo)
        return false;

    uint16 eventId = sGameEventMgr->GetEventIdForQuest(qInfo);
    SeasonalEventQuestMap::const_iterator iter = m_seasonalquests.find(eventId);
    if (iter == m_seasonalquests.end() || iter->second.empty())
        return false;

    // if not found in cooldown list
    return iter->second.find(quest_id) != iter->second.end();
}

void Player::AddUpdateItem(Item* item)
{
    std::lock_guard<std::recursive_mutex> guard(i_itemUpdate_lock);
    m_itemUpdate.insert(item);
}

void Player::RemoveUpdateItem(Item* item)
{
    std::lock_guard<std::recursive_mutex> guard(i_itemUpdate_lock);
    m_itemUpdate.erase(item);
}

void Player::AddDeleteItem(Item* item)
{
    std::lock_guard<std::recursive_mutex> guard(i_itemUpdate_lock);
    m_itemDelete.insert(item);
}

void Player::RemoveDeleteItem(Item* item)
{
    std::lock_guard<std::recursive_mutex> guard(i_itemUpdate_lock);
    m_itemDelete.erase(item);
}

void Player::UpdateItem()
{
    std::set<Item*> _itemUpdate;
    std::set<Item*> _itemDelete;
    {
        std::lock_guard<std::recursive_mutex> guard(i_itemUpdate_lock);
        std::swap(_itemUpdate, m_itemUpdate);
        std::swap(_itemDelete, m_itemDelete);
    }
    for (std::set<Item*>::iterator i = _itemUpdate.begin(); i != _itemUpdate.end(); ++i)
    {
        Item* item = *i;
        if (!item || !item->IsInWorld())
            continue;

        UpdateDataMapType data_map;
        item->BuildFieldsUpdate(this, data_map);
        item->BuildUpdate(data_map);

        WorldPacket packet;
        for (UpdateDataMapType::iterator iter = data_map.begin(); iter != data_map.end(); ++iter)
        {
            if (iter->second.BuildPacket(&packet))
                iter->first->SendDirectMessage(&packet);
            packet.clear();
        }
    }

    for (std::set<Item*>::iterator i = _itemDelete.begin(); i != _itemDelete.end(); ++i)
    {
        Item* item = *i;
        if (!item || item->IsInWorld())
            continue;

        delete item;
    }
}

uint32 Player::GetUnlockedPetBattleSlot()
{
    if (m_achievementMgr->HasAccountAchieved(6566))
        return 3;

    if (m_achievementMgr->HasAccountAchieved(7433))
        return 2;

    if (HasBattlePetTraining())
        return 1;

    return 0;
}

void Player::UnsummonCurrentBattlePetIfAny(bool p_Unvolontary)
{
    if (!_battlePetSummon)
        return;

    if (!p_Unvolontary)
        _lastSummonedBattlePet = 0;

    if (Creature* pet = GetSummonedBattlePet())
    {
        pet->DespawnOrUnsummon();
        pet->AddObjectToRemoveList();
    }

    _battlePetSummon.Clear();

    SetGuidValue(PLAYER_FIELD_SUMMONED_BATTLE_PET_GUID, ObjectGuid::Empty);
    SetUInt32Value(UNIT_FIELD_WILD_BATTLE_PET_LEVEL, 0);
}

void Player::SummonBattlePet(ObjectGuid journalID)
{
    if (!IsInWorld())
        return;

    BattlePetMap::iterator iter = _battlePets.find(journalID);
    if (iter == _battlePets.end())
        return;

    if (Creature* pet = GetSummonedBattlePet())
    {
        pet->DespawnOrUnsummon();
        pet->AddObjectToRemoveList();
    }

    std::shared_ptr<BattlePet> battlePet = iter->second;

    if (battlePet->Health <= 0)
    {
        UnsummonCurrentBattlePetIfAny(false);
        return;
    }

    auto const& speciesInfo = sBattlePetSpeciesStore.LookupEntry(battlePet->Species);
    auto const& summonProperties = sSummonPropertiesStore.LookupEntry(3221);

    if (!speciesInfo || !summonProperties)
        return;

    uint32 team = GetTeam();
    uint32 l_Phase = GetPhaseMask();

    WorldLocation l_Position;
    GetClosePoint(l_Position.m_positionX, l_Position.m_positionY, l_Position.m_positionZ, DEFAULT_WORLD_OBJECT_SIZE);

    TempSummon* currentPet = new Minion(summonProperties, this, false);

    if (!currentPet->Create(sObjectMgr->GetGenerator<HighGuid::Creature>()->Generate(), GetMap(), l_Phase, speciesInfo->CreatureID, 0, team, l_Position.m_positionX, l_Position.m_positionY, l_Position.m_positionZ, GetOrientation()))
    {
        delete currentPet;
        currentPet = nullptr;
        return;
    }

    currentPet->SetTratsport(GetTransport());
    currentPet->SetHomePosition(l_Position);
    currentPet->SetTempSummonType(TEMPSUMMON_MANUAL_DESPAWN);
    currentPet->InitStats(0);
    currentPet->SetOwnerGUID(GetGUID());

    _lastSummonedBattlePet = battlePet->JournalID.GetCounter();

    SetGuidValue(UNIT_FIELD_CRITTER, currentPet->GetGUID());
    SetUInt32Value(UNIT_FIELD_WILD_BATTLE_PET_LEVEL, battlePet->Level);
    SetGuidValue(PLAYER_FIELD_SUMMONED_BATTLE_PET_GUID, battlePet->JournalID);
    SetUInt32Value(PLAYER_FIELD_CURRENT_BATTLE_PET_BREED_QUALITY, battlePet->Breed);

    currentPet->SetGuidValue(UNIT_FIELD_BATTLE_PET_COMPANION_GUID, battlePet->JournalID);
    currentPet->SetUInt32Value(UNIT_FIELD_WILD_BATTLE_PET_LEVEL, battlePet->Level);

    if (!battlePet->Name.empty())
    {
        currentPet->SetUInt32Value(UNIT_FIELD_BATTLE_PET_COMPANION_NAME_TIMESTAMP, battlePet->NameTimeStamp);
        currentPet->SetName(battlePet->Name);
    }
    else
        currentPet->SetUInt32Value(UNIT_FIELD_BATTLE_PET_COMPANION_NAME_TIMESTAMP, 0);

    currentPet->SetUInt32Value(UNIT_FIELD_SHAPESHIFT_FORM, !battlePet->Name.empty());
    currentPet->SetUInt32Value(UNIT_FIELD_CREATED_BY_SPELL, speciesInfo->SummonSpellID);

    currentPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_UNK_15 | UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC | UNIT_FLAG_PVP_ATTACKABLE | UNIT_FLAG_NON_ATTACKABLE);
    currentPet->SetFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_REGENERATE_POWER);
    currentPet->RemoveFlag(UNIT_FIELD_NPC_FLAGS, UNIT_NPC_FLAG_WILD_BATTLE_PET);

    GetMap()->AddToMap(currentPet->ToCreature());

    currentPet->InitSummon();
    currentPet->GetMotionMaster()->MoveFollow(this, currentPet->GetFollowDistance(), (3 * M_PI) / 2);
    currentPet->SetFollowAngle((3 * M_PI) / 2);
    currentPet->SetSpeed(MOVE_WALK, GetSpeedRate(MOVE_WALK), true);
    currentPet->SetSpeed(MOVE_RUN, GetSpeedRate(MOVE_RUN), true);

    _battlePetSummon = currentPet->GetGUID();
}

Creature* Player::GetSummonedBattlePet()
{
    Unit* pet = sObjectAccessor->FindUnit(_battlePetSummon);
    return pet ? pet->ToCreature() : nullptr;
}

uint32 Player::GetBattlePetCombatSize()
{
    uint32 count = 0;

    for (size_t i = 0; i < MAX_PETBATTLE_SLOTS; ++i)
        if (_battlePetCombatTeam[i])
            count++;

    return count;
}

void Player::SummonLastSummonedBattlePet()
{
    SummonBattlePet(ObjectGuid::Create<HighGuid::BattlePet>(_lastSummonedBattlePet));
}

BattlePetMap* Player::GetBattlePets()
{
    return &_battlePets;
}

std::shared_ptr<BattlePet> Player::GetBattlePet(ObjectGuid journalID)
{
    BattlePetMap::iterator iter = _battlePets.find(journalID);
    if (iter == _battlePets.end())
        return std::shared_ptr<BattlePet>();

    return iter->second;
}

std::shared_ptr<BattlePet>* Player::GetBattlePetCombatTeam()
{
    return _battlePetCombatTeam;
}

void Player::SaveBattlePets(SQLTransaction& trans)
{
    for (BattlePetMap::iterator itr = _battlePets.begin(); itr != _battlePets.end(); ++itr)
        if (std::shared_ptr<BattlePet> pet = itr->second)
            pet->Save(trans);
}

void Player::PetBattleCountBattleSpecies()
{
    PetBattle* battle = sPetBattleSystem->GetBattle(_petBattleId);
    if (!battle)
        return;

    uint32 thisTeamID = battle->Teams[PETBATTLE_TEAM_1]->PlayerGuid == GetGUID() ? PETBATTLE_TEAM_1 : PETBATTLE_TEAM_2;

    for (BattlePetMap::iterator itr = _battlePets.begin(); itr != _battlePets.end(); ++itr)
        if (std::shared_ptr<BattlePet> petBattle = itr->second)
        {
            if (battle->Teams[thisTeamID]->CapturedSpeciesCount.find(petBattle->Species) == battle->Teams[thisTeamID]->CapturedSpeciesCount.end())
                battle->Teams[thisTeamID]->CapturedSpeciesCount[petBattle->Species] = 0;

            battle->Teams[thisTeamID]->CapturedSpeciesCount[petBattle->Species]++;
        }
}

bool Player::HasBattlePetTraining()
{
    return HasSpell(119467);
}

uint32 Player::GetBattlePetTrapLevel()
{
    if (m_achievementMgr->HasAccountAchieved(6581))
        return 3;

    if (m_achievementMgr->HasAccountAchieved(6556))
        return 2;

    return 1;
}

uint8 Player::GetBattlePetCountForSpecies(uint32 speciesID)
{
    return std::count_if(_battlePets.begin(), _battlePets.end(), [&](decltype(_battlePets)::value_type pair)
    {
        return pair.second && pair.second->Species == speciesID;
    });
}

void Player::UpdateBattlePetCombatTeam()
{
    for (auto& i : _battlePetCombatTeam)
        i = std::shared_ptr<BattlePet>();

    auto unlockedSlotCount = GetUnlockedPetBattleSlot();

    for (auto itr = _battlePets.begin(); itr != _battlePets.end(); ++itr)
    {
        if (auto battlePet = itr->second)
        {
            if (battlePet->Slot >= 0 && battlePet->Slot < static_cast<int32>(unlockedSlotCount))
            {
                battlePet->UpdateAbilities();
                _battlePetCombatTeam[battlePet->Slot] = battlePet;
            }
        }
    }
}

bool Player::AddBattlePetWithSpeciesId(BattlePetSpeciesEntry const* entry, uint16 flags /*= 0*/, bool sendUpdate /*= true*/, bool sendDiliveryUpdate /*= false*/)
{
    if (!entry)
        return false;

    auto pet = std::make_shared<BattlePet>();
    pet->Slot = PETBATTLE_NULL_SLOT;
    pet->NameTimeStamp = 0;
    pet->Species = entry->ID;
    pet->DisplayModelID = 0;
    pet->Flags = flags;
    pet->Level = 1;
    pet->XP = 0;

    if (auto temp = sBattlePetDataStore->GetBattlePetTemplate(entry->ID))
    {
        pet->Breed = sBattlePetDataStore->GetRandomBreedID(temp->BreedIDs);
        pet->Quality = temp->MinQuality;
    }
    else
    {
        pet->Breed = 3;
        pet->Quality = BATTLEPET_QUALITY_COMMON;
    }

    pet->UpdateStats();
    pet->Health = pet->InfoMaxHealth;
    auto guidlow = pet->AddToPlayer(this);
    _battlePets.emplace(pet->JournalID, pet);

    if (sendUpdate)
    {
        GetSession()->SendBattlePetUpdates();
        UpdateAchievementCriteria(CRITERIA_TYPE_ADD_BATTLE_PET_JOURNAL, entry->CreatureID);
    }

    if (sendDiliveryUpdate)
        SendDirectMessage(WorldPackets::BattlePay::BattlePayBattlePetDelivered(ObjectGuid::Create<HighGuid::BattlePet>(guidlow), entry->CreatureID).Write());

    return true;
}

bool Player::AddBattlePetByCreatureId(uint32 creatureId, bool sendUpdate /*= true*/, bool sendDiliveryUpdate /*= false*/)
{
    return AddBattlePetWithSpeciesId(sDB2Manager.GetSpeciesByCreatureID(creatureId), 0, sendUpdate, sendDiliveryUpdate);
}

bool Player::AddBattlePet(uint32 spellID, uint16 flags, bool sendUpdate /*= true*/)
{
    return AddBattlePetWithSpeciesId(sDB2Manager.GetSpeciesBySpell(spellID), flags, sendUpdate);
}

uint32 Player::GetTimeSync() const
{
    return m_timeSyncServer;
}

uint32 Player::GetTimeSyncClient() const
{
    return m_timeSyncClient;
}

bool Player::_LoadPetBattles(PreparedQueryResult result)
{
    _battlePets.clear();

    if (!result)
    {
        auto add = false;

        for (const auto& itr : _oldPetBattleSpellToMerge)
            if (AddBattlePet(itr.first, 0, false))
                add = true;

        _oldPetBattleSpellToMerge.clear();

        if (add)
        {
            GetSession()->SendBattlePetUpdates();
            return true;
        }
    }

    for (auto i = 0; i < MAX_PETBATTLE_SLOTS; ++i)
        _battlePetCombatTeam[i] = std::shared_ptr<BattlePet>();

    auto unlockedSlotCount = GetUnlockedPetBattleSlot();
    if (unlockedSlotCount > 0)
        SetFlag(PLAYER_FIELD_PLAYER_FLAGS, PLAYER_FLAGS_PET_BATTLES_UNLOCKED);

    std::vector<uint32> alreadyKnownPet;

    if (result)
    {
        do
        {
            auto BattlePetPtr = std::make_shared<BattlePet>();
            BattlePetPtr->Load(result->Fetch());
            _battlePets.emplace(BattlePetPtr->JournalID, BattlePetPtr);

            if (BattlePetPtr->Slot >= 0 && BattlePetPtr->Slot < static_cast<int32>(unlockedSlotCount))
                _battlePetCombatTeam[BattlePetPtr->Slot] = BattlePetPtr;

            alreadyKnownPet.push_back(BattlePetPtr->Species);

        } while (result->NextRow());
    }

    for (auto itr = _oldPetBattleSpellToMerge.begin(); itr != _oldPetBattleSpellToMerge.end(); ++itr)
    {
        if (std::find(alreadyKnownPet.begin(), alreadyKnownPet.end(), itr->second) != alreadyKnownPet.end())
            continue;

        AddBattlePet(itr->first, 0, false);
    }

    _oldPetBattleSpellToMerge.clear();

    GetSession()->SendBattlePetJournal();
    UpdateAchievementCriteria(CRITERIA_TYPE_COLLECT_BATTLEPET, 1);

    return true;
}

void Player::SendUpdateData()
{
    if (!m_updatePacket.empty())
    {
        std::queue<WorldPacket> aBuffer;
        {
            i_updatePacketLock.lock();
            std::swap(aBuffer, m_updatePacket);
            i_updatePacketLock.unlock();
        }
        while (!aBuffer.empty())
        {
            SendDirectMessage(&aBuffer.front());
            aBuffer.pop();
        }
    }
    if (!m_updatePacketInRange.empty())
    {
        std::queue<WorldPacket> aBuffer;
        {
            i_updatePacketInRangeLock.lock();
            std::swap(aBuffer, m_updatePacketInRange);
            i_updatePacketInRangeLock.unlock();
        }
        while (!aBuffer.empty())
        {
            SendMessageToSetInRange(&aBuffer.front(), sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), true);
            aBuffer.pop();
        }
    }
}

void Player::AddUpdatePacket(WorldPacket const* packet)
{
    i_updatePacketLock.lock();
    m_updatePacket.push(std::move(*packet));
    i_updatePacketLock.unlock();
}

void Player::AddUpdatePacketInRange(WorldPacket const* packet)
{
    i_updatePacketInRangeLock.lock();
    m_updatePacketInRange.push(std::move(*packet));
    i_updatePacketInRangeLock.unlock();
}

void Player::UpdateInstance(InstanceSave* save)
{
    if (!save || !save->GetMapEntry() || save->GetMapEntry()->IsGarrison() || save->GetMapEntry()->CanCreatedZone())
        return;

    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_CHAR_INSTANCE);

    stmt->setUInt64(0, GetGUIDLow());
    stmt->setUInt32(1, save->GetInstanceId());
    stmt->setUInt16(2, save->GetMapId());
    stmt->setUInt8(3, save->GetDifficultyID());
    stmt->setBool(4, save->GetPerm());
    stmt->setUInt32(5, save->GetCompletedEncounterMask());
    stmt->setString(6, save->GetData());
    stmt->setUInt32(7, save->GetResetTime());
    stmt->setBool(8, save->GetExtended());

    CharacterDatabase.Execute(stmt);
}

float Player::CalculateLegendaryDropChance(float rate)
{
    uint32 LegendaryCount = std::max<uint32>(GetItemCountByQuality(ITEM_QUALITY_LEGENDARY, EXPANSION_LEGION), 1);
    if (!rate)
        return 0.0f;

    if (LegendaryCount > 3)
        LegendaryCount = 3;

    return (0.18f * rate) * std::max<float>(1.0f, 1.0f + ((m_killPoints / sWorld->getFloatConfig(CONFIG_CAP_KILLPOINTS)) - 1) * 2.0f) / LegendaryCount;
}

float Player::GetRateLegendaryDrop(bool isBoss, bool isRareOrGo, bool isOplote, bool isItemEmissary, int8 ExpansionID, uint8 DifficultyID)
{
    float rate = 0.0f;
    if (ExpansionID != EXPANSION_LEGION) // calculate only for legion map
        return 0.0f;

    if (isItemEmissary) // For Emissary chest
        return 4.0f;

    switch (DifficultyID)
    {
        case DIFFICULTY_LFR_RAID:
        // case DIFFICULTY_NORMAL:
        case DIFFICULTY_HEROIC:
            if (isBoss || isRareOrGo)
                rate = 2.0f;
            break;
        case DIFFICULTY_NONE: // For world boss
            if (isBoss)
                rate = 3.0f;
            else if (isRareOrGo)
                rate = 0.01f;
            if (isOplote)
                rate = 15.0f;
            break;
        case DIFFICULTY_NORMAL_RAID:
        case DIFFICULTY_MYTHIC_DUNGEON:
            if (isBoss || isRareOrGo)
                rate = 3.0f;
            break;
        case DIFFICULTY_HEROIC_RAID:
        case DIFFICULTY_MYTHIC_KEYSTONE:
            if (isBoss || isRareOrGo)
                rate = 4.0f;
            break;
        case DIFFICULTY_MYTHIC_RAID:
            if (isBoss || isRareOrGo)
                rate = 6.0f;
            break;
    }

    return rate;
}

void Player::SendDisplayPlayerChoice(ObjectGuid sender, int32 choiceId)
{
    auto playerChoice = sObjectMgr->GetPlayerChoice(choiceId);
    if (!playerChoice)
        return;

    if (!sConditionMgr->IsObjectMeetToConditions(this, sConditionMgr->GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_PLAYER_CHOICE, choiceId)))
        return;

    auto locale = GetSession()->GetSessionDbLocaleIndex();
    auto playerChoiceLocale = locale != DEFAULT_LOCALE ? sObjectMgr->GetPlayerChoiceLocale(choiceId) : nullptr;

    WorldPackets::Quest::DisplayPlayerChoice displayPlayerChoice;
    displayPlayerChoice.SenderGUID = sender;
    displayPlayerChoice.ChoiceID = choiceId;
    displayPlayerChoice.UiTextureKitID = playerChoice->UiTextureKitId;
    displayPlayerChoice.Question = playerChoice->Question;
    if (playerChoiceLocale)
        ObjectMgr::GetLocaleString(playerChoiceLocale->Question, locale, displayPlayerChoice.Question);

    displayPlayerChoice.CloseChoiceFrame = false; //@TODO
    displayPlayerChoice.HideWarboardHeader = playerChoice->HideWarboardHeader;

    for (std::size_t i = 0; i < playerChoice->Responses.size(); ++i)
    {
        auto const& playerChoiceResponseTemplate = playerChoice->Responses[i];

        if (!sConditionMgr->IsObjectMeetToConditions(this, sConditionMgr->GetConditionsForNotGroupedEntry(CONDITION_SOURCE_TYPE_PLAYER_CHOICE_RESPONS, playerChoiceResponseTemplate.ResponseId)))
            continue;

        if (playerChoiceResponseTemplate.Reward)
        {
            bool rewardNotNeed = false;
            for (auto const& item : playerChoiceResponseTemplate.Reward->Items)
            {
                if (GetItemCount(item.Id) >= item.Quantity)
                {
                    rewardNotNeed = true;
                    break;
                }
            }
            if (rewardNotNeed)
                continue;
        }

        WorldPackets::Quest::PlayerChoiceResponse playerChoiceResponse;
        playerChoiceResponse.ResponseID = playerChoiceResponseTemplate.ResponseId;
        playerChoiceResponse.ChoiceArtFileID = playerChoiceResponseTemplate.ChoiceArtFileId;
        playerChoiceResponse.Answer = playerChoiceResponseTemplate.Answer;
        playerChoiceResponse.Header = playerChoiceResponseTemplate.Header;
        playerChoiceResponse.Description = playerChoiceResponseTemplate.Description;
        playerChoiceResponse.Confirmation = playerChoiceResponseTemplate.Confirmation;
        if (playerChoiceLocale)
        {
            if (auto playerChoiceResponseLocale = Trinity::Containers::MapGetValuePtr(playerChoiceLocale->Responses, playerChoiceResponseTemplate.ResponseId))
            {
                ObjectMgr::GetLocaleString(playerChoiceResponseLocale->Answer, locale, playerChoiceResponse.Answer);
                ObjectMgr::GetLocaleString(playerChoiceResponseLocale->Header, locale, playerChoiceResponse.Header);
                ObjectMgr::GetLocaleString(playerChoiceResponseLocale->Description, locale, playerChoiceResponse.Description);
                ObjectMgr::GetLocaleString(playerChoiceResponseLocale->Confirmation, locale, playerChoiceResponse.Confirmation);
            }
        }

        if (playerChoiceResponseTemplate.Reward)
        {
            playerChoiceResponse.Reward = boost::in_place();
            playerChoiceResponse.Reward->TitleID = playerChoiceResponseTemplate.Reward->TitleId;
            playerChoiceResponse.Reward->PackageID = playerChoiceResponseTemplate.Reward->PackageId;
            playerChoiceResponse.Reward->SkillLineID = playerChoiceResponseTemplate.Reward->SkillLineId;
            playerChoiceResponse.Reward->SkillPointCount = playerChoiceResponseTemplate.Reward->SkillPointCount;
            playerChoiceResponse.Reward->ArenaPointCount = playerChoiceResponseTemplate.Reward->ArenaPointCount;
            playerChoiceResponse.Reward->HonorPointCount = playerChoiceResponseTemplate.Reward->HonorPointCount;
            playerChoiceResponse.Reward->Money = playerChoiceResponseTemplate.Reward->Money;
            playerChoiceResponse.Reward->Xp = playerChoiceResponseTemplate.Reward->Xp;

            for (auto const& item : playerChoiceResponseTemplate.Reward->Items)
            {
                playerChoiceResponse.Reward->Items.emplace_back();
                auto& rewardEntry = playerChoiceResponse.Reward->Items.back();
                rewardEntry.Item.ItemID = item.Id;
                rewardEntry.Quantity = item.Quantity;
                if (!item.BonusListIDs.empty())
                {
                    rewardEntry.Item.ItemBonus = boost::in_place();
                    rewardEntry.Item.ItemBonus->BonusListIDs = item.BonusListIDs;
                }
            }

            for (auto const& currency : playerChoiceResponseTemplate.Reward->Currency)
            {
                playerChoiceResponse.Reward->Items.emplace_back();
                auto& rewardEntry = playerChoiceResponse.Reward->Items.back();
                rewardEntry.Item.ItemID = currency.Id;
                rewardEntry.Quantity = currency.Quantity;
            }

            for (auto const& faction : playerChoiceResponseTemplate.Reward->Faction)
            {
                playerChoiceResponse.Reward->Items.emplace_back();
                auto& rewardEntry = playerChoiceResponse.Reward->Items.back();
                rewardEntry.Item.ItemID = faction.Id;
                rewardEntry.Quantity = faction.Quantity;
            }

            //for (auto const& currency : playerChoiceResponseTemplate.Reward->ItemChoices) @TODO whats this? no data in our dbn anuway for that container
            //{
            //    playerChoiceResponse.Reward->Items.emplace_back();
            //    auto& rewardEntry = playerChoiceResponse.Reward->ItemChoices.back();
            //    rewardEntry.Item.ItemID = currency.Id;
            //    rewardEntry.Quantity = currency.Quantity;
            //}

            displayPlayerChoice.Responses.push_back(playerChoiceResponse);
        }
    }

    SendDirectMessage(displayPlayerChoice.Write());
}

void Player::_LoadWorldQuestStatus(PreparedQueryResult result)
{
    // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "_LoadWorldQuestStatus");

    m_worldquests.clear();

    if (result)
    {
        do
        {
            Field* fields = result->Fetch();
            uint32 quest_id = fields[0].GetUInt32();
            //uint32 guid = fields[1].GetUInt32();
            uint32 resetTime = fields[2].GetUInt32();

            Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
            if (!quest)
                continue;

            if (m_worldquests.find(quest_id) != m_worldquests.end())
                continue;

            WorldQuestInfo& wqi = m_worldquests[quest_id];
            wqi.QuestID = quest_id;
            wqi.resetTime = resetTime;
            wqi.needSave = false;
            SetQuestCompletedBit(sDB2Manager.GetQuestUniqueBitFlag(quest_id), true);

            // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "Weekly quest {%u} cooldown for player (GUID: %u)", quest_id, GetGUIDLow());
        }
        while (result->NextRow());
    }
}

void Player::_SaveWorldQuestStatus(SQLTransaction& trans)
{
    if (m_worldquests.empty())
        return;

    // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "_SaveWorldQuestStatus");

    // we don't need transactions here.
    PreparedStatement* stmt = NULL;

    for (WorldQuestStatusMap::iterator iter = m_worldquests.begin(); iter != m_worldquests.end(); ++iter)
    {
        uint32 quest_id  = iter->first;
        uint32 resetTime  = iter->second.resetTime;
        iter->second.needSave = false;
        ObjectGuid::LowType guid = GetGUIDLow();
        Quest const* quest = sQuestDataStore->GetQuestTemplate(quest_id);
        if (quest && quest->QuestInfoID == QUEST_INFO_ACCOUNT)
            guid = 0;

        // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "_SaveWorldQuestStatus quest_id %u resetTime %u", quest_id, resetTime);

        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHARACTER_WORLDQUESTSTATUS);
        stmt->setUInt64(0, guid);
        stmt->setUInt32(1, quest_id);
        stmt->setUInt32(2, GetSession()->GetAccountId());
        stmt->setUInt32(3, resetTime);
        trans->Append(stmt);
    }
}

bool Player::WorldQuestCompleted(uint32 QuestID) const
{
    WorldQuestStatusMap::const_iterator iter = m_worldquests.find(QuestID);
    if (iter == m_worldquests.end())
        return false;

    // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "WorldQuestCompleted QuestID %u complete %u", QuestID, iter->second > time(nullptr));

    return iter->second.resetTime > time(nullptr);
}

std::tuple<uint32, uint32> Player::GetWorldQuestBonusTreeMod(WorldQuest const* wq)
{
    uint32 BonusLevel = (wq ? wq->worldQuest->BonusLevel : 5);
    uint32 modTreeID = wq ? wq->worldQuest->modTreeID : 26;
    uint32 currentItemLevel = GetAverageItemLevelTotal(false);

    if (currentItemLevel > sWorld->getIntConfig(CONFIG_WORLD_QUEST_ITEMLEVEL_CAP))
        currentItemLevel = sWorld->getIntConfig(CONFIG_WORLD_QUEST_ITEMLEVEL_CAP);

    if (currentItemLevel < sWorld->getIntConfig(CONFIG_WORLD_QUEST_MIN_ITEMLEVEL))
        currentItemLevel = sWorld->getIntConfig(CONFIG_WORLD_QUEST_MIN_ITEMLEVEL);

    uint32 needLevel = (uint32(currentItemLevel / 5) * 5) + BonusLevel; // round to 5
    return std::make_tuple(modTreeID, needLevel);
}

void Player::ResetWorldQuest(uint32 QuestID)
{
    // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "Player::ResetWorldQuest()");

    if (QuestID)
    {
        for (WorldQuestStatusMap::const_iterator iter = m_worldquests.begin(); iter != m_worldquests.end();)
        {
            if (iter->second.QuestID == QuestID)
            {
                m_worldquests.erase(iter++);
                continue;
            }
            ++iter;
        }
        return;
    }
    for (WorldQuestStatusMap::const_iterator iter = m_worldquests.begin(); iter != m_worldquests.end();)
    {
        if (iter->second.resetTime <= (time(NULL) + MINUTE * 5)) // resetTime
        {
            // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "Player::ResetWorldQuest QuestID %u ResetTime %u time(NULL) %u", iter->first, iter->second, time(NULL));
            m_worldquests.erase(iter++);
            continue;
        }
        ++iter;
    }
}

void Player::ClearWorldQuest()
{
    // TC_LOG_DEBUG(LOG_FILTER_WORLD_QUEST, "Player::ClearWorldQuest()");

    m_worldquests.clear();
}

uint32 Player::GetQuestForUnLockThirdSocket()
{
    uint32 questID = 0;

    switch (getClass())
    {
        case CLASS_MONK:
            questID = 43359;
            break;
        case CLASS_MAGE:
            questID = 43415;
            break;
        case CLASS_DRUID:
            questID = 43409;
            break;
        case CLASS_PALADIN:
            questID = 43424;
            break;
        case CLASS_DEMON_HUNTER:
            questID = 43412;
            break;
        case CLASS_WARRIOR:
            questID = 43425;
            break;
        case CLASS_PRIEST:
            questID = 43420;
            break;
        case CLASS_HUNTER:
            questID = 43423;
            break;
        case CLASS_ROGUE:
            questID = 43422;
            break;
        case CLASS_SHAMAN:
            questID = 43418;
            break;
        case CLASS_DEATH_KNIGHT:
            questID = 43407;
            break;
        case CLASS_WARLOCK:
            questID = 43414;
            break;
    }
    return questID;
}

void Player::ScheduleDelayedOperation(uint32 operation)
{
    if (operation < DELAYED_END)
        m_DelayedOperations |= operation;
}

const SpellInQueue * Player::GetSpellInQueue() const
{
    return m_spellInQueue.GCDEnd ? &m_spellInQueue : nullptr;
}

void Player::HandleSpellInQueue()
{
    if (m_spellInQueue.GCDEnd && !(m_operationsAfterDelayMask & OAD_RESET_SPELL_QUEUE))
    {
        if (m_spellInQueue.GCDEnd < getMSTime())
        {
            SendOperationsAfterDelay(OAD_RESET_SPELL_QUEUE);
            CastSpellInQueue();
        }
    }
}

void Player::SetSpellInQueue(uint32 gcdEnd, uint16 recoveryCategory, WorldPackets::Spells::SpellCastRequest* castData)
{
    m_spellInQueue.GCDEnd = gcdEnd;
    m_spellInQueue.RecoveryCategory = recoveryCategory;

    if (castData)
    {
        m_spellInQueue.CastData->Charmer = castData->Charmer;
        m_spellInQueue.CastData->Misc[0] = castData->Misc[0];
        m_spellInQueue.CastData->Misc[1] = castData->Misc[1];
        m_spellInQueue.CastData->MissileTrajectory = castData->MissileTrajectory;
        m_spellInQueue.CastData->MoveUpdate = castData->MoveUpdate;
        m_spellInQueue.CastData->SendCastFlags = castData->SendCastFlags;
        m_spellInQueue.CastData->SpellGuid = castData->SpellGuid;
        m_spellInQueue.CastData->SpellID = castData->SpellID;
        m_spellInQueue.CastData->SpellXSpellVisualID = castData->SpellXSpellVisualID;
        m_spellInQueue.CastData->Target = castData->Target;
        m_spellInQueue.CastData->Weight = castData->Weight;
    }
}

void Player::CancelCastSpell(bool spellInQueue, uint32 spellId, uint32 spellVisual, ObjectGuid spellGuid)
{
    WorldPackets::Spells::CastFailed packet(SMSG_CAST_FAILED);

    if (spellInQueue)
    {
        packet.SpellGuid = m_spellInQueue.CastData->SpellGuid;
    }
    else
    {
        if (spellGuid.IsEmpty())
            packet.SpellGuid = ObjectGuid::Create<HighGuid::Cast>(GetMapId(), spellId, sObjectMgr->GetGenerator<HighGuid::Cast>()->Generate(), SPELL_CAST_TYPE_NORMAL);
        else
            packet.SpellGuid = spellGuid;
    }

    packet.SpellXSpellVisualID = spellInQueue ? m_spellInQueue.CastData->SpellXSpellVisualID : spellVisual;
    packet.SpellID = spellInQueue ? m_spellInQueue.CastData->SpellID : spellId;
    packet.Reason = SPELL_FAILED_DONT_REPORT;

    SendDirectMessage(packet.Write());
}

void Player::Clear()
{
    Unit::Clear();
    // Note: buy back item already deleted from DB when player was saved
    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; ++i)
        if (m_items[i])
            delete m_items[i];

    //all mailed items should be deleted, also all mail should be deallocated
    for (PlayerMails::iterator itr = m_mail.begin(); itr != m_mail.end(); ++itr)
        delete *itr;

    for (ItemMap::iterator iter = mMitems.begin(); iter != mMitems.end(); ++iter)
        delete iter->second;                                //if item is duplicated... then server may crash ... but that item should be deallocated

    delete PlayerTalkClass;

    for (size_t x = 0; x < ItemSetEff->size(); x++)
        delete (*ItemSetEff)[x];

    delete m_declinedname;

    for (uint16 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        if (_voidStorageItems[i])
        {
            delete _voidStorageItems[i]->item;
            delete _voidStorageItems[i];
        }

    for (uint8 i = 0; i < MAX_CUF_PROFILES; ++i)
        _CUFProfiles[i] = nullptr;

    ClearResurrectRequestData();

    delete m_vis;

    delete _wargameRequest;

    sWorld->DecreasePlayerCount();

    m_achievementMgr->ClearMap();
    m_reputationMgr.Clear();
    _collectionMgr->Clear();

    //Clear container
    while (!m_updatePacket.empty())
        m_updatePacket.pop();
    while (!m_updatePacketInRange.empty())
        m_updatePacketInRange.pop();
    while (!m_timeSyncQueue.empty())
        m_timeSyncQueue.pop();

    _researchSites.clear();
    _completedProjects.clear();
    m_clientGUIDs.clear();
    m_extraLookList.clear();
    m_DFQuests.clear();
    for (uint8 i = 0; i < MAX_BOUND; ++i)
        m_boundInstances[i].clear();
    WhisperList.clear();
    m_sceneInstanceID.clear();
    m_timedquests.clear();
    m_weeklyquests.clear();
    m_dailyquests.clear();
    m_seasonalquests.clear();
    m_worldquests.clear();
    _currencyStorage.clear();
    m_itemUpdateQueue.clear();
    m_itemUpdate.clear();
    for (std::set<Item*>::iterator i = m_itemDelete.begin(); i != m_itemDelete.end(); ++i)
    {
        Item* item = *i;
        if (!item || item->IsInWorld())
            continue;

        delete item;
    }
    m_itemDelete.clear();
    m_QuestStatus.clear();
    m_QuestStatusSave.clear();
    m_RewardedQuests.clear();
    m_RewardedQuestsSave.clear();
    mSkillStatus.clear();
    m_overrideSpells.clear();
    m_spellOverrides.clear();
    m_itemSpellList.clear();
    m_excludeCasterSpellList.clear();
    m_casterAuraStateSSpellList.clear();
    m_actionButtons.clear();
    for (uint32 j = 0; j < MAX_SPELLMOD; ++j)
        m_spellMods[j].clear();
    m_enchantDuration.clear();
    m_itemDuration.clear();
    m_itemSoulboundTradeable.clear();
    m_channels.clear();
    m_PetSlots.clear();
    _battlePets.clear();
    AllArtifacts.clear();
    _oldPetBattleSpellToMerge.clear();
    _equipmentSets.clear();
    m_refundableItems.clear();
    m_spellCooldowns.clear();
    m_spellChargeData.clear();
    m_BracketsList.clear();
    for(int i = 0; i < MAX_LOOT_COOLDOWN_TYPE; i++)
        m_playerLootCooldown[i].clear();
    m_sceneStatus.clear();
    GlobalArtifactData.clear();
}

void Player::PrintPlayerSize()
{
    uint32 size = sizeof(Player);

    uint32 sizeObject = Object::GetSize();
    uint32 sizeUnit = Unit::GetSize();

    ChatHandler(this).PSendSysMessage("Player Class size %u sizeObject %u sizeUnit %u", size, sizeObject, sizeUnit);

    size += sizeObject;
    size += sizeUnit;

    for (uint8 i = 0; i < PLAYER_SLOTS_COUNT; ++i)
        if (m_items[i])
            size += sizeof(Item);

    size += m_mail.size() * sizeof(Mail);
    size += mMitems.size() * sizeof(Item);
    size += sizeof(PlayerTalkClass);
    size += ItemSetEff->size() * sizeof(ItemSetEffect);
    size += sizeof(m_declinedname);

    for (uint16 i = 0; i < VOID_STORAGE_MAX_SLOT; ++i)
        if (_voidStorageItems[i])
        {
            size += sizeof(VoidStorageItem);
            if (_voidStorageItems[i]->item)
                size += sizeof(Item);
        }

    size += sizeof(ResurrectionData);
    size += sizeof(Visuals);
    size += sizeof(WargameRequest);
    size += m_achievementMgr->GetSize();
    size += m_reputationMgr.GetSize();
    size += _collectionMgr->GetSize();

    size += _researchSites.size() * sizeof(ResearchSiteSet);
    size += _completedProjects.size() * sizeof(CompletedProjectList);
    size += m_clientGUIDs.size() * sizeof(GuidSet);
    size += m_extraLookList.size() * sizeof(GuidSet);
    size += m_DFQuests.size() * sizeof(DFQuestsDoneList);

    for (uint8 i = 0; i < MAX_BOUND; ++i)
        size += m_boundInstances[i].size() * sizeof(BoundInstancesMap);

    size += WhisperList.size() * sizeof(GuidList);
    size += m_sceneInstanceID.size() * sizeof(std::unordered_map<uint32, uint32>);
    size += m_timedquests.size() * sizeof(QuestSet);
    size += m_weeklyquests.size() * sizeof(QuestSet);
    size += m_dailyquests.size() * sizeof(QuestSet);
    size += m_seasonalquests.size() * sizeof(SeasonalEventQuestMap);
    size += m_worldquests.size() * sizeof(WorldQuestStatusMap);
    size += _currencyStorage.size() * sizeof(PlayerCurrenciesMap);
    size += m_QuestStatus.size() * sizeof(QuestStatusMap);
    size += m_QuestStatusVector->size() * sizeof(QuestStatusData*);
    size += m_QuestStatusSave.size() * sizeof(QuestStatusSaveMap);
    size += m_RewardedQuests.size() * sizeof(RewardedQuestSet);
    size += m_RewardedQuestsSave.size() * sizeof(QuestStatusSaveMap);
    size += mSkillStatus.size() * sizeof(SkillStatusMap);
    size += mSkillStatusVector->size() * sizeof(SkillStatusData*);
    size += m_overrideSpells.size() * sizeof(std::unordered_map<uint32 /*overridenSpellId*/, std::unordered_set<uint32> /*newSpellId*/>);
    size += m_spellOverrides.size() * sizeof(std::unordered_map<uint32 /*overridenSpellId*/, std::unordered_set<uint32> /*newSpellId*/>);
    size += m_itemSpellList.size() * sizeof(ItemSpellList);
    size += m_excludeCasterSpellList.size() * sizeof(ExcludeCasterSpellList);
    size += m_casterAuraStateSSpellList.size() * sizeof(CasterAuraStateSpellList);
    size += m_actionButtons.size() * sizeof(ActionButtonList);

    for (uint32 j = 0; j < MAX_SPELLMOD; ++j)
        size += m_spellMods[j].size() * sizeof(SpellModList);

    size += m_enchantDuration.size() * sizeof(EnchantDurationList);
    size += m_itemDuration.size() * sizeof(ItemDurationList);
    size += m_itemSoulboundTradeable.size() * sizeof(ItemDurationList);
    size += m_channels.size() * sizeof(JoinedChannelsList);
    size += m_PetSlots.size() * sizeof(PlayerPetSlotList);
    size += _battlePets.size() * sizeof(BattlePetMap);
    size += AllArtifacts.size() * sizeof(std::set<std::pair<ObjectGuid, uint32>>);
    size += _oldPetBattleSpellToMerge.size() * sizeof(std::set<std::pair<uint32, uint32>>);
    size += _equipmentSets.size() * sizeof(EquipmentSetContainer);
    size += m_refundableItems.size() * sizeof(GuidSet);
    size += m_spellCooldowns.size() * sizeof(SpellCooldowns);
    size += m_spellChargeData.size() * sizeof(SpellChargeDataMap);
    size += m_BracketsList.size() * sizeof(BracketList);

    for(int i = 0; i < MAX_LOOT_COOLDOWN_TYPE; i++)
        size += m_playerLootCooldown[i].size() * sizeof(PlayerLootCooldownMap);
;
    size += m_sceneStatus.size() * sizeof(std::unordered_map<uint32, SceneEventStatus>);
    size += GlobalArtifactData.size() * sizeof(std::unordered_map<uint32, std::vector<ItemDynamicFieldArtifactPowers>>);

    ChatHandler(this).PSendSysMessage("Player All size %u", size);
}

uint32 Player::GetQuestForUnLockSecondTier()
{
    uint32 questID = 0;

    switch (GetUInt32Value(PLAYER_FIELD_CURRENT_SPEC_ID))
    {
        case SPEC_PRIEST_DISCIPLINE:
        case SPEC_MONK_WINDWALKER:
        case SPEC_HUNTER_BEASTMASTER:
        case SPEC_WARLOCK_DESTRUCTION:
            questID = 45842;
            break;
        case SPEC_HUNTER_SURVIVAL:
        case SPEC_ROGUE_SUBTLETY:
        case SPEC_DEMON_HUNER_HAVOC:
        case SPEC_DK_FROST:
        case SPEC_WARRIOR_ARMS:
            questID = 45865;
            break;
        case SPEC_MAGE_ARCANE:
        case SPEC_ROGUE_ASSASSINATION:
        case SPEC_PALADIN_RETRIBUTION:
        case SPEC_SHAMAN_ENHANCEMENT:
        case SPEC_WARLOCK_DEMONOLOGY:
            questID = 45862;
            break;
        case SPEC_DK_BLOOD:
        case SPEC_DEMON_HUNER_VENGEANCE:
        case SPEC_DRUID_BEAR:
        case SPEC_MONK_BREWMASTER:
        case SPEC_PALADIN_PROTECTION:
        case SPEC_WARRIOR_PROTECTION:
            questID = 45863;
            break;
        case SPEC_PRIEST_HOLY:
        case SPEC_PALADIN_HOLY:
        case SPEC_MONK_MISTWEAVER:
        case SPEC_DRUID_RESTORATION:
        case SPEC_SHAMAN_RESTORATION:
            questID = 45864;
            break;
        case SPEC_DRUID_CAT:
        case SPEC_ROGUE_COMBAT:
        case SPEC_DK_UNHOLY:
        case SPEC_WARRIOR_FURY:
        case SPEC_MAGE_FIRE:
        case SPEC_SHAMAN_ELEMENTAL:
            questID = 45861;
            break;
        case SPEC_PRIEST_SHADOW:
        case SPEC_WARLOCK_AFFLICTION:
        case SPEC_HUNTER_MARKSMAN:
        case SPEC_DRUID_BALANCE:
        case SPEC_MAGE_FROST:
            questID = 45866;
            break;
    }
    return questID;
}

void Player::ApplyDotMod(uint32 spellId, SpellModOp op, float& basemod, float& baseadd, bool onapply)
{
    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
    if (!spellInfo)
        return;

    SpellModifier* modCost = NULL;
    SpellModifier* modCast = NULL;

    for (SpellModList::iterator itr = m_spellMods[op].begin(); itr != m_spellMods[op].end(); ++itr)
    {
        SpellModifier* mod = *itr;

        // Charges can be set only for mods with auras
        if (!mod->ownerAura)
            ASSERT(mod->charges == 0);

        if (Aura* const ownerAura = mod->ownerAura)
        {
            if (onapply && !ownerAura->HasAuraAttribute(AURA_ATTR_IS_USING_CHARGES))
                continue;
            if (!onapply && ownerAura->HasAuraAttribute(AURA_ATTR_IS_USING_CHARGES))
                continue;
        }

        if (!IsAffectedBySpellmod(spellInfo, mod))
            continue;

        SpellInfo const* affectSpell = sSpellMgr->GetSpellInfo(mod->spellId);
        if(!affectSpell)
            continue;

        if((affectSpell->HasAttribute(SPELL_ATTR0_ONLY_STEALTHED)) && !HasStealthAura())
            continue;

        if (mod->type == SPELLMOD_FLAT)
            baseadd += mod->value;
        else if (mod->type == SPELLMOD_PCT)
            AddPct(basemod, mod->value);
    }
}

void Player::CreateDefaultPet()
{
    if (getClass() == CLASS_WARLOCK)
        CastSpell(this, 688, true);

    if (getClass() == CLASS_HUNTER)
    {
        uint32 spellID = 13481;
        uint32 creatureEntry = 0;
        switch (getRace())
        {
            case RACE_HUMAN:
                creatureEntry = 299;
                break;
            case RACE_DWARF:
                creatureEntry = 42713;
                break;
            case RACE_ORC:
                creatureEntry = 42719;
                break;
            case RACE_NIGHTELF:
                creatureEntry = 42718;
                break;
            case RACE_UNDEAD_PLAYER:
                creatureEntry = 51107;
                break;
            case RACE_TAUREN:
                creatureEntry = 42720;
                break;
            case RACE_TROLL:
                creatureEntry = 42721;
                break;
            case RACE_GOBLIN:
                creatureEntry = 42715;
                break;
            case RACE_BLOODELF:
                creatureEntry = 42710;
                break;
            case RACE_DRAENEI:
                creatureEntry = 42712;
                break;
            case RACE_WORGEN:
                creatureEntry = 42722;
                break;
            case RACE_PANDAREN_NEUTRAL:
                creatureEntry = 57239;
                break;
            case RACE_GNOME:
                creatureEntry = 76199;
                break;
            case RACE_NIGHTBORNE:
                creatureEntry = 131069;
                break;
            case RACE_HIGHMOUNTAIN_TAUREN:
                creatureEntry = 131076;
                break;
            case RACE_VOID_ELF:
                creatureEntry = 131072;
                break;
            case RACE_LIGHTFORGED_DRAENEI:
                creatureEntry = 131074;
                break;
            default:
                break;
        }

        if (creatureEntry)
        {
            PetSlot slot = getSlotForNewPet();
            Pet* pet = CreateTamedPetFrom(creatureEntry, spellID);
            if (!pet)
                return;

            // add to world
            pet->GetMap()->AddToMap(pet->ToCreature());
            pet->SetSlot(slot);

            SetMinion(pet, true);

            pet->SavePetToDB();
            ToPlayer()->PetSpellInitialize();

            ToPlayer()->GetSession()->SendStablePet();
        }
    }
}

void Player::_LoadChallengeKey(PreparedQueryResult result)
{
    if (!result)
        return;

    uint8 index = 0;
    Field* fields = result->Fetch();
    m_challengeKeyInfo.ID = fields[index++].GetUInt16();
    m_challengeKeyInfo.Level = fields[index++].GetUInt8();
    m_challengeKeyInfo.Affix = fields[index++].GetUInt8();
    m_challengeKeyInfo.Affix1 = fields[index++].GetUInt8();
    m_challengeKeyInfo.Affix2 = fields[index++].GetUInt8();
    m_challengeKeyInfo.KeyIsCharded = fields[index++].GetUInt8();
    m_challengeKeyInfo.timeReset = fields[index++].GetUInt32();
    m_challengeKeyInfo.InstanceID = fields[index++].GetUInt32();

    if (m_challengeKeyInfo.Level < 2)
        m_challengeKeyInfo.Level = 2;

    if (!m_challengeKeyInfo.KeyIsCharded)
    {
        if (m_challengeKeyInfo.Level > 2)
            ChallengeKeyCharded(nullptr, m_challengeKeyInfo.Level, false);
        m_challengeKeyInfo.KeyIsCharded = 1;
    }
}

void Player::_SaveChallengeKey(SQLTransaction& trans)
{
    if (!m_challengeKeyInfo.needSave && !m_challengeKeyInfo.needUpdate)
        return;

    if (m_challengeKeyInfo.Level < 2)
        m_challengeKeyInfo.Level = 2;

    uint8 index = 0;
    PreparedStatement* stmt = nullptr;
    if (m_challengeKeyInfo.needUpdate)
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHALLENGE_KEY);
    else
        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_CHALLENGE_KEY);

    stmt->setUInt16(index++, m_challengeKeyInfo.ID);
    stmt->setUInt8(index++, m_challengeKeyInfo.Level);
    stmt->setUInt8(index++, m_challengeKeyInfo.Affix);
    stmt->setUInt8(index++, m_challengeKeyInfo.Affix1);
    stmt->setUInt8(index++, m_challengeKeyInfo.Affix2);
    stmt->setUInt8(index++, m_challengeKeyInfo.KeyIsCharded);
    stmt->setUInt32(index++, m_challengeKeyInfo.timeReset);
    stmt->setUInt32(index++, m_challengeKeyInfo.InstanceID);
    stmt->setUInt64(index++, GetGUIDLow());
    trans->Append(stmt);
}

void Player::_SaveDeathMatchStats(SQLTransaction& trans)
{
    if (!dmScore.needSave)
        return;
    
    uint8 index = 0;
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_PLAYER_DEATHMATCH);

    stmt->setUInt64(index++, GetGUIDLow());
    stmt->setUInt32(index++, dmScore.kills);
    stmt->setUInt32(index++, dmScore.deaths);
    stmt->setUInt64(index++, dmScore.damage);
    stmt->setUInt32(index++, dmScore.rating);
    stmt->setUInt32(index++, dmScore.matches);
    // stmt->setUInt32(index++, dmScore.total_kills);
    trans->Append(stmt);
    
    index = 0;
    stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_PLAYER_DEATHMATCH_STORE);
    stmt->setUInt64(index++, GetGUIDLow());
    stmt->setUInt32(index++, dmScore.totalKills);
    stmt->setUInt32(index++, dmScore.selectedMorph);
    std::ostringstream out;
    for (auto morph : dmScore.buyedMorphs)
        out << morph << " ";
    stmt->setString(index++, out.str());

    trans->Append(stmt);
}

void Player::_SaveChatLogos(SQLTransaction& trans)
{
    for (auto& pair : buyed_chat_logos)
    {
        uint8 index = 0;
        auto stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_PLAYER_CHAT_LOGOS);
        stmt->setUInt64(index++, GetGUIDLow());
        stmt->setString(index++, pair.first);
        stmt->setBool(index++, pair.second);
        trans->Append(stmt);
    }
}

void Player::_SaveArmyTrainingInfo(SQLTransaction& trans)
{
    if (!armyTrainingInfo.needSave)
        return;

    uint8 index = 0;
    auto stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_ARMY_TRAINING_INFO);
    stmt->setUInt64(index++, GetGUIDLow());
    for (; index < 4; ++index)
        stmt->setUInt32(index, armyTrainingInfo.justOpenedUnits[index - 1]);

    stmt->setUInt8(index++, armyTrainingInfo.moreHP);
    stmt->setUInt8(index++, armyTrainingInfo.moreDMG);
    stmt->setBool(index++, armyTrainingInfo.moreFixate);
    stmt->setBool(index++, armyTrainingInfo.moreBrave);

    std::stringstream ss;
    for (auto& str : armyTrainingInfo.justFindedChest)
        ss << str << " ";

    stmt->setString(index++, ss.str());
    trans->Append(stmt);
    armyTrainingInfo.needSave = false;
}

bool Player::InitChallengeKey(Item* item)
{
    if (item->GetEntry() != 138019)
        return true;

    if (!m_challengeKeyInfo.IsActive())
        return false;

    m_challengeKeyInfo.Affix = sWorld->getWorldState(WS_CHALLENGE_AFFIXE1_RESET_TIME);
    m_challengeKeyInfo.Affix1 = sWorld->getWorldState(WS_CHALLENGE_AFFIXE2_RESET_TIME);
    m_challengeKeyInfo.Affix2 = sWorld->getWorldState(WS_CHALLENGE_AFFIXE3_RESET_TIME);

    item->SetModifier(ITEM_MODIFIER_CHALLENGE_ID, m_challengeKeyInfo.ID);
    item->SetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_LEVEL, m_challengeKeyInfo.Level);
    if (m_challengeKeyInfo.Level > 3)
        item->SetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_AFFIX_ID_1, m_challengeKeyInfo.Affix);
    if (m_challengeKeyInfo.Level > 6)
        item->SetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_AFFIX_ID_2, m_challengeKeyInfo.Affix1);
    if (m_challengeKeyInfo.Level > 9)
        item->SetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_AFFIX_ID_3, m_challengeKeyInfo.Affix2);

    return true;
}

void Player::UpdateChallengeKey(Item* item)
{
    m_challengeKeyInfo.ID = item->GetModifier(ITEM_MODIFIER_CHALLENGE_ID);
    m_challengeKeyInfo.Level = item->GetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_LEVEL);

    m_challengeKeyInfo.Affix = sWorld->getWorldState(WS_CHALLENGE_AFFIXE1_RESET_TIME);
    m_challengeKeyInfo.Affix1 = sWorld->getWorldState(WS_CHALLENGE_AFFIXE2_RESET_TIME);
    m_challengeKeyInfo.Affix2 = sWorld->getWorldState(WS_CHALLENGE_AFFIXE3_RESET_TIME);

    if (m_challengeKeyInfo.Level > 3)
        item->SetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_AFFIX_ID_1, m_challengeKeyInfo.Affix);
    if (m_challengeKeyInfo.Level > 6)
        item->SetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_AFFIX_ID_2, m_challengeKeyInfo.Affix1);
    if (m_challengeKeyInfo.Level > 9)
        item->SetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_AFFIX_ID_3, m_challengeKeyInfo.Affix2);

    m_challengeKeyInfo.InstanceID = 0;
    m_challengeKeyInfo.needUpdate = true;
}

void Player::CreateChallengeKey(Item* item)
{
    if (!m_challengeKeyInfo.IsActive())
        m_challengeKeyInfo.needSave = true;
    else
        m_challengeKeyInfo.needUpdate = true;

    item->SetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_LEVEL, m_challengeKeyInfo.Level ? m_challengeKeyInfo.Level : 2);

    item->SetUInt32Value(ITEM_FIELD_EXPIRATION, sWorld->getNextChallengeKeyReset() - time(nullptr));

	if(sWorld->getIntConfig(CONFIG_WEIGHTED_MYTHIC_KEYSTONE))
		item->SetModifier(ITEM_MODIFIER_CHALLENGE_ID, *Trinity::Containers::SelectRandomWeightedContainerElement(sDB2Manager.GetChallngeMaps(), sDB2Manager.GetChallngesWeight()));
	else
		item->SetModifier(ITEM_MODIFIER_CHALLENGE_ID, Trinity::Containers::SelectRandomContainerElement(sDB2Manager.GetChallngeMaps()));

    m_challengeKeyInfo.Affix = sWorld->getWorldState(WS_CHALLENGE_AFFIXE1_RESET_TIME);
    m_challengeKeyInfo.Affix1 = sWorld->getWorldState(WS_CHALLENGE_AFFIXE2_RESET_TIME);
    m_challengeKeyInfo.Affix2 = sWorld->getWorldState(WS_CHALLENGE_AFFIXE3_RESET_TIME);

    if (m_challengeKeyInfo.Level > 3)
        item->SetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_AFFIX_ID_1, m_challengeKeyInfo.Affix);
    if (m_challengeKeyInfo.Level > 6)
        item->SetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_AFFIX_ID_2, m_challengeKeyInfo.Affix1);
    if (m_challengeKeyInfo.Level > 9)
        item->SetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_AFFIX_ID_3, m_challengeKeyInfo.Affix2);

    m_challengeKeyInfo.ID = item->GetModifier(ITEM_MODIFIER_CHALLENGE_ID);
    m_challengeKeyInfo.timeReset = sWorld->getNextChallengeKeyReset();

    item->SetState(ITEM_CHANGED, this);
}

void Player::ResetChallengeKey()
{
    DestroyItemCount(138019, 100, true, true);
    m_challengeKeyInfo.ID = 0;
    m_challengeKeyInfo.Level = 0;
    m_challengeKeyInfo.Affix = 0;
    m_challengeKeyInfo.Affix1 = 0;
    m_challengeKeyInfo.Affix2 = 0;
    m_challengeKeyInfo.KeyIsCharded = 1;
    m_challengeKeyInfo.InstanceID = 0;
}

void Player::ChallengeKeyCharded(Item* item, uint32 challengeLevel, bool runRand)
{
    if (challengeLevel > 2)
        challengeLevel -= 1;

    m_challengeKeyInfo.challengeEntry = nullptr;
    if (challengeLevel >= 2)
    {
        m_challengeKeyInfo.Level = challengeLevel;
        if (runRand)
        {
            uint16 oldID = m_challengeKeyInfo.ID;
            while (oldID == m_challengeKeyInfo.ID)
                m_challengeKeyInfo.ID = *Trinity::Containers::SelectRandomWeightedContainerElement(sDB2Manager.GetChallngeMaps(), sDB2Manager.GetChallngesWeight());
        }
        m_challengeKeyInfo.needUpdate = true;
        if (item)
        {
            item->SetModifier(ITEM_MODIFIER_CHALLENGE_KEYSTONE_LEVEL, challengeLevel);
            item->SetModifier(ITEM_MODIFIER_CHALLENGE_ID, m_challengeKeyInfo.ID);
            UpdateChallengeKey(item);
            item->SetState(ITEM_CHANGED, this);
        }
        return;
    }

    if (!m_challengeKeyInfo.IsActive())
        return;

    m_challengeKeyInfo.ID = 0;
    m_challengeKeyInfo.Level = 2;
    m_challengeKeyInfo.Affix = 0;
    m_challengeKeyInfo.Affix1 = 0;
    m_challengeKeyInfo.Affix2 = 0;
    m_challengeKeyInfo.KeyIsCharded = 1;
    m_challengeKeyInfo.InstanceID = 0;
    DestroyItemCount(138019, 100, true, true);
}

void Player::_LoadAccountProgress(PreparedQueryResult result)
{
    if (!result)
        return;

    uint8 index = 0;
    
    Field* fields = result->Fetch();
    m_account_time[PLAYED_TIME_TOTAL] = fields[index++].GetUInt32();
    m_account_time[PLAYED_TIME_LEVEL] = fields[index++].GetUInt32();
}

void Player::_SaveAccountProgress(SQLTransaction& trans)
{
    if (!m_account_time[PLAYED_TIME_TOTAL] && !m_account_time[PLAYED_TIME_LEVEL])
    {
        QueryResult result = CharacterDatabase.PQuery("SELECT totaltime, leveltime from account_progress where account = %u", GetSession()->GetAccountId());
        if (result)
        {
            Field* fields = result->Fetch();
            m_account_time[PLAYED_TIME_TOTAL] = fields[0].GetUInt32();
            m_account_time[PLAYED_TIME_LEVEL] = fields[1].GetUInt32();
        }
        return;
    }
    
    uint8 index = 0;
    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_ACCOUNT_PROGRESS);
    stmt->setUInt32(index++, GetSession()->GetAccountId());
    stmt->setUInt32(index++, m_account_time[PLAYED_TIME_TOTAL]);
    stmt->setUInt32(index++, m_account_time[PLAYED_TIME_LEVEL]);
    trans->Append(stmt);
}

SpellInQueue::SpellInQueue()
{
    GCDEnd = 0;
    RecoveryCategory = 0;
    CastData = new WorldPackets::Spells::SpellCastRequest;
}

void SpellInQueue::Clear()
{
    GCDEnd = 0;
    RecoveryCategory = 0;
    delete CastData;
    CastData = nullptr;
}

uint32 Player::GetGroupUpdateFlag() const
{
    return m_groupUpdateMask;
}

void Player::SetGroupUpdateFlag(uint32 flag)
{
    return; // Need find bugs with update it
    if (GetGroup()) m_groupUpdateMask |= flag;
}

void Player::RemoveGroupUpdateFlag(uint32 flag)
{
    m_groupUpdateMask &= ~flag;
}

PlayerDynamicFieldArenaCooldowns::PlayerDynamicFieldArenaCooldowns(uint32 spellId, uint32 castTime, uint32 endTime) :
    SpellId(spellId), Unk1(0), Unk2(2), Unk3(0), CastTime(castTime), Unk5(0), EndTime(endTime)
{
}

void Player::EnterInTimeWalk(LFGDungeonsEntry const* dbc, bool apply)
{
    if (!apply || !dbc)
    {
        if (!GetUInt32Value(UNIT_FIELD_EFFECTIVE_LEVEL))
            return;

        RescaleAllForTimeWalk();
        return;
    }

    if (dbc->MentorItemLevel && dbc->MentorCharLevel)
        RescaleAllForTimeWalk(dbc->MentorCharLevel, dbc->MentorItemLevel);
}

void Player::RescaleAllForTimeWalk(uint32 level, uint32 ilevelMax, uint32 ilevelMin)
{
    float healthPct = GetHealthPct();
    bool isArenaOrBG = false;

    if (Map* map = GetMap())
        isArenaOrBG = map->IsBattlegroundOrArena();

    if (!isArenaOrBG)
    {
        for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
            if (Item* item = m_items[i])
                if (CanUseAttackType(GetAttackBySlot(i)))
                    _ApplyItemMods(item, i, false);
    }

    SetEffectiveLevel(level);
    SetMaxItemLevel(ilevelMax);
    SetMinItemLevel(ilevelMin);
    InitStatsForLevel(true);

    if (!isArenaOrBG)
    {
        for (uint8 i = 0; i < INVENTORY_SLOT_BAG_END; ++i)
            if (Item* item = m_items[i])
                if (CanUseAttackType(GetAttackBySlot(i)))
                    _ApplyItemMods(item, i, true);

        SetHealth(std::max(uint64(1ull), uint64(healthPct * (float)GetMaxHealth() / 100.0f)));

        SendOperationsAfterDelay(OAD_RECALC_ITEM_LVL);

        std::vector<Item*> arts;

        if (Item* art = GetArtifactWeapon())
            arts.push_back(art);

        for (uint8 i = INVENTORY_SLOT_ITEM_START; i < GetInventoryEndSlot(); ++i)
        {
            if (Item* pItem = m_items[i])
            {
                if (ItemTemplate const* temp = pItem->GetTemplate())
                {
                    if (temp->GetArtifactID())
                        arts.push_back(pItem);
                }
            }
        }

        for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
        {
            if (Bag* pBag = GetBagByPos(i))
            {
                for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
                {
                    if (Item* pItem = pBag->GetItemByPos(j))
                    {
                        if (ItemTemplate const* temp = pItem->GetTemplate())
                        {
                            if (temp->GetArtifactID())
                                arts.push_back(pItem);
                        }
                    }
                }
            }
        }

        if (!arts.empty())
        {
            bool hasPvpScaling = HasPvpStatsScalingEnabled();

            for (auto itr : arts)
            {
                for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot <= SOCK_ENCHANTMENT_SLOT_3; ++slot)
                    itr->ApplyArtifactPowerEnchantmentBonuses(EnchantmentSlot(slot), itr->GetEnchantmentId(EnchantmentSlot(slot)), false, this);

                if (!hasPvpScaling)
                {
                    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot <= SOCK_ENCHANTMENT_SLOT_3; ++slot)
                        itr->ApplyArtifactPowerEnchantmentBonuses(EnchantmentSlot(slot), itr->GetEnchantmentId(EnchantmentSlot(slot)), true, this);
                }
            }
        }
    }

    RecalculateAmountAllAuras();
}

uint32 Player::GetEncounterMask(lfg::LFGDungeonData const* dungeonData, lfg::LfgReward const* reward)
{
    uint32 completedMask = 0;
    DungeonEncounterList const* encounters = sObjectMgr->GetDungeonEncounterList(dungeonData->map, (Difficulty)dungeonData->difficulty);
    if (!encounters || !reward->encounterMask)
        return completedMask;

    for (auto encounter : *encounters)
    {
        if (!encounter || !encounter->dbcEntry)
            continue;

        if (!(reward->encounterMask & (1 << encounter->dbcEntry->Bit)))
            continue;

        uint32 cooldownid = encounter->creditEntry;
        uint32 cooldowntype = TYPE_CREATURE;

        if (PersonalLootData const* plData = sObjectMgr->GetPersonalLootData(cooldownid, TYPE_CREATURE))
        {
            if (plData->cooldownid)
            {
                cooldownid = plData->cooldownid;
                cooldowntype = plData->cooldowntype;
            }
            if(plData->goEntry)
            {
                cooldownid = plData->goEntry;
                cooldowntype = TYPE_GO;
            }
        }
        if (IsPlayerLootCooldown(cooldownid, cooldowntype, dungeonData->difficulty))
            completedMask |= 1 << encounter->dbcEntry->Bit;
    }

    return completedMask;
}

void Player::_LoadKillCreature(PreparedQueryResult result)
{
    if (!result)
        return;
    do
    {
        Field* fields = result->Fetch();
        uint32 entry = fields[0].GetInt32();
        LogsSystem::KillCreatureData& kills = m_killMap[entry];
        kills.Entry = entry;
        kills.Counter = fields[1].GetUInt32();
        kills.Points = fields[2].GetFloat();
        kills.NeedUpdate = false;
        kills.NeedSave = false;
        if (m_killList.size() <= entry)
            m_killList.resize(entry + 1, nullptr);
        m_killList[entry] = &kills;
    }
    while (result->NextRow());
}

void Player::_SaveKillCreature(SQLTransaction& trans)
{
    std::lock_guard<std::recursive_mutex> guard(i_killMapLock);
    PreparedStatement* stmt = NULL;
    for (KillCreatureMap::iterator iter = m_killMap.begin(); iter != m_killMap.end(); ++iter)
    {
        if (iter->second.NeedSave)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_KILL_CREATURE);
            stmt->setUInt64(0, GetGUIDLow());
            stmt->setUInt32(1, iter->second.Entry);
            stmt->setUInt32(2, iter->second.Counter);
            stmt->setFloat(2, iter->second.Points);
            iter->second.NeedUpdate = false;
            iter->second.NeedSave = false;
            trans->Append(stmt);
        }
        else if (iter->second.NeedUpdate)
        {
            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_KILL_CREATURE);
            stmt->setUInt32(0, iter->second.Counter);
            stmt->setFloat(1, iter->second.Points);
            stmt->setUInt64(2, GetGUIDLow());
            stmt->setUInt32(3, iter->second.Entry);
            iter->second.NeedUpdate = false;
            trans->Append(stmt);
        }
    }
}

void Player::AddKillCreature(uint32 entry, uint32 count, bool encounter)
{
    if (!count)
        return;

    CreatureTemplate const* ci = sObjectMgr->GetCreatureTemplate(entry);
    if (!GetMap() || !ci || (!encounter && sObjectMgr->GetDungeonEncounterByCreature(entry)))
        return;

    if (m_killList.size() <= entry)
        m_killList.resize(entry + 1, nullptr);

    if (!m_killList[entry])
    {
        std::lock_guard<std::recursive_mutex> guard(i_killMapLock);
        LogsSystem::KillCreatureData& kills = m_killMap[entry];
        kills.Entry = entry;
        kills.Counter += count;
        kills.Points += count * GetRateLegendaryDrop(ci->isWorldBoss(), true, false, false, GetMap()->GetEntry()->ExpansionID, GetMap()->GetLootDifficulty());
        kills.NeedUpdate = false;
        kills.NeedSave = true;
        m_killList[entry] = &kills;
        return;
    }
    m_killList[entry]->Counter += count;
    m_killList[entry]->Points += count * GetRateLegendaryDrop(ci->isWorldBoss(), true, false, false, GetMap()->GetEntry()->ExpansionID, GetMap()->GetLootDifficulty());
    m_killList[entry]->NeedUpdate = true;
}

uint32 Player::GetKillCreature(uint32 entry) const
{
    if (m_killList.size() <= entry)
        return 0;

    if (!m_killList[entry])
        return 0;

    return m_killList[entry]->Counter;
}

float Player::GetKillCreaturePoints(uint32 entry) const
{
    if (m_killList.size() <= entry)
        return 0;

    if (!m_killList[entry])
        return 0;

    return m_killList[entry]->Points;
}

void Player::SpecialDamageLogs(Unit* victim, uint32 damage, DamageEffectType damagetype, SpellInfo const* spellProto)
{
    float crit = GetFloatValue(PLAYER_FIELD_CRIT_PERCENTAGE);
    float mastery = GetFloatValue(PLAYER_FIELD_MASTERY) + GetRatingBonusValue(CR_MASTERY);
    float hasteM = GetRatingBonusValue(CR_HASTE_MELEE);
    float hasteR = GetRatingBonusValue(CR_HASTE_RANGED);
    float hasteS = GetRatingBonusValue(CR_HASTE_SPELL);
    float vers = GetFloatValue(PLAYER_FIELD_VERSATILITY);

    // impossible, but check it...
    if (!victim)
        return;

    std::string damageDesc = damage >= 7000000 ? "cheat" : "suspicious";

    sLog->outWarden("AnticheatSpecial: Player %s (GUID: %u) dealed %s damage %u at victim with entry %u (healthPct %f) on map %u\n"
        "                    damageInfo: spell %u, damageType %u, totalDoneMod(player) %.2f, totalTakenMod(victim) %.2f\n"
        "                    stats: class %u, str %.2f, agi %.2f, int %.2f, critRating %.2f, masteryRating %.2f, hasteRating %.2f (%.2f %.2f), versRating %.2f",
        GetName(), GetGUIDLow(), damageDesc.c_str(), damage, victim->GetEntry(), victim->GetHealthPct(), GetMapId(),
        spellProto ? spellProto->Id : 0, uint8(damagetype), GetTotalAuraMultiplier(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE), victim->GetTotalAuraMultiplier(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN),
        getClass(), GetTotalStatValue(STAT_STRENGTH), GetTotalStatValue(STAT_AGILITY), GetTotalStatValue(STAT_INTELLECT), crit, mastery, hasteM, hasteR, hasteS, vers);
}

void Player::SpecialLootLogs(ObjectGuid sourceGuid, uint32 itemEntry)
{
    bool cheating = true;

    if (itemEntry != 124106 && itemEntry != 124444 && itemEntry != 124116)
        return;

    uint32 felwortWQ[15] = { 41524, 41515, 41523, 41522, 41225, 41511, 41512, 41513, 41514, 41521, 41516, 41517, 41518, 41519, 41520 };
    if (itemEntry == 124106)
    {
        if (!sourceGuid.IsGameObject())
            cheating = false;
        else
        {
            for (uint8 i = 0; i < 15; ++i)
            {
                if (FindQuestSlot(felwortWQ[i]) != MAX_QUEST_LOG_SIZE)
                {
                    cheating = false;
                    break;
                }
            }
        }
    }

    uint32 brimstoneWQ[15] = { 41210, 41487, 41208, 41481, 41482, 41483, 41484, 41486, 41209, 41488, 41489, 41490, 41491, 41492, 41493 };
    if (itemEntry == 124444)
    {
        if (!sourceGuid.IsGameObject() && !sourceGuid.IsCreature())
            cheating = false;
        else
        {
            for (uint8 i = 0; i < 15; ++i)
            {
                if (FindQuestSlot(brimstoneWQ[i]) != MAX_QUEST_LOG_SIZE)
                {
                    cheating = false;
                    break;
                }
            }
        }
    }

    uint32 felhideWQ[15] = { 41563, 41567, 41239, 41561, 41562, 41564, 41565, 41566, 41560, 41568, 41569, 41570, 41571, 41572, 41573 };
    if (itemEntry == 124116)
    {
        if (!sourceGuid.IsCreature())
            cheating = false;
        else
        {
            for (uint8 i = 0; i < 15; ++i)
            {
                if (FindQuestSlot(felhideWQ[i]) != MAX_QUEST_LOG_SIZE)
                {
                    cheating = false;
                    break;
                }
            }
        }
    }

    if (cheating)
        sLog->outWarden("AnticheatSpecial: Player %s (GUID: %u) looting item %u illegal", GetName(), GetGUIDLow(), itemEntry);
}

std::string Player::GetShortDescription() const
{
    std::stringstream oss;
    oss << GetName() << ":" << GetGUIDLow() << ":" << GetSession()->GetAccountId() << "@" << GetSession()->GetRemoteAddress().c_str() << "]";
    return oss.str();
}
